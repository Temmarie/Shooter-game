/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is not neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./assets/audio/sndBtn.wav":
/*!*********************************!*\
  !*** ./assets/audio/sndBtn.wav ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => __WEBPACK_DEFAULT_EXPORT__\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (__webpack_require__.p + \"e4f8df4270889f4b0cc6a130ee30cf2e.wav\");\n\n//# sourceURL=webpack://Shooter-Game/./assets/audio/sndBtn.wav?");

/***/ }),

/***/ "./assets/audio/sndExplode.wav":
/*!*************************************!*\
  !*** ./assets/audio/sndExplode.wav ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => __WEBPACK_DEFAULT_EXPORT__\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (__webpack_require__.p + \"95a442793d9f1f4093b90edf98e961e6.wav\");\n\n//# sourceURL=webpack://Shooter-Game/./assets/audio/sndExplode.wav?");

/***/ }),

/***/ "./assets/audio/sndLaserEnemy.wav":
/*!****************************************!*\
  !*** ./assets/audio/sndLaserEnemy.wav ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => __WEBPACK_DEFAULT_EXPORT__\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (__webpack_require__.p + \"0cd0cabaa3de88b1f8e7daf1e6d38596.wav\");\n\n//# sourceURL=webpack://Shooter-Game/./assets/audio/sndLaserEnemy.wav?");

/***/ }),

/***/ "./assets/audio/sndLaserPlayer.wav":
/*!*****************************************!*\
  !*** ./assets/audio/sndLaserPlayer.wav ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => __WEBPACK_DEFAULT_EXPORT__\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (__webpack_require__.p + \"e7aa675083b7b4ee2c66473b0eb76f94.wav\");\n\n//# sourceURL=webpack://Shooter-Game/./assets/audio/sndLaserPlayer.wav?");

/***/ }),

/***/ "./assets/images/baseBg.png":
/*!**********************************!*\
  !*** ./assets/images/baseBg.png ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => __WEBPACK_DEFAULT_EXPORT__\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (__webpack_require__.p + \"79be7b430477cef6edede7357df8f2b4.png\");\n\n//# sourceURL=webpack://Shooter-Game/./assets/images/baseBg.png?");

/***/ }),

/***/ "./assets/images/buttonUp.png":
/*!************************************!*\
  !*** ./assets/images/buttonUp.png ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => __WEBPACK_DEFAULT_EXPORT__\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (__webpack_require__.p + \"c4fd14f2ca70251db26414f67878f9c3.png\");\n\n//# sourceURL=webpack://Shooter-Game/./assets/images/buttonUp.png?");

/***/ }),

/***/ "./assets/images/leadersBoardButton.png":
/*!**********************************************!*\
  !*** ./assets/images/leadersBoardButton.png ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => __WEBPACK_DEFAULT_EXPORT__\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (__webpack_require__.p + \"6c1648e15e290d31846ef2e420aa1777.png\");\n\n//# sourceURL=webpack://Shooter-Game/./assets/images/leadersBoardButton.png?");

/***/ }),

/***/ "./assets/images/playButton.png":
/*!**************************************!*\
  !*** ./assets/images/playButton.png ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => __WEBPACK_DEFAULT_EXPORT__\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (__webpack_require__.p + \"c621704ff07a2e8a4f2975ceeca75efc.png\");\n\n//# sourceURL=webpack://Shooter-Game/./assets/images/playButton.png?");

/***/ }),

/***/ "./assets/images/return.png":
/*!**********************************!*\
  !*** ./assets/images/return.png ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => __WEBPACK_DEFAULT_EXPORT__\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (__webpack_require__.p + \"1df1f304a396031b9a7dc1f13b30aad4.png\");\n\n//# sourceURL=webpack://Shooter-Game/./assets/images/return.png?");

/***/ }),

/***/ "./assets/images/sprEnemy0.png":
/*!*************************************!*\
  !*** ./assets/images/sprEnemy0.png ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => __WEBPACK_DEFAULT_EXPORT__\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (__webpack_require__.p + \"5797af3959bef324e5ef99a6aa835563.png\");\n\n//# sourceURL=webpack://Shooter-Game/./assets/images/sprEnemy0.png?");

/***/ }),

/***/ "./assets/images/sprExplosion.png":
/*!****************************************!*\
  !*** ./assets/images/sprExplosion.png ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => __WEBPACK_DEFAULT_EXPORT__\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (__webpack_require__.p + \"0f1042ddd7f8db4ef36c194510d55331.png\");\n\n//# sourceURL=webpack://Shooter-Game/./assets/images/sprExplosion.png?");

/***/ }),

/***/ "./assets/images/sprLaserEnemy.png":
/*!*****************************************!*\
  !*** ./assets/images/sprLaserEnemy.png ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => __WEBPACK_DEFAULT_EXPORT__\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (__webpack_require__.p + \"6d31f15ebc10d075670871f1f9d43b38.png\");\n\n//# sourceURL=webpack://Shooter-Game/./assets/images/sprLaserEnemy.png?");

/***/ }),

/***/ "./assets/images/sprLaserPlayer.png":
/*!******************************************!*\
  !*** ./assets/images/sprLaserPlayer.png ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => __WEBPACK_DEFAULT_EXPORT__\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (__webpack_require__.p + \"f8ef09920d61b3104e838476296043fc.png\");\n\n//# sourceURL=webpack://Shooter-Game/./assets/images/sprLaserPlayer.png?");

/***/ }),

/***/ "./assets/images/sprPlayer.png":
/*!*************************************!*\
  !*** ./assets/images/sprPlayer.png ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => __WEBPACK_DEFAULT_EXPORT__\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (__webpack_require__.p + \"30a8b9b0ebd9aeeb4b8d9b38b4cd8e4b.png\");\n\n//# sourceURL=webpack://Shooter-Game/./assets/images/sprPlayer.png?");

/***/ }),

/***/ "./assets/images/sprShieldTile.png":
/*!*****************************************!*\
  !*** ./assets/images/sprShieldTile.png ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => __WEBPACK_DEFAULT_EXPORT__\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (__webpack_require__.p + \"ce9fc4fe2cfd0578d058b23efeefbb57.png\");\n\n//# sourceURL=webpack://Shooter-Game/./assets/images/sprShieldTile.png?");

/***/ }),

/***/ "./src/content/enemy.js":
/*!******************************!*\
  !*** ./src/content/enemy.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Enemy\": () => /* binding */ Enemy,\n/* harmony export */   \"EnemyLaser\": () => /* binding */ EnemyLaser\n/* harmony export */ });\n/* harmony import */ var _entity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./entity */ \"./src/content/entity.js\");\n/* eslint-disable max-classes-per-file */\n\n\nclass EnemyLaser extends _entity__WEBPACK_IMPORTED_MODULE_0__.Entity {\n  constructor(scene, x, y) {\n    super(scene, x, y, 'sprLaserEnemy');\n  }\n}\n\nclass Enemy extends _entity__WEBPACK_IMPORTED_MODULE_0__.Entity {\n  constructor(scene, x, y, key) {\n    super(scene, x, y, key);\n    this.setOrigin(0);\n  }\n}\n\n\n\n//# sourceURL=webpack://Shooter-Game/./src/content/enemy.js?");

/***/ }),

/***/ "./src/content/entity.js":
/*!*******************************!*\
  !*** ./src/content/entity.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Entity\": () => /* binding */ Entity,\n/* harmony export */   \"ShieldTile\": () => /* binding */ ShieldTile,\n/* harmony export */   \"Explosion\": () => /* binding */ Explosion\n/* harmony export */ });\n/* harmony import */ var _phaser_min__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../phaser.min */ \"./src/phaser.min.js\");\n/* harmony import */ var _phaser_min__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_phaser_min__WEBPACK_IMPORTED_MODULE_0__);\n/* eslint-disable max-classes-per-file */\n\n\nclass Entity extends (_phaser_min__WEBPACK_IMPORTED_MODULE_0___default().GameObjects.Sprite) {\n  constructor(scene, x, y, key) {\n    super(scene, x, y, key);\n    this.scene.add.existing(this);\n    this.scene.physics.world.enableBody(this, 0);\n  }\n}\n\nclass ShieldTile extends Entity {\n  constructor(scene, x, y) {\n    super(scene, x, y, 'sprShieldTile');\n    this.setOrigin(0);\n    this.setScale(2);\n    this.setDepth(-2);\n  }\n}\n\nclass Explosion extends Entity {\n  constructor(scene, x, y) {\n    super(scene, x, y, 'sprExplosion');\n    this.play('sprExplosion');\n    this.setOrigin(0);\n    this.setScale(2);\n    this.on('animationcomplete', () => {\n      if (this) {\n        this.destroy();\n      }\n    });\n  }\n}\n\n\n\n//# sourceURL=webpack://Shooter-Game/./src/content/entity.js?");

/***/ }),

/***/ "./src/content/player.js":
/*!*******************************!*\
  !*** ./src/content/player.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Player\": () => /* binding */ Player,\n/* harmony export */   \"PlayerLaser\": () => /* binding */ PlayerLaser\n/* harmony export */ });\n/* harmony import */ var _entity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./entity */ \"./src/content/entity.js\");\n/* eslint-disable max-classes-per-file */\n\n\nclass Player extends _entity__WEBPACK_IMPORTED_MODULE_0__.Entity {\n  constructor(scene, x, y) {\n    super(scene, x, y, 'sprPlayer');\n    this.setScale(2);\n  }\n}\n\nclass PlayerLaser extends _entity__WEBPACK_IMPORTED_MODULE_0__.Entity {\n  constructor(scene, x, y) {\n    super(scene, x, y, 'sprLaserPlayer');\n  }\n}\n\n\n\n//# sourceURL=webpack://Shooter-Game/./src/content/player.js?");

/***/ }),

/***/ "./src/helpers/buttonHelpers.js":
/*!**************************************!*\
  !*** ./src/helpers/buttonHelpers.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"addButtonText\": () => /* binding */ addButtonText,\n/* harmony export */   \"addButtonFunctionality\": () => /* binding */ addButtonFunctionality\n/* harmony export */ });\nconst addButtonText = (scene, y, text) => {\n  scene.add.text(\n    scene.game.config.width * 0.5,\n    y,\n    text,\n    { color: '#000', fontSize: 20, fontFamily: 'monospace' },\n  ).setOrigin(0.5);\n};\n\nconst addButtonFunctionality = (scene, button, callback) => {\n  button.setInteractive();\n\n  button.on('pointerover', () => {\n  }, scene);\n\n  button.on('pointerdown', () => {\n  }, scene);\n\n  button.on('pointerup', () => {\n    callback();\n  }, scene);\n};\n\n//# sourceURL=webpack://Shooter-Game/./src/helpers/buttonHelpers.js?");

/***/ }),

/***/ "./src/helpers/scoreLogic.js":
/*!***********************************!*\
  !*** ./src/helpers/scoreLogic.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"deleteNameInput\": () => /* binding */ deleteNameInput,\n/* harmony export */   \"postScore\": () => /* binding */ postScore,\n/* harmony export */   \"handleScore\": () => /* binding */ handleScore,\n/* harmony export */   \"restartGame\": () => /* binding */ restartGame,\n/* harmony export */   \"createNameInput\": () => /* binding */ createNameInput,\n/* harmony export */   \"getGameScores\": () => /* binding */ getGameScores\n/* harmony export */ });\nlet nameInput;\n\nconst apiInfo = {\n  url: 'https://us-central1-js-capstone-backend.cloudfunctions.net/api/',\n  headers: {\n    'Content-Type': 'application/json',\n  },\n  gameID: '88Rte0h1UgvXxeV6E5S7',\n};\n\nconst getPlayerName = () => {\n  const playerName = nameInput.value;\n  if (playerName) {\n    return playerName;\n  }\n  // eslint-disable-next-line no-alert\n  alert('Name required');\n  return false;\n};\n\nconst deleteNameInput = () => {\n  nameInput.parentElement.removeChild(nameInput);\n};\n\nconst postScore = async (playerName, score) => {\n  try {\n    await fetch(`${apiInfo.url}games/:${apiInfo.gameID}/scores/`, {\n      method: 'POST',\n      headers: apiInfo.headers,\n      body: JSON.stringify({ user: playerName, score }),\n    });\n    return true;\n  } catch (error) {\n    return false;\n  }\n};\n\nconst handleScore = async (scene, gameScore) => {\n  const playerName = getPlayerName();\n  const result = await postScore(playerName, gameScore);\n  if (result) {\n    scene.scene.start('Score');\n    deleteNameInput();\n  }\n};\n\nconst restartGame = (scene) => {\n  scene.scene.start('SceneMain');\n  deleteNameInput();\n};\n\nconst createNameInput = () => {\n  nameInput = document.createElement('input');\n  nameInput.placeholder = 'Your name here';\n  nameInput.type = 'text';\n  document.querySelector('#game').appendChild(nameInput);\n};\n\nconst getGameScores = async () => {\n  try {\n    const rawResult = await fetch(`${apiInfo.url}games/:${apiInfo.gameID}/scores/`);\n    const scoreBoard = await rawResult.json();\n    return scoreBoard;\n  } catch (error) {\n    return 'Sorry, something went wrong.';\n  }\n};\n\n//# sourceURL=webpack://Shooter-Game/./src/helpers/scoreLogic.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _phaser_min__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./phaser.min */ \"./src/phaser.min.js\");\n/* harmony import */ var _phaser_min__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_phaser_min__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _js_startScene__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./js/startScene */ \"./src/js/startScene.js\");\n/* harmony import */ var _js_sceneMain__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./js/sceneMain */ \"./src/js/sceneMain.js\");\n/* harmony import */ var _js_gameOver__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./js/gameOver */ \"./src/js/gameOver.js\");\n/* harmony import */ var _js_score__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./js/score */ \"./src/js/score.js\");\n\n\n\n\n\n\n\nconst config = {\n  type: (_phaser_min__WEBPACK_IMPORTED_MODULE_0___default().WEBGL),\n  width: 670,\n  height: 640,\n  backgroundColor: 'black',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { x: 0, y: 0 },\n    },\n  },\n  scene: [\n    _js_startScene__WEBPACK_IMPORTED_MODULE_1__.default,\n    _js_sceneMain__WEBPACK_IMPORTED_MODULE_2__.default,\n    _js_gameOver__WEBPACK_IMPORTED_MODULE_3__.default,\n    _js_score__WEBPACK_IMPORTED_MODULE_4__.default,\n  ],\n  pixelArt: true,\n  roundPixels: true,\n};\n\n// eslint-disable-next-line no-unused-vars\nconst game = new (_phaser_min__WEBPACK_IMPORTED_MODULE_0___default().Game)(config);\n\n\n//# sourceURL=webpack://Shooter-Game/./src/index.js?");

/***/ }),

/***/ "./src/js/gameOver.js":
/*!****************************!*\
  !*** ./src/js/gameOver.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => /* binding */ GameOver\n/* harmony export */ });\n/* harmony import */ var _phaser_min__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../phaser.min */ \"./src/phaser.min.js\");\n/* harmony import */ var _phaser_min__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_phaser_min__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _helpers_buttonHelpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../helpers/buttonHelpers */ \"./src/helpers/buttonHelpers.js\");\n/* harmony import */ var _helpers_scoreLogic__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../helpers/scoreLogic */ \"./src/helpers/scoreLogic.js\");\n/* harmony import */ var _assets_images_baseBg_png__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../assets/images/baseBg.png */ \"./assets/images/baseBg.png\");\n/* harmony import */ var _assets_images_buttonUp_png__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../assets/images/buttonUp.png */ \"./assets/images/buttonUp.png\");\n\n\n\n\n\n\nclass GameOver extends (_phaser_min__WEBPACK_IMPORTED_MODULE_0___default().Scene) {\n  constructor() {\n    super('GameOver');\n  }\n\n  preload() {\n    this.load.image('GOendBG', _assets_images_baseBg_png__WEBPACK_IMPORTED_MODULE_3__.default);\n    this.load.image('btnUP', _assets_images_buttonUp_png__WEBPACK_IMPORTED_MODULE_4__.default);\n  }\n\n\n  init(data) {\n    this.gameScore = data.gameScore;\n  }\n\n\n  create() {\n    this.add.image(260, 400, 'GOendBG');\n\n    this.addText(200, 'GAME OVER', 45);\n\n    this.addText(300, `Your score: ${this.gameScore}`, 25);\n\n    _helpers_scoreLogic__WEBPACK_IMPORTED_MODULE_2__.createNameInput();\n\n    this.btnSubmit = this.add.sprite(\n      this.game.config.width * 0.5,\n      370,\n      'btnUP',\n    );\n    // eslint-disable-next-line max-len\n    _helpers_buttonHelpers__WEBPACK_IMPORTED_MODULE_1__.addButtonFunctionality(this, this.btnSubmit, () => _helpers_scoreLogic__WEBPACK_IMPORTED_MODULE_2__.handleScore(this, this.gameScore));\n    _helpers_buttonHelpers__WEBPACK_IMPORTED_MODULE_1__.addButtonText(this, 370, 'Submit score');\n  }\n\n  addText(y, text, size) {\n    this.add.text(\n      this.game.config.width * 0.5,\n      y,\n      text,\n      {\n        fontFamily: 'monospace',\n        fontSize: size,\n        fontStyle: 'bold',\n        color: '#ffffff',\n        align: 'center',\n      },\n    ).setOrigin(0.5);\n  }\n}\n\n//# sourceURL=webpack://Shooter-Game/./src/js/gameOver.js?");

/***/ }),

/***/ "./src/js/sceneMain.js":
/*!*****************************!*\
  !*** ./src/js/sceneMain.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => /* binding */ SceneMain\n/* harmony export */ });\n/* harmony import */ var _phaser_min__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../phaser.min */ \"./src/phaser.min.js\");\n/* harmony import */ var _phaser_min__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_phaser_min__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _assets_images_sprPlayer_png__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../assets/images/sprPlayer.png */ \"./assets/images/sprPlayer.png\");\n/* harmony import */ var _assets_images_sprEnemy0_png__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../assets/images/sprEnemy0.png */ \"./assets/images/sprEnemy0.png\");\n/* harmony import */ var _assets_images_sprShieldTile_png__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../assets/images/sprShieldTile.png */ \"./assets/images/sprShieldTile.png\");\n/* harmony import */ var _assets_images_sprLaserEnemy_png__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../assets/images/sprLaserEnemy.png */ \"./assets/images/sprLaserEnemy.png\");\n/* harmony import */ var _assets_images_sprLaserPlayer_png__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../assets/images/sprLaserPlayer.png */ \"./assets/images/sprLaserPlayer.png\");\n/* harmony import */ var _assets_images_sprExplosion_png__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../assets/images/sprExplosion.png */ \"./assets/images/sprExplosion.png\");\n/* harmony import */ var _assets_audio_sndExplode_wav__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../assets/audio/sndExplode.wav */ \"./assets/audio/sndExplode.wav\");\n/* harmony import */ var _assets_audio_sndLaserPlayer_wav__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../assets/audio/sndLaserPlayer.wav */ \"./assets/audio/sndLaserPlayer.wav\");\n/* harmony import */ var _assets_audio_sndLaserEnemy_wav__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../assets/audio/sndLaserEnemy.wav */ \"./assets/audio/sndLaserEnemy.wav\");\n/* harmony import */ var _content_player__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../content/player */ \"./src/content/player.js\");\n/* harmony import */ var _content_enemy__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../content/enemy */ \"./src/content/enemy.js\");\n/* harmony import */ var _content_entity__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../content/entity */ \"./src/content/entity.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nclass SceneMain extends (_phaser_min__WEBPACK_IMPORTED_MODULE_0___default().Scene) {\n  constructor() {\n    super({ key: 'SceneMain' });\n  }\n\n  init(data) {\n    this.passingData = data;\n  }\n\n  preload() {\n    this.load.image('sprPlayer', _assets_images_sprPlayer_png__WEBPACK_IMPORTED_MODULE_1__.default);\n    this.load.spritesheet('sprEnemy0', _assets_images_sprEnemy0_png__WEBPACK_IMPORTED_MODULE_2__.default, {\n      frameWidth: 8,\n      frameHeight: 8,\n    });\n    this.load.image('sprShieldTile', _assets_images_sprShieldTile_png__WEBPACK_IMPORTED_MODULE_3__.default);\n    this.load.image('sprLaserEnemy', _assets_images_sprLaserEnemy_png__WEBPACK_IMPORTED_MODULE_4__.default);\n    this.load.image('sprLaserPlayer', _assets_images_sprLaserPlayer_png__WEBPACK_IMPORTED_MODULE_5__.default);\n    this.load.spritesheet('sprExplosion', _assets_images_sprExplosion_png__WEBPACK_IMPORTED_MODULE_6__.default, {\n      frameWidth: 8,\n      frameHeight: 8,\n    });\n\n    this.load.audio('sndExplode', _assets_audio_sndExplode_wav__WEBPACK_IMPORTED_MODULE_7__.default);\n    this.load.audio('sndLaserPlayer', _assets_audio_sndLaserPlayer_wav__WEBPACK_IMPORTED_MODULE_8__.default);\n    this.load.audio('sndLaserEnemy', _assets_audio_sndLaserEnemy_wav__WEBPACK_IMPORTED_MODULE_9__.default);\n  }\n\n  create() {\n    if (Object.getOwnPropertyNames(this.passingData).length === 0\n      && this.passingData.constructor === Object) {\n      this.passingData = {\n        maxLives: 3,\n        lives: 3,\n        score: 0,\n      };\n    }\n\n    this.sfx = {\n      explode: this.sound.add('sndExplode'),\n      laserPlayer: this.sound.add('sndLaserPlayer'),\n      laserEnemy: this.sound.add('sndLaserEnemy'),\n    };\n\n\n    this.anims.create({\n      key: 'sprEnemy0',\n      frames: this.anims.generateFrameNumbers('sprEnemy0'),\n      frameRate: 10,\n      repeat: -1,\n    });\n\n    this.anims.create({\n      key: 'sprExplosion',\n      frames: this.anims.generateFrameNumbers('sprExplosion'),\n      frameRate: 15,\n      repeat: 0,\n    });\n\n\n    this.textScore = this.add.text(\n      12,\n      10,\n      `Score: ${this.passingData.score}`,\n      {\n        fontFamily: 'monospace',\n        fontSize: 16,\n        align: 'left',\n      },\n    );\n\n    this.player = new _content_player__WEBPACK_IMPORTED_MODULE_10__.Player(\n      this,\n      this.game.config.width * 0.5,\n      this.game.config.height - 54,\n    );\n    this.player.body.collideWorldBounds = true;\n\n    this.keyA = this.input.keyboard.addKey((_phaser_min__WEBPACK_IMPORTED_MODULE_0___default().Input.Keyboard.KeyCodes.A));\n    this.keyD = this.input.keyboard.addKey((_phaser_min__WEBPACK_IMPORTED_MODULE_0___default().Input.Keyboard.KeyCodes.D));\n    this.keySpace = this.input.keyboard.addKey((_phaser_min__WEBPACK_IMPORTED_MODULE_0___default().Input.Keyboard.KeyCodes.SPACE));\n\n    this.playerShootDelay = 20;\n    this.playerShootTick = 0;\n\n    this.shieldPattern = [\n      [0, 1, 1, 1, 1, 1, 0],\n      [1, 1, 1, 1, 1, 1, 1],\n      [1, 1, 1, 1, 1, 1, 1],\n      [1, 1, 0, 0, 0, 1, 1],\n      [1, 1, 0, 0, 0, 1, 1],\n      [1, 1, 0, 0, 0, 1, 1],\n    ];\n\n    this.enemies = this.add.group();\n    this.enemyLasers = this.add.group();\n    this.playerLasers = this.add.group();\n    this.explosions = this.add.group();\n    this.shieldTiles = this.add.group();\n    this.shieldHoles = this.add.group();\n\n    this.lastEnemyMoveDir = 'RIGHT';\n    this.enemyMoveDir = 'LEFT';\n    this.enemyRect = new (_phaser_min__WEBPACK_IMPORTED_MODULE_0___default().Geom.Rectangle)(\n      0,\n      0,\n      Math.round((this.game.config.width / 24) * 0.75) * 24,\n      Math.round((this.game.config.height / 20) * 0.25) * 20,\n    );\n\n    for (let x = 0; x < Math.round((this.game.config.width / 24) * 0.75); x += 1) {\n      for (let y = 0; y < Math.round((this.game.config.height / 20) * 0.25); y += 1) {\n        const enemy = new _content_enemy__WEBPACK_IMPORTED_MODULE_11__.Enemy(this, x * 24, 128 + (y * 20), 'sprEnemy0');\n        enemy.play('sprEnemy0');\n        enemy.setScale(2);\n        this.enemies.add(enemy);\n      }\n    }\n\n    this.updateEnemiesMovement();\n    this.updateEnemiesShooting();\n    this.updatePlayerMovement();\n    this.updatePlayerShooting();\n    this.updateLasers();\n    this.createLivesIcons();\n\n    this.physics.add.overlap(this.playerLasers, this.enemies, (laser, enemy) => {\n      if (laser) {\n        laser.destroy();\n      }\n\n      if (enemy) {\n        this.createExplosion(enemy.x, enemy.y);\n        this.addScore(10);\n        enemy.destroy();\n      } else {\n        this.scene.start('GameOver', {\n          gameScore: this.passingData.score,\n        });\n      }\n    }, null, this);\n\n    this.physics.add.overlap(this.playerLasers, this.enemyLasers, (playerLaser, enemyLaser) => {\n      if (playerLaser) {\n        playerLaser.destroy();\n      }\n\n      if (enemyLaser) {\n        enemyLaser.destroy();\n      }\n    }, null, this);\n\n    this.physics.add.overlap(this.playerLasers, this.shieldTiles, (laser, tile) => {\n      if (laser) {\n        laser.destroy();\n      }\n\n      this.destroyShieldTile(tile);\n    }, null, this);\n\n    this.physics.add.overlap(this.enemyLasers, this.shieldTiles, (laser, tile) => {\n      if (laser) {\n        laser.destroy();\n      }\n\n      this.destroyShieldTile(tile);\n    }, null, this);\n\n    this.physics.add.overlap(this.player, this.enemies, (player) => {\n      if (player) {\n        player.destroy();\n\n        this.onLifeDown();\n      }\n    }, null, this);\n\n    this.physics.add.overlap(this.player, this.enemyLasers, (player, laser) => {\n      if (player) {\n        player.destroy();\n\n        this.onLifeDown();\n      }\n\n      if (laser) {\n        laser.destroy();\n      }\n    }, null, this);\n\n    const totalShieldsWidth = (4 * 96) + (7 * 8);\n    for (let i = 0; i < 4; i += 1) {\n      this.addShield(\n        ((this.game.config.width * 0.5) - (totalShieldsWidth * 0.5)) + ((i * 96) + (7 * 8)),\n        this.game.config.height - 128,\n      );\n    }\n  }\n\n\n  addScore(amount) {\n    this.passingData.score += amount;\n    this.textScore.setText(`Score: ${this.passingData.score}`);\n  }\n\n  setEnemyDirection(direction) {\n    this.lastEnemyMoveDir = this.enemyMoveDir;\n    this.enemyMoveDir = direction;\n  }\n\n  updateEnemiesMovement() {\n    this.enemyMoveTimer = this.time.addEvent({\n      delay: 1024,\n      callback() {\n        if (this.enemyMoveDir === 'RIGHT') {\n          this.enemyRect.x += 6;\n\n          if (this.enemyRect.x + this.enemyRect.width > this.game.config.width - 20) {\n            this.setEnemyDirection('DOWN');\n          }\n        } else if (this.enemyMoveDir === 'LEFT') {\n          this.enemyRect.x -= 6;\n\n          if (this.enemyRect.x < 20) {\n            this.setEnemyDirection('DOWN');\n          }\n        } else if (this.enemyMoveDir === 'DOWN') {\n          this.enemyMoveTimer.delay -= 100;\n          this.moveEnemiesDown();\n        }\n\n        for (let i = this.enemies.getChildren().length - 1; i >= 0; i -= 1) {\n          const enemy = this.enemies.getChildren()[i];\n\n          if (this.enemyMoveDir === 'RIGHT') {\n            enemy.x += 6;\n          } else if (this.enemyMoveDir === 'LEFT') {\n            enemy.x -= 6;\n          }\n        }\n      },\n      callbackScope: this,\n      loop: true,\n    });\n  }\n\n  updateEnemiesShooting() {\n    this.time.addEvent({\n      delay: 300,\n      callback() {\n        for (let i = 0; i < this.enemies.getChildren().length; i += 1) {\n          const enemy = this.enemies.getChildren()[i];\n\n          if (_phaser_min__WEBPACK_IMPORTED_MODULE_0___default().Math.Between(0, 1000) > 995) {\n            const laser = new _content_enemy__WEBPACK_IMPORTED_MODULE_11__.EnemyLaser(this, enemy.x, enemy.y);\n            this.enemyLasers.add(laser);\n\n            this.sfx.laserEnemy.play();\n          }\n        }\n      },\n      callbackScope: this,\n      loop: true,\n    });\n  }\n\n  moveEnemiesDown() {\n    for (let i = this.enemies.getChildren().length - 1; i >= 0; i -= 1) {\n      const enemy = this.enemies.getChildren()[i];\n\n      enemy.y += 20;\n\n      if (this.lastEnemyMoveDir === 'LEFT') {\n        this.setEnemyDirection('RIGHT');\n      } else if (this.lastEnemyMoveDir === 'RIGHT') {\n        this.setEnemyDirection('LEFT');\n      }\n    }\n  }\n\n  updatePlayerMovement() {\n    this.time.addEvent({\n      delay: 60,\n      callback() {\n        if (this.keyA.isDown) {\n          this.player.x -= 8;\n        }\n\n        if (this.keyD.isDown) {\n          this.player.x += 8;\n        }\n      },\n      callbackScope: this,\n      loop: true,\n    });\n  }\n\n  updatePlayerShooting() {\n    this.time.addEvent({\n      delay: 15,\n      callback() {\n        if (this.keySpace.isDown && this.player.active) {\n          if (this.playerShootTick < this.playerShootDelay) {\n            this.playerShootTick += 1;\n          } else {\n            const laser = new _content_player__WEBPACK_IMPORTED_MODULE_10__.PlayerLaser(this, this.player.x, this.player.y);\n            this.playerLasers.add(laser);\n\n            this.sfx.laserPlayer.play();\n\n            this.playerShootTick = 0;\n          }\n        }\n      },\n      callbackScope: this,\n      loop: true,\n    });\n  }\n\n  updateLasers() {\n    this.time.addEvent({\n      delay: 30,\n      callback() {\n        for (let i = 0; i < this.playerLasers.getChildren().length; i += 1) {\n          const laser = this.playerLasers.getChildren()[i];\n\n          laser.y -= laser.displayHeight;\n\n          if (laser.y < 16) {\n            this.createExplosion(laser.x, laser.y);\n\n            if (laser) {\n              laser.destroy();\n            }\n          }\n        }\n      },\n      callbackScope: this,\n      loop: true,\n    });\n\n    this.time.addEvent({\n      delay: 128,\n      callback() {\n        for (let i = 0; i < this.enemyLasers.getChildren().length; i += 1) {\n          const laser = this.enemyLasers.getChildren()[i];\n\n          laser.y += laser.displayHeight;\n        }\n      },\n      callbackScope: this,\n      loop: true,\n    });\n  }\n\n  addShield(posX, posY) {\n    for (let y = 0; y < this.shieldPattern.length; y += 1) {\n      for (let x = 0; x < this.shieldPattern[y].length; x += 1) {\n        if (this.shieldPattern[y][x] === 1) {\n          const tile = new _content_entity__WEBPACK_IMPORTED_MODULE_12__.ShieldTile(\n            this,\n            posX + (x * 8),\n            posY + (y * 8),\n          );\n          this.shieldTiles.add(tile);\n        }\n      }\n    }\n  }\n\n  destroyShieldTile(tile) {\n    if (tile) {\n      this.createExplosion(tile.x, tile.y);\n\n      for (let i = 0; i < _phaser_min__WEBPACK_IMPORTED_MODULE_0___default().Math.Between(10, 20); i += 1) {\n        const shieldHole = this.add.graphics({\n          fillStyle: {\n            color: 0x000000,\n          },\n        });\n        shieldHole.setDepth(-1);\n\n        const size = _phaser_min__WEBPACK_IMPORTED_MODULE_0___default().Math.Between(2, 4);\n        const self = this;\n\n        if (_phaser_min__WEBPACK_IMPORTED_MODULE_0___default().Math.Between(0, 100) > 25) {\n          const rect = new (_phaser_min__WEBPACK_IMPORTED_MODULE_0___default().Geom.Rectangle)(\n            tile.x + (_phaser_min__WEBPACK_IMPORTED_MODULE_0___default().Math.Between(-2, tile.displayWidth + 2)),\n            tile.y + (_phaser_min__WEBPACK_IMPORTED_MODULE_0___default().Math.Between(-2, tile.displayHeight + 2)),\n            size,\n            size,\n          );\n          shieldHole.fillRectShape(rect);\n          self.shieldHoles.add(shieldHole);\n        } else {\n          const rect = new (_phaser_min__WEBPACK_IMPORTED_MODULE_0___default().Geom.Rectangle)(\n            tile.x + (_phaser_min__WEBPACK_IMPORTED_MODULE_0___default().Math.Between(-4, tile.displayWidth + 4)),\n            tile.y + (_phaser_min__WEBPACK_IMPORTED_MODULE_0___default().Math.Between(-4, tile.displayHeight + 4)),\n          );\n          shieldHole.fillRectShape(rect);\n          self.shieldHoles.add(shieldHole);\n        }\n      }\n      tile.destroy();\n    }\n  }\n\n  createExplosion(x, y) {\n    this.sfx.explode.play();\n\n    const explosion = new _content_entity__WEBPACK_IMPORTED_MODULE_12__.Explosion(this, x, y);\n    this.explosions.add(explosion);\n  }\n\n  createLivesIcons() {\n    for (let i = 0; i < this.passingData.lives; i += 1) {\n      const icon = this.add.sprite(\n        32 + (i * 32),\n        this.game.config.height - 24,\n        'sprPlayer',\n      );\n      icon.setScale(2);\n      icon.setDepth(5);\n    }\n  }\n\n  onLifeDown() {\n    if (this.passingData.lives === 0) {\n      this.textScore.setVisible(false);\n      this.scene.start('GameOver', {\n        gameScore: this.passingData.score,\n      });\n      this.passingData.score = 0;\n      this.passingData.lives = 3;\n    }\n\n    this.time.addEvent({\n      delay: 3000,\n      callback() {\n        if (this.passingData.lives > 0) {\n          this.passingData.lives -= 1;\n\n          this.scene.start('SceneMain', this.passingData);\n        } else {\n          this.scene.start('SceneMain', { });\n        }\n      },\n      callbackScope: this,\n      loop: false,\n    });\n  }\n}\n\n\n//# sourceURL=webpack://Shooter-Game/./src/js/sceneMain.js?");

/***/ }),

/***/ "./src/js/score.js":
/*!*************************!*\
  !*** ./src/js/score.js ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => /* binding */ Score\n/* harmony export */ });\n/* harmony import */ var _phaser_min__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../phaser.min */ \"./src/phaser.min.js\");\n/* harmony import */ var _phaser_min__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_phaser_min__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _helpers_scoreLogic__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../helpers/scoreLogic */ \"./src/helpers/scoreLogic.js\");\n/* harmony import */ var _assets_images_baseBg_png__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../assets/images/baseBg.png */ \"./assets/images/baseBg.png\");\n/* harmony import */ var _assets_images_buttonUp_png__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../assets/images/buttonUp.png */ \"./assets/images/buttonUp.png\");\n/* harmony import */ var _assets_images_return_png__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../assets/images/return.png */ \"./assets/images/return.png\");\n\n\n\n\n\n\nclass Score extends (_phaser_min__WEBPACK_IMPORTED_MODULE_0___default().Scene) {\n  constructor() {\n    super('Score');\n  }\n\n  preload() {\n    this.load.image('endBG', _assets_images_baseBg_png__WEBPACK_IMPORTED_MODULE_2__.default);\n    this.load.image('SbtnUP', _assets_images_buttonUp_png__WEBPACK_IMPORTED_MODULE_3__.default);\n    this.load.image('returnBtn', _assets_images_return_png__WEBPACK_IMPORTED_MODULE_4__.default);\n  }\n\n  create() {\n    this.add.image(260, 440, 'endBG');\n\n    this.add.text(\n      this.game.config.width * 0.5,\n      70,\n      'Leaders Board', {\n        fontSize: 28,\n        fontFamily: 'monospace',\n      },\n    ).setOrigin(0.5);\n\n\n    this.returnButton = this.add.sprite(\n      this.game.config.width * 0.5,\n      this.game.config.height * 0.9,\n      'returnBtn',\n    );\n\n    this.returnButton.setInteractive();\n\n    this.returnButton.on('pointerdown', () => {\n      this.scene.start('StartScene');\n    }, this);\n\n    this.setUpScores();\n  }\n\n  async setUpScores() {\n    const resultObject = await (0,_helpers_scoreLogic__WEBPACK_IMPORTED_MODULE_1__.getGameScores)();\n\n    if (Array.isArray(resultObject.result)) {\n      this.scores = resultObject.result.sort((a, b) => ((a.score > b.score) ? -1 : 1));\n\n      for (let i = 0; i < 10; i += 1) {\n        const y = 150 + (30 * i);\n\n        this.addText(150, y, this.scores[i].user);\n        this.addText(400, y, this.scores[i].score);\n      }\n    } else {\n      this.addText(150, 160, resultObject);\n    }\n  }\n\n  addText(x, y, text) {\n    this.add.text(\n      x,\n      y,\n      text,\n      {\n        fontFamily: 'monospace',\n        fontSize: 15,\n        fontStyle: 'bold',\n        color: '#ffffff',\n        align: 'center',\n      },\n    ).setOrigin(0.5);\n  }\n}\n\n\n//# sourceURL=webpack://Shooter-Game/./src/js/score.js?");

/***/ }),

/***/ "./src/js/startScene.js":
/*!******************************!*\
  !*** ./src/js/startScene.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => /* binding */ StartScene\n/* harmony export */ });\n/* harmony import */ var _phaser_min__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../phaser.min */ \"./src/phaser.min.js\");\n/* harmony import */ var _phaser_min__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_phaser_min__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _assets_images_playButton_png__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../assets/images/playButton.png */ \"./assets/images/playButton.png\");\n/* harmony import */ var _assets_images_leadersBoardButton_png__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../assets/images/leadersBoardButton.png */ \"./assets/images/leadersBoardButton.png\");\n/* harmony import */ var _assets_audio_sndBtn_wav__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../assets/audio/sndBtn.wav */ \"./assets/audio/sndBtn.wav\");\n/* harmony import */ var _assets_images_baseBg_png__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../assets/images/baseBg.png */ \"./assets/images/baseBg.png\");\n\n\n\n\n\n\nclass StartScene extends (_phaser_min__WEBPACK_IMPORTED_MODULE_0___default().Scene) {\n  constructor() {\n    super({ key: 'StartScene' });\n  }\n\n  preload() {\n    this.load.image('sprBtnPlay', _assets_images_playButton_png__WEBPACK_IMPORTED_MODULE_1__.default);\n    this.load.image('bgStart', _assets_images_baseBg_png__WEBPACK_IMPORTED_MODULE_4__.default);\n    this.load.image('ldBtn', _assets_images_leadersBoardButton_png__WEBPACK_IMPORTED_MODULE_2__.default);\n\n    this.load.audio('sndBtn', _assets_audio_sndBtn_wav__WEBPACK_IMPORTED_MODULE_3__.default);\n  }\n\n  create() {\n    this.sfx = {\n      btn: this.sound.add('sndBtn'),\n    };\n\n    this.add.image(260, 400, 'bgStart');\n\n    this.textTitle = this.add.text(\n      this.game.config.width * 0.5,\n      64,\n      \"Space Wars\",\n      {\n        fontFamily: 'monospace',\n        fontSize: 32,\n        align: 'center',\n      },\n    );\n    this.textTitle.setOrigin(0.5);\n\n    this.btnPlay = this.add.sprite(\n      this.game.config.width * 0.5,\n      this.game.config.height * 0.5,\n      'sprBtnPlay',\n    );\n    this.btnPlay.setInteractive();\n\n    this.btnPlay.on('pointerover', () => {\n      this.sfx.btn.play();\n    }, this);\n\n    this.btnPlay.on('pointerdown', () => {\n      this.sfx.btn.play();\n      this.scene.start('SceneMain');\n    }, this);\n\n\n    this.leaderBoard = this.add.sprite(\n      this.game.config.width * 0.5,\n      this.game.config.height * 0.6,\n      'ldBtn',\n    );\n    this.leaderBoard.setInteractive();\n\n    this.leaderBoard.on('pointerover', () => {\n      this.sfx.btn.play();\n    }, this);\n\n\n    this.leaderBoard.on('pointerdown', () => {\n      this.sfx.btn.play();\n      this.scene.start('Score');\n    }, this);\n\n    const style = {\n      fontFamily: 'monospace',\n      fontSize: 16,\n      color: '#aaf',\n      align: 'center',\n    };\n    const instruction1 = 'Use A and D to move your plane left or right.';\n    const instruction2 = 'Use Space Bar to shoot.';\n    const xPos = this.game.config.width * 0.5;\n    const yPos = this.game.config.height - 40;\n    this.instructions1 = this.add.text(xPos, yPos, instruction1, style);\n    this.instructions1.setOrigin(0.5);\n    this.instructions2 = this.add.text(xPos, yPos + 20, instruction2, style);\n    this.instructions2.setOrigin(0.5);\n  }\n}\n\n\n//# sourceURL=webpack://Shooter-Game/./src/js/startScene.js?");

/***/ }),

/***/ "./src/phaser.min.js":
/*!***************************!*\
  !*** ./src/phaser.min.js ***!
  \***************************/
/***/ ((module) => {

eval("!(function (t, e) {  true ? module.exports = e() : 0; }(window, () => {\n  return n = {}, s.m = i = [function (t, e) { function r(t, e, i, n) { for (const s in e) if (e.hasOwnProperty(s)) { const r = (l = e, u = s, f = d = void 0, f = (c = i) ? l[u] : Object.getOwnPropertyDescriptor(l, u), !c && f.value && typeof f.value === 'object' && (f = f.value), !(!f || !((d = f).get && typeof d.get === 'function' || d.set && typeof d.set === 'function')) && (void 0 === f.enumerable && (f.enumerable = !0), void 0 === f.configurable && (f.configurable = !0), f)); if (!1 !== r) { if (o = (n || t).prototype, a = s, h = void 0, (h = Object.getOwnPropertyDescriptor(o, a)) && (h.value && typeof h.value === 'object' && (h = h.value), !1 === h.configurable)) { if (p.ignoreFinals) continue; throw new Error(`cannot override final property '${s}', set Class.ignoreFinals = true to skip`); }Object.defineProperty(t.prototype, s, r); } else t.prototype[s] = e[s]; } let o; let a; let h; let l; let u; let c; let d; let f; } function o(t, e) { if (e) { Array.isArray(e) || (e = [e]); for (let i = 0; i < e.length; i++)r(t, e[i].prototype || e[i]); } } function p(t) { let e; let i; let n; if ((t = t || {}).initialize) { if (typeof t.initialize !== 'function') throw new Error('initialize must be a function'); n = t.initialize, delete t.initialize; } else { n = t.Extends ? (i = t.Extends, function () { i.apply(this, arguments); }) : function () {}; }t.Extends ? (n.prototype = Object.create(t.Extends.prototype), n.prototype.constructor = n, e = t.Extends, delete t.Extends) : n.prototype.constructor = n; let s = null; return t.Mixins && (s = t.Mixins, delete t.Mixins), o(n, s), r(n, t, !0, e), n; }p.extend = r, p.mixin = o, p.ignoreFinals = !1, t.exports = p; }, function (t, e) { t.exports = function () {}; }, function (t, e) { t.exports = function (t, e, i) { const n = typeof t; return t && n != 'number' && n != 'string' && t.hasOwnProperty(e) && void 0 !== t[e] ? t[e] : i; }; }, function (t, e, i) {\n    const n = i(0); const s = i(106); var r = new n({\n      initialize(t, e) { this.x = 0, this.y = 0, typeof t === 'object' ? (this.x = t.x || 0, this.y = t.y || 0) : (void 0 === e && (e = t), this.x = t || 0, this.y = e || 0); }, clone() { return new r(this.x, this.y); }, copy(t) { return this.x = t.x || 0, this.y = t.y || 0, this; }, setFromObject(t) { return this.x = t.x || 0, this.y = t.y || 0, this; }, set(t, e) { return void 0 === e && (e = t), this.x = t, this.y = e, this; }, setTo(t, e) { return this.set(t, e); }, setToPolar(t, e) { return e == null && (e = 1), this.x = Math.cos(t) * e, this.y = Math.sin(t) * e, this; }, equals(t) { return this.x === t.x && this.y === t.y; }, fuzzyEquals(t, e) { return s(this.x, t.x, e) && s(this.y, t.y, e); }, angle() { let t = Math.atan2(this.y, this.x); return t < 0 && (t += 2 * Math.PI), t; }, setAngle(t) { return this.setToPolar(t, this.length()); }, add(t) { return this.x += t.x, this.y += t.y, this; }, subtract(t) { return this.x -= t.x, this.y -= t.y, this; }, multiply(t) { return this.x *= t.x, this.y *= t.y, this; }, scale(t) { return isFinite(t) ? (this.x *= t, this.y *= t) : (this.x = 0, this.y = 0), this; }, divide(t) { return this.x /= t.x, this.y /= t.y, this; }, negate() { return this.x = -this.x, this.y = -this.y, this; }, distance(t) { const e = t.x - this.x; const i = t.y - this.y; return Math.sqrt(e * e + i * i); }, distanceSq(t) { const e = t.x - this.x; const i = t.y - this.y; return e * e + i * i; }, length() { const t = this.x; const e = this.y; return Math.sqrt(t * t + e * e); }, setLength(t) { return this.normalize().scale(t); }, lengthSq() { const t = this.x; const e = this.y; return t * t + e * e; }, normalize() { const t = this.x; const e = this.y; let i = t * t + e * e; return i > 0 && (i = 1 / Math.sqrt(i), this.x = t * i, this.y = e * i), this; }, normalizeRightHand() { const t = this.x; return this.x = -1 * this.y, this.y = t, this; }, normalizeLeftHand() { const t = this.x; return this.x = this.y, this.y = -1 * t, this; }, dot(t) { return this.x * t.x + this.y * t.y; }, cross(t) { return this.x * t.y - this.y * t.x; }, lerp(t, e) { void 0 === e && (e = 0); const i = this.x; const n = this.y; return this.x = i + e * (t.x - i), this.y = n + e * (t.y - n), this; }, transformMat3(t) { const e = this.x; const i = this.y; const n = t.val; return this.x = n[0] * e + n[3] * i + n[6], this.y = n[1] * e + n[4] * i + n[7], this; }, transformMat4(t) { const e = this.x; const i = this.y; const n = t.val; return this.x = n[0] * e + n[4] * i + n[12], this.y = n[1] * e + n[5] * i + n[13], this; }, reset() { return this.x = 0, this.y = 0, this; }, limit(t) { const e = this.length(); return e && t < e && this.scale(t / e), this; }, reflect(t) { return t = t.clone().normalize(), this.subtract(t.scale(2 * this.dot(t))); }, mirror(t) { return this.reflect(t).negate(); }, rotate(t) { const e = Math.cos(t); const i = Math.sin(t); return this.set(e * this.x - i * this.y, i * this.x + e * this.y); },\n    }); r.ZERO = new r(), r.RIGHT = new r(1, 0), r.LEFT = new r(-1, 0), r.UP = new r(0, -1), r.DOWN = new r(0, 1), r.ONE = new r(1, 1), t.exports = r;\n  }, function (t, e, i) { const n = i(0); const s = i(47); const r = new n({ initialize(t, e) { void 0 === t && (t = 0), void 0 === e && (e = t), this.type = s.POINT, this.x = t, this.y = e; }, setTo(t, e) { return void 0 === t && (t = 0), void 0 === e && (e = t), this.x = t, this.y = e, this; } }); t.exports = r; }, function (t, e, i) {\n    const n = i(0); const s = i(23); const r = i(22); const o = new n({\n      initialize(t) { this.scene = t, this.systems = t.sys, this.displayList, this.updateList, t.sys.events.once(r.BOOT, this.boot, this), t.sys.events.on(r.START, this.start, this); }, boot() { this.displayList = this.systems.displayList, this.updateList = this.systems.updateList, this.systems.events.once(r.DESTROY, this.destroy, this); }, start() { this.systems.events.once(r.SHUTDOWN, this.shutdown, this); }, existing(t) { return (t.renderCanvas || t.renderWebGL) && this.displayList.add(t), t.preUpdate && this.updateList.add(t), t; }, shutdown() { this.systems.events.off(r.SHUTDOWN, this.shutdown, this); }, destroy() { this.shutdown(), this.scene.sys.events.off(r.START, this.start, this), this.scene = null, this.systems = null, this.displayList = null, this.updateList = null; },\n    }); o.register = function (t, e) { o.prototype.hasOwnProperty(t) || (o.prototype[t] = e); }, o.remove = function (t) { o.prototype.hasOwnProperty(t) && delete o.prototype[t]; }, s.register('GameObjectFactory', o, 'add'), t.exports = o;\n  }, function (t, e) { t.exports = function (t, e, i) { if (t && typeof t !== 'number') { if (t.hasOwnProperty(e)) return t[e]; if (e.indexOf('.') === -1) return i; for (var n = e.split('.'), s = t, r = i, o = 0; o < n.length; o++) { if (!s.hasOwnProperty(n[o])) { r = i; break; }r = s[n[o]], s = s[n[o]]; } return r; } return i; }; }, function (t, e) { t.exports = function (t) { if (typeof t !== 'object' || t.nodeType || t === t.window) return !1; try { if (t.constructor && !{}.hasOwnProperty.call(t.constructor.prototype, 'isPrototypeOf')) return !1; } catch (t) { return !1; } return !0; }; }, function (t, e) { let i = {}; const n = { install(t) { for (const e in i)t[e] = i[e]; }, register(t, e) { i[t] = e; }, destroy() { i = {}; } }; t.exports = n; }, function (t, e) {\n    t.exports = {\n      getTintFromFloats(t, e, i, n) { return ((255 & (255 * n | 0)) << 24 | (255 & (255 * t | 0)) << 16 | (255 & (255 * e | 0)) << 8 | 255 & (255 * i | 0)) >>> 0; }, getTintAppendFloatAlpha(t, e) { return ((255 & (255 * e | 0)) << 24 | t) >>> 0; }, getTintAppendFloatAlphaAndSwap(t, e) { return ((255 & (255 * e | 0)) << 24 | (255 & (0 | t)) << 16 | (255 & (t >> 8 | 0)) << 8 | 255 & (t >> 16 | 0)) >>> 0; }, getFloatsFromUintRGB(t) { return [(255 & (t >> 16 | 0)) / 255, (255 & (t >> 8 | 0)) / 255, (255 & (0 | t)) / 255]; }, getComponentCount(t, e) { for (var i = 0, n = 0; n < t.length; ++n) { const s = t[n]; s.type === e.FLOAT ? i += s.size : i += 1; } return i; },\n    };\n  }, function (t, e, i) {\n    const n = Object.prototype.hasOwnProperty; let f = '~'; function s() {} function a(t, e, i) { this.fn = t, this.context = e, this.once = i || !1; } function r(t, e, i, n, s) { if (typeof i !== 'function') throw new TypeError('The listener must be a function'); const r = new a(i, n || t, s); const o = f ? f + e : e; return t._events[o] ? t._events[o].fn ? t._events[o] = [t._events[o], r] : t._events[o].push(r) : (t._events[o] = r, t._eventsCount++), t; } function l(t, e) { --t._eventsCount == 0 ? t._events = new s() : delete t._events[e]; } function o() { this._events = new s(), this._eventsCount = 0; }Object.create && (s.prototype = Object.create(null), (new s()).__proto__ || (f = !1)), o.prototype.eventNames = function () { let t; let e; const i = []; if (this._eventsCount === 0) return i; for (e in t = this._events)n.call(t, e) && i.push(f ? e.slice(1) : e); return Object.getOwnPropertySymbols ? i.concat(Object.getOwnPropertySymbols(t)) : i; }, o.prototype.listeners = function (t) { const e = f ? f + t : t; const i = this._events[e]; if (!i) return []; if (i.fn) return [i.fn]; for (var n = 0, s = i.length, r = new Array(s); n < s; n++)r[n] = i[n].fn; return r; }, o.prototype.listenerCount = function (t) { const e = f ? f + t : t; const i = this._events[e]; return i ? i.fn ? 1 : i.length : 0; }, o.prototype.emit = function (t, e, i, n, s, r) { const o = f ? f + t : t; if (!this._events[o]) return !1; let a; const h = this._events[o]; const l = arguments.length; if (h.fn) { switch (h.once && this.removeListener(t, h.fn, void 0, !0), l) { case 1: return h.fn.call(h.context), !0; case 2: return h.fn.call(h.context, e), !0; case 3: return h.fn.call(h.context, e, i), !0; case 4: return h.fn.call(h.context, e, i, n), !0; case 5: return h.fn.call(h.context, e, i, n, s), !0; case 6: return h.fn.call(h.context, e, i, n, s, r), !0; } for (d = 1, a = new Array(l - 1); d < l; d++)a[d - 1] = arguments[d]; h.fn.apply(h.context, a); } else for (var u, c = h.length, d = 0; d < c; d++) switch (h[d].once && this.removeListener(t, h[d].fn, void 0, !0), l) { case 1: h[d].fn.call(h[d].context); break; case 2: h[d].fn.call(h[d].context, e); break; case 3: h[d].fn.call(h[d].context, e, i); break; case 4: h[d].fn.call(h[d].context, e, i, n); break; default: if (!a) for (u = 1, a = new Array(l - 1); u < l; u++)a[u - 1] = arguments[u]; h[d].fn.apply(h[d].context, a); } return !0; }, o.prototype.on = function (t, e, i) { return r(this, t, e, i, !1); }, o.prototype.once = function (t, e, i) { return r(this, t, e, i, !0); }, o.prototype.removeListener = function (t, e, i, n) { const s = f ? f + t : t; if (!this._events[s]) return this; if (!e) return l(this, s), this; const r = this._events[s]; if (r.fn)r.fn !== e || n && !r.once || i && r.context !== i || l(this, s); else { for (var o = 0, a = [], h = r.length; o < h; o++)(r[o].fn !== e || n && !r[o].once || i && r[o].context !== i) && a.push(r[o]); a.length ? this._events[s] = a.length === 1 ? a[0] : a : l(this, s); } return this; }, o.prototype.removeAllListeners = function (t) { let e; return t ? (e = f ? f + t : t, this._events[e] && l(this, e)) : (this._events = new s(), this._eventsCount = 0), this; }, o.prototype.off = o.prototype.removeListener, o.prototype.addListener = o.prototype.on, o.prefixed = f, o.EventEmitter = o, t.exports = o;\n  }, function (t, e, i) {\n    const n = i(0); const s = i(48); const r = i(152); const o = i(274); const a = i(47); const h = i(56); const l = i(155); const u = new n({\n      initialize(t, e, i, n) { void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === n && (n = 0), this.type = a.RECTANGLE, this.x = t, this.y = e, this.width = i, this.height = n; }, contains(t, e) { return s(this, t, e); }, getPoint(t, e) { return r(this, t, e); }, getPoints(t, e, i) { return o(this, t, e, i); }, getRandomPoint(t) { return l(this, t); }, setTo(t, e, i, n) { return this.x = t, this.y = e, this.width = i, this.height = n, this; }, setEmpty() { return this.setTo(0, 0, 0, 0); }, setPosition(t, e) { return void 0 === e && (e = t), this.x = t, this.y = e, this; }, setSize(t, e) { return void 0 === e && (e = t), this.width = t, this.height = e, this; }, isEmpty() { return this.width <= 0 || this.height <= 0; }, getLineA(t) { return void 0 === t && (t = new h()), t.setTo(this.x, this.y, this.right, this.y), t; }, getLineB(t) { return void 0 === t && (t = new h()), t.setTo(this.right, this.y, this.right, this.bottom), t; }, getLineC(t) { return void 0 === t && (t = new h()), t.setTo(this.right, this.bottom, this.x, this.bottom), t; }, getLineD(t) { return void 0 === t && (t = new h()), t.setTo(this.x, this.bottom, this.x, this.y), t; }, left: { get() { return this.x; }, set(t) { t >= this.right ? this.width = 0 : this.width = this.right - t, this.x = t; } }, right: { get() { return this.x + this.width; }, set(t) { t <= this.x ? this.width = 0 : this.width = t - this.x; } }, top: { get() { return this.y; }, set(t) { t >= this.bottom ? this.height = 0 : this.height = this.bottom - t, this.y = t; } }, bottom: { get() { return this.y + this.height; }, set(t) { t <= this.y ? this.height = 0 : this.height = t - this.y; } }, centerX: { get() { return this.x + this.width / 2; }, set(t) { this.x = t - this.width / 2; } }, centerY: { get() { return this.y + this.height / 2; }, set(t) { this.y = t - this.height / 2; } },\n    }); t.exports = u;\n  }, function (t, e, i) {\n    t.exports = {\n      Alpha: i(533), AlphaSingle: i(269), Animation: i(504), BlendMode: i(272), ComputedSize: i(552), Crop: i(553), Depth: i(273), Flip: i(554), GetBounds: i(555), Mask: i(277), Origin: i(572), PathFollower: i(573), Pipeline: i(156), ScrollFactor: i(280), Size: i(574), Texture: i(575), TextureCrop: i(576), Tint: i(577), ToJSON: i(281), Transform: i(282), TransformMatrix: i(29), Visible: i(283),\n    };\n  }, function (t, e) {\n    const i = {\n      PI2: 2 * Math.PI, TAU: 0.5 * Math.PI, EPSILON: 1e-6, DEG_TO_RAD: Math.PI / 180, RAD_TO_DEG: 180 / Math.PI, RND: null, MIN_SAFE_INTEGER: Number.MIN_SAFE_INTEGER || -9007199254740991, MAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER || 9007199254740991,\n    }; t.exports = i;\n  }, function (t, e, i) {\n    const n = i(0); const s = i(281); const r = i(113); const o = i(10); const a = i(90); var h = new n({\n      Extends: o, initialize(t, e) { o.call(this), this.scene = t, this.type = e, this.state = 0, this.parentContainer = null, this.name = '', this.active = !0, this.tabIndex = -1, this.data = null, this.renderFlags = 15, this.cameraFilter = 0, this.input = null, this.body = null, this.ignoreDestroy = !1, t.sys.queueDepthSort(); }, setActive(t) { return this.active = t, this; }, setName(t) { return this.name = t, this; }, setState(t) { return this.state = t, this; }, setDataEnabled() { return this.data || (this.data = new r(this)), this; }, setData(t, e) { return this.data || (this.data = new r(this)), this.data.set(t, e), this; }, incData(t, e) { return this.data || (this.data = new r(this)), this.data.inc(t, e), this; }, toggleData(t) { return this.data || (this.data = new r(this)), this.data.toggle(t), this; }, getData(t) { return this.data || (this.data = new r(this)), this.data.get(t); }, setInteractive(t, e, i) { return this.scene.sys.input.enable(this, t, e, i), this; }, disableInteractive() { return this.input && (this.input.enabled = !1), this; }, removeInteractive() { return this.scene.sys.input.clear(this), this.input = void 0, this; }, update() {}, toJSON() { return s(this); }, willRender(t) { return !(h.RENDER_MASK !== this.renderFlags || this.cameraFilter !== 0 && this.cameraFilter & t.id); }, getIndexList() { for (var t = this, e = this.parentContainer, i = []; e && (i.unshift(e.getIndex(t)), (t = e).parentContainer);)e = e.parentContainer; return i.unshift(this.scene.sys.displayList.getIndex(t)), i; }, destroy(t) { let e; void 0 === t && (t = !1), this.scene && !this.ignoreDestroy && (this.preDestroy && this.preDestroy.call(this), this.emit(a.DESTROY, this), e = this.scene.sys, t || (e.displayList.remove(this), e.updateList.remove(this)), this.input && (e.input.clear(this), this.input = void 0), this.data && (this.data.destroy(), this.data = void 0), this.body && (this.body.destroy(), this.body = void 0), t || e.queueDepthSort(), this.active = !1, this.visible = !1, this.scene = void 0, this.parentContainer = void 0, this.removeAllListeners()); },\n    }); h.RENDER_MASK = 15, t.exports = h;\n  }, function (t, e, i) { const s = i(170); const r = i(6); t.exports = function (t, e, i) { const n = r(t, e, null); if (n === null) return i; if (Array.isArray(n)) return s.RND.pick(n); if (typeof n === 'object') { if (n.hasOwnProperty('randInt')) return s.RND.integerInRange(n.randInt[0], n.randInt[1]); if (n.hasOwnProperty('randFloat')) return s.RND.realInRange(n.randFloat[0], n.randFloat[1]); } else if (typeof n === 'function') return n(e); return n; }; }, function (t, e, i) {\n    const n = i(0); const s = i(23); const r = i(22); const o = new n({\n      initialize(t) { this.scene = t, this.systems = t.sys, this.displayList, this.updateList, t.sys.events.once(r.BOOT, this.boot, this), t.sys.events.on(r.START, this.start, this); }, boot() { this.displayList = this.systems.displayList, this.updateList = this.systems.updateList, this.systems.events.once(r.DESTROY, this.destroy, this); }, start() { this.systems.events.once(r.SHUTDOWN, this.shutdown, this); }, shutdown() { this.systems.events.off(r.SHUTDOWN, this.shutdown, this); }, destroy() { this.shutdown(), this.scene.sys.events.off(r.START, this.start, this), this.scene = null, this.systems = null, this.displayList = null, this.updateList = null; },\n    }); o.register = function (t, e) { o.prototype.hasOwnProperty(t) || (o.prototype[t] = e); }, o.remove = function (t) { o.prototype.hasOwnProperty(t) && delete o.prototype[t]; }, s.register('GameObjectCreator', o, 'make'), t.exports = o;\n  }, function (t, e) {\n    t.exports = {\n      LOADER_IDLE: 0, LOADER_LOADING: 1, LOADER_PROCESSING: 2, LOADER_COMPLETE: 3, LOADER_SHUTDOWN: 4, LOADER_DESTROYED: 5, FILE_PENDING: 10, FILE_LOADING: 11, FILE_LOADED: 12, FILE_FAILED: 13, FILE_PROCESSING: 14, FILE_ERRORED: 16, FILE_COMPLETE: 17, FILE_DESTROYED: 18, FILE_POPULATED: 19,\n    };\n  }, function (t, e, i) { const u = i(7); var c = function () { let t; let e; let i; let n; let s; let r; let o = arguments[0] || {}; let a = 1; const h = arguments.length; let l = !1; for (typeof o === 'boolean' && (l = o, o = arguments[1] || {}, a = 2), h === a && (o = this, --a); a < h; a++) if ((t = arguments[a]) != null) for (e in t)i = o[e], o !== (n = t[e]) && (l && n && (u(n) || (s = Array.isArray(n))) ? (r = s ? (s = !1, i && Array.isArray(i) ? i : []) : i && u(i) ? i : {}, o[e] = c(l, r, n)) : void 0 !== n && (o[e] = n)); return o; }; t.exports = c; }, function (t, e) { t.exports = function (t, e, i) { return Math.max(e, Math.min(i, t)); }; }, function (t, e, i) {\n    t.exports = {\n      BLUR: i(556), BOOT: i(557), CONTEXT_LOST: i(558), CONTEXT_RESTORED: i(559), DESTROY: i(560), FOCUS: i(561), HIDDEN: i(562), PAUSE: i(563), POST_RENDER: i(564), POST_STEP: i(565), PRE_RENDER: i(566), PRE_STEP: i(567), READY: i(568), RESUME: i(569), STEP: i(570), VISIBLE: i(571),\n    };\n  }, function (t, e, i) {\n    const n = i(0); const s = i(17); const r = i(82); const o = i(2); const a = i(138); const h = i(215); const l = i(455); const u = i(139); const c = new n({\n      initialize(t, e) { this.loader = t, this.cache = o(e, 'cache', !1), this.type = o(e, 'type', !1), this.key = o(e, 'key', !1); const i = this.key; if (t.prefix && t.prefix !== '' && (this.key = t.prefix + i), !this.type || !this.key) throw new Error(`Error calling 'Loader.${this.type}' invalid key provided.`); this.url = o(e, 'url'), void 0 === this.url ? this.url = `${t.path + i}.${o(e, 'extension', '')}` : typeof this.url === 'string' && this.url.indexOf('blob:') !== 0 && this.url.indexOf('data:') !== 0 && (this.url = t.path + this.url), this.src = '', this.xhrSettings = u(o(e, 'responseType', void 0)), o(e, 'xhrSettings', !1) && (this.xhrSettings = h(this.xhrSettings, o(e, 'xhrSettings', {}))), this.xhrLoader = null, this.state = typeof this.url === 'function' ? s.FILE_POPULATED : s.FILE_PENDING, this.bytesTotal = 0, this.bytesLoaded = -1, this.percentComplete = -1, this.crossOrigin = void 0, this.data = void 0, this.config = o(e, 'config', {}), this.multiFile, this.linkFile; }, setLink(t) { (this.linkFile = t).linkFile = this; }, resetXHR() { this.xhrLoader && (this.xhrLoader.onload = void 0, this.xhrLoader.onerror = void 0, this.xhrLoader.onprogress = void 0); }, load() { this.state === s.FILE_POPULATED ? this.loader.nextFile(this, !0) : (this.state = s.FILE_LOADING, this.src = a(this, this.loader.baseURL), this.src.indexOf('data:') === 0 ? console.warn(`Local data URIs are not supported: ${this.key}`) : this.xhrLoader = l(this, this.loader.xhr)); }, onLoad(t, e) { const i = t.responseURL && t.responseURL.indexOf('file://') === 0 && e.target.status === 0; let n = !(e.target && e.target.status !== 200) || i; t.readyState === 4 && t.status >= 400 && t.status <= 599 && (n = !1), this.state = s.FILE_LOADED, this.resetXHR(), this.loader.nextFile(this, n); }, onError() { this.resetXHR(), this.loader.nextFile(this, !1); }, onProgress(t) { t.lengthComputable && (this.bytesLoaded = t.loaded, this.bytesTotal = t.total, this.percentComplete = Math.min(this.bytesLoaded / this.bytesTotal, 1), this.loader.emit(r.FILE_PROGRESS, this, this.percentComplete)); }, onProcess() { this.state = s.FILE_PROCESSING, this.onProcessComplete(); }, onProcessComplete() { this.state = s.FILE_COMPLETE, this.multiFile && this.multiFile.onFileComplete(this), this.loader.fileProcessComplete(this); }, onProcessError() { this.state = s.FILE_ERRORED, this.multiFile && this.multiFile.onFileFailed(this), this.loader.fileProcessComplete(this); }, hasCacheConflict() { return this.cache && this.cache.exists(this.key); }, addToCache() { this.cache && this.cache.add(this.key, this.data), this.pendingDestroy(); }, pendingDestroy(t) { void 0 === t && (t = this.data); const e = this.key; const i = this.type; this.loader.emit(r.FILE_COMPLETE, e, i, t), this.loader.emit(`${r.FILE_KEY_COMPLETE + i}-${e}`, e, i, t), this.loader.flagForRemoval(this); }, destroy() { this.loader = null, this.cache = null, this.xhrSettings = null, this.multiFile = null, this.linkFile = null, this.data = null; },\n    }); c.createObjectURL = function (t, e, i) { let n; typeof URL === 'function' ? t.src = URL.createObjectURL(e) : ((n = new FileReader()).onload = function () { t.removeAttribute('crossOrigin'), t.src = `data:${e.type || i};base64,${n.result.split(',')[1]}`; }, n.onerror = t.onerror, n.readAsDataURL(e)); }, c.revokeObjectURL = function (t) { typeof URL === 'function' && URL.revokeObjectURL(t.src); }, t.exports = c;\n  }, function (t, e, i) {\n    t.exports = {\n      BOOT: i(709), CREATE: i(710), DESTROY: i(711), PAUSE: i(712), POST_UPDATE: i(713), PRE_UPDATE: i(714), READY: i(715), RENDER: i(716), RESUME: i(717), SHUTDOWN: i(718), SLEEP: i(719), START: i(720), TRANSITION_COMPLETE: i(721), TRANSITION_INIT: i(722), TRANSITION_OUT: i(723), TRANSITION_START: i(724), TRANSITION_WAKE: i(725), UPDATE: i(726), WAKE: i(727),\n    };\n  }, function (t, e) {\n    const s = {}; const r = {}; const i = {\n      register(t, e, i, n) { void 0 === n && (n = !1), s[t] = { plugin: e, mapping: i, custom: n }; }, registerCustom(t, e, i, n) { r[t] = { plugin: e, mapping: i, data: n }; }, hasCore(t) { return s.hasOwnProperty(t); }, hasCustom(t) { return r.hasOwnProperty(t); }, getCore(t) { return s[t]; }, getCustom(t) { return r[t]; }, getCustomClass(t) { return r.hasOwnProperty(t) ? r[t].plugin : null; }, remove(t) { s.hasOwnProperty(t) && delete s[t]; }, removeCustom(t) { r.hasOwnProperty(t) && delete r[t]; }, destroyCorePlugins() { for (const t in s)s.hasOwnProperty(t) && delete s[t]; }, destroyCustomPlugins() { for (const t in r)r.hasOwnProperty(t) && delete r[t]; },\n    }; t.exports = i;\n  }, function (t, e, i) { const f = i(2); t.exports = function (t, e, i, n, s, r) { void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = r.width), void 0 === n && (n = r.height); const o = f(s, 'isNotEmpty', !1); const a = f(s, 'isColliding', !1); const h = f(s, 'hasInterestingFace', !1); t < 0 && (i += t, t = 0), e < 0 && (n += e, e = 0), t + i > r.width && (i = Math.max(r.width - t, 0)), e + n > r.height && (n = Math.max(r.height - e, 0)); for (var l = [], u = e; u < e + n; u++) for (let c = t; c < t + i; c++) { const d = r.data[u][c]; if (d !== null) { if (o && d.index === -1) continue; if (a && !d.collides) continue; if (h && !d.hasInterestingFace) continue; l.push(d); } } return l; }; }, function (t, e) { t.exports = function (t, e, i, n, s, r) { let o; void 0 === n && (n = 0), void 0 === s && (s = 0), void 0 === r && (r = 1); let a = 0; const h = t.length; if (r === 1) for (o = s; o < h; o++)t[o][e] = i + a * n, a++; else for (o = s; o >= 0; o--)t[o][e] = i + a * n, a++; return t; }; }, function (t, e, i) {\n    let a; const h = i(33); const l = i(167); const u = []; let c = !1; function n(t, e, i, n, s) { void 0 === e && (e = 1), void 0 === i && (i = 1), void 0 === n && (n = h.CANVAS), void 0 === s && (s = !1); let r = a(n); const o = (r === null ? (r = { parent: t, canvas: document.createElement('canvas'), type: n }, n === h.CANVAS && u.push(r)) : r.parent = t, r.canvas); return s && (r.parent = o), o.width = e, o.height = i, c && n === h.CANVAS && l.disable(o.getContext('2d')), o; } function s() { let e = 0; return u.forEach((t) => { t.parent && e++; }), e; }t.exports = {\n      create2D(t, e, i) { return n(t, e, i, h.CANVAS); }, create: n, createWebGL(t, e, i) { return n(t, e, i, h.WEBGL); }, disableSmoothing() { c = !0; }, enableSmoothing() { c = !1; }, first: a = function (t) { if (void 0 === t && (t = h.CANVAS), t === h.WEBGL) return null; for (let e = 0; e < u.length; e++) { const i = u[e]; if (!i.parent && i.type === t) return i; } return null; }, free() { return u.length - s(); }, pool: u, remove(e) { const i = e instanceof HTMLCanvasElement; u.forEach((t) => { (i && t.canvas === e || !i && t.parent === e) && (t.parent = null, t.canvas.width = 1, t.canvas.height = 1); }); }, total: s,\n    };\n  }, function (t, e, i) { const l = i(52); const u = i(15); t.exports = function (t, e, i) { e.x = u(i, 'x', 0), e.y = u(i, 'y', 0), e.depth = u(i, 'depth', 0), e.flipX = u(i, 'flipX', !1), e.flipY = u(i, 'flipY', !1); const n = u(i, 'scale', null); typeof n === 'number' ? e.setScale(n) : n !== null && (e.scaleX = u(n, 'x', 1), e.scaleY = u(n, 'y', 1)); const s = u(i, 'scrollFactor', null); typeof s === 'number' ? e.setScrollFactor(s) : s !== null && (e.scrollFactorX = u(s, 'x', 1), e.scrollFactorY = u(s, 'y', 1)), e.rotation = u(i, 'rotation', 0); const r = u(i, 'angle', null); r !== null && (e.angle = r), e.alpha = u(i, 'alpha', 1); let o; let a; const h = u(i, 'origin', null); return typeof h === 'number' ? e.setOrigin(h) : h !== null && (o = u(h, 'x', 0.5), a = u(h, 'y', 0.5), e.setOrigin(o, a)), e.blendMode = u(i, 'blendMode', l.NORMAL), e.visible = u(i, 'visible', !0), u(i, 'add', !0) && t.sys.displayList.add(e), e.preUpdate && t.sys.updateList.add(e), e; }; }, function (t, e) { t.exports = function (t, e, i, n, s) { const r = n.alpha * i.alpha; if (r <= 0) return !1; const o = t._tempMatrix1.copyFromArray(n.matrix.matrix); const a = t._tempMatrix2.applyITRS(i.x, i.y, i.rotation, i.scaleX, i.scaleY); const h = t._tempMatrix3; return s ? (o.multiplyWithOffset(s, -n.scrollX * i.scrollFactorX, -n.scrollY * i.scrollFactorY), a.e = i.x, a.f = i.y) : (a.e -= n.scrollX * i.scrollFactorX, a.f -= n.scrollY * i.scrollFactorY), o.multiply(a, h), e.globalCompositeOperation = t.blendModes[i.blendMode], e.globalAlpha = r, e.save(), h.setToContext(e), e.imageSmoothingEnabled = !(!t.antialias || i.frame && i.frame.source.scaleMode), !0; }; }, function (t, e, i) {\n    const n = i(0); const r = i(13); const c = i(3); const s = new n({\n      initialize(t, e, i, n, s, r) {\n        void 0 === t && (t = 1), void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === n && (n = 1), void 0 === s && (s = 0), void 0 === r && (r = 0), this.matrix = new Float32Array([t, e, i, n, s, r, 0, 0, 1]), this.decomposedMatrix = {\n          translateX: 0, translateY: 0, scaleX: 1, scaleY: 1, rotation: 0,\n        };\n      },\n      a: { get() { return this.matrix[0]; }, set(t) { this.matrix[0] = t; } },\n      b: { get() { return this.matrix[1]; }, set(t) { this.matrix[1] = t; } },\n      c: { get() { return this.matrix[2]; }, set(t) { this.matrix[2] = t; } },\n      d: { get() { return this.matrix[3]; }, set(t) { this.matrix[3] = t; } },\n      e: { get() { return this.matrix[4]; }, set(t) { this.matrix[4] = t; } },\n      f: { get() { return this.matrix[5]; }, set(t) { this.matrix[5] = t; } },\n      tx: { get() { return this.matrix[4]; }, set(t) { this.matrix[4] = t; } },\n      ty: { get() { return this.matrix[5]; }, set(t) { this.matrix[5] = t; } },\n      rotation: { get() { return Math.acos(this.a / this.scaleX) * (Math.atan(-this.c / this.a) < 0 ? -1 : 1); } },\n      rotationNormalized: { get() { const t = this.matrix; const e = t[0]; const i = t[1]; const n = t[2]; const s = t[3]; return e || i ? i > 0 ? Math.acos(e / this.scaleX) : -Math.acos(e / this.scaleX) : n || s ? r.TAU - (s > 0 ? Math.acos(-n / this.scaleY) : -Math.acos(n / this.scaleY)) : 0; } },\n      scaleX: { get() { return Math.sqrt(this.a * this.a + this.b * this.b); } },\n      scaleY: { get() { return Math.sqrt(this.c * this.c + this.d * this.d); } },\n      loadIdentity() { const t = this.matrix; return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 1, t[4] = 0, t[5] = 0, this; },\n      translate(t, e) { const i = this.matrix; return i[4] = i[0] * t + i[2] * e + i[4], i[5] = i[1] * t + i[3] * e + i[5], this; },\n      scale(t, e) { const i = this.matrix; return i[0] *= t, i[1] *= t, i[2] *= e, i[3] *= e, this; },\n      rotate(t) { const e = Math.sin(t); const i = Math.cos(t); const n = this.matrix; const s = n[0]; const r = n[1]; const o = n[2]; const a = n[3]; return n[0] = s * i + o * e, n[1] = r * i + a * e, n[2] = s * -e + o * i, n[3] = r * -e + a * i, this; },\n      multiply(t, e) { const i = this.matrix; const n = t.matrix; const s = i[0]; const r = i[1]; const o = i[2]; const a = i[3]; const h = i[4]; const l = i[5]; const u = n[0]; const c = n[1]; const d = n[2]; const f = n[3]; const p = n[4]; const g = n[5]; const v = void 0 === e ? this : e; return v.a = u * s + c * o, v.b = u * r + c * a, v.c = d * s + f * o, v.d = d * r + f * a, v.e = p * s + g * o + h, v.f = p * r + g * a + l, v; },\n      multiplyWithOffset(t, e, i) { const n = this.matrix; const s = t.matrix; const r = n[0]; const o = n[1]; const a = n[2]; const h = n[3]; const l = e * r + i * a + n[4]; const u = e * o + i * h + n[5]; const c = s[0]; const d = s[1]; const f = s[2]; const p = s[3]; const g = s[4]; const v = s[5]; return n[0] = c * r + d * a, n[1] = c * o + d * h, n[2] = f * r + p * a, n[3] = f * o + p * h, n[4] = g * r + v * a + l, n[5] = g * o + v * h + u, this; },\n      transform(t, e, i, n, s, r) { const o = this.matrix; const a = o[0]; const h = o[1]; const l = o[2]; const u = o[3]; const c = o[4]; const d = o[5]; return o[0] = t * a + e * l, o[1] = t * h + e * u, o[2] = i * a + n * l, o[3] = i * h + n * u, o[4] = s * a + r * l + c, o[5] = s * h + r * u + d, this; },\n      transformPoint(t, e, i) { void 0 === i && (i = { x: 0, y: 0 }); const n = this.matrix; const s = n[0]; const r = n[1]; const o = n[2]; const a = n[3]; const h = n[4]; const l = n[5]; return i.x = t * s + e * o + h, i.y = t * r + e * a + l, i; },\n      invert() { const t = this.matrix; const e = t[0]; const i = t[1]; const n = t[2]; const s = t[3]; const r = t[4]; const o = t[5]; const a = e * s - i * n; return t[0] = s / a, t[1] = -i / a, t[2] = -n / a, t[3] = e / a, t[4] = (n * o - s * r) / a, t[5] = -(e * o - i * r) / a, this; },\n      copyFrom(t) { const e = this.matrix; return e[0] = t.a, e[1] = t.b, e[2] = t.c, e[3] = t.d, e[4] = t.e, e[5] = t.f, this; },\n      copyFromArray(t) { const e = this.matrix; return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4], e[5] = t[5], this; },\n      copyToContext(t) { const e = this.matrix; return t.transform(e[0], e[1], e[2], e[3], e[4], e[5]), t; },\n      setToContext(t) { const e = this.matrix; return t.setTransform(e[0], e[1], e[2], e[3], e[4], e[5]), t; },\n      copyToArray(t) { const e = this.matrix; return void 0 === t ? t = [e[0], e[1], e[2], e[3], e[4], e[5]] : (t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4], t[5] = e[5]), t; },\n      setTransform(t, e, i, n, s, r) { const o = this.matrix; return o[0] = t, o[1] = e, o[2] = i, o[3] = n, o[4] = s, o[5] = r, this; },\n      decomposeMatrix() { let t; let e; const i = this.decomposedMatrix; const n = this.matrix; const s = n[0]; const r = n[1]; const o = n[2]; const a = n[3]; const h = s * a - r * o; return i.translateX = n[4], i.translateY = n[5], s || r ? (t = Math.sqrt(s * s + r * r), i.rotation = r > 0 ? Math.acos(s / t) : -Math.acos(s / t), i.scaleX = t, i.scaleY = h / t) : o || a ? (e = Math.sqrt(o * o + a * a), i.rotation = 0.5 * Math.PI - (a > 0 ? Math.acos(-o / e) : -Math.acos(o / e)), i.scaleX = h / e, i.scaleY = e) : (i.rotation = 0, i.scaleX = 0, i.scaleY = 0), i; },\n      applyITRS(t, e, i, n, s) { const r = this.matrix; const o = Math.sin(i); const a = Math.cos(i); return r[4] = t, r[5] = e, r[0] = a * n, r[1] = o * n, r[2] = -o * s, r[3] = a * s, this; },\n      applyInverse(t, e, i) { void 0 === i && (i = new c()); const n = this.matrix; const s = n[0]; const r = n[1]; const o = n[2]; const a = n[3]; const h = n[4]; const l = n[5]; const u = 1 / (s * a + o * -r); return i.x = a * u * t + -o * u * e + (l * o - h * a) * u, i.y = s * u * e + -r * u * t + (-l * s + h * r) * u, i; },\n      getX(t, e) { return t * this.a + e * this.c + this.e; },\n      getY(t, e) { return t * this.b + e * this.d + this.f; },\n      getCSSMatrix() { const t = this.matrix; return `matrix(${t[0]},${t[1]},${t[2]},${t[3]},${t[4]},${t[5]})`; },\n      destroy() { this.matrix = null, this.decomposedMatrix = null; },\n    }); t.exports = s;\n  }, function (t, e, i) {\n    const n = i(0); const s = i(12); const r = i(14); const o = i(56); const a = new n({\n      Extends: r, Mixins: [s.AlphaSingle, s.BlendMode, s.ComputedSize, s.Depth, s.GetBounds, s.Mask, s.Origin, s.Pipeline, s.ScrollFactor, s.Transform, s.Visible], initialize(t, e, i) { void 0 === e && (e = 'Shape'), r.call(this, t, e), this.geom = i, this.pathData = [], this.pathIndexes = [], this.fillColor = 16777215, this.fillAlpha = 1, this.strokeColor = 16777215, this.strokeAlpha = 1, this.lineWidth = 1, this.isFilled = !1, this.isStroked = !1, this.closePath = !0, this._tempLine = new o(), this.initPipeline(); }, setFillStyle(t, e) { return void 0 === e && (e = 1), void 0 === t ? this.isFilled = !1 : (this.fillColor = t, this.fillAlpha = e, this.isFilled = !0), this; }, setStrokeStyle(t, e, i) { return void 0 === i && (i = 1), void 0 === t ? this.isStroked = !1 : (this.lineWidth = t, this.strokeColor = e, this.strokeAlpha = i, this.isStroked = !0), this; }, setClosePath(t) { return this.closePath = t, this; }, preDestroy() { this.geom = null, this._tempLine = null, this.pathData = [], this.pathIndexes = []; },\n    }); t.exports = a;\n  }, function (t, e, i) {\n    const n = i(0); const r = i(165); const o = i(295); const s = i(166); const a = i(296); var h = new n({\n      initialize(t, e, i, n) { void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === n && (n = 255), this.r = 0, this.g = 0, this.b = 0, this.a = 255, this._h = 0, this._s = 0, this._v = 0, this._locked = !1, this.gl = [0, 0, 0, 1], this._color = 0, this._color32 = 0, this._rgba = '', this.setTo(t, e, i, n); }, transparent() { return this._locked = !0, this.red = 0, this.green = 0, this.blue = 0, this.alpha = 0, this._locked = !1, this.update(!0); }, setTo(t, e, i, n, s) { return void 0 === n && (n = 255), void 0 === s && (s = !0), this._locked = !0, this.red = t, this.green = e, this.blue = i, this.alpha = n, this._locked = !1, this.update(s); }, setGLTo(t, e, i, n) { return void 0 === n && (n = 1), this._locked = !0, this.redGL = t, this.greenGL = e, this.blueGL = i, this.alphaGL = n, this._locked = !1, this.update(!0); }, setFromRGB(t) { return this._locked = !0, this.red = t.r, this.green = t.g, this.blue = t.b, t.hasOwnProperty('a') && (this.alpha = t.a), this._locked = !1, this.update(!0); }, setFromHSV(t, e, i) { return s(t, e, i, this); }, update(t) { if (void 0 === t && (t = !1), this._locked) return this; const e = this.r; const i = this.g; const n = this.b; const s = this.a; return this._color = r(e, i, n), this._color32 = o(e, i, n, s), this._rgba = `rgba(${e},${i},${n},${s / 255})`, t && a(e, i, n, this), this; }, updateHSV() { const t = this.r; const e = this.g; const i = this.b; return a(t, e, i, this), this; }, clone() { return new h(this.r, this.g, this.b, this.a); }, gray(t) { return this.setTo(t, t, t); }, random(t, e) { void 0 === t && (t = 0), void 0 === e && (e = 255); const i = Math.floor(t + Math.random() * (e - t)); const n = Math.floor(t + Math.random() * (e - t)); const s = Math.floor(t + Math.random() * (e - t)); return this.setTo(i, n, s); }, randomGray(t, e) { void 0 === t && (t = 0), void 0 === e && (e = 255); const i = Math.floor(t + Math.random() * (e - t)); return this.setTo(i, i, i); }, saturate(t) { return this.s += t / 100, this; }, desaturate(t) { return this.s -= t / 100, this; }, lighten(t) { return this.v += t / 100, this; }, darken(t) { return this.v -= t / 100, this; }, brighten(t) { var e = this.r; var i = this.g; var n = this.b; var e = Math.max(0, Math.min(255, e - Math.round(-t / 100 * 255))); var i = Math.max(0, Math.min(255, i - Math.round(-t / 100 * 255))); var n = Math.max(0, Math.min(255, n - Math.round(-t / 100 * 255))); return this.setTo(e, i, n); }, color: { get() { return this._color; } }, color32: { get() { return this._color32; } }, rgba: { get() { return this._rgba; } }, redGL: { get() { return this.gl[0]; }, set(t) { this.gl[0] = Math.min(Math.abs(t), 1), this.r = Math.floor(255 * this.gl[0]), this.update(!0); } }, greenGL: { get() { return this.gl[1]; }, set(t) { this.gl[1] = Math.min(Math.abs(t), 1), this.g = Math.floor(255 * this.gl[1]), this.update(!0); } }, blueGL: { get() { return this.gl[2]; }, set(t) { this.gl[2] = Math.min(Math.abs(t), 1), this.b = Math.floor(255 * this.gl[2]), this.update(!0); } }, alphaGL: { get() { return this.gl[3]; }, set(t) { this.gl[3] = Math.min(Math.abs(t), 1), this.a = Math.floor(255 * this.gl[3]), this.update(); } }, red: { get() { return this.r; }, set(t) { t = Math.floor(Math.abs(t)), this.r = Math.min(t, 255), this.gl[0] = t / 255, this.update(!0); } }, green: { get() { return this.g; }, set(t) { t = Math.floor(Math.abs(t)), this.g = Math.min(t, 255), this.gl[1] = t / 255, this.update(!0); } }, blue: { get() { return this.b; }, set(t) { t = Math.floor(Math.abs(t)), this.b = Math.min(t, 255), this.gl[2] = t / 255, this.update(!0); } }, alpha: { get() { return this.a; }, set(t) { t = Math.floor(Math.abs(t)), this.a = Math.min(t, 255), this.gl[3] = t / 255, this.update(); } }, h: { get() { return this._h; }, set(t) { this._h = t, s(t, this._s, this._v, this); } }, s: { get() { return this._s; }, set(t) { this._s = t, s(this._h, t, this._v, this); } }, v: { get() { return this._v; }, set(t) { this._v = t, s(this._h, this._s, t, this); } },\n    }); t.exports = h;\n  }, function (t, e) {\n    t.exports = {\n      CSV: 0, TILED_JSON: 1, ARRAY_2D: 2, WELTMEISTER: 3,\n    };\n  }, function (t, e, i) {\n    const n = {\n      VERSION: '3.24.1', BlendModes: i(52), ScaleModes: i(234), AUTO: 0, CANVAS: 1, WEBGL: 2, HEADLESS: 3, FOREVER: -1, NONE: 4, UP: 5, DOWN: 6, LEFT: 7, RIGHT: 8,\n    }; t.exports = n;\n  }, function (t, e) { t.exports = function (t) { return t.y + t.height - t.height * t.originY; }; }, function (t, e) { t.exports = function (t) { return t.x - t.width * t.originX; }; }, function (t, e) { t.exports = function (t) { return t.x + t.width - t.width * t.originX; }; }, function (t, e) { t.exports = function (t) { return t.y - t.height * t.originY; }; }, function (t, e) { t.exports = function (t, e, i, n, s, r) { let o; void 0 === n && (n = 0), void 0 === s && (s = 0), void 0 === r && (r = 1); let a = 0; const h = t.length; if (r === 1) for (o = s; o < h; o++)t[o][e] += i + a * n, a++; else for (o = s; o >= 0; o--)t[o][e] += i + a * n, a++; return t; }; }, function (t, e, i) { const n = i(13); t.exports = function (t) { return t * n.DEG_TO_RAD; }; }, function (t, e, i) {\n    t.exports = {\n      DESTROY: i(647), FADE_IN_COMPLETE: i(648), FADE_IN_START: i(649), FADE_OUT_COMPLETE: i(650), FADE_OUT_START: i(651), FLASH_COMPLETE: i(652), FLASH_START: i(653), PAN_COMPLETE: i(654), PAN_START: i(655), POST_RENDER: i(656), PRE_RENDER: i(657), ROTATE_COMPLETE: i(658), ROTATE_START: i(659), SHAKE_COMPLETE: i(660), SHAKE_START: i(661), ZOOM_COMPLETE: i(662), ZOOM_START: i(663),\n    };\n  }, function (t, e) { t.exports = function (t, e, i, n) { const s = i || e.fillColor; const r = n || e.fillAlpha; const o = (16711680 & s) >>> 16; const a = (65280 & s) >>> 8; const h = 255 & s; t.fillStyle = `rgba(${o},${a},${h},${r})`; }; }, function (t, e) { const h = {}; t.exports = h, (function () { h._nextId = 0, h._seed = 0, h._nowStartTime = +new Date(), h.extend = function (t, e) { for (var i, n = typeof e === 'boolean' ? (i = 2, e) : (i = 1, !0), s = i; s < arguments.length; s++) { const r = arguments[s]; if (r) for (const o in r)!n || !r[o] || r[o].constructor !== Object || t[o] && t[o].constructor !== Object ? t[o] = r[o] : (t[o] = t[o] || {}, h.extend(t[o], n, r[o])); } return t; }, h.clone = function (t, e) { return h.extend({}, e, t); }, h.keys = function (t) { if (Object.keys) return Object.keys(t); const e = []; for (const i in t)e.push(i); return e; }, h.values = function (t) { const e = []; if (Object.keys) { for (let i = Object.keys(t), n = 0; n < i.length; n++)e.push(t[i[n]]); return e; } for (const s in t)e.push(t[s]); return e; }, h.get = function (t, e, i, n) { e = e.split('.').slice(i, n); for (let s = 0; s < e.length; s += 1)t = t[e[s]]; return t; }, h.set = function (t, e, i, n, s) { const r = e.split('.').slice(n, s); return h.get(t, e, 0, -1)[r[r.length - 1]] = i; }, h.shuffle = function (t) { for (let e = t.length - 1; e > 0; e--) { const i = Math.floor(h.random() * (e + 1)); const n = t[e]; t[e] = t[i], t[i] = n; } return t; }, h.choose = function (t) { return t[Math.floor(h.random() * t.length)]; }, h.isElement = function (t) { return typeof HTMLElement !== 'undefined' ? t instanceof HTMLElement : !!(t && t.nodeType && t.nodeName); }, h.isArray = function (t) { return Object.prototype.toString.call(t) === '[object Array]'; }, h.isFunction = function (t) { return typeof t === 'function'; }, h.isPlainObject = function (t) { return typeof t === 'object' && t.constructor === Object; }, h.isString = function (t) { return Object.prototype.toString.call(t) === '[object String]'; }, h.clamp = function (t, e, i) { return t < e ? e : i < t ? i : t; }, h.sign = function (t) { return t < 0 ? -1 : 1; }, h.now = function () { if (typeof window !== 'undefined' && window.performance) { if (window.performance.now) return window.performance.now(); if (window.performance.webkitNow) return window.performance.webkitNow(); } return new Date() - h._nowStartTime; }, h.random = function (t, e) { return e = void 0 !== e ? e : 1, (t = void 0 !== t ? t : 0) + i() * (e - t); }; var i = function () { return h._seed = (9301 * h._seed + 49297) % 233280, h._seed / 233280; }; h.colorToNumber = function (t) { return (t = t.replace('#', '')).length == 3 && (t = t.charAt(0) + t.charAt(0) + t.charAt(1) + t.charAt(1) + t.charAt(2) + t.charAt(2)), parseInt(t, 16); }, h.logLevel = 1, h.log = function () { console && h.logLevel > 0 && h.logLevel <= 3 && console.log.apply(console, ['matter-js:'].concat(Array.prototype.slice.call(arguments))); }, h.info = function () { console && h.logLevel > 0 && h.logLevel <= 2 && console.info.apply(console, ['matter-js:'].concat(Array.prototype.slice.call(arguments))); }, h.warn = function () { console && h.logLevel > 0 && h.logLevel <= 3 && console.warn.apply(console, ['matter-js:'].concat(Array.prototype.slice.call(arguments))); }, h.nextId = function () { return h._nextId++; }, h.indexOf = function (t, e) { if (t.indexOf) return t.indexOf(e); for (let i = 0; i < t.length; i++) if (t[i] === e) return i; return -1; }, h.map = function (t, e) { if (t.map) return t.map(e); for (var i = [], n = 0; n < t.length; n += 1)i.push(e(t[n])); return i; }, h.topologicalSort = function (t) { const e = []; const i = []; const n = []; for (const s in t)i[s] || n[s] || h._topologicalSort(s, i, n, t, e); return e; }, h._topologicalSort = function (t, e, i, n, s) { const r = n[t] || []; i[t] = !0; for (let o = 0; o < r.length; o += 1) { const a = r[o]; i[a] || e[a] || h._topologicalSort(a, e, i, n, s); }i[t] = !1, e[t] = !0, s.push(t); }, h.chain = function () { for (var r = [], t = 0; t < arguments.length; t += 1) { const e = arguments[t]; e._chained ? r.push.apply(r, e._chained) : r.push(e); } function i() { for (var t, e = new Array(arguments.length), i = 0, n = arguments.length; i < n; i++)e[i] = arguments[i]; for (i = 0; i < r.length; i += 1) { const s = r[i].apply(t, e); void 0 !== s && (t = s); } return t; } return i._chained = r, i; }, h.chainPathBefore = function (t, e, i) { return h.set(t, e, h.chain(i, h.get(t, e))); }, h.chainPathAfter = function (t, e, i) { return h.set(t, e, h.chain(h.get(t, e), i)); }; }()); }, function (t, e) { t.exports = function (t, e) { return t.y = e + t.height * t.originY, t; }; }, function (t, e) { t.exports = function (t, e) { return t.x = e + t.width * t.originX, t; }; }, function (t, e) { t.exports = function (t, e) { return t.x = e - t.width + t.width * t.originX, t; }; }, function (t, e) { t.exports = function (t, e) { return t.y = e - t.height + t.height * t.originY, t; }; }, function (t, e) {\n    t.exports = {\n      CIRCLE: 0, ELLIPSE: 1, LINE: 2, POINT: 3, POLYGON: 4, RECTANGLE: 5, TRIANGLE: 6,\n    };\n  }, function (t, e) { t.exports = function (t, e, i) { return !(t.width <= 0 || t.height <= 0) && (t.x <= e && t.x + t.width >= e && t.y <= i && t.y + t.height >= i); }; }, function (t, e) { t.exports = function (t, e, i, n) { const s = i || e.strokeColor; const r = n || e.strokeAlpha; const o = (16711680 & s) >>> 16; const a = (65280 & s) >>> 8; const h = 255 & s; t.strokeStyle = `rgba(${o},${a},${h},${r})`, t.lineWidth = e.lineWidth; }; }, function (t, e) {\n    t.exports = {\n      DYNAMIC_BODY: 0, STATIC_BODY: 1, GROUP: 2, TILEMAPLAYER: 3, FACING_NONE: 10, FACING_UP: 11, FACING_DOWN: 12, FACING_LEFT: 13, FACING_RIGHT: 14,\n    };\n  }, function (t, e, i) { const d = i(142); const f = i(24); t.exports = function (t, e, i, n, s) { for (var r, o, a, h, l = f(t, e, i, n, null, s), u = 0; u < l.length; u++) { const c = l[u]; c && (c.collides ? (r = d(c.x, c.y - 1, !0, s), o = d(c.x, c.y + 1, !0, s), a = d(c.x - 1, c.y, !0, s), h = d(c.x + 1, c.y, !0, s), c.faceTop = !r || !r.collides, c.faceBottom = !o || !o.collides, c.faceLeft = !a || !a.collides, c.faceRight = !h || !h.collides) : c.resetFaces()); } }; }, function (t, e) {\n    t.exports = {\n      SKIP_CHECK: -1, NORMAL: 0, ADD: 1, MULTIPLY: 2, SCREEN: 3, OVERLAY: 4, DARKEN: 5, LIGHTEN: 6, COLOR_DODGE: 7, COLOR_BURN: 8, HARD_LIGHT: 9, SOFT_LIGHT: 10, DIFFERENCE: 11, EXCLUSION: 12, HUE: 13, SATURATION: 14, COLOR: 15, LUMINOSITY: 16, ERASE: 17, SOURCE_IN: 18, SOURCE_OUT: 19, SOURCE_ATOP: 20, DESTINATION_OVER: 21, DESTINATION_IN: 22, DESTINATION_OUT: 23, DESTINATION_ATOP: 24, LIGHTER: 25, COPY: 26, XOR: 27,\n    };\n  }, function (t, e) { t.exports = function (t, e, i, n) { const s = t - i; const r = e - n; return Math.sqrt(s * s + r * r); }; }, function (t, e, i) {\n    t.exports = {\n      BOOT: i(823), DESTROY: i(824), DRAG_END: i(825), DRAG_ENTER: i(826), DRAG: i(827), DRAG_LEAVE: i(828), DRAG_OVER: i(829), DRAG_START: i(830), DROP: i(831), GAME_OUT: i(832), GAME_OVER: i(833), GAMEOBJECT_DOWN: i(834), GAMEOBJECT_DRAG_END: i(835), GAMEOBJECT_DRAG_ENTER: i(836), GAMEOBJECT_DRAG: i(837), GAMEOBJECT_DRAG_LEAVE: i(838), GAMEOBJECT_DRAG_OVER: i(839), GAMEOBJECT_DRAG_START: i(840), GAMEOBJECT_DROP: i(841), GAMEOBJECT_MOVE: i(842), GAMEOBJECT_OUT: i(843), GAMEOBJECT_OVER: i(844), GAMEOBJECT_POINTER_DOWN: i(845), GAMEOBJECT_POINTER_MOVE: i(846), GAMEOBJECT_POINTER_OUT: i(847), GAMEOBJECT_POINTER_OVER: i(848), GAMEOBJECT_POINTER_UP: i(849), GAMEOBJECT_POINTER_WHEEL: i(850), GAMEOBJECT_UP: i(851), GAMEOBJECT_WHEEL: i(852), MANAGER_BOOT: i(853), MANAGER_PROCESS: i(854), MANAGER_UPDATE: i(855), POINTER_DOWN: i(856), POINTER_DOWN_OUTSIDE: i(857), POINTER_MOVE: i(858), POINTER_OUT: i(859), POINTER_OVER: i(860), POINTER_UP: i(861), POINTER_UP_OUTSIDE: i(862), POINTER_WHEEL: i(863), POINTERLOCK_CHANGE: i(864), PRE_UPDATE: i(865), SHUTDOWN: i(866), START: i(867), UPDATE: i(868),\n    };\n  }, function (t, e) { t.exports = function (t, e, i) { return t.radius > 0 && e >= t.left && e <= t.right && i >= t.top && i <= t.bottom && (t.x - e) * (t.x - e) + (t.y - i) * (t.y - i) <= t.radius * t.radius; }; }, function (t, e, i) {\n    const n = i(0); const s = i(275); const r = i(153); const o = i(47); const a = i(154); const h = i(3); const l = new n({\n      initialize(t, e, i, n) { void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === n && (n = 0), this.type = o.LINE, this.x1 = t, this.y1 = e, this.x2 = i, this.y2 = n; }, getPoint(t, e) { return s(this, t, e); }, getPoints(t, e, i) { return r(this, t, e, i); }, getRandomPoint(t) { return a(this, t); }, setTo(t, e, i, n) { return void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === n && (n = 0), this.x1 = t, this.y1 = e, this.x2 = i, this.y2 = n, this; }, getPointA(t) { return void 0 === t && (t = new h()), t.set(this.x1, this.y1), t; }, getPointB(t) { return void 0 === t && (t = new h()), t.set(this.x2, this.y2), t; }, left: { get() { return Math.min(this.x1, this.x2); }, set(t) { this.x1 <= this.x2 ? this.x1 = t : this.x2 = t; } }, right: { get() { return Math.max(this.x1, this.x2); }, set(t) { this.x1 > this.x2 ? this.x1 = t : this.x2 = t; } }, top: { get() { return Math.min(this.y1, this.y2); }, set(t) { this.y1 <= this.y2 ? this.y1 = t : this.y2 = t; } }, bottom: { get() { return Math.max(this.y1, this.y2); }, set(t) { this.y1 > this.y2 ? this.y1 = t : this.y2 = t; } },\n    }); t.exports = l;\n  }, function (t, e) { t.exports = function (t) { return Math.sqrt((t.x2 - t.x1) * (t.x2 - t.x1) + (t.y2 - t.y1) * (t.y2 - t.y1)); }; }, function (t, e) { t.exports = function (t, e, i) { const n = i - e; return e + ((t - e) % n + n) % n; }; }, function (t, e, i) {\n    t.exports = {\n      COMPLETE: i(891), DECODED: i(892), DECODED_ALL: i(893), DESTROY: i(894), DETUNE: i(895), GLOBAL_DETUNE: i(896), GLOBAL_MUTE: i(897), GLOBAL_RATE: i(898), GLOBAL_VOLUME: i(899), LOOP: i(900), LOOPED: i(901), MUTE: i(902), PAUSE_ALL: i(903), PAUSE: i(904), PLAY: i(905), RATE: i(906), RESUME_ALL: i(907), RESUME: i(908), SEEK: i(909), STOP_ALL: i(910), STOP: i(911), UNLOCKED: i(912), VOLUME: i(913),\n    };\n  }, function (t, e, i) {\n    const n = i(0); const h = i(17); const l = i(21); const s = i(8); const u = i(2); const c = i(6); const d = i(7); const r = new n({\n      Extends: l,\n      initialize(t, e, i, n, s) {\n        let r; let o = 'json'; d(e) && (e = u(r = e, 'key'), i = u(r, 'url'), n = u(r, 'xhrSettings'), o = u(r, 'extension', o), s = u(r, 'dataKey', s)); const a = {\n          type: 'json', cache: t.cacheManager.json, extension: o, responseType: 'text', key: e, url: i, xhrSettings: n, config: s,\n        }; l.call(this, t, a), d(i) && (this.data = s ? c(i, s) : i, this.state = h.FILE_POPULATED);\n      },\n      onProcess() { let t; let e; this.state !== h.FILE_POPULATED && (this.state = h.FILE_PROCESSING, t = JSON.parse(this.xhrLoader.responseText), e = this.config, this.data = typeof e === 'string' ? c(t, e, t) : t), this.onProcessComplete(); },\n    }); s.register('json', function (t, e, i, n) { if (Array.isArray(t)) for (let s = 0; s < t.length; s++) this.addFile(new r(this, t[s])); else this.addFile(new r(this, t, e, n, i)); return this; }), t.exports = r;\n  }, function (t, e, i) {\n    const n = new (i(0))({\n      initialize(t, e, i, n) { this.loader = t, this.type = e, this.key = i, this.multiKeyIndex = t.multiKeyIndex++, this.files = n, this.complete = !1, this.pending = n.length, this.failed = 0, this.config = {}, this.baseURL = t.baseURL, this.path = t.path, this.prefix = t.prefix; for (let s = 0; s < n.length; s++)n[s].multiFile = this; }, isReadyToProcess() { return this.pending === 0 && this.failed === 0 && !this.complete; }, addToMultiFile(t) { return this.files.push(t), (t.multiFile = this).pending++, this.complete = !1, this; }, onFileComplete(t) { this.files.indexOf(t) !== -1 && this.pending--; }, onFileFailed(t) { this.files.indexOf(t) !== -1 && this.failed++; },\n    }); t.exports = n;\n  }, function (t, e, i) {\n    const p = {}; t.exports = p; const g = i(86); const u = i(99); const s = i(239); const r = i(42); const v = i(100); const c = i(513); !(function () {\n      p._inertiaScale = 4, p._nextCollidingGroupId = 1, p._nextNonCollidingGroupId = -1, p._nextCategory = 1, p.create = function (t) {\n        const e = {\n          id: r.nextId(),\n          type: 'body',\n          label: 'Body',\n          parts: [],\n          plugin: {},\n          angle: 0,\n          vertices: null,\n          position: { x: 0, y: 0 },\n          force: { x: 0, y: 0 },\n          torque: 0,\n          positionImpulse: { x: 0, y: 0 },\n          previousPositionImpulse: { x: 0, y: 0 },\n          constraintImpulse: { x: 0, y: 0, angle: 0 },\n          totalContacts: 0,\n          speed: 0,\n          angularSpeed: 0,\n          velocity: { x: 0, y: 0 },\n          angularVelocity: 0,\n          isSensor: !1,\n          isStatic: !1,\n          isSleeping: !1,\n          motion: 0,\n          sleepThreshold: 60,\n          density: 0.001,\n          restitution: 0,\n          friction: 0.1,\n          frictionStatic: 0.5,\n          frictionAir: 0.01,\n          collisionFilter: { category: 1, mask: 4294967295, group: 0 },\n          slop: 0.05,\n          timeScale: 1,\n          events: null,\n          bounds: null,\n          chamfer: null,\n          circleRadius: 0,\n          positionPrev: null,\n          anglePrev: 0,\n          parent: null,\n          axes: null,\n          area: 0,\n          mass: 0,\n          inverseMass: 0,\n          inertia: 0,\n          inverseInertia: 0,\n          _original: null,\n          render: {\n            visible: !0, opacity: 1, sprite: { xOffset: 0, yOffset: 0 }, fillColor: null, fillOpacity: null, lineColor: null, lineOpacity: null, lineThickness: null,\n          },\n          gameObject: null,\n          scale: { x: 1, y: 1 },\n          centerOfMass: { x: 0, y: 0 },\n          centerOffset: { x: 0, y: 0 },\n          gravityScale: { x: 1, y: 1 },\n          ignoreGravity: !1,\n          ignorePointer: !1,\n          onCollideCallback: null,\n          onCollideEndCallback: null,\n          onCollideActiveCallback: null,\n          onCollideWith: {},\n        }; !t.hasOwnProperty('position') && t.hasOwnProperty('vertices') ? t.position = g.centre(t.vertices) : t.hasOwnProperty('vertices') || (e.vertices = g.fromPath('L 0 0 L 40 0 L 40 40 L 0 40')); const i = r.extend(e, t); return n(i, t), i.setOnCollideWith = function (t, e) { return e ? this.onCollideWith[t.id] = e : delete this.onCollideWith[t.id], this; }, i;\n      }, p.nextGroup = function (t) { return t ? p._nextNonCollidingGroupId-- : p._nextCollidingGroupId++; }, p.nextCategory = function () { return p._nextCategory <<= 1, p._nextCategory; }; var n = function (t, e) {\n        e = e || {}, p.set(t, {\n          bounds: t.bounds || v.create(t.vertices), positionPrev: t.positionPrev || u.clone(t.position), anglePrev: t.anglePrev || t.angle, vertices: t.vertices, parts: t.parts || [t], isStatic: t.isStatic, isSleeping: t.isSleeping, parent: t.parent || t,\n        }); let i; let n; let s; let r; const o = t.bounds; g.rotate(t.vertices, t.angle, t.position), c.rotate(t.axes, t.angle), v.update(o, t.vertices, t.velocity), p.set(t, {\n          axes: e.axes || t.axes, area: e.area || t.area, mass: e.mass || t.mass, inertia: e.inertia || t.inertia,\n        }), t.parts.length === 1 && (i = t.centerOfMass, n = t.centerOffset, s = o.max.x - o.min.x, r = o.max.y - o.min.y, i.x = -(o.min.x - t.position.x) / s, i.y = -(o.min.y - t.position.y) / r, n.x = s * i.x, n.y = r * i.y);\n      }; p.set = function (t, e, i) { let n; for (n in typeof e === 'string' && (n = e, (e = {})[n] = i), e) if (Object.prototype.hasOwnProperty.call(e, n)) switch (i = e[n], n) { case 'isStatic': p.setStatic(t, i); break; case 'isSleeping': s.set(t, i); break; case 'mass': p.setMass(t, i); break; case 'density': p.setDensity(t, i); break; case 'inertia': p.setInertia(t, i); break; case 'vertices': p.setVertices(t, i); break; case 'position': p.setPosition(t, i); break; case 'angle': p.setAngle(t, i); break; case 'velocity': p.setVelocity(t, i); break; case 'angularVelocity': p.setAngularVelocity(t, i); break; case 'parts': p.setParts(t, i); break; case 'centre': p.setCentre(t, i); break; default: t[n] = i; } }, p.setStatic = function (t, e) {\n        for (let i = 0; i < t.parts.length; i++) {\n          const n = t.parts[i]; (n.isStatic = e) ? (n._original = {\n            restitution: n.restitution, friction: n.friction, mass: n.mass, inertia: n.inertia, density: n.density, inverseMass: n.inverseMass, inverseInertia: n.inverseInertia,\n          }, n.restitution = 0, n.friction = 1, n.mass = n.inertia = n.density = 1 / 0, n.inverseMass = n.inverseInertia = 0, n.positionPrev.x = n.position.x, n.positionPrev.y = n.position.y, n.anglePrev = n.angle, n.angularVelocity = 0, n.speed = 0, n.angularSpeed = 0, n.motion = 0) : n._original && (n.restitution = n._original.restitution, n.friction = n._original.friction, n.mass = n._original.mass, n.inertia = n._original.inertia, n.density = n._original.density, n.inverseMass = n._original.inverseMass, n.inverseInertia = n._original.inverseInertia, n._original = null);\n        }\n      }, p.setMass = function (t, e) { const i = t.inertia / (t.mass / 6); t.inertia = e / 6 * i, t.inverseInertia = 1 / t.inertia, t.mass = e, t.inverseMass = 1 / t.mass, t.density = t.mass / t.area; }, p.setDensity = function (t, e) { p.setMass(t, e * t.area), t.density = e; }, p.setInertia = function (t, e) { t.inertia = e, t.inverseInertia = 1 / t.inertia; }, p.setVertices = function (t, e) { e[0].body === t ? t.vertices = e : t.vertices = g.create(e, t), t.axes = c.fromVertices(t.vertices), t.area = g.area(t.vertices), p.setMass(t, t.density * t.area); const i = g.centre(t.vertices); g.translate(t.vertices, i, -1), p.setInertia(t, p._inertiaScale * g.inertia(t.vertices, t.mass)), g.translate(t.vertices, t.position), v.update(t.bounds, t.vertices, t.velocity); }, p.setParts = function (t, e, i) { for (e = e.slice(0), t.parts.length = 0, t.parts.push(t), t.parent = t, r = 0; r < e.length; r++) { const n = e[r]; n !== t && (n.parent = t).parts.push(n); } if (t.parts.length !== 1) { if (i = void 0 === i || i) { for (var s = [], r = 0; r < e.length; r++)s = s.concat(e[r].vertices); g.clockwiseSort(s); const o = g.hull(s); const a = g.centre(o); p.setVertices(t, o), g.translate(t.vertices, a); } const h = p._totalProperties(t); const l = h.centre.x; const u = h.centre.y; const c = t.bounds; const d = t.centerOfMass; const f = t.centerOffset; v.update(c, t.vertices, t.velocity), d.x = -(c.min.x - l) / (c.max.x - c.min.x), d.y = -(c.min.y - u) / (c.max.y - c.min.y), f.x = l, f.y = u, t.area = h.area, (t.parent = t).position.x = l, t.position.y = u, t.positionPrev.x = l, t.positionPrev.y = u, p.setMass(t, h.mass), p.setInertia(t, h.inertia), p.setPosition(t, h.centre); } }, p.setCentre = function (t, e, i) { i ? (t.positionPrev.x += e.x, t.positionPrev.y += e.y, t.position.x += e.x, t.position.y += e.y) : (t.positionPrev.x = e.x - (t.position.x - t.positionPrev.x), t.positionPrev.y = e.y - (t.position.y - t.positionPrev.y), t.position.x = e.x, t.position.y = e.y); }, p.setPosition = function (t, e) { const i = u.sub(e, t.position); t.positionPrev.x += i.x, t.positionPrev.y += i.y; for (let n = 0; n < t.parts.length; n++) { const s = t.parts[n]; s.position.x += i.x, s.position.y += i.y, g.translate(s.vertices, i), v.update(s.bounds, s.vertices, t.velocity); } }, p.setAngle = function (t, e) { const i = e - t.angle; t.anglePrev += i; for (let n = 0; n < t.parts.length; n++) { const s = t.parts[n]; s.angle += i, g.rotate(s.vertices, i, t.position), c.rotate(s.axes, i), v.update(s.bounds, s.vertices, t.velocity), n > 0 && u.rotateAbout(s.position, i, t.position, s.position); } }, p.setVelocity = function (t, e) { t.positionPrev.x = t.position.x - e.x, t.positionPrev.y = t.position.y - e.y, t.velocity.x = e.x, t.velocity.y = e.y, t.speed = u.magnitude(t.velocity); }, p.setAngularVelocity = function (t, e) { t.anglePrev = t.angle - e, t.angularVelocity = e, t.angularSpeed = Math.abs(t.angularVelocity); }, p.translate = function (t, e) { p.setPosition(t, u.add(t.position, e)); }, p.rotate = function (t, e, i) { let n; let s; let r; let o; i && (n = Math.cos(e), s = Math.sin(e), r = t.position.x - i.x, o = t.position.y - i.y, p.setPosition(t, { x: i.x + (r * n - o * s), y: i.y + (r * s + o * n) })), p.setAngle(t, t.angle + e); }, p.scale = function (t, e, i, n) { let s = 0; let r = 0; n = n || t.position; for (let o = 0; o < t.parts.length; o++) { const a = t.parts[o]; a.scale.x = e, a.scale.y = i, g.scale(a.vertices, e, i, n), a.axes = c.fromVertices(a.vertices), a.area = g.area(a.vertices), p.setMass(a, t.density * a.area), g.translate(a.vertices, { x: -a.position.x, y: -a.position.y }), p.setInertia(a, p._inertiaScale * g.inertia(a.vertices, a.mass)), g.translate(a.vertices, { x: a.position.x, y: a.position.y }), o > 0 && (s += a.area, r += a.inertia), a.position.x = n.x + (a.position.x - n.x) * e, a.position.y = n.y + (a.position.y - n.y) * i, v.update(a.bounds, a.vertices, t.velocity); }t.parts.length > 1 && (t.area = s, t.isStatic || (p.setMass(t, t.density * s), p.setInertia(t, r))), t.circleRadius && (e === i ? t.circleRadius *= e : t.circleRadius = null); }, p.update = function (t, e, i, n) { const s = Math.pow(e * i * t.timeScale, 2); const r = 1 - t.frictionAir * i * t.timeScale; const o = t.position.x - t.positionPrev.x; const a = t.position.y - t.positionPrev.y; t.velocity.x = o * r * n + t.force.x / t.mass * s, t.velocity.y = a * r * n + t.force.y / t.mass * s, t.positionPrev.x = t.position.x, t.positionPrev.y = t.position.y, t.position.x += t.velocity.x, t.position.y += t.velocity.y, t.angularVelocity = (t.angle - t.anglePrev) * r * n + t.torque / t.inertia * s, t.anglePrev = t.angle, t.angle += t.angularVelocity, t.speed = u.magnitude(t.velocity), t.angularSpeed = Math.abs(t.angularVelocity); for (let h = 0; h < t.parts.length; h++) { const l = t.parts[h]; g.translate(l.vertices, t.velocity), h > 0 && (l.position.x += t.velocity.x, l.position.y += t.velocity.y), t.angularVelocity !== 0 && (g.rotate(l.vertices, t.angularVelocity, t.position), c.rotate(l.axes, t.angularVelocity), h > 0 && u.rotateAbout(l.position, t.angularVelocity, t.position, l.position)), v.update(l.bounds, l.vertices, t.velocity); } }, p.applyForce = function (t, e, i) { t.force.x += i.x, t.force.y += i.y; const n = e.x - t.position.x; const s = e.y - t.position.y; t.torque += n * i.y - s * i.x; }, p._totalProperties = function (t) {\n        for (var e = {\n            mass: 0, area: 0, inertia: 0, centre: { x: 0, y: 0 },\n          }, i = t.parts.length === 1 ? 0 : 1; i < t.parts.length; i++) { const n = t.parts[i]; const s = n.mass !== 1 / 0 ? n.mass : 1; e.mass += s, e.area += n.area, e.inertia += n.inertia, e.centre = u.add(e.centre, u.mult(n.position, s)); } return e.centre = u.div(e.centre, e.mass), e;\n      };\n    }());\n  }, function (t, e) { t.exports = function (t, e, i, n) { void 0 === e && (e = !0); let s = n.baseTileWidth; const r = n.tilemapLayer; return r && (void 0 === i && (i = r.scene.cameras.main), t -= r.x + i.scrollX * (1 - r.scrollFactorX), s *= r.scaleX), e ? Math.floor(t / s) : t / s; }; }, function (t, e) { t.exports = function (t, e, i, n) { void 0 === e && (e = !0); let s = n.baseTileHeight; const r = n.tilemapLayer; return r && (void 0 === i && (i = r.scene.cameras.main), t -= r.y + i.scrollY * (1 - r.scrollFactorY), s *= r.scaleY), e ? Math.floor(t / s) : t / s; }; }, function (t, e, i) {\n    const n = i(0); const s = i(55); const r = i(266); const o = i(267); const a = i(47); const h = i(150); const l = new n({\n      initialize(t, e, i) { void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = 0), this.type = a.CIRCLE, this.x = t, this.y = e, this._radius = i, this._diameter = 2 * i; }, contains(t, e) { return s(this, t, e); }, getPoint(t, e) { return r(this, t, e); }, getPoints(t, e, i) { return o(this, t, e, i); }, getRandomPoint(t) { return h(this, t); }, setTo(t, e, i) { return this.x = t, this.y = e, this._radius = i, this._diameter = 2 * i, this; }, setEmpty() { return this._radius = 0, this._diameter = 0, this; }, setPosition(t, e) { return void 0 === e && (e = t), this.x = t, this.y = e, this; }, isEmpty() { return this._radius <= 0; }, radius: { get() { return this._radius; }, set(t) { this._radius = t, this._diameter = 2 * t; } }, diameter: { get() { return this._diameter; }, set(t) { this._diameter = t, this._radius = 0.5 * t; } }, left: { get() { return this.x - this._radius; }, set(t) { this.x = t + this._radius; } }, right: { get() { return this.x + this._radius; }, set(t) { this.x = t - this._radius; } }, top: { get() { return this.y - this._radius; }, set(t) { this.y = t + this._radius; } }, bottom: { get() { return this.y + this._radius; }, set(t) { this.y = t - this._radius; } },\n    }); t.exports = l;\n  }, function (t, e, i) {\n    function n(t, e, i) { i = i || 2; let n; let s; let r; let o; let a; let h; let l; const u = e && e.length; const c = u ? e[0] * i : t.length; let d = g(t, 0, c, i, !0); const f = []; if (!d || d.next === d.prev) return f; if (u && (d = (function (t, e, i, n) { let s; let r; let o; let a; let h; const l = []; for (s = 0, r = e.length; s < r; s++)o = e[s] * n, a = s < r - 1 ? e[s + 1] * n : t.length, (h = g(t, o, a, n, !1)) === h.next && (h.steiner = !0), l.push(function (t) { let e = t; let i = t; for (;e.x < i.x && (i = e), e = e.next, e !== t;);return i; }(h)); for (l.sort(y), s = 0; s < l.length; s++)!(function (t, e) { { let i; (e = (function (t, e) { let i; let n = e; const s = t.x; const r = t.y; let o = -1 / 0; do { if (r <= n.y && r >= n.next.y && n.next.y !== n.y) { const a = n.x + (r - n.y) * (n.next.x - n.x) / (n.next.y - n.y); if (a <= s && o < a) { if ((o = a) === s) { if (r === n.y) return n; if (r === n.next.y) return n.next; }i = n.x < n.next.x ? n : n.next; } }n = n.next; } while (n !== e);if (!i) return null; if (s === o) return i.prev; let h; const l = i; const u = i.x; const c = i.y; let d = 1 / 0; n = i.next; for (;n !== l;)s >= n.x && n.x >= u && s !== n.x && T(r < c ? s : o, r, u, c, r < c ? o : s, r, n.x, n.y) && ((h = Math.abs(r - n.y) / (s - n.x)) < d || h === d && n.x > i.x) && b(n, t) && (i = n, d = h), n = n.next; return i; }(t, e))) && v(i = E(e, t), i.next); } }(l[s], i)), i = v(i, i.next); return i; }(t, e, d, i))), t.length > 80 * i) { n = r = t[0], s = o = t[1]; for (let p = i; p < c; p += i)(a = t[p]) < n && (n = a), (h = t[p + 1]) < s && (s = h), r < a && (r = a), o < h && (o = h); l = (l = Math.max(r - n, o - s)) !== 0 ? 1 / l : 0; } return m(d, f, i, n, s, l), f; } function g(t, e, i, n, s) { let r; let o; if (s === S(t, e, i, n) > 0) for (r = e; r < i; r += n)o = a(r, t[r], t[r + 1], o); else for (r = i - n; e <= r; r -= n)o = a(r, t[r], t[r + 1], o); return o && u(o, o.next) && (d(o), o = o.next), o; } function v(t, e) { if (!t) return t; e = e || t; let i; let n = t; do { if (i = !1, n.steiner || !u(n, n.next) && w(n.prev, n, n.next) !== 0)n = n.next; else { if (d(n), (n = e = n.prev) === n.next) break; i = !0; } } while (i || n !== e);return e; } function m(t, e, i, n, s, r, o) { if (t) { !o && r && (function (t, e, i, n) { let s = t; for (;s.z === null && (s.z = x(s.x, s.y, e, i, n)), s.prevZ = s.prev, s.nextZ = s.next, s = s.next, s !== t;);s.prevZ.nextZ = null, s.prevZ = null, (function (t) { let e; let i; let n; let s; let r; let o; let a; let h; let l = 1; do { for (i = t, r = t = null, o = 0; i;) { for (o++, n = i, e = a = 0; e < l && (a++, n = n.nextZ); e++);for (h = l; a > 0 || h > 0 && n;)a !== 0 && (h === 0 || !n || i.z <= n.z) ? (i = (s = i).nextZ, a--) : (n = (s = n).nextZ, h--), r ? r.nextZ = s : t = s, s.prevZ = r, r = s; i = n; }r.nextZ = null, l *= 2; } while (o > 1); }(s)); }(t, n, s, r)); for (var a, h, l = t; t.prev !== t.next;) if (a = t.prev, h = t.next, r ? (function (t, e, i, n) { const s = t.prev; const r = t; const o = t.next; if (w(s, r, o) >= 0) return !1; const a = s.x < r.x ? s.x < o.x ? s.x : o.x : r.x < o.x ? r.x : o.x; const h = s.y < r.y ? s.y < o.y ? s.y : o.y : r.y < o.y ? r.y : o.y; const l = s.x > r.x ? s.x > o.x ? s.x : o.x : r.x > o.x ? r.x : o.x; const u = s.y > r.y ? s.y > o.y ? s.y : o.y : r.y > o.y ? r.y : o.y; const c = x(a, h, e, i, n); const d = x(l, u, e, i, n); let f = t.prevZ; let p = t.nextZ; for (;f && f.z >= c && p && p.z <= d;) { if (f !== t.prev && f !== t.next && T(s.x, s.y, r.x, r.y, o.x, o.y, f.x, f.y) && w(f.prev, f, f.next) >= 0) return !1; if (f = f.prevZ, p !== t.prev && p !== t.next && T(s.x, s.y, r.x, r.y, o.x, o.y, p.x, p.y) && w(p.prev, p, p.next) >= 0) return !1; p = p.nextZ; } for (;f && f.z >= c;) { if (f !== t.prev && f !== t.next && T(s.x, s.y, r.x, r.y, o.x, o.y, f.x, f.y) && w(f.prev, f, f.next) >= 0) return !1; f = f.prevZ; } for (;p && p.z <= d;) { if (p !== t.prev && p !== t.next && T(s.x, s.y, r.x, r.y, o.x, o.y, p.x, p.y) && w(p.prev, p, p.next) >= 0) return !1; p = p.nextZ; } return !0; }(t, n, s, r)) : (function (t) { const e = t.prev; const i = t; const n = t.next; if (w(e, i, n) >= 0) return !1; let s = t.next.next; for (;s !== t.prev;) { if (T(e.x, e.y, i.x, i.y, n.x, n.y, s.x, s.y) && w(s.prev, s, s.next) >= 0) return !1; s = s.next; } return !0; }(t)))e.push(a.i / i), e.push(t.i / i), e.push(h.i / i), d(t), t = h.next, l = h.next; else if ((t = h) === l) { o ? o === 1 ? m(t = (function (t, e, i) { let n = t; do { const s = n.prev; const r = n.next.next; !u(s, r) && c(s, n, n.next, r) && b(s, r) && b(r, s) && (e.push(s.i / i), e.push(n.i / i), e.push(r.i / i), d(n), d(n.next), n = t = r), n = n.next; } while (n !== t);return n; }(t, e, i)), e, i, n, s, r, 2) : o === 2 && (function (t, e, i, n, s, r) { let o = t; do { for (let a = o.next.next; a !== o.prev;) { if (o.i !== a.i && (function (t, e) { return t.next.i !== e.i && t.prev.i !== e.i && !(function (t, e) { let i = t; do { if (i.i !== t.i && i.next.i !== t.i && i.i !== e.i && i.next.i !== e.i && c(i, i.next, t, e)) return !0; i = i.next; } while (i !== t);return !1; }(t, e)) && b(t, e) && b(e, t) && (function (t, e) { let i = t; let n = !1; const s = (t.x + e.x) / 2; const r = (t.y + e.y) / 2; for (;i.y > r != i.next.y > r && i.next.y !== i.y && s < (i.next.x - i.x) * (r - i.y) / (i.next.y - i.y) + i.x && (n = !n), i = i.next, i !== t;);return n; }(t, e)); }(o, a))) { let h = E(o, a); return o = v(o, o.next), h = v(h, h.next), m(o, e, i, n, s, r), m(h, e, i, n, s, r); }a = a.next; }o = o.next; } while (o !== t); }(t, e, i, n, s, r)) : m(v(t), e, i, n, s, r, 1); break; } } } function y(t, e) { return t.x - e.x; } function x(t, e, i, n, s) { return (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = 32767 * (t - i) * s) | t << 8)) | t << 4)) | t << 2)) | t << 1)) | (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = 32767 * (e - n) * s) | e << 8)) | e << 4)) | e << 2)) | e << 1)) << 1; } function T(t, e, i, n, s, r, o, a) { return (s - o) * (e - a) - (t - o) * (r - a) >= 0 && (t - o) * (n - a) - (i - o) * (e - a) >= 0 && (i - o) * (r - a) - (s - o) * (n - a) >= 0; } function w(t, e, i) { return (e.y - t.y) * (i.x - e.x) - (e.x - t.x) * (i.y - e.y); } function u(t, e) { return t.x === e.x && t.y === e.y; } function c(t, e, i, n) { return u(t, e) && u(i, n) || u(t, n) && u(i, e) || w(t, e, i) > 0 != w(t, e, n) > 0 && w(i, n, t) > 0 != w(i, n, e) > 0; } function b(t, e) { return w(t.prev, t, t.next) < 0 ? w(t, e, t.next) >= 0 && w(t, t.prev, e) >= 0 : w(t, e, t.prev) < 0 || w(t, t.next, e) < 0; } function E(t, e) { const i = new o(t.i, t.x, t.y); const n = new o(e.i, e.x, e.y); const s = t.next; const r = e.prev; return (t.next = e).prev = t, (i.next = s).prev = i, (n.next = i).prev = n, (r.next = n).prev = r, n; } function a(t, e, i, n) { const s = new o(t, e, i); return n ? (s.next = n.next, (s.prev = n).next.prev = s, n.next = s) : (s.prev = s).next = s, s; } function d(t) { t.next.prev = t.prev, t.prev.next = t.next, t.prevZ && (t.prevZ.nextZ = t.nextZ), t.nextZ && (t.nextZ.prevZ = t.prevZ); } function o(t, e, i) { this.i = t, this.x = e, this.y = i, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1; } function S(t, e, i, n) { for (var s = 0, r = e, o = i - n; r < i; r += n)s += (t[o] - t[r]) * (t[r + 1] + t[o + 1]), o = r; return s; }(t.exports = n).deviation = function (t, e, i, n) { const s = e && e.length; const r = s ? e[0] * i : t.length; let o = Math.abs(S(t, 0, r, i)); if (s) for (var a = 0, h = e.length; a < h; a++) { const l = e[a] * i; const u = a < h - 1 ? e[a + 1] * i : t.length; o -= Math.abs(S(t, l, u, i)); } for (var c = 0, a = 0; a < n.length; a += 3) { const d = n[a] * i; const f = n[a + 1] * i; const p = n[a + 2] * i; c += Math.abs((t[d] - t[p]) * (t[1 + f] - t[1 + d]) - (t[d] - t[f]) * (t[1 + p] - t[1 + d])); } return o === 0 && c === 0 ? 0 : Math.abs((c - o) / o); }, n.flatten = function (t) { for (var e = t[0][0].length, i = { vertices: [], holes: [], dimensions: e }, n = 0, s = 0; s < t.length; s++) { for (let r = 0; r < t[s].length; r++) for (let o = 0; o < e; o++)i.vertices.push(t[s][r][o]); s > 0 && (n += t[s - 1].length, i.holes.push(n)); } return i; };\n  }, function (t, e) { t.exports = function (t) { const e = {}; for (const i in t)Array.isArray(t[i]) ? e[i] = t[i].slice(0) : e[i] = t[i]; return e; }; }, function (t, e) { t.exports = function (t, e, i, n) { const s = t.length; if (e < 0 || s < e || i <= e || s < i || s < e + i) { if (n) throw new Error('Range Error: Values outside acceptable range'); return !1; } return !0; }; }, function (t, e, i) { const r = i(115); const o = i(181); t.exports = function (t, e) { let i; let n = r.Power0; if (typeof t === 'string' ? r.hasOwnProperty(t) ? n = r[t] : (i = '', t.indexOf('.') && ((i = t.substr(t.indexOf('.') + 1)).toLowerCase() === 'in' ? i = 'easeIn' : i.toLowerCase() === 'out' ? i = 'easeOut' : i.toLowerCase() === 'inout' && (i = 'easeInOut')), t = o(t.substr(0, t.indexOf('.') + 1) + i), r.hasOwnProperty(t) && (n = r[t])) : typeof t === 'function' ? n = t : Array.isArray(t) && t.length, !e) return n; const s = e.slice(0); return s.unshift(0), function (t) { return s[0] = t, n.apply(this, s); }; }; }, function (t, e, i) { const v = i(9); t.exports = function (t, e, i, n, s) { const r = t.strokeTint; const o = v.getTintAppendFloatAlphaAndSwap(e.strokeColor, e.strokeAlpha * i); r.TL = o, r.TR = o, r.BL = o, r.BR = o; const a = e.pathData; let h = a.length - 1; const l = e.lineWidth; const u = l / 2; let c = a[0] - n; let d = a[1] - s; e.closePath || (h -= 2); for (let f = 2; f < h; f += 2) { const p = a[f] - n; const g = a[f + 1] - s; t.setTexture2D(), t.batchLine(c, d, p, g, u, u, l, f - 2, !!e.closePath && f === h - 1), c = p, d = g; } }; }, function (t, e, i) {\n    const n = i(0); const s = i(83); const r = i(425); const o = i(426); const a = i(47); const h = i(56); const l = i(158); const u = new n({\n      initialize(t, e, i, n, s, r) { void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === n && (n = 0), void 0 === s && (s = 0), void 0 === r && (r = 0), this.type = a.TRIANGLE, this.x1 = t, this.y1 = e, this.x2 = i, this.y2 = n, this.x3 = s, this.y3 = r; }, contains(t, e) { return s(this, t, e); }, getPoint(t, e) { return r(this, t, e); }, getPoints(t, e, i) { return o(this, t, e, i); }, getRandomPoint(t) { return l(this, t); }, setTo(t, e, i, n, s, r) { return void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === n && (n = 0), void 0 === s && (s = 0), void 0 === r && (r = 0), this.x1 = t, this.y1 = e, this.x2 = i, this.y2 = n, this.x3 = s, this.y3 = r, this; }, getLineA(t) { return void 0 === t && (t = new h()), t.setTo(this.x1, this.y1, this.x2, this.y2), t; }, getLineB(t) { return void 0 === t && (t = new h()), t.setTo(this.x2, this.y2, this.x3, this.y3), t; }, getLineC(t) { return void 0 === t && (t = new h()), t.setTo(this.x3, this.y3, this.x1, this.y1), t; }, left: { get() { return Math.min(this.x1, this.x2, this.x3); }, set(t) { var e = 0; var e = this.x1 <= this.x2 && this.x1 <= this.x3 ? this.x1 - t : this.x2 <= this.x1 && this.x2 <= this.x3 ? this.x2 - t : this.x3 - t; this.x1 -= e, this.x2 -= e, this.x3 -= e; } }, right: { get() { return Math.max(this.x1, this.x2, this.x3); }, set(t) { var e = 0; var e = this.x1 >= this.x2 && this.x1 >= this.x3 ? this.x1 - t : this.x2 >= this.x1 && this.x2 >= this.x3 ? this.x2 - t : this.x3 - t; this.x1 -= e, this.x2 -= e, this.x3 -= e; } }, top: { get() { return Math.min(this.y1, this.y2, this.y3); }, set(t) { var e = 0; var e = this.y1 <= this.y2 && this.y1 <= this.y3 ? this.y1 - t : this.y2 <= this.y1 && this.y2 <= this.y3 ? this.y2 - t : this.y3 - t; this.y1 -= e, this.y2 -= e, this.y3 -= e; } }, bottom: { get() { return Math.max(this.y1, this.y2, this.y3); }, set(t) { var e = 0; var e = this.y1 >= this.y2 && this.y1 >= this.y3 ? this.y1 - t : this.y2 >= this.y1 && this.y2 >= this.y3 ? this.y2 - t : this.y3 - t; this.y1 -= e, this.y2 -= e, this.y3 -= e; } },\n    }); t.exports = u;\n  }, function (t, e, i) {\n    const n = i(0); const s = i(17); const c = i(21); const r = i(8); const d = i(2); const f = i(7); const o = new n({\n      Extends: c,\n      initialize: function t(e, i, n, s, r) {\n        let o; let a; let h = 'png'; f(i) && (i = d(a = i, 'key'), n = d(a, 'url'), o = d(a, 'normalMap'), s = d(a, 'xhrSettings'), h = d(a, 'extension', h), r = d(a, 'frameConfig')), Array.isArray(n) && (o = n[1], n = n[0]); let l; const u = {\n          type: 'image', cache: e.textureManager, extension: h, responseType: 'blob', key: i, url: n, xhrSettings: s, config: r,\n        }; c.call(this, e, u), o && ((l = new t(e, this.key, o, s, r)).type = 'normalMap', this.setLink(l), e.addFile(l));\n      },\n      onProcess() { this.state = s.FILE_PROCESSING, this.data = new Image(), this.data.crossOrigin = this.crossOrigin; const t = this; this.data.onload = function () { c.revokeObjectURL(t.data), t.onProcessComplete(); }, this.data.onerror = function () { c.revokeObjectURL(t.data), t.onProcessError(); }, c.createObjectURL(this.data, this.xhrLoader.response, 'image/png'); },\n      addToCache() { let t; const e = this.linkFile; e && e.state === s.FILE_COMPLETE ? (t = this.type === 'image' ? this.cache.addImage(this.key, this.data, e.data) : this.cache.addImage(e.key, e.data, this.data), this.pendingDestroy(t), e.pendingDestroy(t)) : e || (t = this.cache.addImage(this.key, this.data), this.pendingDestroy(t)); },\n    }); r.register('image', function (t, e, i) { if (Array.isArray(t)) for (let n = 0; n < t.length; n++) this.addFile(new o(this, t[n])); else this.addFile(new o(this, t, e, i)); return this; }), t.exports = o;\n  }, function (t, e) { t.exports = function (t, e) { e ? t.setCollision(!0, !0, !0, !0, !1) : t.resetCollision(!1); }; }, function (t, e, i) {\n    const n = i(0); const s = i(12); const r = i(444); const o = new n({\n      Mixins: [s.Alpha, s.Flip, s.Visible], initialize(t, e, i, n, s, r, o, a) { this.layer = t, this.index = e, this.x = i, this.y = n, this.width = s, this.height = r, this.baseWidth = void 0 !== o ? o : s, this.baseHeight = void 0 !== a ? a : r, this.pixelX = 0, this.pixelY = 0, this.updatePixelXY(), this.properties = {}, this.rotation = 0, this.collideLeft = !1, this.collideRight = !1, this.collideUp = !1, this.collideDown = !1, this.faceLeft = !1, this.faceRight = !1, this.faceTop = !1, this.faceBottom = !1, this.collisionCallback = null, (this.collisionCallbackContext = this).tint = 16777215, this.physics = {}; }, containsPoint(t, e) { return !(t < this.pixelX || e < this.pixelY || t > this.right || e > this.bottom); }, copy(t) { return this.index = t.index, this.alpha = t.alpha, this.properties = t.properties, this.visible = t.visible, this.setFlip(t.flipX, t.flipY), this.tint = t.tint, this.rotation = t.rotation, this.collideUp = t.collideUp, this.collideDown = t.collideDown, this.collideLeft = t.collideLeft, this.collideRight = t.collideRight, this.collisionCallback = t.collisionCallback, this.collisionCallbackContext = t.collisionCallbackContext, this; }, getCollisionGroup() { return this.tileset ? this.tileset.getTileCollisionGroup(this.index) : null; }, getTileData() { return this.tileset ? this.tileset.getTileData(this.index) : null; }, getLeft(t) { const e = this.tilemapLayer; return e ? e.tileToWorldX(this.x, t) : this.x * this.baseWidth; }, getRight(t) { const e = this.tilemapLayer; return e ? this.getLeft(t) + this.width * e.scaleX : this.getLeft(t) + this.width; }, getTop(t) { const e = this.tilemapLayer; return e ? e.tileToWorldY(this.y, t) - (this.height - this.baseHeight) * e.scaleY : this.y * this.baseHeight - (this.height - this.baseHeight); }, getBottom(t) { const e = this.tilemapLayer; return e ? this.getTop(t) + this.height * e.scaleY : this.getTop(t) + this.height; }, getBounds(t, e) { return void 0 === e && (e = new r()), e.x = this.getLeft(), e.y = this.getTop(), e.width = this.getRight() - e.x, e.height = this.getBottom() - e.y, e; }, getCenterX(t) { return (this.getLeft(t) + this.getRight(t)) / 2; }, getCenterY(t) { return (this.getTop(t) + this.getBottom(t)) / 2; }, destroy() { this.collisionCallback = void 0, this.collisionCallbackContext = void 0, this.properties = void 0; }, intersects(t, e, i, n) { return !(i <= this.pixelX || n <= this.pixelY || t >= this.right || e >= this.bottom); }, isInteresting(t, e) { return t && e ? this.canCollide || this.hasInterestingFace : t ? this.collides : !!e && this.hasInterestingFace; }, resetCollision(t) { return void 0 === t && (t = !0), this.collideLeft = !1, this.collideRight = !1, this.collideUp = !1, this.collideDown = !1, this.faceTop = !1, this.faceBottom = !1, this.faceLeft = !1, this.faceRight = !1, t && this.tilemapLayer && this.tilemapLayer.calculateFacesAt(this.x, this.y), this; }, resetFaces() { return this.faceTop = !1, this.faceBottom = !1, this.faceLeft = !1, this.faceRight = !1, this; }, setCollision(t, e, i, n, s) { return void 0 === e && (e = t), void 0 === i && (i = t), void 0 === n && (n = t), void 0 === s && (s = !0), this.collideLeft = t, this.collideRight = e, this.collideUp = i, this.collideDown = n, this.faceLeft = t, this.faceRight = e, this.faceTop = i, this.faceBottom = n, s && this.tilemapLayer && this.tilemapLayer.calculateFacesAt(this.x, this.y), this; }, setCollisionCallback(t, e) { return t === null ? (this.collisionCallback = void 0, this.collisionCallbackContext = void 0) : (this.collisionCallback = t, this.collisionCallbackContext = e), this; }, setSize(t, e, i, n) { return void 0 !== t && (this.width = t), void 0 !== e && (this.height = e), void 0 !== i && (this.baseWidth = i), void 0 !== n && (this.baseHeight = n), this.updatePixelXY(), this; }, updatePixelXY() { return this.pixelX = this.x * this.baseWidth, this.pixelY = this.y * this.baseHeight, this; }, canCollide: { get() { return this.collideLeft || this.collideRight || this.collideUp || this.collideDown || this.collisionCallback; } }, collides: { get() { return this.collideLeft || this.collideRight || this.collideUp || this.collideDown; } }, hasInterestingFace: { get() { return this.faceTop || this.faceBottom || this.faceLeft || this.faceRight; } }, tileset: { get() { const t = this.layer.tilemapLayer; if (t) { const e = t.gidMap[this.index]; if (e) return e; } return null; } }, tilemapLayer: { get() { return this.layer.tilemapLayer; } }, tilemap: { get() { const t = this.tilemapLayer; return t ? t.tilemap : null; } },\n    }); t.exports = o;\n  }, function (t, e, i) {\n    const n = i(0); const r = i(12); const o = i(14); const s = i(967); const a = new n({\n      Extends: o, Mixins: [r.Alpha, r.BlendMode, r.Depth, r.Flip, r.GetBounds, r.Mask, r.Origin, r.Pipeline, r.ScrollFactor, r.Size, r.TextureCrop, r.Tint, r.Transform, r.Visible, s], initialize(t, e, i, n, s) { o.call(this, t, 'Sprite'), this._crop = this.resetCropObject(), this.anims = new r.Animation(this), this.setTexture(n, s), this.setPosition(e, i), this.setSizeToFrame(), this.setOriginFromFrame(), this.initPipeline(); }, preUpdate(t, e) { this.anims.update(t, e); }, play(t, e, i) { return this.anims.play(t, e, i), this; }, toJSON() { return r.ToJSON(this); }, preDestroy() { this.anims.destroy(), this.anims = void 0; },\n    }); t.exports = a;\n  }, function (t, e) { t.exports = function (t) { return t.x - t.width * t.originX + 0.5 * t.width; }; }, function (t, e) { t.exports = function (t, e) { const i = t.width * t.originX; return t.x = e + i - 0.5 * t.width, t; }; }, function (t, e) { t.exports = function (t) { return t.y - t.height * t.originY + 0.5 * t.height; }; }, function (t, e) { t.exports = function (t, e) { const i = t.height * t.originY; return t.y = e + i - 0.5 * t.height, t; }; }, function (t, e) { t.exports = function (t, e) { if (!(e >= t.length)) { for (var i = t.length - 1, n = t[e], s = e; s < i; s++)t[s] = t[s + 1]; return t.length = i, n; } }; }, function (t, e, i) {\n    const n = i(0); const s = i(176); const r = i(11); const o = i(3); const a = new n({\n      initialize(t) { this.type = t, this.defaultDivisions = 5, this.arcLengthDivisions = 100, this.cacheArcLengths = [], this.needsUpdate = !0, this.active = !0, this._tmpVec2A = new o(), this._tmpVec2B = new o(); }, draw(t, e) { return void 0 === e && (e = 32), t.strokePoints(this.getPoints(e)); }, getBounds(t, e) { t = t || new r(), void 0 === e && (e = 16); const i = this.getLength(); i < e && (e = i / 2); const n = Math.max(1, Math.round(i / e)); return s(this.getSpacedPoints(n), t); }, getDistancePoints(t) { const e = this.getLength(); const i = Math.max(1, e / t); return this.getSpacedPoints(i); }, getEndPoint(t) { return void 0 === t && (t = new o()), this.getPointAt(1, t); }, getLength() { const t = this.getLengths(); return t[t.length - 1]; }, getLengths(t) { if (void 0 === t && (t = this.arcLengthDivisions), this.cacheArcLengths.length === t + 1 && !this.needsUpdate) return this.cacheArcLengths; this.needsUpdate = !1; let e; const i = []; const n = this.getPoint(0, this._tmpVec2A); let s = 0; i.push(0); for (let r = 1; r <= t; r++)s += (e = this.getPoint(r / t, this._tmpVec2B)).distance(n), i.push(s), n.copy(e); return this.cacheArcLengths = i; }, getPointAt(t, e) { const i = this.getUtoTmapping(t); return this.getPoint(i, e); }, getPoints(t, e, i) { void 0 === i && (i = []), t = t || (e ? this.getLength() / e : this.defaultDivisions); for (let n = 0; n <= t; n++)i.push(this.getPoint(n / t)); return i; }, getRandomPoint(t) { return void 0 === t && (t = new o()), this.getPoint(Math.random(), t); }, getSpacedPoints(t, e, i) { void 0 === i && (i = []), t = t || (e ? this.getLength() / e : this.defaultDivisions); for (let n = 0; n <= t; n++) { const s = this.getUtoTmapping(n / t, null, t); i.push(this.getPoint(s)); } return i; }, getStartPoint(t) { return void 0 === t && (t = new o()), this.getPointAt(0, t); }, getTangent(t, e) { void 0 === e && (e = new o()); let i = t - 1e-4; let n = t + 1e-4; return i < 0 && (i = 0), n > 1 && (n = 1), this.getPoint(i, this._tmpVec2A), this.getPoint(n, e), e.subtract(this._tmpVec2A).normalize(); }, getTangentAt(t, e) { const i = this.getUtoTmapping(t); return this.getTangent(i, e); }, getTFromDistance(t, e) { return t <= 0 ? 0 : this.getUtoTmapping(0, t, e); }, getUtoTmapping(t, e, i) { for (var n, s = this.getLengths(i), r = 0, o = s.length, a = e ? Math.min(e, s[o - 1]) : t * s[o - 1], h = 0, l = o - 1; h <= l;) if ((n = s[r = Math.floor(h + (l - h) / 2)] - a) < 0)h = r + 1; else { if (!(n > 0)) { l = r; break; }l = r - 1; } if (s[r = l] === a) return r / (o - 1); const u = s[r]; return (r + (a - u) / (s[r + 1] - u)) / (o - 1); }, updateArcLengths() { this.needsUpdate = !0, this.getLengths(); },\n    }); t.exports = a;\n  }, function (t, e, i) {\n    t.exports = {\n      ADD: i(870), COMPLETE: i(871), FILE_COMPLETE: i(872), FILE_KEY_COMPLETE: i(873), FILE_LOAD_ERROR: i(874), FILE_LOAD: i(875), FILE_PROGRESS: i(876), POST_PROCESS: i(877), PROGRESS: i(878), START: i(879),\n    };\n  }, function (t, e) { t.exports = function (t, e, i) { const n = t.x3 - t.x1; const s = t.y3 - t.y1; const r = t.x2 - t.x1; const o = t.y2 - t.y1; const a = e - t.x1; const h = i - t.y1; const l = n * n + s * s; const u = n * r + s * o; const c = n * a + s * h; const d = r * r + o * o; const f = r * a + o * h; const p = l * d - u * u; const g = p == 0 ? 0 : 1 / p; const v = (d * c - u * f) * g; const m = (l * f - u * c) * g; return v >= 0 && m >= 0 && v + m < 1; }; }, function (t, e, i) { const p = i(4); t.exports = function (t, e, i) { void 0 === i && (i = new p()); const n = t.x1; const s = t.y1; const r = t.x2; const o = t.y2; const a = e.x1; const h = e.y1; const l = e.x2; const u = e.y2; const c = (u - h) * (r - n) - (l - a) * (o - s); if (c == 0) return !1; const d = ((l - a) * (s - h) - (u - h) * (n - a)) / c; const f = ((r - n) * (s - h) - (o - s) * (n - a)) / c; return d >= 0 && d <= 1 && f >= 0 && f <= 1 && (i.x = n + d * (r - n), i.y = s + d * (o - s), !0); }; }, function (t, e) { t.exports = function (t) { return Math.atan2(t.y2 - t.y1, t.x2 - t.x1); }; }, function (t, e, i) {\n    const a = {}; t.exports = a; const T = i(99); const w = i(42); a.create = function (t, e) {\n      for (var i = [], n = 0; n < t.length; n++) {\n        const s = t[n]; const r = {\n          x: s.x, y: s.y, index: n, body: e, isInternal: !1, contact: null, offset: null,\n        }; r.contact = { vertex: r, normalImpulse: 0, tangentImpulse: 0 }, i.push(r);\n      } return i;\n    }, a.fromPath = function (t, e) { const n = []; return t.replace(/L?\\s*([-\\d.e]+)[\\s,]*([-\\d.e]+)*/gi, (t, e, i) => { n.push({ x: parseFloat(e), y: parseFloat(i) }); }), a.create(n, e); }, a.centre = function (t) { for (var e, i, n, s = a.area(t, !0), r = { x: 0, y: 0 }, o = 0; o < t.length; o++)n = (o + 1) % t.length, e = T.cross(t[o], t[n]), i = T.mult(T.add(t[o], t[n]), e), r = T.add(r, i); return T.div(r, 6 * s); }, a.mean = function (t) { for (var e = { x: 0, y: 0 }, i = 0; i < t.length; i++)e.x += t[i].x, e.y += t[i].y; return T.div(e, t.length); }, a.area = function (t, e) { for (var i = 0, n = t.length - 1, s = 0; s < t.length; s++)i += (t[n].x - t[s].x) * (t[n].y + t[s].y), n = s; return e ? i / 2 : Math.abs(i) / 2; }, a.inertia = function (t, e) { for (var i, n, s = 0, r = 0, o = t, a = 0; a < o.length; a++)n = (a + 1) % o.length, s += (i = Math.abs(T.cross(o[n], o[a]))) * (T.dot(o[n], o[n]) + T.dot(o[n], o[a]) + T.dot(o[a], o[a])), r += i; return e / 6 * (s / r); }, a.translate = function (t, e, i) { let n; if (i) for (n = 0; n < t.length; n++)t[n].x += e.x * i, t[n].y += e.y * i; else for (n = 0; n < t.length; n++)t[n].x += e.x, t[n].y += e.y; return t; }, a.rotate = function (t, e, i) { if (e !== 0) { for (let n = Math.cos(e), s = Math.sin(e), r = 0; r < t.length; r++) { const o = t[r]; const a = o.x - i.x; const h = o.y - i.y; o.x = i.x + (a * n - h * s), o.y = i.y + (a * s + h * n); } return t; } }, a.contains = function (t, e) { for (let i = 0; i < t.length; i++) { const n = t[i]; const s = t[(i + 1) % t.length]; if ((e.x - n.x) * (s.y - n.y) + (e.y - n.y) * (n.x - s.x) > 0) return !1; } return !0; }, a.scale = function (t, e, i, n) { if (e === 1 && i === 1) return t; let s; let r; n = n || a.centre(t); for (let o = 0; o < t.length; o++)s = t[o], r = T.sub(s, n), t[o].x = n.x + r.x * e, t[o].y = n.y + r.y * i; return t; }, a.chamfer = function (t, e, i, n, s) { e = typeof e === 'number' ? [e] : e || [8], i = void 0 !== i ? i : -1, n = n || 2, s = s || 14; for (var r = [], o = 0; o < t.length; o++) { const a = t[o - 1 >= 0 ? o - 1 : t.length - 1]; const h = t[o]; const l = t[(o + 1) % t.length]; const u = e[o < e.length ? o : e.length - 1]; if (u !== 0) { const c = T.normalise({ x: h.y - a.y, y: a.x - h.x }); const d = T.normalise({ x: l.y - h.y, y: h.x - l.x }); const f = Math.sqrt(2 * Math.pow(u, 2)); const p = T.mult(w.clone(c), u); const g = T.normalise(T.mult(T.add(c, d), 0.5)); const v = T.sub(h, T.mult(g, f)); let m = i; i === -1 && (m = 1.75 * Math.pow(u, 0.32)), (m = w.clamp(m, n, s)) % 2 == 1 && (m += 1); for (let y = Math.acos(T.dot(c, d)) / m, x = 0; x < m; x++)r.push(T.add(T.rotate(p, y * x), v)); } else r.push(h); } return r; }, a.clockwiseSort = function (t) { const i = a.mean(t); return t.sort((t, e) => T.angle(i, t) - T.angle(i, e)), t; }, a.isConvex = function (t) { let e; let i; let n; let s; let r = 0; const o = t.length; if (o < 3) return null; for (e = 0; e < o; e++) if (n = (e + 2) % o, s = (t[i = (e + 1) % o].x - t[e].x) * (t[n].y - t[i].y), (s -= (t[i].y - t[e].y) * (t[n].x - t[i].x)) < 0 ? r |= 1 : s > 0 && (r |= 2), r === 3) return !1; return r !== 0 || null; }, a.hull = function (t) { let e; let i; const n = []; const s = []; for ((t = t.slice(0)).sort((t, e) => { const i = t.x - e.x; return i != 0 ? i : t.y - e.y; }), i = 0; i < t.length; i += 1) { for (e = t[i]; s.length >= 2 && T.cross3(s[s.length - 2], s[s.length - 1], e) <= 0;)s.pop(); s.push(e); } for (i = t.length - 1; i >= 0; --i) { for (e = t[i]; n.length >= 2 && T.cross3(n[n.length - 2], n[n.length - 1], e) <= 0;)n.pop(); n.push(e); } return n.pop(), s.pop(), n.concat(s); };\n  }, function (t, e, i) { const n = i(19); t.exports = function (t, e, i) { return (i - e) * (t = n(t, 0, 1)); }; }, function (t, e) { t.exports = function (t, e, i) { return t && t.hasOwnProperty(e) ? t[e] : i; }; }, function (t, e) {\n    t.exports = {\n      CREATED: 0, INIT: 1, DELAY: 2, OFFSET_DELAY: 3, PENDING_RENDER: 4, PLAYING_FORWARD: 5, PLAYING_BACKWARD: 6, HOLD_DELAY: 7, REPEAT_DELAY: 8, COMPLETE: 9, PENDING_ADD: 20, PAUSED: 21, LOOP_DELAY: 22, ACTIVE: 23, COMPLETE_DELAY: 24, PENDING_REMOVE: 25, REMOVED: 26,\n    };\n  }, function (t, e, i) {\n    t.exports = {\n      DESTROY: i(582), VIDEO_COMPLETE: i(583), VIDEO_CREATED: i(584), VIDEO_ERROR: i(585), VIDEO_LOOP: i(586), VIDEO_PLAY: i(587), VIDEO_SEEKED: i(588), VIDEO_SEEKING: i(589), VIDEO_STOP: i(590), VIDEO_TIMEOUT: i(591), VIDEO_UNLOCKED: i(592),\n    };\n  }, function (t, e, i) {\n    const n = i(0); const s = i(12); const r = i(39); const o = i(10); const a = i(40); const h = i(11); const l = i(29); const u = i(164); const _ = i(3); const c = new n({\n      Extends: o,\n      Mixins: [s.Alpha, s.Visible],\n      initialize(t, e, i, n) { void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === n && (n = 0), o.call(this), this.scene, this.sceneManager, this.scaleManager, this.cameraManager, this.id = 0, this.name = '', this.resolution = 1, this.roundPixels = !1, this.useBounds = !1, this.worldView = new h(), this.dirty = !0, this._x = t, this._y = e, this._cx = 0, this._cy = 0, this._cw = 0, this._ch = 0, this._width = i, this._height = n, this._bounds = new h(), this._scrollX = 0, this._scrollY = 0, this._zoom = 1, this._rotation = 0, this.matrix = new l(), this.transparent = !0, this.backgroundColor = u('rgba(0,0,0,0)'), this.disableCull = !1, this.culledObjects = [], this.midPoint = new _(i / 2, n / 2), this.originX = 0.5, this.originY = 0.5, this._customViewport = !1, this.mask = null, this._maskCamera = null; },\n      setOrigin(t, e) { return void 0 === t && (t = 0.5), void 0 === e && (e = t), this.originX = t, this.originY = e, this; },\n      getScroll(t, e, i) { void 0 === i && (i = new _()); const n = 0.5 * this.width; const s = 0.5 * this.height; return i.x = t - n, i.y = e - s, this.useBounds && (i.x = this.clampX(i.x), i.y = this.clampY(i.y)), i; },\n      centerOnX(t) { const e = 0.5 * this.width; return this.midPoint.x = t, this.scrollX = t - e, this.useBounds && (this.scrollX = this.clampX(this.scrollX)), this; },\n      centerOnY(t) { const e = 0.5 * this.height; return this.midPoint.y = t, this.scrollY = t - e, this.useBounds && (this.scrollY = this.clampY(this.scrollY)), this; },\n      centerOn(t, e) { return this.centerOnX(t), this.centerOnY(e), this; },\n      centerToBounds() { let t; let e; let i; return this.useBounds && (t = this._bounds, e = 0.5 * this.width, i = 0.5 * this.height, this.midPoint.set(t.centerX, t.centerY), this.scrollX = t.centerX - e, this.scrollY = t.centerY - i), this; },\n      centerToSize() { return this.scrollX = 0.5 * this.width, this.scrollY = 0.5 * this.height, this; },\n      cull(t) { if (this.disableCull) return t; const e = this.matrix.matrix; const i = e[0]; const n = e[1]; const s = e[2]; const r = e[3]; if (!(i * r - n * s)) return t; for (var o = e[4], a = e[5], h = this.scrollX, l = this.scrollY, u = this.width, c = this.height, d = this.y, f = d + c, p = this.x, g = p + u, v = this.culledObjects, m = t.length, y = v.length = 0; y < m; ++y) { var x; var T; var w; var b; const E = t[y]; E.hasOwnProperty('width') && !E.parentContainer ? (x = E.width, T = E.height, p < ((w = E.x - h * E.scrollFactorX - x * E.originX) + x) * i + ((b = E.y - l * E.scrollFactorY - T * E.originY) + T) * s + o && w * i + b * s + o < g && d < (w + x) * n + (b + T) * r + a && w * n + b * r + a < f && v.push(E)) : v.push(E); } return v; },\n      getWorldPoint(t, e, i) { void 0 === i && (i = new _()); const n = this.matrix.matrix; const s = n[0]; const r = n[1]; const o = n[2]; const a = n[3]; const h = n[4]; const l = n[5]; let u = s * a - r * o; if (!u) return i.x = t, i.y = e, i; const c = a * (u = 1 / u); const d = -r * u; const f = -o * u; const p = s * u; const g = (o * l - a * h) * u; const v = (r * h - s * l) * u; const m = Math.cos(this.rotation); const y = Math.sin(this.rotation); const x = this.zoom; const T = this.resolution; const w = this.scrollX; const b = this.scrollY; const E = t + (w * m - b * y) * x; const S = e + (w * y + b * m) * x; return i.x = (E * c + S * f) * T + g, i.y = (E * d + S * p) * T + v, i; },\n      ignore(t) { const e = this.id; Array.isArray(t) || (t = [t]); for (let i = 0; i < t.length; i++) { const n = t[i]; Array.isArray(n) ? this.ignore(n) : n.isParent ? this.ignore(n.getChildren()) : n.cameraFilter |= e; } return this; },\n      preRender(t) { const e = this.width; const i = this.height; const n = 0.5 * e; const s = 0.5 * i; const r = this.zoom * t; const o = this.matrix; let a = e * this.originX; let h = i * this.originY; let l = this.scrollX; let u = this.scrollY; this.useBounds && (l = this.clampX(l), u = this.clampY(u)), this.roundPixels && (a = Math.round(a), h = Math.round(h)); const c = (this.scrollX = l) + n; const d = (this.scrollY = u) + s; this.midPoint.set(c, d); const f = e / r; const p = i / r; this.worldView.setTo(c - f / 2, d - p / 2, f, p), o.applyITRS(this.x + a, this.y + h, this.rotation, r, r), o.translate(-a, -h); },\n      clampX(t) { const e = this._bounds; const i = this.displayWidth; const n = e.x + (i - this.width) / 2; const s = Math.max(n, n + e.width - i); return t < n ? t = n : s < t && (t = s), t; },\n      clampY(t) { const e = this._bounds; const i = this.displayHeight; const n = e.y + (i - this.height) / 2; const s = Math.max(n, n + e.height - i); return t < n ? t = n : s < t && (t = s), t; },\n      removeBounds() { return this.useBounds = !1, this.dirty = !0, this._bounds.setEmpty(), this; },\n      setAngle(t) { return void 0 === t && (t = 0), this.rotation = r(t), this; },\n      setBackgroundColor(t) { return void 0 === t && (t = 'rgba(0,0,0,0)'), this.backgroundColor = u(t), this.transparent = this.backgroundColor.alpha === 0, this; },\n      setBounds(t, e, i, n, s) { return void 0 === s && (s = !1), this._bounds.setTo(t, e, i, n), this.dirty = !0, this.useBounds = !0, s ? this.centerToBounds() : (this.scrollX = this.clampX(this.scrollX), this.scrollY = this.clampY(this.scrollY)), this; },\n      getBounds(t) { void 0 === t && (t = new h()); const e = this._bounds; return t.setTo(e.x, e.y, e.width, e.height), t; },\n      setName(t) { return void 0 === t && (t = ''), this.name = t, this; },\n      setPosition(t, e) { return void 0 === e && (e = t), this.x = t, this.y = e, this; },\n      setRotation(t) { return void 0 === t && (t = 0), this.rotation = t, this; },\n      setRoundPixels(t) { return this.roundPixels = t, this; },\n      setScene(t) { this.scene && this._customViewport && this.sceneManager.customViewports--; const e = (this.scene = t).sys; this.sceneManager = e.game.scene, this.scaleManager = e.scale, this.cameraManager = e.cameras; const i = this.scaleManager.resolution; return this.resolution = i, this._cx = this._x * i, this._cy = this._y * i, this._cw = this._width * i, this._ch = this._height * i, this.updateSystem(), this; },\n      setScroll(t, e) { return void 0 === e && (e = t), this.scrollX = t, this.scrollY = e, this; },\n      setSize(t, e) { return void 0 === e && (e = t), this.width = t, this.height = e, this; },\n      setViewport(t, e, i, n) { return this.x = t, this.y = e, this.width = i, this.height = n, this; },\n      setZoom(t) { return void 0 === t && (t = 1), t === 0 && (t = 0.001), this.zoom = t, this; },\n      setMask(t, e) { return void 0 === e && (e = !0), this.mask = t, this._maskCamera = e ? this.cameraManager.default : this, this; },\n      clearMask(t) { return void 0 === t && (t = !1), t && this.mask && this.mask.destroy(), this.mask = null, this; },\n      toJSON() {\n        const t = {\n          name: this.name, x: this.x, y: this.y, width: this.width, height: this.height, zoom: this.zoom, rotation: this.rotation, roundPixels: this.roundPixels, scrollX: this.scrollX, scrollY: this.scrollY, backgroundColor: this.backgroundColor.rgba,\n        }; return this.useBounds && (t.bounds = {\n          x: this._bounds.x, y: this._bounds.y, width: this._bounds.width, height: this._bounds.height,\n        }), t;\n      },\n      update() {},\n      updateSystem() { let t; let e; this.scaleManager && (t = this._x !== 0 || this._y !== 0 || this.scaleManager.width !== this._width || this.scaleManager.height !== this._height, e = this.sceneManager, t && !this._customViewport ? e.customViewports++ : !t && this._customViewport && e.customViewports--, this.dirty = !0, this._customViewport = t); },\n      destroy() { this.emit(a.DESTROY, this), this.removeAllListeners(), this.matrix.destroy(), this.culledObjects = [], this._customViewport && this.sceneManager.customViewports--, this._bounds = null, this.scene = null, this.scaleManager = null, this.sceneManager = null, this.cameraManager = null; },\n      x: { get() { return this._x; }, set(t) { this._x = t, this._cx = t * this.resolution, this.updateSystem(); } },\n      y: { get() { return this._y; }, set(t) { this._y = t, this._cy = t * this.resolution, this.updateSystem(); } },\n      width: { get() { return this._width; }, set(t) { this._width = t, this._cw = t * this.resolution, this.updateSystem(); } },\n      height: { get() { return this._height; }, set(t) { this._height = t, this._ch = t * this.resolution, this.updateSystem(); } },\n      scrollX: { get() { return this._scrollX; }, set(t) { this._scrollX = t, this.dirty = !0; } },\n      scrollY: { get() { return this._scrollY; }, set(t) { this._scrollY = t, this.dirty = !0; } },\n      zoom: { get() { return this._zoom; }, set(t) { this._zoom = t, this.dirty = !0; } },\n      rotation: { get() { return this._rotation; }, set(t) { this._rotation = t, this.dirty = !0; } },\n      centerX: { get() { return this.x + 0.5 * this.width; } },\n      centerY: { get() { return this.y + 0.5 * this.height; } },\n      displayWidth: { get() { return this.width / this.zoom; } },\n      displayHeight: { get() { return this.height / this.zoom; } },\n    }); t.exports = c;\n  }, function (t, e, i) {\n    t.exports = {\n      ENTER_FULLSCREEN: i(703), FULLSCREEN_FAILED: i(704), FULLSCREEN_UNSUPPORTED: i(705), LEAVE_FULLSCREEN: i(706), ORIENTATION_CHANGE: i(707), RESIZE: i(708),\n    };\n  }, function (t, e) { t.exports = function (t, e, i, n) { return void 0 === i && (i = 0), e === 0 ? t : (t -= i, t = e * Math.floor(t / e), n ? (i + t) / e : i + t); }; }, function (t, e, i) {\n    const n = i(0); const C = i(19); const s = i(18); var r = new n({\n      initialize(t, e, i, n, s, r, o) {\n        this.texture = t, this.name = e, this.source = t.source[i], this.sourceIndex = i, this.glTexture = this.source.glTexture, this.cutX, this.cutY, this.cutWidth, this.cutHeight, this.x = 0, this.y = 0, this.width, this.height, this.halfWidth, this.halfHeight, this.centerX, this.centerY, this.pivotX = 0, this.pivotY = 0, this.customPivot = !1, this.rotated = !1, this.autoRound = -1, this.customData = {}, this.u0 = 0, this.v0 = 0, this.u1 = 0, this.v1 = 0, this.data = {\n          cut: {\n            x: 0, y: 0, w: 0, h: 0, r: 0, b: 0,\n          },\n          trim: !1,\n          sourceSize: { w: 0, h: 0 },\n          spriteSourceSize: {\n            x: 0, y: 0, w: 0, h: 0, r: 0, b: 0,\n          },\n          radius: 0,\n          drawImage: {\n            x: 0, y: 0, width: 0, height: 0,\n          },\n        }, this.setSize(r, o, n, s);\n      },\n      setSize(t, e, i, n) { void 0 === i && (i = 0), void 0 === n && (n = 0), this.cutX = i, this.cutY = n, this.cutWidth = t, this.cutHeight = e, this.width = t, this.height = e, this.halfWidth = Math.floor(0.5 * t), this.halfHeight = Math.floor(0.5 * e), this.centerX = Math.floor(t / 2), this.centerY = Math.floor(e / 2); const s = this.data; const r = s.cut; r.x = i, r.y = n, r.w = t, r.h = e, r.r = i + t, r.b = n + e, s.sourceSize.w = t, s.sourceSize.h = e, s.spriteSourceSize.w = t, s.spriteSourceSize.h = e, s.radius = 0.5 * Math.sqrt(t * t + e * e); const o = s.drawImage; return o.x = i, o.y = n, o.width = t, o.height = e, this.updateUVs(); },\n      setTrim(t, e, i, n, s, r) { const o = this.data; const a = o.spriteSourceSize; return o.trim = !0, o.sourceSize.w = t, o.sourceSize.h = e, a.x = i, a.y = n, a.w = s, a.h = r, a.r = i + s, a.b = n + r, this.x = i, this.y = n, this.width = s, this.height = r, this.halfWidth = 0.5 * s, this.halfHeight = 0.5 * r, this.centerX = Math.floor(s / 2), this.centerY = Math.floor(r / 2), this.updateUVs(); },\n      setCropUVs(t, e, i, n, s, r, o) { let a; let h; let l; let u; let c; let d; let f; const p = this.cutX; const g = this.cutY; const v = this.cutWidth; const m = this.cutHeight; const y = this.realWidth; const x = this.realHeight; let T = p + (e = C(e, 0, y)); let w = g + (i = C(i, 0, x)); let b = n = C(n, 0, y - e); let E = s = C(s, 0, x - i); const S = this.data; S.trim ? (a = S.spriteSourceSize, h = e + (n = C(n, 0, v - e)), l = i + (s = C(s, 0, m - i)), !(a.r < e || a.b < i || a.x > h || a.y > l) ? (u = Math.max(a.x, e), c = Math.max(a.y, i), b = d = Math.min(a.r, h) - u, E = f = Math.min(a.b, l) - c, T = r ? p + (v - (u - a.x) - d) : p + (u - a.x), w = o ? g + (m - (c - a.y) - f) : g + (c - a.y), e = u, i = c, n = d, s = f) : E = b = w = T = 0) : (r && (T = p + (v - e - n)), o && (w = g + (m - i - s))); const _ = this.source.width; const A = this.source.height; return t.u0 = Math.max(0, T / _), t.v0 = Math.max(0, w / A), t.u1 = Math.min(1, (T + b) / _), t.v1 = Math.min(1, (w + E) / A), t.x = e, t.y = i, t.cx = T, t.cy = w, t.cw = b, t.ch = E, t.width = n, t.height = s, t.flipX = r, t.flipY = o, t; },\n      updateCropUVs(t, e, i) { return this.setCropUVs(t, t.x, t.y, t.width, t.height, e, i); },\n      updateUVs() { const t = this.cutX; const e = this.cutY; const i = this.cutWidth; const n = this.cutHeight; const s = this.data.drawImage; s.width = i, s.height = n; const r = this.source.width; const o = this.source.height; return this.u0 = t / r, this.v0 = e / o, this.u1 = (t + i) / r, this.v1 = (e + n) / o, this; },\n      updateUVsInverted() { const t = this.source.width; const e = this.source.height; return this.u0 = (this.cutX + this.cutHeight) / t, this.v0 = this.cutY / e, this.u1 = this.cutX / t, this.v1 = (this.cutY + this.cutWidth) / e, this; },\n      clone() { const t = new r(this.texture, this.name, this.sourceIndex); return t.cutX = this.cutX, t.cutY = this.cutY, t.cutWidth = this.cutWidth, t.cutHeight = this.cutHeight, t.x = this.x, t.y = this.y, t.width = this.width, t.height = this.height, t.halfWidth = this.halfWidth, t.halfHeight = this.halfHeight, t.centerX = this.centerX, t.centerY = this.centerY, t.rotated = this.rotated, t.data = s(!0, t.data, this.data), t.updateUVs(), t; },\n      destroy() { this.source = null, this.texture = null, this.glTexture = null, this.customData = null, this.data = null; },\n      realWidth: { get() { return this.data.sourceSize.w; } },\n      realHeight: { get() { return this.data.sourceSize.h; } },\n      radius: { get() { return this.data.radius; } },\n      trimmed: { get() { return this.data.trim; } },\n      canvasData: { get() { return this.data.drawImage; } },\n    }); t.exports = r;\n  }, function (t, e, i) {\n    const n = i(0); const s = i(96); const r = i(398); const o = i(399); const a = i(47); const h = i(157); const l = new n({\n      initialize(t, e, i, n) { void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === n && (n = 0), this.type = a.ELLIPSE, this.x = t, this.y = e, this.width = i, this.height = n; }, contains(t, e) { return s(this, t, e); }, getPoint(t, e) { return r(this, t, e); }, getPoints(t, e, i) { return o(this, t, e, i); }, getRandomPoint(t) { return h(this, t); }, setTo(t, e, i, n) { return this.x = t, this.y = e, this.width = i, this.height = n, this; }, setEmpty() { return this.width = 0, this.height = 0, this; }, setPosition(t, e) { return void 0 === e && (e = t), this.x = t, this.y = e, this; }, setSize(t, e) { return void 0 === e && (e = t), this.width = t, this.height = e, this; }, isEmpty() { return this.width <= 0 || this.height <= 0; }, getMinorRadius() { return Math.min(this.width, this.height) / 2; }, getMajorRadius() { return Math.max(this.width, this.height) / 2; }, left: { get() { return this.x - this.width / 2; }, set(t) { this.x = t + this.width / 2; } }, right: { get() { return this.x + this.width / 2; }, set(t) { this.x = t - this.width / 2; } }, top: { get() { return this.y - this.height / 2; }, set(t) { this.y = t + this.height / 2; } }, bottom: { get() { return this.y + this.height / 2; }, set(t) { this.y = t - this.height / 2; } },\n    }); t.exports = l;\n  }, function (t, e) { t.exports = function (t, e, i) { if (t.width <= 0 || t.height <= 0) return !1; let n = (e - t.x) / t.width; let s = (i - t.y) / t.height; return (n *= n) + (s *= s) < 0.25; }; }, function (t, e, i) {\n    const B = i(241); const n = i(0); const r = i(90); const N = i(2); const Y = i(6); const s = i(7); const X = i(392); const o = i(133); const a = i(75); const h = new n({\n      initialize(t, e, i) { i ? e && !Array.isArray(e) && (e = [e]) : Array.isArray(e) ? s(e[0]) && (i = e, e = null) : s(e) && (i = e, e = null), this.scene = t, this.children = new o(), this.isParent = !0, this.type = 'Group', this.classType = N(i, 'classType', a), this.name = N(i, 'name', ''), this.active = N(i, 'active', !0), this.maxSize = N(i, 'maxSize', -1), this.defaultKey = N(i, 'defaultKey', null), this.defaultFrame = N(i, 'defaultFrame', null), this.runChildUpdate = N(i, 'runChildUpdate', !1), this.createCallback = N(i, 'createCallback', null), this.removeCallback = N(i, 'removeCallback', null), this.createMultipleCallback = N(i, 'createMultipleCallback', null), this.internalCreateCallback = N(i, 'internalCreateCallback', null), this.internalRemoveCallback = N(i, 'internalRemoveCallback', null), e && this.addMultiple(e), i && this.createMultiple(i); },\n      create(t, e, i, n, s, r) { if (void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = this.defaultKey), void 0 === n && (n = this.defaultFrame), void 0 === s && (s = !0), void 0 === r && (r = !0), this.isFull()) return null; const o = new this.classType(this.scene, t, e, i, n); return this.scene.sys.displayList.add(o), o.preUpdate && this.scene.sys.updateList.add(o), o.visible = s, o.setActive(r), this.add(o), o; },\n      createMultiple(t) { if (this.isFull()) return []; Array.isArray(t) || (t = [t]); var e = []; if (t[0].key) for (let i = 0; i < t.length; i++) var n = this.createFromConfig(t[i]); var e = e.concat(n); return e; },\n      createFromConfig(t) {\n        if (this.isFull()) return []; this.classType = N(t, 'classType', this.classType); let e = N(t, 'key', void 0); let i = N(t, 'frame', null); const n = N(t, 'visible', !0); const s = N(t, 'active', !0); const r = []; if (void 0 === e) return r; Array.isArray(e) || (e = [e]), Array.isArray(i) || (i = [i]); const o = N(t, 'repeat', 0); const a = N(t, 'randomKey', !1); const h = N(t, 'randomFrame', !1); const l = N(t, 'yoyo', !1); const u = N(t, 'quantity', !1); const c = N(t, 'frameQuantity', 1); const d = N(t, 'max', 0); const f = X(e, i, {\n          max: d, qty: u || c, random: a, randomB: h, repeat: o, yoyo: l,\n        }); t.createCallback && (this.createCallback = t.createCallback), t.removeCallback && (this.removeCallback = t.removeCallback); for (let p = 0; p < f.length; p++) { const g = this.create(0, 0, f[p].a, f[p].b, n, s); if (!g) break; r.push(g); } const v = Y(t, 'setXY.x', 0); const m = Y(t, 'setXY.y', 0); const y = Y(t, 'setXY.stepX', 0); const x = Y(t, 'setXY.stepY', 0); B.SetXY(r, v, m, y, x); const T = Y(t, 'setRotation.value', 0); const w = Y(t, 'setRotation.step', 0); B.SetRotation(r, T, w); const b = Y(t, 'setScale.x', 1); const E = Y(t, 'setScale.y', b); const S = Y(t, 'setScale.stepX', 0); const _ = Y(t, 'setScale.stepY', 0); B.SetScale(r, b, E, S, _); const A = Y(t, 'setAlpha.value', 1); const C = Y(t, 'setAlpha.step', 0); B.SetAlpha(r, A, C); const M = Y(t, 'setDepth.value', 0); const P = Y(t, 'setDepth.step', 0); B.SetDepth(r, M, P); const O = Y(t, 'setScrollFactor.x', 1); const R = Y(t, 'setScrollFactor.y', O); const L = Y(t, 'setScrollFactor.stepX', 0); const k = Y(t, 'setScrollFactor.stepY', 0); B.SetScrollFactor(r, O, R, L, k); const D = N(t, 'hitArea', null); const F = N(t, 'hitAreaCallback', null); D && B.SetHitArea(r, D, F); const I = N(t, 'gridAlign', !1); return I && B.GridAlign(r, I), this.createMultipleCallback && this.createMultipleCallback.call(this, r), r;\n      },\n      preUpdate(t, e) { if (this.runChildUpdate && this.children.size !== 0) for (let i = this.children.entries.slice(), n = 0; n < i.length; n++) { const s = i[n]; s.active && s.update(t, e); } },\n      add(t, e) { return void 0 === e && (e = !1), this.isFull() || (this.children.set(t), this.internalCreateCallback && this.internalCreateCallback.call(this, t), this.createCallback && this.createCallback.call(this, t), e && (this.scene.sys.displayList.add(t), t.preUpdate && this.scene.sys.updateList.add(t)), t.on(r.DESTROY, this.remove, this)), this; },\n      addMultiple(t, e) { if (void 0 === e && (e = !1), Array.isArray(t)) for (let i = 0; i < t.length; i++) this.add(t[i], e); return this; },\n      remove(t, e, i) { return void 0 === e && (e = !1), void 0 === i && (i = !1), this.children.contains(t) && (this.children.delete(t), this.internalRemoveCallback && this.internalRemoveCallback.call(this, t), this.removeCallback && this.removeCallback.call(this, t), t.off(r.DESTROY, this.remove, this), i ? t.destroy() : e && (t.scene.sys.displayList.remove(t), t.preUpdate && t.scene.sys.updateList.remove(t))), this; },\n      clear(t, e) { void 0 === t && (t = !1), void 0 === e && (e = !1); for (let i = this.children, n = 0; n < i.size; n++) { const s = i.entries[n]; s.off(r.DESTROY, this.remove, this), e ? s.destroy() : t && (s.scene.sys.displayList.remove(s), s.preUpdate && s.scene.sys.updateList.remove(s)); } return this.children.clear(), this; },\n      contains(t) { return this.children.contains(t); },\n      getChildren() { return this.children.entries; },\n      getLength() { return this.children.size; },\n      getFirst(t, e, i, n, s, r, o) { return this.getHandler(!0, 1, t, e, i, n, s, r, o); },\n      getFirstNth(t, e, i, n, s, r, o, a) { return this.getHandler(!0, t, e, i, n, s, r, o, a); },\n      getLast(t, e, i, n, s, r, o) { return this.getHandler(!1, 1, t, e, i, n, s, r, o); },\n      getLastNth(t, e, i, n, s, r, o, a) { return this.getHandler(!1, t, e, i, n, s, r, o, a); },\n      getHandler(t, e, i, n, s, r, o, a, h) { let l; let u; void 0 === i && (i = !1), void 0 === n && (n = !1); let c = 0; const d = this.children.entries; if (t) for (u = 0; u < d.length; u++) if ((l = d[u]).active === i) { if (++c === e) break; } else l = null; else for (u = d.length - 1; u >= 0; u--) if ((l = d[u]).active === i) { if (++c === e) break; } else l = null; return l ? (typeof s === 'number' && (l.x = s), typeof r === 'number' && (l.y = r), l) : n ? this.create(s, r, o, a, h) : null; },\n      get(t, e, i, n, s) { return this.getFirst(!1, !0, t, e, i, n, s); },\n      getFirstAlive(t, e, i, n, s, r) { return this.getFirst(!0, t, e, i, n, s, r); },\n      getFirstDead(t, e, i, n, s, r) { return this.getFirst(!1, t, e, i, n, s, r); },\n      playAnimation(t, e) { return B.PlayAnimation(this.children.entries, t, e), this; },\n      isFull() { return this.maxSize !== -1 && this.children.size >= this.maxSize; },\n      countActive(t) { void 0 === t && (t = !0); for (var e = 0, i = 0; i < this.children.size; i++) this.children.entries[i].active === t && e++; return e; },\n      getTotalUsed() { return this.countActive(); },\n      getTotalFree() { const t = this.getTotalUsed(); return (this.maxSize === -1 ? 999999999999 : this.maxSize) - t; },\n      setActive(t) { return this.active = t, this; },\n      setName(t) { return this.name = t, this; },\n      propertyValueSet(t, e, i, n, s) { return B.PropertyValueSet(this.children.entries, t, e, i, n, s), this; },\n      propertyValueInc(t, e, i, n, s) { return B.PropertyValueInc(this.children.entries, t, e, i, n, s), this; },\n      setX(t, e) { return B.SetX(this.children.entries, t, e), this; },\n      setY(t, e) { return B.SetY(this.children.entries, t, e), this; },\n      setXY(t, e, i, n) { return B.SetXY(this.children.entries, t, e, i, n), this; },\n      incX(t, e) { return B.IncX(this.children.entries, t, e), this; },\n      incY(t, e) { return B.IncY(this.children.entries, t, e), this; },\n      incXY(t, e, i, n) { return B.IncXY(this.children.entries, t, e, i, n), this; },\n      shiftPosition(t, e, i) { return B.ShiftPosition(this.children.entries, t, e, i), this; },\n      angle(t, e) { return B.Angle(this.children.entries, t, e), this; },\n      rotate(t, e) { return B.Rotate(this.children.entries, t, e), this; },\n      rotateAround(t, e) { return B.RotateAround(this.children.entries, t, e), this; },\n      rotateAroundDistance(t, e, i) { return B.RotateAroundDistance(this.children.entries, t, e, i), this; },\n      setAlpha(t, e) { return B.SetAlpha(this.children.entries, t, e), this; },\n      setTint(t, e, i, n) { return B.SetTint(this.children.entries, t, e, i, n), this; },\n      setOrigin(t, e, i, n) { return B.SetOrigin(this.children.entries, t, e, i, n), this; },\n      scaleX(t, e) { return B.ScaleX(this.children.entries, t, e), this; },\n      scaleY(t, e) { return B.ScaleY(this.children.entries, t, e), this; },\n      scaleXY(t, e, i, n) { return B.ScaleXY(this.children.entries, t, e, i, n), this; },\n      setDepth(t, e) { return B.SetDepth(this.children.entries, t, e), this; },\n      setBlendMode(t) { return B.SetBlendMode(this.children.entries, t), this; },\n      setHitArea(t, e) { return B.SetHitArea(this.children.entries, t, e), this; },\n      shuffle() { return B.Shuffle(this.children.entries), this; },\n      kill(t) { this.children.contains(t) && t.setActive(!1); },\n      killAndHide(t) { this.children.contains(t) && (t.setActive(!1), t.setVisible(!1)); },\n      setVisible(t, e, i) { return B.SetVisible(this.children.entries, t, e, i), this; },\n      toggleVisible() { return B.ToggleVisible(this.children.entries), this; },\n      destroy(t) { void 0 === t && (t = !1), this.scene && !this.ignoreDestroy && (this.clear(!1, t), this.scene = void 0, this.children = void 0); },\n    }); t.exports = h;\n  }, function (t, e, i) { const _ = i(9); t.exports = function (t, e, i, n, s, r) { for (let o = _.getTintAppendFloatAlphaAndSwap(i.fillColor, i.fillAlpha * n), a = i.pathData, h = i.pathIndexes, l = 0; l < h.length; l += 3) { const u = 2 * h[l]; const c = 2 * h[l + 1]; const d = 2 * h[l + 2]; const f = a[0 + u] - s; const p = a[1 + u] - r; const g = a[0 + c] - s; const v = a[1 + c] - r; const m = a[0 + d] - s; const y = a[1 + d] - r; const x = e.getX(f, p); const T = e.getY(f, p); const w = e.getX(g, v); const b = e.getY(g, v); const E = e.getX(m, y); const S = e.getY(m, y); t.setTexture2D(), t.batchTri(x, T, w, b, E, S, 0, 0, 1, 1, o, o, o, t.tintEffect); } }; }, function (t, e) { const i = {}; (t.exports = i).create = function (t, e) { return { x: t || 0, y: e || 0 }; }, i.clone = function (t) { return { x: t.x, y: t.y }; }, i.magnitude = function (t) { return Math.sqrt(t.x * t.x + t.y * t.y); }, i.magnitudeSquared = function (t) { return t.x * t.x + t.y * t.y; }, i.rotate = function (t, e, i) { const n = Math.cos(e); const s = Math.sin(e); i = i || {}; const r = t.x * n - t.y * s; return i.y = t.x * s + t.y * n, i.x = r, i; }, i.rotateAbout = function (t, e, i, n) { const s = Math.cos(e); const r = Math.sin(e); n = n || {}; const o = i.x + ((t.x - i.x) * s - (t.y - i.y) * r); return n.y = i.y + ((t.x - i.x) * r + (t.y - i.y) * s), n.x = o, n; }, i.normalise = function (t) { const e = i.magnitude(t); return e === 0 ? { x: 0, y: 0 } : { x: t.x / e, y: t.y / e }; }, i.dot = function (t, e) { return t.x * e.x + t.y * e.y; }, i.cross = function (t, e) { return t.x * e.y - t.y * e.x; }, i.cross3 = function (t, e, i) { return (e.x - t.x) * (i.y - t.y) - (e.y - t.y) * (i.x - t.x); }, i.add = function (t, e, i) { return (i = i || {}).x = t.x + e.x, i.y = t.y + e.y, i; }, i.sub = function (t, e, i) { return (i = i || {}).x = t.x - e.x, i.y = t.y - e.y, i; }, i.mult = function (t, e) { return { x: t.x * e, y: t.y * e }; }, i.div = function (t, e) { return { x: t.x / e, y: t.y / e }; }, i.perp = function (t, e) { return { x: (e = !0 === e ? -1 : 1) * -t.y, y: e * t.x }; }, i.neg = function (t) { return { x: -t.x, y: -t.y }; }, i.angle = function (t, e) { return Math.atan2(e.y - t.y, e.x - t.x); }, i._temp = [i.create(), i.create(), i.create(), i.create(), i.create(), i.create()]; }, function (t, e) { const i = {}; (t.exports = i).create = function (t) { const e = { min: { x: 0, y: 0 }, max: { x: 0, y: 0 } }; return t && i.update(e, t), e; }, i.update = function (t, e, i) { t.min.x = 1 / 0, t.max.x = -1 / 0, t.min.y = 1 / 0, t.max.y = -1 / 0; for (let n = 0; n < e.length; n++) { const s = e[n]; s.x > t.max.x && (t.max.x = s.x), s.x < t.min.x && (t.min.x = s.x), s.y > t.max.y && (t.max.y = s.y), s.y < t.min.y && (t.min.y = s.y); }i && (i.x > 0 ? t.max.x += i.x : t.min.x += i.x, i.y > 0 ? t.max.y += i.y : t.min.y += i.y); }, i.contains = function (t, e) { return e.x >= t.min.x && e.x <= t.max.x && e.y >= t.min.y && e.y <= t.max.y; }, i.overlaps = function (t, e) { return t.min.x <= e.max.x && t.max.x >= e.min.x && t.max.y >= e.min.y && t.min.y <= e.max.y; }, i.translate = function (t, e) { t.min.x += e.x, t.max.x += e.x, t.min.y += e.y, t.max.y += e.y; }, i.shift = function (t, e) { const i = t.max.x - t.min.x; const n = t.max.y - t.min.y; t.min.x = e.x, t.max.x = e.x + i, t.min.y = e.y, t.max.y = e.y + n; }; }, function (t, e) { t.exports = function (t, e, i) { return t >= 0 && t < i.width && e >= 0 && e < i.height; }; }, function (t, e, i) { const n = i(0); const s = i(2); const r = new n({ initialize(t) { void 0 === t && (t = {}), this.name = s(t, 'name', 'layer'), this.x = s(t, 'x', 0), this.y = s(t, 'y', 0), this.width = s(t, 'width', 0), this.height = s(t, 'height', 0), this.tileWidth = s(t, 'tileWidth', 0), this.tileHeight = s(t, 'tileHeight', 0), this.baseTileWidth = s(t, 'baseTileWidth', this.tileWidth), this.baseTileHeight = s(t, 'baseTileHeight', this.tileHeight), this.widthInPixels = s(t, 'widthInPixels', this.width * this.baseTileWidth), this.heightInPixels = s(t, 'heightInPixels', this.height * this.baseTileHeight), this.alpha = s(t, 'alpha', 1), this.visible = s(t, 'visible', !0), this.properties = s(t, 'properties', []), this.indexes = s(t, 'indexes', []), this.collideIndexes = s(t, 'collideIndexes', []), this.callbacks = s(t, 'callbacks', []), this.bodies = s(t, 'bodies', []), this.data = s(t, 'data', []), this.tilemapLayer = s(t, 'tilemapLayer', null); } }); t.exports = r; }, function (t, e, i) { const n = i(0); const s = i(2); const r = new n({ initialize(t) { void 0 === t && (t = {}), this.name = s(t, 'name', 'map'), this.width = s(t, 'width', 0), this.height = s(t, 'height', 0), this.infinite = s(t, 'infinite', !1), this.tileWidth = s(t, 'tileWidth', 0), this.tileHeight = s(t, 'tileHeight', 0), this.widthInPixels = s(t, 'widthInPixels', this.width * this.tileWidth), this.heightInPixels = s(t, 'heightInPixels', this.height * this.tileHeight), this.format = s(t, 'format', null), this.orientation = s(t, 'orientation', 'orthogonal'), this.renderOrder = s(t, 'renderOrder', 'right-down'), this.version = s(t, 'version', '1'), this.properties = s(t, 'properties', {}), this.layers = s(t, 'layers', []), this.images = s(t, 'images', []), this.objects = s(t, 'objects', {}), this.collision = s(t, 'collision', {}), this.tilesets = s(t, 'tilesets', []), this.imageCollections = s(t, 'imageCollections', []), this.tiles = s(t, 'tiles', []); } }); t.exports = r; }, function (t, e, i) {\n    const n = new (i(0))({\n      initialize(t, e, i, n, s, r, o, a) { (void 0 === i || i <= 0) && (i = 32), (void 0 === n || n <= 0) && (n = 32), void 0 === s && (s = 0), void 0 === r && (r = 0), void 0 === o && (o = {}), void 0 === a && (a = {}), this.name = t, this.firstgid = e, this.tileWidth = i, this.tileHeight = n, this.tileMargin = s, this.tileSpacing = r, this.tileProperties = o, this.tileData = a, this.image = null, this.glTexture = null, this.rows = 0, this.columns = 0, this.total = 0, this.texCoordinates = []; }, getTileProperties(t) { return this.containsTileIndex(t) ? this.tileProperties[t - this.firstgid] : null; }, getTileData(t) { return this.containsTileIndex(t) ? this.tileData[t - this.firstgid] : null; }, getTileCollisionGroup(t) { const e = this.getTileData(t); return e && e.objectgroup ? e.objectgroup : null; }, containsTileIndex(t) { return t >= this.firstgid && t < this.firstgid + this.total; }, getTileTextureCoordinates(t) { return this.containsTileIndex(t) ? this.texCoordinates[t - this.firstgid] : null; }, setImage(t) { return this.image = t, this.glTexture = t.get().source.glTexture, this.updateTileData(this.image.source[0].width, this.image.source[0].height), this; }, setTileSize(t, e) { return void 0 !== t && (this.tileWidth = t), void 0 !== e && (this.tileHeight = e), this.image && this.updateTileData(this.image.source[0].width, this.image.source[0].height), this; }, setSpacing(t, e) { return void 0 !== t && (this.tileMargin = t), void 0 !== e && (this.tileSpacing = e), this.image && this.updateTileData(this.image.source[0].width, this.image.source[0].height), this; }, updateTileData(t, e) { let i = (e - 2 * this.tileMargin + this.tileSpacing) / (this.tileHeight + this.tileSpacing); let n = (t - 2 * this.tileMargin + this.tileSpacing) / (this.tileWidth + this.tileSpacing); i % 1 == 0 && n % 1 == 0 || console.warn(`Image tile area not tile size multiple in: ${this.name}`), i = Math.floor(i), n = Math.floor(n), this.rows = i, this.columns = n, this.total = i * n, this.texCoordinates.length = 0; for (let s = this.tileMargin, r = this.tileMargin, o = 0; o < this.rows; o++) { for (let a = 0; a < this.columns; a++) this.texCoordinates.push({ x: s, y: r }), s += this.tileWidth + this.tileSpacing; s = this.tileMargin, r += this.tileHeight + this.tileSpacing; } return this; },\n    }); t.exports = n;\n  }, function (t, e) {\n    t.exports = {\n      TOP_LEFT: 0, TOP_CENTER: 1, TOP_RIGHT: 2, LEFT_TOP: 3, LEFT_CENTER: 4, LEFT_BOTTOM: 5, CENTER: 6, RIGHT_TOP: 7, RIGHT_CENTER: 8, RIGHT_BOTTOM: 9, BOTTOM_LEFT: 10, BOTTOM_CENTER: 11, BOTTOM_RIGHT: 12,\n    };\n  }, function (t, e) { t.exports = function (t, e, i) { return void 0 === i && (i = 1e-4), Math.abs(t - e) < i; }; }, function (t, e, i) { const n = i(0); const s = i(12); const r = i(14); const o = i(970); const a = new n({ Extends: r, Mixins: [s.Alpha, s.BlendMode, s.Depth, s.Flip, s.GetBounds, s.Mask, s.Origin, s.Pipeline, s.ScrollFactor, s.Size, s.TextureCrop, s.Tint, s.Transform, s.Visible, o], initialize(t, e, i, n, s) { r.call(this, t, 'Image'), this._crop = this.resetCropObject(), this.setTexture(n, s), this.setPosition(e, i), this.setSizeToFrame(), this.setOriginFromFrame(), this.initPipeline(); } }); t.exports = a; }, function (t, e) { t.exports = function (t, e) { return t.hasOwnProperty(e); }; }, function (t, e, i) { const v = {}; t.exports = v; const m = i(86); const y = i(42); const x = i(62); const d = i(100); const f = i(99); const T = i(1386); v.rectangle = function (t, e, i, n, s) { s = s || {}; let r; const o = { label: 'Rectangle Body', position: { x: t, y: e }, vertices: m.fromPath(`L 0 0 L ${i} 0 L ${i} ${n} L 0 ${n}`) }; return s.chamfer && (r = s.chamfer, o.vertices = m.chamfer(o.vertices, r.radius, r.quality, r.qualityMin, r.qualityMax), delete s.chamfer), x.create(y.extend({}, o, s)); }, v.trapezoid = function (t, e, i, n, s, r) { r = r || {}; let o; const a = i * (s *= 0.5); const h = a + (1 - 2 * s) * i; const l = h + a; const u = s < 0.5 ? `L 0 0 L ${a} ${-n} L ${h} ${-n} L ${l} 0` : `L 0 0 L ${h} ${-n} L ${l} 0`; const c = { label: 'Trapezoid Body', position: { x: t, y: e }, vertices: m.fromPath(u) }; return r.chamfer && (o = r.chamfer, c.vertices = m.chamfer(c.vertices, o.radius, o.quality, o.qualityMin, o.qualityMax), delete r.chamfer), x.create(y.extend({}, c, r)); }, v.circle = function (t, e, i, n, s) { n = n || {}; const r = { label: 'Circle Body', circleRadius: i }; s = s || 25; let o = Math.ceil(Math.max(10, Math.min(s, i))); return o % 2 == 1 && (o += 1), v.polygon(t, e, o, i, y.extend({}, r, n)); }, v.polygon = function (t, e, i, n, s) { if (s = s || {}, i < 3) return v.circle(t, e, n, s); for (var r = 2 * Math.PI / i, o = '', a = 0.5 * r, h = 0; h < i; h += 1) { const l = a + h * r; const u = Math.cos(l) * n; const c = Math.sin(l) * n; o += `L ${u.toFixed(3)} ${c.toFixed(3)} `; } let d; const f = { label: 'Polygon Body', position: { x: t, y: e }, vertices: m.fromPath(o) }; return s.chamfer && (d = s.chamfer, f.vertices = m.chamfer(f.vertices, d.radius, d.quality, d.qualityMin, d.qualityMax), delete s.chamfer), x.create(y.extend({}, f, s)); }, v.fromVertices = function (t, e, i, n, s, r, o) { let a; let h; let l; let u; let c; for (n = n || {}, h = [], s = void 0 !== s && s, r = void 0 !== r ? r : 0.01, o = void 0 !== o ? o : 10, T || y.warn('Bodies.fromVertices: poly-decomp.js required. Could not decompose vertices. Fallback to convex hull.'), y.isArray(i[0]) || (i = [i]), c = 0; c < i.length; c += 1) if (u = i[c], (l = m.isConvex(u)) || !T)u = l ? m.clockwiseSort(u) : m.hull(u), h.push({ position: { x: t, y: e }, vertices: u }); else { const d = u.map((t) => [t.x, t.y]); T.makeCCW(d), !1 !== r && T.removeCollinearPoints(d, r); for (var f = T.quickDecomp(d), p = 0; p < f.length; p++) { const g = f[p].map((t) => ({ x: t[0], y: t[1] })); o > 0 && m.area(g) < o || h.push({ position: m.centre(g), vertices: g }); } } for (p = 0; p < h.length; p++)h[p] = x.create(y.extend(h[p], n)); return s && v.flagCoincidentParts(h, 5), h.length > 1 ? (a = x.create(y.extend({ parts: h.slice(0) }, n)), x.setPosition(a, { x: t, y: e }), a) : h[0]; }, v.flagCoincidentParts = function (t, e) { void 0 === e && (e = 5); for (let i = 0; i < t.length; i++) for (let n = t[i], s = i + 1; s < t.length; s++) { const r = t[s]; if (d.overlaps(n.bounds, r.bounds)) for (let o = n.vertices, a = r.vertices, h = 0; h < n.vertices.length; h++) for (let l = 0; l < r.vertices.length; l++) { const u = f.magnitudeSquared(f.sub(o[(h + 1) % o.length], a[l])); const c = f.magnitudeSquared(f.sub(o[h], a[(l + 1) % a.length])); u < e && c < e && (o[h].isInternal = !0, a[l].isInternal = !0); } } return t; }; }, function (t, e, i) {\n    const r = i(52); const n = i(65); const s = i(55); const o = i(0); const a = i(12); const h = i(14); const l = i(11); const u = i(48); const c = new o({\n      Extends: h, Mixins: [a.Depth, a.GetBounds, a.Origin, a.Transform, a.ScrollFactor, a.Visible], initialize(t, e, i, n, s) { void 0 === n && (n = 1), void 0 === s && (s = n), h.call(this, t, 'Zone'), this.setPosition(e, i), this.width = n, this.height = s, this.blendMode = r.NORMAL, this.updateDisplayOrigin(); }, displayWidth: { get() { return this.scaleX * this.width; }, set(t) { this.scaleX = t / this.width; } }, displayHeight: { get() { return this.scaleY * this.height; }, set(t) { this.scaleY = t / this.height; } }, setSize(t, e, i) { void 0 === i && (i = !0), this.width = t, this.height = e, this.updateDisplayOrigin(); const n = this.input; return i && n && !n.customHitArea && (n.hitArea.width = t, n.hitArea.height = e), this; }, setDisplaySize(t, e) { return this.displayWidth = t, this.displayHeight = e, this; }, setCircleDropZone(t) { return this.setDropZone(new n(0, 0, t), s); }, setRectangleDropZone(t, e) { return this.setDropZone(new l(0, 0, t, e), u); }, setDropZone(t, e) { return void 0 === t ? this.setRectangleDropZone(this.width, this.height) : this.input || this.setInteractive(t, e, !0), this; }, setAlpha() {}, setBlendMode() {}, renderCanvas() {}, renderWebGL() {},\n    }); t.exports = c;\n  }, function (t, e, i) {\n    t.exports = {\n      ADD_ANIMATION: i(534), ANIMATION_COMPLETE: i(535), ANIMATION_REPEAT: i(536), ANIMATION_RESTART: i(537), ANIMATION_START: i(538), PAUSE_ALL: i(539), REMOVE_ANIMATION: i(540), RESUME_ALL: i(541), SPRITE_ANIMATION_COMPLETE: i(542), SPRITE_ANIMATION_KEY_COMPLETE: i(543), SPRITE_ANIMATION_KEY_REPEAT: i(544), SPRITE_ANIMATION_KEY_RESTART: i(545), SPRITE_ANIMATION_KEY_START: i(546), SPRITE_ANIMATION_KEY_UPDATE: i(547), SPRITE_ANIMATION_REPEAT: i(548), SPRITE_ANIMATION_RESTART: i(549), SPRITE_ANIMATION_START: i(550), SPRITE_ANIMATION_UPDATE: i(551),\n    };\n  }, function (t, e) { t.exports = function (t) { return 2 * (t.width + t.height); }; }, function (t, e, i) {\n    const n = i(0); const a = i(284); const s = new n({\n      initialize(t, e) { this.parent = t, (this.events = e) || (this.events = t.events ? t.events : t), this.list = {}, this.values = {}, this._frozen = !1, !t.hasOwnProperty('sys') && this.events && this.events.once('destroy', this.destroy, this); },\n      get(t) { const e = this.list; if (Array.isArray(t)) { for (var i = [], n = 0; n < t.length; n++)i.push(e[t[n]]); return i; } return e[t]; },\n      getAll() { const t = {}; for (const e in this.list) this.list.hasOwnProperty(e) && (t[e] = this.list[e]); return t; },\n      query(t) { const e = {}; for (const i in this.list) this.list.hasOwnProperty(i) && i.match(t) && (e[i] = this.list[i]); return e; },\n      set(t, e) { if (this._frozen) return this; if (typeof t === 'string') return this.setValue(t, e); for (const i in t) this.setValue(i, t[i]); return this; },\n      inc(t, e) { if (this._frozen) return this; void 0 === e && (e = 1); let i = this.get(t); return void 0 === i && (i = 0), this.set(t, i + e), this; },\n      toggle(t) { return this._frozen || this.set(t, !this.get(t)), this; },\n      setValue(i, t) {\n        return this._frozen || (this.has(i) ? this.values[i] = t : (s = (n = this).list, r = this.events, o = this.parent, Object.defineProperty(this.values, i, {\n          enumerable: !0, configurable: !0, get() { return s[i]; }, set(t) { let e; n._frozen || (e = s[i], s[i] = t, r.emit(a.CHANGE_DATA, o, i, t, e), r.emit(a.CHANGE_DATA_KEY + i, o, t, e)); },\n        }), s[i] = t, r.emit(a.SET_DATA, o, i, t))), this; let n; let s; let r; let o;\n      },\n      each(t, e) { for (var i = [this.parent, null, void 0], n = 1; n < arguments.length; n++)i.push(arguments[n]); for (const s in this.list)i[1] = s, i[2] = this.list[s], t.apply(e, i); return this; },\n      merge(t, e) { for (const i in void 0 === e && (e = !0), t)t.hasOwnProperty(i) && (e || !e && !this.has(i)) && this.setValue(i, t[i]); return this; },\n      remove(t) { if (this._frozen) return this; if (!Array.isArray(t)) return this.removeValue(t); for (let e = 0; e < t.length; e++) this.removeValue(t[e]); return this; },\n      removeValue(t) { let e; return this.has(t) && (e = this.list[t], delete this.list[t], delete this.values[t], this.events.emit(a.REMOVE_DATA, this.parent, t, e)), this; },\n      pop(t) { let e = void 0; return !this._frozen && this.has(t) && (e = this.list[t], delete this.list[t], delete this.values[t], this.events.emit(a.REMOVE_DATA, this.parent, t, e)), e; },\n      has(t) { return this.list.hasOwnProperty(t); },\n      setFreeze(t) { return this._frozen = t, this; },\n      reset() { for (const t in this.list) delete this.list[t], delete this.values[t]; return this._frozen = !1, this; },\n      destroy() { this.reset(), this.events.off(a.CHANGE_DATA), this.events.off(a.SET_DATA), this.events.off(a.REMOVE_DATA), this.parent = null; },\n      freeze: { get() { return this._frozen; }, set(t) { this._frozen = !!t; } },\n      count: { get() { let t = 0; for (const e in this.list) void 0 !== this.list[e] && t++; return t; } },\n    }); t.exports = s;\n  }, function (t, e) { t.exports = function (t) { for (let e = t.length - 1; e > 0; e--) { const i = Math.floor(Math.random() * (e + 1)); const n = t[e]; t[e] = t[i], t[i] = n; } return t; }; }, function (t, e, i) {\n    const n = i(302); const s = i(303); const r = i(304); const o = i(305); const a = i(306); const h = i(307); const l = i(308); const u = i(309); const c = i(310); const d = i(311); const f = i(312); const p = i(313); t.exports = {\n      Power0: l, Power1: u.Out, Power2: o.Out, Power3: c.Out, Power4: d.Out, Linear: l, Quad: u.Out, Cubic: o.Out, Quart: c.Out, Quint: d.Out, Sine: f.Out, Expo: h.Out, Circ: r.Out, Elastic: a.Out, Back: n.Out, Bounce: s.Out, Stepped: p, 'Quad.easeIn': u.In, 'Cubic.easeIn': o.In, 'Quart.easeIn': c.In, 'Quint.easeIn': d.In, 'Sine.easeIn': f.In, 'Expo.easeIn': h.In, 'Circ.easeIn': r.In, 'Elastic.easeIn': a.In, 'Back.easeIn': n.In, 'Bounce.easeIn': s.In, 'Quad.easeOut': u.Out, 'Cubic.easeOut': o.Out, 'Quart.easeOut': c.Out, 'Quint.easeOut': d.Out, 'Sine.easeOut': f.Out, 'Expo.easeOut': h.Out, 'Circ.easeOut': r.Out, 'Elastic.easeOut': a.Out, 'Back.easeOut': n.Out, 'Bounce.easeOut': s.Out, 'Quad.easeInOut': u.InOut, 'Cubic.easeInOut': o.InOut, 'Quart.easeInOut': c.InOut, 'Quint.easeInOut': d.InOut, 'Sine.easeInOut': f.InOut, 'Expo.easeInOut': h.InOut, 'Circ.easeInOut': r.InOut, 'Elastic.easeInOut': a.InOut, 'Back.easeInOut': n.InOut, 'Bounce.easeInOut': s.InOut,\n    };\n  }, function (t, e) { t.exports = function (t, e, i) { return (e - t) * i + t; }; }, function (t, e, i) {\n    (function (i) {\n      const n = {\n        android: !1, chromeOS: !1, cordova: !1, crosswalk: !1, desktop: !1, ejecta: !1, electron: !1, iOS: !1, iOSVersion: 0, iPad: !1, iPhone: !1, kindle: !1, linux: !1, macOS: !1, node: !1, nodeWebkit: !1, pixelRatio: 1, webApp: !1, windows: !1, windowsPhone: !1,\n      }; t.exports = (function () { const t = navigator.userAgent; /Windows/.test(t) ? n.windows = !0 : /Mac OS/.test(t) && !/like Mac OS/.test(t) ? n.macOS = !0 : /Android/.test(t) ? n.android = !0 : /Linux/.test(t) ? n.linux = !0 : /iP[ao]d|iPhone/i.test(t) ? (n.iOS = !0, navigator.appVersion.match(/OS (\\d+)/), n.iOSVersion = parseInt(RegExp.$1, 10), n.iPhone = t.toLowerCase().indexOf('iphone') !== -1, n.iPad = t.toLowerCase().indexOf('ipad') !== -1) : /Kindle/.test(t) || /\\bKF[A-Z][A-Z]+/.test(t) || /Silk.*Mobile Safari/.test(t) ? n.kindle = !0 : /CrOS/.test(t) && (n.chromeOS = !0), (/Windows Phone/i.test(t) || /IEMobile/i.test(t)) && (n.android = !1, n.iOS = !1, n.macOS = !1, n.windows = !0, n.windowsPhone = !0); const e = /Silk/.test(t); return (n.windows || n.macOS || n.linux && !e || n.chromeOS) && (n.desktop = !0), (n.windowsPhone || /Windows NT/i.test(t) && /Touch/i.test(t)) && (n.desktop = !1), navigator.standalone && (n.webApp = !0), void 0 !== window.cordova && (n.cordova = !0), void 0 !== i && i.versions && i.versions.node && (n.node = !0), n.node && typeof i.versions === 'object' && (n.nodeWebkit = !!i.versions['node-webkit'], n.electron = !!i.versions.electron), void 0 !== window.ejecta && (n.ejecta = !0), /Crosswalk/.test(t) && (n.crosswalk = !0), n.pixelRatio = window.devicePixelRatio || 1, n; }());\n    }).call(this, i(729));\n  }, function (t, e, i) {\n    let n; const s = i(117); const r = {\n      chrome: !1, chromeVersion: 0, edge: !1, firefox: !1, firefoxVersion: 0, ie: !1, ieVersion: 0, mobileSafari: !1, opera: !1, safari: !1, safariVersion: 0, silk: !1, trident: !1, tridentVersion: 0,\n    }; t.exports = (n = navigator.userAgent, /Edge\\/\\d+/.test(n) ? r.edge = !0 : /Chrome\\/(\\d+)/.test(n) && !s.windowsPhone ? (r.chrome = !0, r.chromeVersion = parseInt(RegExp.$1, 10)) : /Firefox\\D+(\\d+)/.test(n) ? (r.firefox = !0, r.firefoxVersion = parseInt(RegExp.$1, 10)) : /AppleWebKit/.test(n) && s.iOS ? r.mobileSafari = !0 : /MSIE (\\d+\\.\\d+);/.test(n) ? (r.ie = !0, r.ieVersion = parseInt(RegExp.$1, 10)) : /Opera/.test(n) ? r.opera = !0 : /Safari/.test(n) && !s.windowsPhone ? r.safari = !0 : /Trident\\/(\\d+\\.\\d+)(.*)rv:(\\d+\\.\\d+)/.test(n) && (r.ie = !0, r.trident = !0, r.tridentVersion = parseInt(RegExp.$1, 10), r.ieVersion = parseInt(RegExp.$3, 10)), /Silk/.test(n) && (r.silk = !0), r);\n  }, function (t, e) { t.exports = function (t, e) { return Math.random() * (e - t) + t; }; }, function (t, e) { t.exports = function (t, e) { return t > 0 && (t & t - 1) == 0 && e > 0 && (e & e - 1) == 0; }; }, function (t, e, i) {\n    t.exports = {\n      ADD: i(781), ERROR: i(782), LOAD: i(783), READY: i(784), REMOVE: i(785),\n    };\n  }, function (t, e) { t.exports = function (t, e) { let i; if (e) typeof e === 'string' ? i = document.getElementById(e) : typeof e === 'object' && e.nodeType === 1 && (i = e); else if (t.parentElement || e === null) return t; return (i = i || document.body).appendChild(t), t; }; }, function (t, e, i) { const a = i(80); t.exports = function (t, e, i, n) { if (void 0 === n && (n = t), !Array.isArray(e)) return (r = t.indexOf(e)) !== -1 ? (a(t, r), i && i.call(n, e), e) : null; for (let s = e.length - 1; s >= 0;) { var r; const o = e[s]; (r = t.indexOf(o)) !== -1 ? (a(t, r), i && i.call(n, o)) : e.pop(), s--; } return e; }; }, function (t, e) {\n    t.exports = {\n      BACKSPACE: 8, TAB: 9, ENTER: 13, SHIFT: 16, CTRL: 17, ALT: 18, PAUSE: 19, CAPS_LOCK: 20, ESC: 27, SPACE: 32, PAGE_UP: 33, PAGE_DOWN: 34, END: 35, HOME: 36, LEFT: 37, UP: 38, RIGHT: 39, DOWN: 40, PRINT_SCREEN: 42, INSERT: 45, DELETE: 46, ZERO: 48, ONE: 49, TWO: 50, THREE: 51, FOUR: 52, FIVE: 53, SIX: 54, SEVEN: 55, EIGHT: 56, NINE: 57, NUMPAD_ZERO: 96, NUMPAD_ONE: 97, NUMPAD_TWO: 98, NUMPAD_THREE: 99, NUMPAD_FOUR: 100, NUMPAD_FIVE: 101, NUMPAD_SIX: 102, NUMPAD_SEVEN: 103, NUMPAD_EIGHT: 104, NUMPAD_NINE: 105, NUMPAD_ADD: 107, NUMPAD_SUBTRACT: 109, A: 65, B: 66, C: 67, D: 68, E: 69, F: 70, G: 71, H: 72, I: 73, J: 74, K: 75, L: 76, M: 77, N: 78, O: 79, P: 80, Q: 81, R: 82, S: 83, T: 84, U: 85, V: 86, W: 87, X: 88, Y: 89, Z: 90, F1: 112, F2: 113, F3: 114, F4: 115, F5: 116, F6: 117, F7: 118, F8: 119, F9: 120, F10: 121, F11: 122, F12: 123, SEMICOLON: 186, PLUS: 187, COMMA: 188, MINUS: 189, PERIOD: 190, FORWARD_SLASH: 191, BACK_SLASH: 220, QUOTES: 222, BACKTICK: 192, OPEN_BRACKET: 219, CLOSED_BRACKET: 221, SEMICOLON_FIREFOX: 59, COLON: 58, COMMA_FIREFOX_WINDOWS: 60, COMMA_FIREFOX: 62, BRACKET_RIGHT_FIREFOX: 174, BRACKET_LEFT_FIREFOX: 175,\n    };\n  }, function (t, e) {\n    t.exports = {\n      PENDING: 0, INIT: 1, START: 2, LOADING: 3, CREATING: 4, RUNNING: 5, PAUSED: 6, SLEEPING: 7, SHUTDOWN: 8, DESTROYED: 9,\n    };\n  }, function (t, e, i) { const s = i(67); t.exports = function (t, e) { const i = s(t); for (const n in e)i.hasOwnProperty(n) || (i[n] = e[n]); return i; }; }, function (t, e, i) {\n    const n = i(0); const o = i(67); const s = i(10); const r = i(59); const a = i(20); const h = i(1); const l = i(382); const u = i(383); const c = new n({\n      Extends: s,\n      initialize(t) { s.call(this), this.game = t, this.jsonCache = t.cache.json, this.sounds = [], this.mute = !1, this.volume = 1, this.pauseOnBlur = !0, this._rate = 1, this._detune = 0, this.locked = this.locked || !1, this.unlocked = !1, t.events.on(a.BLUR, this.onGameBlur, this), t.events.on(a.FOCUS, this.onGameFocus, this), t.events.on(a.PRE_STEP, this.update, this), t.events.once(a.DESTROY, this.destroy, this); },\n      add: h,\n      addAudioSprite(t, e) {\n        void 0 === e && (e = {}); let i; let n; const s = this.add(t, e); for (const r in s.spritemap = this.jsonCache.get(t).spritemap, s.spritemap) {\n          s.spritemap.hasOwnProperty(r) && (i = o(e), n = s.spritemap[r], i.loop = !!n.hasOwnProperty('loop') && n.loop, s.addMarker({\n            name: r, start: n.start, duration: n.end - n.start, config: i,\n          }));\n        } return s;\n      },\n      get(t) { return u(this.sounds, 'key', t); },\n      getAll(t) { return l(this.sounds, 'key', t); },\n      play(t, e) { const i = this.add(t); return i.once(r.COMPLETE, i.destroy, i), e ? e.name ? (i.addMarker(e), i.play(e.name)) : i.play(e) : i.play(); },\n      playAudioSprite(t, e, i) { const n = this.addAudioSprite(t); return n.once(r.COMPLETE, n.destroy, n), n.play(e, i); },\n      remove(t) { const e = this.sounds.indexOf(t); return e !== -1 && (t.destroy(), this.sounds.splice(e, 1), !0); },\n      removeAll() { this.sounds.forEach((t) => { t.destroy(); }), this.sounds.length = 0; },\n      removeByKey(t) { for (var e = 0, i = this.sounds.length - 1; i >= 0; i--) { const n = this.sounds[i]; n.key === t && (n.destroy(), this.sounds.splice(i, 1), e++); } return e; },\n      pauseAll() { this.forEachActiveSound((t) => { t.pause(); }), this.emit(r.PAUSE_ALL, this); },\n      resumeAll() { this.forEachActiveSound((t) => { t.resume(); }), this.emit(r.RESUME_ALL, this); },\n      stopAll() { this.forEachActiveSound((t) => { t.stop(); }), this.emit(r.STOP_ALL, this); },\n      stopByKey(t) { let e = 0; return this.getAll(t).forEach((t) => { t.stop() && e++; }), e; },\n      unlock: h,\n      onBlur: h,\n      onFocus: h,\n      onGameBlur() { this.pauseOnBlur && this.onBlur(); },\n      onGameFocus() { this.pauseOnBlur && this.onFocus(); },\n      update(e, i) { this.unlocked && (this.unlocked = !1, this.locked = !1, this.emit(r.UNLOCKED, this)); for (let t = this.sounds.length - 1; t >= 0; t--) this.sounds[t].pendingRemove && this.sounds.splice(t, 1); this.sounds.forEach((t) => { t.update(e, i); }); },\n      destroy() { this.game.events.off(a.BLUR, this.onGameBlur, this), this.game.events.off(a.FOCUS, this.onGameFocus, this), this.game.events.off(a.PRE_STEP, this.update, this), this.removeAllListeners(), this.removeAll(), this.sounds.length = 0, this.sounds = null, this.game = null; },\n      forEachActiveSound(i, n) { const s = this; this.sounds.forEach((t, e) => { t && !t.pendingRemove && i.call(n || s, t, e, s.sounds); }); },\n      setRate(t) { return this.rate = t, this; },\n      rate: { get() { return this._rate; }, set(t) { this._rate = t, this.forEachActiveSound((t) => { t.calculateRate(); }), this.emit(r.GLOBAL_RATE, this, t); } },\n      setDetune(t) { return this.detune = t, this; },\n      detune: { get() { return this._detune; }, set(t) { this._detune = t, this.forEachActiveSound((t) => { t.calculateRate(); }), this.emit(r.GLOBAL_DETUNE, this, t); } },\n    }); t.exports = c;\n  }, function (t, e, i) {\n    const n = i(0); const s = i(10); const r = i(59); const o = i(18); const a = i(1); const h = new n({\n      Extends: s,\n      initialize(t, e, i) {\n        s.call(this), this.manager = t, this.key = e, this.isPlaying = !1, this.isPaused = !1, this.totalRate = 1, this.duration = this.duration || 0, this.totalDuration = this.totalDuration || 0, this.config = {\n          mute: !1, volume: 1, rate: 1, detune: 0, seek: 0, loop: !1, delay: 0,\n        }, this.currentConfig = this.config, this.config = o(this.config, i), this.markers = {}, this.currentMarker = null, this.pendingRemove = !1;\n      },\n      addMarker(t) {\n        return !(!t || !t.name || typeof t.name !== 'string') && (this.markers[t.name] ? (console.error(`addMarker ${t.name} already exists in Sound`), !1) : (t = o(!0, {\n          name: '',\n          start: 0,\n          duration: this.totalDuration - (t.start || 0),\n          config: {\n            mute: !1, volume: 1, rate: 1, detune: 0, seek: 0, loop: !1, delay: 0,\n          },\n        }, t), this.markers[t.name] = t, !0));\n      },\n      updateMarker(t) { return !(!t || !t.name || typeof t.name !== 'string') && (this.markers[t.name] ? (this.markers[t.name] = o(!0, this.markers[t.name], t), !0) : (console.warn(`Audio Marker: ${t.name} missing in Sound: ${this.key}`), !1)); },\n      removeMarker(t) { const e = this.markers[t]; return e ? (this.markers[t] = null, e) : null; },\n      play(t, e) { if (void 0 === t && (t = ''), typeof t === 'object' && (e = t, t = ''), typeof t !== 'string') return !1; if (t) { if (!this.markers[t]) return console.warn(`Marker: ${t} missing in Sound: ${this.key}`), !1; this.currentMarker = this.markers[t], this.currentConfig = this.currentMarker.config, this.duration = this.currentMarker.duration; } else this.currentMarker = null, this.currentConfig = this.config, this.duration = this.totalDuration; return this.resetConfig(), this.currentConfig = o(this.currentConfig, e), this.isPlaying = !0, !(this.isPaused = !1); },\n      pause() { return !(this.isPaused || !this.isPlaying) && (this.isPlaying = !1, this.isPaused = !0); },\n      resume() { return !(!this.isPaused || this.isPlaying) && (this.isPlaying = !0, !(this.isPaused = !1)); },\n      stop() { return !(!this.isPaused && !this.isPlaying) && (this.isPlaying = !1, this.isPaused = !1, this.resetConfig(), !0); },\n      applyConfig() { this.mute = this.currentConfig.mute, this.volume = this.currentConfig.volume, this.rate = this.currentConfig.rate, this.detune = this.currentConfig.detune, this.loop = this.currentConfig.loop; },\n      resetConfig() { this.currentConfig.seek = 0, this.currentConfig.delay = 0; },\n      update: a,\n      calculateRate() { const t = this.currentConfig.detune + this.manager.detune; const e = Math.pow(1.0005777895065548, t); this.totalRate = this.currentConfig.rate * this.manager.rate * e; },\n      destroy() { this.pendingRemove || (this.emit(r.DESTROY, this), this.pendingRemove = !0, this.manager = null, this.key = '', this.removeAllListeners(), this.isPlaying = !1, this.isPaused = !1, this.config = null, this.currentConfig = null, this.markers = null, this.currentMarker = null); },\n    }); t.exports = h;\n  }, function (t, e, i) {\n    const s = i(183); const n = i(0); const r = i(1); const o = i(131); const a = new n({\n      initialize(t) { this.parent = t, this.list = [], this.position = 0, this.addCallback = r, this.removeCallback = r, this._sortKey = ''; }, add(t, e) { return e ? s.Add(this.list, t) : s.Add(this.list, t, 0, this.addCallback, this); }, addAt(t, e, i) { return i ? s.AddAt(this.list, t, e) : s.AddAt(this.list, t, e, 0, this.addCallback, this); }, getAt(t) { return this.list[t]; }, getIndex(t) { return this.list.indexOf(t); }, sort(i, t) { return i && (void 0 === t && (t = function (t, e) { return t[i] - e[i]; }), o.inplace(this.list, t)), this; }, getByName(t) { return s.GetFirst(this.list, 'name', t); }, getRandom(t, e) { return s.GetRandom(this.list, t, e); }, getFirst(t, e, i, n) { return s.GetFirst(this.list, t, e, i, n); }, getAll(t, e, i, n) { return s.GetAll(this.list, t, e, i, n); }, count(t, e) { return s.CountAllMatching(this.list, t, e); }, swap(t, e) { s.Swap(this.list, t, e); }, moveTo(t, e) { return s.MoveTo(this.list, t, e); }, remove(t, e) { return e ? s.Remove(this.list, t) : s.Remove(this.list, t, this.removeCallback, this); }, removeAt(t, e) { return e ? s.RemoveAt(this.list, t) : s.RemoveAt(this.list, t, this.removeCallback, this); }, removeBetween(t, e, i) { return i ? s.RemoveBetween(this.list, t, e) : s.RemoveBetween(this.list, t, e, this.removeCallback, this); }, removeAll(t) { for (let e = this.list.length; e--;) this.remove(this.list[e], t); return this; }, bringToTop(t) { return s.BringToTop(this.list, t); }, sendToBack(t) { return s.SendToBack(this.list, t); }, moveUp(t) { return s.MoveUp(this.list, t), t; }, moveDown(t) { return s.MoveDown(this.list, t), t; }, reverse() { return this.list.reverse(), this; }, shuffle() { return s.Shuffle(this.list), this; }, replace(t, e) { return s.Replace(this.list, t, e); }, exists(t) { return this.list.indexOf(t) > -1; }, setAll(t, e, i, n) { return s.SetAll(this.list, t, e, i, n), this; }, each(t, e) { for (var i = [null], n = 2; n < arguments.length; n++)i.push(arguments[n]); for (n = 0; n < this.list.length; n++)i[0] = this.list[n], t.apply(e, i); }, shutdown() { this.removeAll(), this.list = []; }, destroy() { this.removeAll(), this.parent = null, this.addCallback = null, this.removeCallback = null; }, length: { get() { return this.list.length; } }, first: { get() { return (this.position = 0) < this.list.length ? this.list[0] : null; } }, last: { get() { return this.list.length > 0 ? (this.position = this.list.length - 1, this.list[this.position]) : null; } }, next: { get() { return this.position < this.list.length ? (this.position++, this.list[this.position]) : null; } }, previous: { get() { return this.position > 0 ? (this.position--, this.list[this.position]) : null; } },\n    }); t.exports = a;\n  }, function (t, e, i) { const n = i(184); const s = i(390); t.exports = function (t, e) { if (void 0 === e && (e = 90), !n(t)) return null; if (typeof e !== 'string' && (e = (e % 360 + 360) % 360), e === 90 || e === -270 || e === 'rotateLeft')(t = s(t)).reverse(); else if (e === -90 || e === 270 || e === 'rotateRight')t.reverse(), t = s(t); else if (Math.abs(e) === 180 || e === 'rotate180') { for (let i = 0; i < t.length; i++)t[i].reverse(); t.reverse(); } return t; }; }, function (e, t, i) { !(function () { function t(t, e) { return n(t.slice(), e); } function n(t, e) { typeof e !== 'function' && (e = function (t, e) { return String(t).localeCompare(e); }); const i = t.length; if (i <= 1) return t; for (let n = new Array(i), s = 1; s < i; s *= 2) { o(t, e, s, n); const r = t; t = n, n = r; } return t; }t.inplace = function (t, e) { const i = n(t, e); return i !== t && o(i, null, t.length, t), t; }; var o = function (t, e, i, n) { for (var s, r, o, a, h = t.length, l = 0, u = 2 * i, c = 0; c < h; c += u) for (r = (s = c + i) + i, h < s && (s = h), h < r && (r = h), o = c, a = s; ;) if (o < s && a < r)e(t[o], t[a]) <= 0 ? n[l++] = t[o++] : n[l++] = t[a++]; else if (o < s)n[l++] = t[o++]; else { if (!(a < r)) break; n[l++] = t[a++]; } }; e.exports = t; }()); }, function (t, e, i) {\n    const n = i(0); const s = i(12); const h = i(14); const l = i(945); const r = i(946); const o = i(187); const a = i(947); var u = new n({\n      Extends: h,\n      Mixins: [s.Alpha, s.BlendMode, s.Depth, s.Mask, s.Origin, s.Pipeline, s.ScrollFactor, s.Texture, s.Tint, s.Transform, s.Visible, a],\n      initialize(t, e, i, n, s, r, o) { void 0 === s && (s = ''), void 0 === o && (o = 0), h.call(this, t, 'BitmapText'), this.font = n; const a = this.scene.sys.cache.bitmapFont.get(n); this.fontData = a.data, this._text = '', this._fontSize = r || this.fontData.size, this._letterSpacing = 0, this._align = o, this._bounds = l(), this._dirty = !0, this._maxWidth = 0, this.wordWrapCharCode = 32, this.setTexture(a.texture, a.frame), this.setPosition(e, i), this.setOrigin(0, 0), this.initPipeline(), this.setText(s); },\n      setLeftAlign() { return this._align = u.ALIGN_LEFT, this._dirty = !0, this; },\n      setCenterAlign() { return this._align = u.ALIGN_CENTER, this._dirty = !0, this; },\n      setRightAlign() { return this._align = u.ALIGN_RIGHT, this._dirty = !0, this; },\n      setFontSize(t) { return this._fontSize = t, this._dirty = !0, this; },\n      setLetterSpacing(t) { return void 0 === t && (t = 0), this._letterSpacing = t, this._dirty = !0, this; },\n      setText(t) { return t || t === 0 || (t = ''), Array.isArray(t) && (t = t.join('\\n')), t !== this.text && (this._text = t.toString(), this._dirty = !0, this.updateDisplayOrigin()), this; },\n      getTextBounds(t) { const e = this._bounds; return !this._dirty && this.scaleX === e.scaleX && this.scaleY === e.scaleY || (l(this, t, e), this._dirty = !1, this.updateDisplayOrigin()), e; },\n      updateDisplayOrigin() { return this._displayOriginX = this.originX * this.width, this._displayOriginY = this.originY * this.height, this._dirty = !0, this; },\n      setFont(t, e, i) { let n; return void 0 === e && (e = this._fontSize), void 0 === i && (i = this._align), t === this.font || (n = this.scene.sys.cache.bitmapFont.get(t)) && (this.font = t, this.fontData = n.data, this._fontSize = e, this._align = i, this.setTexture(n.texture, n.frame), l(this, !1, this._bounds)), this; },\n      setMaxWidth(t, e) { return this._maxWidth = t, this._dirty = !0, void 0 !== e && (this.wordWrapCharCode = e), this; },\n      align: { set(t) { this._align = t, this._dirty = !0; }, get() { return this._align; } },\n      text: { set(t) { this.setText(t); }, get() { return this._text; } },\n      fontSize: { set(t) { this._fontSize = t, this._dirty = !0; }, get() { return this._fontSize; } },\n      letterSpacing: { set(t) { this._letterSpacing = t, this._dirty = !0; }, get() { return this._letterSpacing; } },\n      maxWidth: { set(t) { this._maxWidth = t, this._dirty = !0; }, get() { return this._maxWidth; } },\n      width: { get() { return this.getTextBounds(!1), this._bounds.global.width; } },\n      height: { get() { return this.getTextBounds(!1), this._bounds.global.height; } },\n      toJSON() {\n        const t = s.ToJSON(this); const e = {\n          font: this.font, text: this.text, fontSize: this.fontSize, letterSpacing: this.letterSpacing, align: this.align,\n        }; return t.data = e, t;\n      },\n    }); u.ALIGN_LEFT = 0, u.ALIGN_CENTER = 1, u.ALIGN_RIGHT = 2, u.ParseFromAtlas = r, u.ParseXMLBitmapFont = o, t.exports = u;\n  }, function (t, e, i) {\n    var n = new (i(0))({\n      initialize(t) { if (this.entries = [], Array.isArray(t)) for (let e = 0; e < t.length; e++) this.set(t[e]); }, set(t) { return this.entries.indexOf(t) === -1 && this.entries.push(t), this; }, get(t, e) { for (let i = 0; i < this.entries.length; i++) { const n = this.entries[i]; if (n[t] === e) return n; } }, getArray() { return this.entries.slice(0); }, delete(t) { const e = this.entries.indexOf(t); return e > -1 && this.entries.splice(e, 1), this; }, dump() { console.group('Set'); for (let t = 0; t < this.entries.length; t++) { const e = this.entries[t]; console.log(e); }console.groupEnd(); }, each(t, e) { let i; const n = this.entries.slice(); const s = n.length; if (e) for (i = 0; i < s && !1 !== t.call(e, n[i], i); i++);else for (i = 0; i < s && !1 !== t(n[i], i); i++);return this; }, iterate(t, e) { let i; const n = this.entries.length; if (e) for (i = 0; i < n && !1 !== t.call(e, this.entries[i], i); i++);else for (i = 0; i < n && !1 !== t(this.entries[i], i); i++);return this; }, iterateLocal(t) { for (var e = [], i = 1; i < arguments.length; i++)e.push(arguments[i]); const n = this.entries.length; for (i = 0; i < n; i++) { const s = this.entries[i]; s[t].apply(s, e); } return this; }, clear() { return this.entries.length = 0, this; }, contains(t) { return this.entries.indexOf(t) > -1; }, union(t) { const e = new n(); return t.entries.forEach((t) => { e.set(t); }), this.entries.forEach((t) => { e.set(t); }), e; }, intersect(e) { const i = new n(); return this.entries.forEach((t) => { e.contains(t) && i.set(t); }), i; }, difference(e) { const i = new n(); return this.entries.forEach((t) => { e.contains(t) || i.set(t); }), i; }, size: { get() { return this.entries.length; }, set(t) { return t < this.entries.length ? this.entries.length = t : this.entries.length; } },\n    }); t.exports = n;\n  }, function (t, e, i) {\n    const n = i(0); const s = i(12); const c = i(14); const r = i(1077); const o = i(1); const a = new n({\n      Extends: c, Mixins: [s.BlendMode, s.Depth, s.Mask, s.Pipeline, s.Size, s.Texture, s.Transform, s.Visible, s.ScrollFactor, r], initialize(t, e, i, n, s, r, o, a, h) { if (c.call(this, t, 'Mesh'), n.length !== s.length) throw new Error('Mesh Vertex count must match UV count'); let l; const u = n.length / 2 | 0; if (r.length > 0 && r.length < u) throw new Error('Mesh Color count must match Vertex count'); if (o.length > 0 && o.length < u) throw new Error('Mesh Alpha count must match Vertex count'); if (r.length === 0) for (l = 0; l < u; ++l)r[l] = 16777215; if (o.length === 0) for (l = 0; l < u; ++l)o[l] = 1; this.vertices = new Float32Array(n), this.uv = new Float32Array(s), this.colors = new Uint32Array(r), this.alphas = new Float32Array(o), this.tintFill = !1, this.setTexture(a, h), this.setPosition(e, i), this.setSizeToFrame(), this.initPipeline(); }, setAlpha: o,\n    }); t.exports = a;\n  }, function (t, e) { t.exports = function (t, e) { return !(t.width <= 0 || t.height <= 0 || e.width <= 0 || e.height <= 0) && !(t.right < e.x || t.bottom < e.y || t.x > e.right || t.y > e.bottom); }; }, function (t, e, i) {\n    const l = i(6); const u = {}; const n = {\n      register(t, e, i, n, s) {\n        u[t] = {\n          plugin: e, mapping: i, settingsKey: n, configKey: s,\n        };\n      },\n      getPlugin(t) { return u[t]; },\n      install(t) { const e = t.scene.sys; const i = e.settings.input; const n = e.game.config; for (const s in u) { const r = u[s].plugin; const o = u[s].mapping; const a = u[s].settingsKey; const h = u[s].configKey; l(i, a, n[h]) && (t[o] = new r(t)); } },\n      remove(t) { u.hasOwnProperty(t) && delete u[t]; },\n    }; t.exports = n;\n  }, function (t, e, i) {\n    t.exports = {\n      ANY_KEY_DOWN: i(1217), ANY_KEY_UP: i(1218), COMBO_MATCH: i(1219), DOWN: i(1220), KEY_DOWN: i(1221), KEY_UP: i(1222), UP: i(1223),\n    };\n  }, function (t, e) { t.exports = function (t, e) { return !!t.url && (t.url.match(/^(?:blob:|data:|http:\\/\\/|https:\\/\\/|\\/\\/)/) ? t.url : e + t.url); }; }, function (t, e) {\n    t.exports = function (t, e, i, n, s, r) {\n      return void 0 === t && (t = ''), void 0 === e && (e = !0), void 0 === i && (i = ''), void 0 === n && (n = ''), void 0 === s && (s = 0), void 0 === r && (r = !1), {\n        responseType: t, async: e, user: i, password: n, timeout: s, headers: void 0, header: void 0, headerValue: void 0, requestedWith: !1, overrideMimeType: void 0, withCredentials: r,\n      };\n    };\n  }, function (t, e, i) { const n = i(0); const s = i(217); const r = i(75); const o = new n({ Extends: r, Mixins: [s.Acceleration, s.Angular, s.Bounce, s.Debug, s.Drag, s.Enable, s.Friction, s.Gravity, s.Immovable, s.Mass, s.Size, s.Velocity], initialize(t, e, i, n, s) { r.call(this, t, e, i, n, s), this.body = null; } }); t.exports = o; }, function (t, e, i) {\n    t.exports = {\n      CalculateFacesAt: i(220), CalculateFacesWithin: i(51), Copy: i(1313), CreateFromTiles: i(1314), CullTiles: i(1315), Fill: i(1316), FilterTiles: i(1317), FindByIndex: i(1318), FindTile: i(1319), ForEachTile: i(1320), GetTileAt: i(142), GetTileAtWorldXY: i(1321), GetTilesWithin: i(24), GetTilesWithinShape: i(1322), GetTilesWithinWorldXY: i(1323), HasTileAt: i(476), HasTileAtWorldXY: i(1324), IsInLayerBounds: i(101), PutTileAt: i(221), PutTileAtWorldXY: i(1325), PutTilesAt: i(1326), Randomize: i(1327), RemoveTileAt: i(477), RemoveTileAtWorldXY: i(1328), RenderDebug: i(1329), ReplaceByIndex: i(475), SetCollision: i(1330), SetCollisionBetween: i(1331), SetCollisionByExclusion: i(1332), SetCollisionByProperty: i(1333), SetCollisionFromCollisionGroup: i(1334), SetTileIndexCallback: i(1335), SetTileLocationCallback: i(1336), Shuffle: i(1337), SwapByIndex: i(1338), TileToWorldX: i(143), TileToWorldXY: i(1339), TileToWorldY: i(144), WeightedRandomize: i(1340), WorldToTileX: i(63), WorldToTileXY: i(1341), WorldToTileY: i(64),\n    };\n  }, function (t, e, i) { const r = i(101); t.exports = function (t, e, i, n) { if (void 0 === i && (i = !1), r(t, e, n)) { const s = n.data[e][t] || null; return s !== null && (s.index !== -1 || i) ? s : null; } return null; }; }, function (t, e) { t.exports = function (t, e, i) { let n = i.baseTileWidth; const s = i.tilemapLayer; let r = 0; return s && (void 0 === e && (e = s.scene.cameras.main), r = s.x + e.scrollX * (1 - s.scrollFactorX), n *= s.scaleX), r + t * n; }; }, function (t, e) { t.exports = function (t, e, i) { let n = i.baseTileHeight; const s = i.tilemapLayer; let r = 0; return s && (void 0 === e && (e = s.scene.cameras.main), r = s.y + e.scrollY * (1 - s.scrollFactorY), n *= s.scaleY), r + t * n; }; }, function (t, e) { t.exports = function (o, a, t) { return o.hasOwnProperty(a) ? typeof o[a] === 'function' ? function (t, e, i, n, s, r) { return o[a](t, e, i, n, s, r); } : function () { return o[a]; } : typeof t === 'function' ? t : function () { return t; }; }; }, function (t, e, i) { const R = i(230); const L = i(15); const k = i(88); const D = i(69); const F = i(145); const I = i(498); const B = i(228); const N = i(6); const Y = i(229); const X = i(231); const U = i(233); t.exports = function (t, e, i) { void 0 === i && (i = R); for (var n = i.targets ? i.targets : B(e), s = I(e), r = F(e, 'delay', i.delay), o = F(e, 'duration', i.duration), a = N(e, 'easeParams', i.easeParams), h = D(N(e, 'ease', i.ease), a), l = F(e, 'hold', i.hold), u = F(e, 'repeat', i.repeat), c = F(e, 'repeatDelay', i.repeatDelay), d = k(e, 'yoyo', i.yoyo), f = k(e, 'flipX', i.flipX), p = k(e, 'flipY', i.flipY), g = [], v = 0; v < s.length; v++) for (let m = s[v].key, y = s[v].value, x = 0; x < n.length; x++) { const T = Y(m, y); const w = U(n[x], x, m, T.getEnd, T.getStart, T.getActive, D(N(y, 'ease', h), a), F(y, 'delay', r), F(y, 'duration', o), k(y, 'yoyo', d), F(y, 'hold', l), F(y, 'repeat', u), F(y, 'repeatDelay', c), k(y, 'flipX', f), k(y, 'flipY', p)); g.push(w); } const b = new X(t, g, n); b.offset = L(e, 'offset', null), b.completeDelay = L(e, 'completeDelay', 0), b.loop = Math.round(L(e, 'loop', 0)), b.loopDelay = Math.round(L(e, 'loopDelay', 0)), b.paused = k(e, 'paused', !1), b.useFrames = k(e, 'useFrames', !1); for (let E = N(e, 'callbackScope', b), S = [b, null], _ = X.TYPES, A = 0; A < _.length; A++) { var C; var M; const P = _[A]; const O = N(e, P, !1); O && (C = N(e, `${P}Scope`, E), M = N(e, `${P}Params`, []), b.setCallback(P, O, S.concat(M), C)); } return b; }; }, function (t, e, i) {\n    const n = i(0); const r = i(9); const s = new n({\n      initialize(t) { this.name = 'WebGLPipeline', this.game = t.game, this.view = t.game.canvas, this.resolution = 1, this.width = 0, this.height = 0, this.gl = t.gl, this.vertexCount = 0, this.vertexCapacity = t.vertexCapacity, this.renderer = t.renderer, this.vertexData = t.vertices ? t.vertices : new ArrayBuffer(t.vertexCapacity * t.vertexSize), this.vertexBuffer = this.renderer.createVertexBuffer(t.vertices ? t.vertices : this.vertexData.byteLength, this.gl.STREAM_DRAW), this.program = this.renderer.createProgram(t.vertShader, t.fragShader), this.attributes = t.attributes, this.vertexSize = t.vertexSize, this.topology = t.topology, this.bytes = new Uint8Array(this.vertexData), this.vertexComponentCount = r.getComponentCount(t.attributes, this.gl), this.flushLocked = !1, this.active = !1; },\n      boot() {},\n      addAttribute(t, e, i, n, s) {\n        return this.attributes.push({\n          name: t, size: e, type: this.renderer.glFormats[i], normalized: n, offset: s,\n        }), this.vertexComponentCount = r.getComponentCount(this.attributes, this.gl), this;\n      },\n      shouldFlush() { return this.vertexCount >= this.vertexCapacity; },\n      resize(t, e, i) { return this.width = t * i, this.height = e * i, this.resolution = i, this; },\n      bind() { const t = this.gl; const e = this.vertexBuffer; const i = this.attributes; const n = this.program; const s = this.renderer; const r = this.vertexSize; s.setProgram(n), s.setVertexBuffer(e); for (let o = 0; o < i.length; ++o) { const a = i[o]; const h = t.getAttribLocation(n, a.name); h >= 0 ? (t.enableVertexAttribArray(h), t.vertexAttribPointer(h, a.size, a.type, a.normalized, r, a.offset)) : h !== -1 && t.disableVertexAttribArray(h); } return this; },\n      onBind() { return this; },\n      onPreRender() { return this; },\n      onRender() { return this; },\n      onPostRender() { return this; },\n      flush() { if (this.flushLocked) return this; this.flushLocked = !0; const t = this.gl; const e = this.vertexCount; const i = this.topology; const n = this.vertexSize; if (e !== 0) return t.bufferSubData(t.ARRAY_BUFFER, 0, this.bytes.subarray(0, e * n)), t.drawArrays(i, 0, e), this.vertexCount = 0, this.flushLocked = !1, this; this.flushLocked = !1; },\n      destroy() { const t = this.gl; return t.deleteProgram(this.program), t.deleteBuffer(this.vertexBuffer), delete this.program, delete this.vertexBuffer, delete this.gl, this; },\n      setFloat1(t, e) { return this.renderer.setFloat1(this.program, t, e), this; },\n      setFloat2(t, e, i) { return this.renderer.setFloat2(this.program, t, e, i), this; },\n      setFloat3(t, e, i, n) { return this.renderer.setFloat3(this.program, t, e, i, n), this; },\n      setFloat4(t, e, i, n, s) { return this.renderer.setFloat4(this.program, t, e, i, n, s), this; },\n      setFloat1v(t, e) { return this.renderer.setFloat1v(this.program, t, e), this; },\n      setFloat2v(t, e) { return this.renderer.setFloat2v(this.program, t, e), this; },\n      setFloat3v(t, e) { return this.renderer.setFloat3v(this.program, t, e), this; },\n      setFloat4v(t, e) { return this.renderer.setFloat4v(this.program, t, e), this; },\n      setInt1(t, e) { return this.renderer.setInt1(this.program, t, e), this; },\n      setInt2(t, e, i) { return this.renderer.setInt2(this.program, t, e, i), this; },\n      setInt3(t, e, i, n) { return this.renderer.setInt3(this.program, t, e, i, n), this; },\n      setInt4(t, e, i, n, s) { return this.renderer.setInt4(this.program, t, e, i, n, s), this; },\n      setMatrix2(t, e, i) { return this.renderer.setMatrix2(this.program, t, e, i), this; },\n      setMatrix3(t, e, i) { return this.renderer.setMatrix3(this.program, t, e, i), this; },\n      setMatrix4(t, e, i) { return this.renderer.setMatrix4(this.program, t, e, i), this; },\n    }); t.exports = s;\n  }, function (t, e, i) {\n    const c = {}; t.exports = c; const o = i(240); const r = i(42); const a = i(100); const d = i(62); c.create = function (t) {\n      return r.extend({\n        id: r.nextId(), type: 'composite', parent: null, isModified: !1, bodies: [], constraints: [], composites: [], label: 'Composite', plugin: {},\n      }, t);\n    }, c.setModified = function (t, e, i, n) { if (o.trigger(t, 'compositeModified', t), t.isModified = e, i && t.parent && c.setModified(t.parent, e, i, n), n) for (let s = 0; s < t.composites.length; s++) { const r = t.composites[s]; c.setModified(r, e, i, n); } }, c.add = function (t, e) { const i = [].concat(e); o.trigger(t, 'beforeAdd', { object: e }); for (let n = 0; n < i.length; n++) { const s = i[n]; switch (s.type) { case 'body': if (s.parent !== s) { r.warn('Composite.add: skipped adding a compound body part (you must add its parent instead)'); break; }c.addBody(t, s); break; case 'constraint': c.addConstraint(t, s); break; case 'composite': c.addComposite(t, s); break; case 'mouseConstraint': c.addConstraint(t, s.constraint); } } return o.trigger(t, 'afterAdd', { object: e }), t; }, c.remove = function (t, e, i) { const n = [].concat(e); o.trigger(t, 'beforeRemove', { object: e }); for (let s = 0; s < n.length; s++) { const r = n[s]; switch (r.type) { case 'body': c.removeBody(t, r, i); break; case 'constraint': c.removeConstraint(t, r, i); break; case 'composite': c.removeComposite(t, r, i); break; case 'mouseConstraint': c.removeConstraint(t, r.constraint); } } return o.trigger(t, 'afterRemove', { object: e }), t; }, c.addComposite = function (t, e) { return t.composites.push(e), e.parent = t, c.setModified(t, !0, !0, !1), t; }, c.removeComposite = function (t, e, i) { const n = t.composites.indexOf(e); if (n !== -1 && (c.removeCompositeAt(t, n), c.setModified(t, !0, !0, !1)), i) for (let s = 0; s < t.composites.length; s++)c.removeComposite(t.composites[s], e, !0); return t; }, c.removeCompositeAt = function (t, e) { return t.composites.splice(e, 1), c.setModified(t, !0, !0, !1), t; }, c.addBody = function (t, e) { return t.bodies.push(e), c.setModified(t, !0, !0, !1), t; }, c.removeBody = function (t, e, i) { const n = t.bodies.indexOf(e); if (n !== -1 && (c.removeBodyAt(t, n), c.setModified(t, !0, !0, !1)), i) for (let s = 0; s < t.composites.length; s++)c.removeBody(t.composites[s], e, !0); return t; }, c.removeBodyAt = function (t, e) { return t.bodies.splice(e, 1), c.setModified(t, !0, !0, !1), t; }, c.addConstraint = function (t, e) { return t.constraints.push(e), c.setModified(t, !0, !0, !1), t; }, c.removeConstraint = function (t, e, i) { const n = t.constraints.indexOf(e); if (n !== -1 && c.removeConstraintAt(t, n), i) for (let s = 0; s < t.composites.length; s++)c.removeConstraint(t.composites[s], e, !0); return t; }, c.removeConstraintAt = function (t, e) { return t.constraints.splice(e, 1), c.setModified(t, !0, !0, !1), t; }, c.clear = function (t, e, i) { if (i) for (let n = 0; n < t.composites.length; n++)c.clear(t.composites[n], e, !0); return e ? t.bodies = t.bodies.filter((t) => t.isStatic) : t.bodies.length = 0, t.constraints.length = 0, t.composites.length = 0, c.setModified(t, !0, !0, !1), t; }, c.allBodies = function (t) { for (var e = [].concat(t.bodies), i = 0; i < t.composites.length; i++)e = e.concat(c.allBodies(t.composites[i])); return e; }, c.allConstraints = function (t) { for (var e = [].concat(t.constraints), i = 0; i < t.composites.length; i++)e = e.concat(c.allConstraints(t.composites[i])); return e; }, c.allComposites = function (t) { for (var e = [].concat(t.composites), i = 0; i < t.composites.length; i++)e = e.concat(c.allComposites(t.composites[i])); return e; }, c.get = function (t, e, i) { let n; let s; switch (i) { case 'body': n = c.allBodies(t); break; case 'constraint': n = c.allConstraints(t); break; case 'composite': n = c.allComposites(t).concat(t); } return !n || (s = n.filter((t) => t.id.toString() === e.toString())).length === 0 ? null : s[0]; }, c.move = function (t, e, i) { return c.remove(t, e), c.add(i, e), t; }, c.rebase = function (t) { for (let e = c.allBodies(t).concat(c.allConstraints(t)).concat(c.allComposites(t)), i = 0; i < e.length; i++)e[i].id = r.nextId(); return c.setModified(t, !0, !0, !1), t; }, c.translate = function (t, e, i) { for (let n = i ? c.allBodies(t) : t.bodies, s = 0; s < n.length; s++)d.translate(n[s], e); return c.setModified(t, !0, !0, !1), t; }, c.rotate = function (t, e, i, n) { for (let s = Math.cos(e), r = Math.sin(e), o = n ? c.allBodies(t) : t.bodies, a = 0; a < o.length; a++) { const h = o[a]; const l = h.position.x - i.x; const u = h.position.y - i.y; d.setPosition(h, { x: i.x + (l * s - u * r), y: i.y + (l * r + u * s) }), d.rotate(h, e); } return c.setModified(t, !0, !0, !1), t; }, c.scale = function (t, e, i, n, s) { for (let r = s ? c.allBodies(t) : t.bodies, o = 0; o < r.length; o++) { const a = r[o]; const h = a.position.x - n.x; const l = a.position.y - n.y; d.setPosition(a, { x: n.x + h * e, y: n.y + l * i }), d.scale(a, e, i); } return c.setModified(t, !0, !0, !1), t; }, c.bounds = function (t) { for (var e = c.allBodies(t), i = [], n = 0; n < e.length; n += 1) { const s = e[n]; i.push(s.bounds.min, s.bounds.max); } return a.create(i); };\n  }, function (t, e, i) { const n = i(4); t.exports = function (t, e, i) { return void 0 === i && (i = new n()), i.x = t.x + t.radius * Math.cos(e), i.y = t.y + t.radius * Math.sin(e), i; }; }, function (t, e, i) { const a = i(4); t.exports = function (t, e) { void 0 === e && (e = new a()); const i = 2 * Math.PI * Math.random(); const n = Math.random() + Math.random(); const s = n > 1 ? 2 - n : n; const r = s * Math.cos(i); const o = s * Math.sin(i); return e.x = t.x + r * t.radius, e.y = t.y + o * t.radius, e; }; }, function (t, e, i) {\n    const n = i(19); const s = i(0); const r = i(10); const o = i(111); const a = i(270); const g = i(271); const v = i(6); const h = new s({\n      Extends: r,\n      initialize(t, e, i) { r.call(this), this.manager = t, this.key = e, this.type = 'frame', this.frames = this.getFrames(t.textureManager, v(i, 'frames', []), v(i, 'defaultTextureKey', null)), this.frameRate = v(i, 'frameRate', null), this.duration = v(i, 'duration', null), this.duration === null && this.frameRate === null ? (this.frameRate = 24, this.duration = this.frameRate / this.frames.length * 1e3) : this.duration && this.frameRate === null ? this.frameRate = this.frames.length / (this.duration / 1e3) : this.duration = this.frames.length / this.frameRate * 1e3, this.msPerFrame = 1e3 / this.frameRate, this.skipMissedFrames = v(i, 'skipMissedFrames', !0), this.delay = v(i, 'delay', 0), this.repeat = v(i, 'repeat', 0), this.repeatDelay = v(i, 'repeatDelay', 0), this.yoyo = v(i, 'yoyo', !1), this.showOnStart = v(i, 'showOnStart', !1), this.hideOnComplete = v(i, 'hideOnComplete', !1), this.paused = !1, this.manager.on(o.PAUSE_ALL, this.pause, this), this.manager.on(o.RESUME_ALL, this.resume, this); },\n      addFrame(t) { return this.addFrameAt(this.frames.length, t); },\n      addFrameAt(t, e) { let i; let n; const s = this.getFrames(this.manager.textureManager, e); return s.length > 0 && (t === 0 ? this.frames = s.concat(this.frames) : t === this.frames.length ? this.frames = this.frames.concat(s) : (i = this.frames.slice(0, t), n = this.frames.slice(t), this.frames = i.concat(s, n)), this.updateFrameSequence()), this; },\n      checkFrame(t) { return t >= 0 && t < this.frames.length; },\n      completeAnimation(t) { this.hideOnComplete && (t.parent.visible = !1), t.stop(); },\n      getFirstTick(t, e) { void 0 === e && (e = !0), t.accumulator = 0, t.nextTick = t.msPerFrame + t.currentFrame.duration, e && (t.nextTick += t._delay); },\n      getFrameAt(t) { return this.frames[t]; },\n      getFrames(t, i, e) { let n; let s; let r; const o = []; let a = 1; if (typeof i === 'string' && (s = i, r = t.get(s).getFrameNames(), i = [], r.forEach((t, e) => { i.push({ key: s, frame: e }); })), !Array.isArray(i) || i.length === 0) return o; for (p = 0; p < i.length; p++) { var h; var l; var u; const c = i[p]; const d = v(c, 'key', e); d && (h = v(c, 'frame', 0), l = t.getFrame(d, h), (u = new g(d, h, a, l)).duration = v(c, 'duration', 0), u.isFirst = !n, n && ((n.nextFrame = u).prevFrame = n), o.push(u), n = u, a++); } if (o.length > 0) { u.isLast = !0, u.nextFrame = o[0], o[0].prevFrame = u; for (var f = 1 / (o.length - 1), p = 0; p < o.length; p++)o[p].progress = p * f; } return o; },\n      getNextTick(t) { t.accumulator -= t.nextTick, t.nextTick = t.msPerFrame + t.currentFrame.duration; },\n      load(t, e) { e >= this.frames.length && (e = 0), t.currentAnim !== this && (t.currentAnim = this, t.frameRate = this.frameRate, t.duration = this.duration, t.msPerFrame = this.msPerFrame, t.skipMissedFrames = this.skipMissedFrames, t._delay = this.delay, t._repeat = this.repeat, t._repeatDelay = this.repeatDelay, t._yoyo = this.yoyo); let i = this.frames[e]; e !== 0 || t.forward || (i = this.getLastFrame()), t.updateFrame(i); },\n      getFrameByProgress(t) { return t = n(t, 0, 1), a(t, this.frames, 'progress'); },\n      nextFrame(t) { const e = t.currentFrame; e.isLast ? t._yoyo ? this.handleYoyoFrame(t, !1) : t.repeatCounter > 0 ? t._reverse && t.forward ? t.forward = !1 : this.repeatAnimation(t) : this.completeAnimation(t) : this.updateAndGetNextTick(t, e.nextFrame); },\n      handleYoyoFrame(t, e) { if (e = e || !1, t._reverse === !e && t.repeatCounter > 0) return t._repeatDelay && !t.pendingRepeat || (t.forward = e), void this.repeatAnimation(t); let i; t._reverse === e || t.repeatCounter !== 0 ? (i = (t.forward = e) ? t.currentFrame.nextFrame : t.currentFrame.prevFrame, this.updateAndGetNextTick(t, i)) : this.completeAnimation(t); },\n      getLastFrame() { return this.frames[this.frames.length - 1]; },\n      previousFrame(t) { const e = t.currentFrame; e.isFirst ? t._yoyo ? this.handleYoyoFrame(t, !0) : t.repeatCounter > 0 ? (t._reverse && !t.forward ? t.currentFrame = this.getLastFrame() : t.forward = !0, this.repeatAnimation(t)) : this.completeAnimation(t) : this.updateAndGetNextTick(t, e.prevFrame); },\n      updateAndGetNextTick(t, e) { t.updateFrame(e), this.getNextTick(t); },\n      removeFrame(t) { const e = this.frames.indexOf(t); return e !== -1 && this.removeFrameAt(e), this; },\n      removeFrameAt(t) { return this.frames.splice(t, 1), this.updateFrameSequence(), this; },\n      repeatAnimation(t) { if (t._pendingStop === 2) return this.completeAnimation(t); let e; let i; t._repeatDelay > 0 && !1 === t.pendingRepeat ? (t.pendingRepeat = !0, t.accumulator -= t.nextTick, t.nextTick += t._repeatDelay) : (t.repeatCounter--, t.updateFrame(t.currentFrame[t.forward ? 'nextFrame' : 'prevFrame']), t.isPlaying && (this.getNextTick(t), t.pendingRepeat = !1, e = t.currentFrame, i = t.parent, this.emit(o.ANIMATION_REPEAT, this, e), i.emit(o.SPRITE_ANIMATION_KEY_REPEAT + this.key, this, e, t.repeatCounter, i), i.emit(o.SPRITE_ANIMATION_REPEAT, this, e, t.repeatCounter, i))); },\n      setFrame(t) { t.forward ? this.nextFrame(t) : this.previousFrame(t); },\n      toJSON() {\n        const e = {\n          key: this.key, type: this.type, frames: [], frameRate: this.frameRate, duration: this.duration, skipMissedFrames: this.skipMissedFrames, delay: this.delay, repeat: this.repeat, repeatDelay: this.repeatDelay, yoyo: this.yoyo, showOnStart: this.showOnStart, hideOnComplete: this.hideOnComplete,\n        }; return this.frames.forEach((t) => { e.frames.push(t.toJSON()); }), e;\n      },\n      updateFrameSequence() { for (var t, e = this.frames.length, i = 1 / (e - 1), n = 0; n < e; n++)(t = this.frames[n]).index = n + 1, t.isFirst = !1, t.isLast = !1, t.progress = n * i, n === 0 ? (t.isFirst = !0, e === 1 ? (t.isLast = !0, (t.nextFrame = t).prevFrame = t) : (t.isLast = !1, t.prevFrame = this.frames[e - 1], t.nextFrame = this.frames[n + 1])) : n === e - 1 && e > 1 ? (t.isLast = !0, t.prevFrame = this.frames[e - 2], t.nextFrame = this.frames[0]) : e > 1 && (t.prevFrame = this.frames[n - 1], t.nextFrame = this.frames[n + 1]); return this; },\n      pause() { return this.paused = !0, this; },\n      resume() { return this.paused = !1, this; },\n      destroy() { this.removeAllListeners(), this.manager.off(o.PAUSE_ALL, this.pause, this), this.manager.off(o.RESUME_ALL, this.resume, this), this.manager.remove(this.key); for (let t = 0; t < this.frames.length; t++) this.frames[t].destroy(); this.frames = [], this.manager = null; },\n    }); t.exports = h;\n  }, function (t, e, i) { const s = i(112); const r = i(4); t.exports = function (t, e, i) { if (void 0 === i && (i = new r()), e <= 0 || e >= 1) return i.x = t.x, i.y = t.y, i; let n = s(t) * e; return e > 0.5 ? (n -= t.width + t.height) <= t.width ? (i.x = t.right - n, i.y = t.bottom) : (i.x = t.x, i.y = t.bottom - (n - t.width)) : n <= t.width ? (i.x = t.x + n, i.y = t.y) : (i.x = t.right, i.y = t.y + (n - t.width)), i; }; }, function (t, e, i) { const d = i(57); const f = i(4); t.exports = function (t, e, i, n) { void 0 === n && (n = []), !e && i > 0 && (e = d(t) / i); for (let s = t.x1, r = t.y1, o = t.x2, a = t.y2, h = 0; h < e; h++) { const l = h / e; const u = s + (o - s) * l; const c = r + (a - r) * l; n.push(new f(u, c)); } return n; }; }, function (t, e, i) { const n = i(4); t.exports = function (t, e) { void 0 === e && (e = new n()); const i = Math.random(); return e.x = t.x1 + i * (t.x2 - t.x1), e.y = t.y1 + i * (t.y2 - t.y1), e; }; }, function (t, e, i) { const n = i(4); t.exports = function (t, e) { return void 0 === e && (e = new n()), e.x = t.x + Math.random() * t.width, e.y = t.y + Math.random() * t.height, e; }; }, function (t, e) {\n    const i = {\n      defaultPipeline: null, pipeline: null, initPipeline(t) { void 0 === t && (t = 'TextureTintPipeline'); const e = this.scene.sys.game.renderer; return !!(e && e.gl && e.hasPipeline(t)) && (this.defaultPipeline = e.getPipeline(t), this.pipeline = this.defaultPipeline, !0); }, setPipeline(t) { const e = this.scene.sys.game.renderer; return e && e.gl && e.hasPipeline(t) && (this.pipeline = e.getPipeline(t)), this; }, resetPipeline() { return this.pipeline = this.defaultPipeline, this.pipeline !== null; }, getPipelineName() { return this.pipeline.name; },\n    }; t.exports = i;\n  }, function (t, e, i) { const s = i(4); t.exports = function (t, e) { void 0 === e && (e = new s()); const i = Math.random() * Math.PI * 2; const n = Math.sqrt(Math.random()); return e.x = t.x + n * Math.cos(i) * t.width / 2, e.y = t.y + n * Math.sin(i) * t.height / 2, e; }; }, function (t, e, i) { const h = i(4); t.exports = function (t, e) { void 0 === e && (e = new h()); const i = t.x2 - t.x1; const n = t.y2 - t.y1; const s = t.x3 - t.x1; const r = t.y3 - t.y1; let o = Math.random(); let a = Math.random(); return o + a >= 1 && (o = 1 - o, a = 1 - a), e.x = t.x1 + (i * o + s * a), e.y = t.y1 + (n * o + r * a), e; }; }, function (t, e) { t.exports = function (t, e, i, n, s) { const r = n + Math.atan2(t.y - i, t.x - e); return t.x = e + s * Math.cos(r), t.y = i + s * Math.sin(r), t; }; }, function (t, e) { t.exports = function (t, e, i) { return (t = Math.max(0, Math.min(1, (t - e) / (i - e)))) * t * t * (t * (6 * t - 15) + 10); }; }, function (t, e) { t.exports = function (t, e, i) { return t <= e ? 0 : i <= t ? 1 : (t = (t - e) / (i - e)) * t * (3 - 2 * t); }; }, function (t, e, i) {\n    const n = new (i(0))({\n      initialize(t) { if (this.entries = {}, this.size = 0, Array.isArray(t)) for (let e = 0; e < t.length; e++) this.set(t[e][0], t[e][1]); }, set(t, e) { return this.has(t) || this.size++, this.entries[t] = e, this; }, get(t) { if (this.has(t)) return this.entries[t]; }, getArray() { const t = []; const e = this.entries; for (const i in e)t.push(e[i]); return t; }, has(t) { return this.entries.hasOwnProperty(t); }, delete(t) { return this.has(t) && (delete this.entries[t], this.size--), this; }, clear() { return Object.keys(this.entries).forEach(function (t) { delete this.entries[t]; }, this), this.size = 0, this; }, keys() { return Object.keys(this.entries); }, values() { const t = []; const e = this.entries; for (const i in e)t.push(e[i]); return t; }, dump() { const t = this.entries; for (const e in console.group('Map'), t)console.log(e, t[e]); console.groupEnd(); }, each(t) { const e = this.entries; for (const i in e) if (!1 === t(i, e[i])) break; return this; }, contains(t) { const e = this.entries; for (const i in e) if (e[i] === t) return !0; return !1; }, merge(t, e) { void 0 === e && (e = !1); const i = this.entries; const n = t.entries; for (const s in n)i.hasOwnProperty(s) && e ? i[s] = n[s] : this.set(s, n[s]); return this; },\n    }); t.exports = n;\n  }, function (t, e) { t.exports = function (t, e, i, n) { void 0 === e && (e = 0), void 0 === i && (i = ' '), void 0 === n && (n = 3); let s; if (e + 1 >= (t = t.toString()).length) switch (n) { case 1: t = new Array(e + 1 - t.length).join(i) + t; break; case 3: var r = Math.ceil((s = e - t.length) / 2); t = new Array(1 + (s - r)).join(i) + t + new Array(r + 1).join(i); break; default: t += new Array(e + 1 - t.length).join(i); } return t; }; }, function (t, e, i) { const n = i(294); const s = i(297); const r = i(299); const o = i(300); t.exports = function (t) { switch (typeof t) { case 'string': return (t.substr(0, 3).toLowerCase() === 'rgb' ? o : n)(t); case 'number': return s(t); case 'object': return r(t); } }; }, function (t, e) { t.exports = function (t, e, i) { return t << 16 | e << 8 | i; }; }, function (t, e, i) {\n    const f = i(165); t.exports = function (t, e, i, n) {\n      void 0 === e && (e = 1), void 0 === i && (i = 1); const s = Math.floor(6 * t); const r = 6 * t - s; const o = Math.floor(i * (1 - e) * 255); const a = Math.floor(i * (1 - r * e) * 255); const h = Math.floor(i * (1 - (1 - r) * e) * 255); let l = i = Math.floor(i *= 255); let u = i; let c = i; const d = s % 6; return d == 0 ? (u = h, c = o) : d == 1 ? (l = a, c = o) : d == 2 ? (l = o, c = h) : d == 3 ? (l = o, u = a) : d == 4 ? (l = h, u = o) : d == 5 && (u = o, c = a), n ? n.setTo ? n.setTo(l, u, c, n.alpha, !1) : (n.r = l, n.g = u, n.b = c, n.color = f(l, u, c), n) : {\n        r: l, g: u, b: c, color: f(l, u, c),\n      };\n    };\n  }, function (t, e) {\n    let i = ''; function n(t) { for (let e = ['i', 'webkitI', 'msI', 'mozI', 'oI'], i = 0; i < e.length; i++) { const n = `${e[i]}mageSmoothingEnabled`; if (n in t) return n; } return null; }t.exports = {\n      disable(t) { return i === '' && (i = n(t)), i && (t[i] = !1), t; }, enable(t) { return i === '' && (i = n(t)), i && (t[i] = !0), t; }, getPrefix: n, isEnabled(t) { return i !== null ? t[i] : null; },\n    };\n  }, function (t, e) { t.exports = function (t, e, i) { return t.x = e - t.width / 2, t.y = i - t.height / 2, t; }; }, function (t, e, i) {\n    const n = i(117); const r = i(118); const o = i(26); const a = {\n      canvas: !1, canvasBitBltShift: null, file: !1, fileSystem: !1, getUserMedia: !0, littleEndian: !1, localStorage: !1, pointerLock: !1, support32bit: !1, vibration: !1, webGL: !1, worker: !1,\n    }; t.exports = (function () { a.canvas = !!window.CanvasRenderingContext2D; try { a.localStorage = !!localStorage.getItem; } catch (t) { a.localStorage = !1; }a.file = !!(window.File && window.FileReader && window.FileList && window.Blob), a.fileSystem = !!window.requestFileSystem; let t; let e; let i; let s = !1; return a.webGL = (function () { if (window.WebGLRenderingContext) try { const t = o.createWebGL(this); const e = t.getContext('webgl') || t.getContext('experimental-webgl'); const i = o.create2D(this); const n = i.getContext('2d').createImageData(1, 1); return s = n.data instanceof Uint8ClampedArray, o.remove(t), o.remove(i), !!e; } catch (t) { return !1; } return !1; }()), a.worker = !!window.Worker, a.pointerLock = 'pointerLockElement' in document || 'mozPointerLockElement' in document || 'webkitPointerLockElement' in document, navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia || navigator.oGetUserMedia, window.URL = window.URL || window.webkitURL || window.mozURL || window.msURL, a.getUserMedia = a.getUserMedia && !!navigator.getUserMedia && !!window.URL, r.firefox && r.firefoxVersion < 21 && (a.getUserMedia = !1), !n.iOS && (r.ie || r.firefox || r.chrome) && (a.canvasBitBltShift = !0), (r.safari || r.mobileSafari) && (a.canvasBitBltShift = !1), navigator.vibrate = navigator.vibrate || navigator.webkitVibrate || navigator.mozVibrate || navigator.msVibrate, navigator.vibrate && (a.vibration = !0), typeof ArrayBuffer !== 'undefined' && typeof Uint8Array !== 'undefined' && typeof Uint32Array !== 'undefined' && (a.littleEndian = (t = new ArrayBuffer(4), e = new Uint8Array(t), i = new Uint32Array(t), e[0] = 161, e[1] = 178, e[2] = 195, e[3] = 212, i[0] === 3569595041 || i[0] !== 2712847316 && null)), a.support32bit = typeof ArrayBuffer !== 'undefined' && typeof Uint8ClampedArray !== 'undefined' && typeof Int32Array !== 'undefined' && a.littleEndian !== null && s, a; }());\n  }, function (t, e, i) {\n    const n = i(13); var s = i(18)(!1, s = {\n      Angle: i(734), Distance: i(743), Easing: i(748), Fuzzy: i(749), Interpolation: i(752), Pow2: i(757), Snap: i(759), RandomDataGenerator: i(761), Average: i(762), Bernstein: i(324), Between: i(172), CatmullRom: i(171), CeilTo: i(763), Clamp: i(19), DegToRad: i(39), Difference: i(764), Factorial: i(325), FloatBetween: i(119), FloorTo: i(765), FromPercent: i(87), GetSpeed: i(766), IsEven: i(767), IsEvenStrict: i(768), Linear: i(116), MaxAdd: i(769), MinSub: i(770), Percent: i(771), RadToDeg: i(173), RandomXY: i(772), RandomXYZ: i(773), RandomXYZW: i(774), Rotate: i(331), RotateAround: i(276), RotateAroundDistance: i(159), RotateTo: i(775), RoundAwayFromZero: i(332), RoundTo: i(776), SinCosTableGenerator: i(777), SmootherStep: i(160), SmoothStep: i(161), ToXY: i(778), TransformXY: i(333), Within: i(779), Wrap: i(58), Vector2: i(3), Vector3: i(174), Vector4: i(334), Matrix3: i(335), Matrix4: i(336), Quaternion: i(337), RotateVec3: i(780),\n    }, n); t.exports = s;\n  }, function (t, e) { t.exports = function (t, e, i, n, s) { const r = 0.5 * (n - e); const o = 0.5 * (s - i); const a = t * t; return (2 * i - 2 * n + r + o) * (t * a) + (-3 * i + 3 * n - 2 * r - o) * a + r * t + i; }; }, function (t, e) { t.exports = function (t, e) { return Math.floor(Math.random() * (e - t + 1) + t); }; }, function (t, e, i) { const n = i(13); t.exports = function (t) { return t * n.RAD_TO_DEG; }; }, function (t, e, i) {\n    var n = new (i(0))({\n      initialize(t, e, i) { this.x = 0, this.y = 0, this.z = 0, typeof t === 'object' ? (this.x = t.x || 0, this.y = t.y || 0, this.z = t.z || 0) : (this.x = t || 0, this.y = e || 0, this.z = i || 0); }, up() { return this.x = 0, this.y = 1, this.z = 0, this; }, clone() { return new n(this.x, this.y, this.z); }, crossVectors(t, e) { const i = t.x; const n = t.y; const s = t.z; const r = e.x; const o = e.y; const a = e.z; return this.x = n * a - s * o, this.y = s * r - i * a, this.z = i * o - n * r, this; }, equals(t) { return this.x === t.x && this.y === t.y && this.z === t.z; }, copy(t) { return this.x = t.x, this.y = t.y, this.z = t.z || 0, this; }, set(t, e, i) { return typeof t === 'object' ? (this.x = t.x || 0, this.y = t.y || 0, this.z = t.z || 0) : (this.x = t || 0, this.y = e || 0, this.z = i || 0), this; }, add(t) { return this.x += t.x, this.y += t.y, this.z += t.z || 0, this; }, subtract(t) { return this.x -= t.x, this.y -= t.y, this.z -= t.z || 0, this; }, multiply(t) { return this.x *= t.x, this.y *= t.y, this.z *= t.z || 1, this; }, scale(t) { return isFinite(t) ? (this.x *= t, this.y *= t, this.z *= t) : (this.x = 0, this.y = 0, this.z = 0), this; }, divide(t) { return this.x /= t.x, this.y /= t.y, this.z /= t.z || 1, this; }, negate() { return this.x = -this.x, this.y = -this.y, this.z = -this.z, this; }, distance(t) { const e = t.x - this.x; const i = t.y - this.y; const n = t.z - this.z || 0; return Math.sqrt(e * e + i * i + n * n); }, distanceSq(t) { const e = t.x - this.x; const i = t.y - this.y; const n = t.z - this.z || 0; return e * e + i * i + n * n; }, length() { const t = this.x; const e = this.y; const i = this.z; return Math.sqrt(t * t + e * e + i * i); }, lengthSq() { const t = this.x; const e = this.y; const i = this.z; return t * t + e * e + i * i; }, normalize() { const t = this.x; const e = this.y; const i = this.z; let n = t * t + e * e + i * i; return n > 0 && (n = 1 / Math.sqrt(n), this.x = t * n, this.y = e * n, this.z = i * n), this; }, dot(t) { return this.x * t.x + this.y * t.y + this.z * t.z; }, cross(t) { const e = this.x; const i = this.y; const n = this.z; const s = t.x; const r = t.y; const o = t.z; return this.x = i * o - n * r, this.y = n * s - e * o, this.z = e * r - i * s, this; }, lerp(t, e) { void 0 === e && (e = 0); const i = this.x; const n = this.y; const s = this.z; return this.x = i + e * (t.x - i), this.y = n + e * (t.y - n), this.z = s + e * (t.z - s), this; }, transformMat3(t) { const e = this.x; const i = this.y; const n = this.z; const s = t.val; return this.x = e * s[0] + i * s[3] + n * s[6], this.y = e * s[1] + i * s[4] + n * s[7], this.z = e * s[2] + i * s[5] + n * s[8], this; }, transformMat4(t) { const e = this.x; const i = this.y; const n = this.z; const s = t.val; return this.x = s[0] * e + s[4] * i + s[8] * n + s[12], this.y = s[1] * e + s[5] * i + s[9] * n + s[13], this.z = s[2] * e + s[6] * i + s[10] * n + s[14], this; }, transformCoordinates(t) { const e = this.x; const i = this.y; const n = this.z; const s = t.val; const r = e * s[0] + i * s[4] + n * s[8] + s[12]; const o = e * s[1] + i * s[5] + n * s[9] + s[13]; const a = e * s[2] + i * s[6] + n * s[10] + s[14]; const h = e * s[3] + i * s[7] + n * s[11] + s[15]; return this.x = r / h, this.y = o / h, this.z = a / h, this; }, transformQuat(t) { const e = this.x; const i = this.y; const n = this.z; const s = t.x; const r = t.y; const o = t.z; const a = t.w; const h = a * e + r * n - o * i; const l = a * i + o * e - s * n; const u = a * n + s * i - r * e; const c = -s * e - r * i - o * n; return this.x = h * a + c * -s + l * -o - u * -r, this.y = l * a + c * -r + u * -s - h * -o, this.z = u * a + c * -o + h * -r - l * -s, this; }, project(t) { const e = this.x; const i = this.y; const n = this.z; const s = t.val; const r = s[0]; const o = s[1]; const a = s[2]; const h = s[3]; const l = s[4]; const u = s[5]; const c = s[6]; const d = s[7]; const f = s[8]; const p = s[9]; const g = s[10]; const v = s[11]; const m = s[12]; const y = s[13]; const x = s[14]; const T = 1 / (e * h + i * d + n * v + s[15]); return this.x = (e * r + i * l + n * f + m) * T, this.y = (e * o + i * u + n * p + y) * T, this.z = (e * a + i * c + n * g + x) * T, this; }, unproject(t, e) { const i = t.x; const n = t.y; const s = t.z; const r = t.w; const o = this.x - i; const a = r - this.y - 1 - n; const h = this.z; return this.x = 2 * o / s - 1, this.y = 2 * a / r - 1, this.z = 2 * h - 1, this.project(e); }, reset() { return this.x = 0, this.y = 0, this.z = 0, this; },\n    }); n.ZERO = new n(), n.RIGHT = new n(1, 0, 0), n.LEFT = new n(-1, 0, 0), n.UP = new n(0, -1, 0), n.DOWN = new n(0, 1, 0), n.FORWARD = new n(0, 0, 1), n.BACK = new n(0, 0, -1), n.ONE = new n(1, 1, 1), t.exports = n;\n  }, function (t, e, i) { t.exports = { Global: ['game', 'anims', 'cache', 'plugins', 'registry', 'scale', 'sound', 'textures'], CoreScene: ['EventEmitter', 'CameraManager', 'GameObjectCreator', 'GameObjectFactory', 'ScenePlugin', 'DisplayList', 'UpdateList'], DefaultScene: ['Clock', 'DataManagerPlugin', 'InputPlugin', 'Loader', 'TweenManager', 'LightsPlugin'] }; }, function (t, e, i) { const u = i(11); const c = i(13); t.exports = function (t, e) { if (void 0 === e && (e = new u()), t.length === 0) return e; for (var i, n, s, r = Number.MAX_VALUE, o = Number.MAX_VALUE, a = c.MIN_SAFE_INTEGER, h = c.MIN_SAFE_INTEGER, l = 0; l < t.length; l++)i = t[l], s = Array.isArray(i) ? (n = i[0], i[1]) : (n = i.x, i.y), r = Math.min(r, n), o = Math.min(o, s), a = Math.max(a, n), h = Math.max(h, s); return e.x = r, e.y = o, e.width = a - r, e.height = h - o, e; }; }, function (t, e, i) {\n    const n = {\n      CENTER: i(359), ORIENTATION: i(360), SCALE_MODE: i(361), ZOOM: i(362),\n    }; t.exports = n;\n  }, function (t, e) { t.exports = function (t) { t.parentNode && t.parentNode.removeChild(t); }; }, function (t, e) {\n    t.exports = {\n      MOUSE_DOWN: 0, MOUSE_MOVE: 1, MOUSE_UP: 2, TOUCH_START: 3, TOUCH_MOVE: 4, TOUCH_END: 5, POINTER_LOCK_CHANGE: 6, TOUCH_CANCEL: 7, MOUSE_WHEEL: 8,\n    };\n  }, function (t, e, i) {\n    const n = i(0); const s = i(125); const r = i(175); const o = i(22); const a = i(880); const h = i(881); const l = i(1); const u = i(375); const c = new n({\n      initialize(t, e) { this.scene = t, this.game, this.renderer, this.config = e, this.settings = u.create(e), this.canvas, this.context, this.anims, this.cache, this.plugins, this.registry, this.scale, this.sound, this.textures, this.add, this.cameras, this.displayList, this.events, this.make, this.scenePlugin, this.updateList, this.sceneUpdate = l; }, init(t) { this.settings.status = s.INIT, this.sceneUpdate = l, this.game = t, this.renderer = t.renderer, this.canvas = t.canvas, this.context = t.context; const e = t.plugins; (this.plugins = e).addToScene(this, r.Global, [r.CoreScene, h(this), a(this)]), this.events.emit(o.BOOT, this), this.settings.isBooted = !0; }, install(t) { Array.isArray(t) || (t = [t]), this.plugins.installLocal(this, t); }, step(t, e) { this.events.emit(o.PRE_UPDATE, t, e), this.events.emit(o.UPDATE, t, e), this.sceneUpdate.call(this.scene, t, e), this.events.emit(o.POST_UPDATE, t, e); }, render(t) { const e = this.displayList; e.depthSort(), this.cameras.render(t, e), this.events.emit(o.RENDER, t); }, queueDepthSort() { this.displayList.queueDepthSort(); }, depthSort() { this.displayList.depthSort(); }, pause(t) { return this.settings.active && (this.settings.status = s.PAUSED, this.settings.active = !1, this.events.emit(o.PAUSE, this, t)), this; }, resume(t) { return this.settings.active || (this.settings.status = s.RUNNING, this.settings.active = !0, this.events.emit(o.RESUME, this, t)), this; }, sleep(t) { return this.settings.status = s.SLEEPING, this.settings.active = !1, this.settings.visible = !1, this.events.emit(o.SLEEP, this, t), this; }, wake(t) { const e = this.settings; return e.status = s.RUNNING, e.active = !0, e.visible = !0, this.events.emit(o.WAKE, this, t), e.isTransition && this.events.emit(o.TRANSITION_WAKE, e.transitionFrom, e.transitionDuration), this; }, getData() { return this.settings.data; }, isSleeping() { return this.settings.status === s.SLEEPING; }, isActive() { return this.settings.status === s.RUNNING; }, isPaused() { return this.settings.status === s.PAUSED; }, isTransitioning() { return this.settings.isTransition || this.scenePlugin._target !== null; }, isTransitionOut() { return this.scenePlugin._target !== null && this.scenePlugin._duration > 0; }, isTransitionIn() { return this.settings.isTransition; }, isVisible() { return this.settings.visible; }, setVisible(t) { return this.settings.visible = t, this; }, setActive(t, e) { return t ? this.resume(e) : this.pause(e); }, start(t) { t && (this.settings.data = t), this.settings.status = s.START, this.settings.active = !0, this.settings.visible = !0, this.events.emit(o.START, this), this.events.emit(o.READY, this, t); }, shutdown(t) { this.events.off(o.TRANSITION_INIT), this.events.off(o.TRANSITION_START), this.events.off(o.TRANSITION_COMPLETE), this.events.off(o.TRANSITION_OUT), this.settings.status = s.SHUTDOWN, this.settings.active = !1, this.settings.visible = !1, this.events.emit(o.SHUTDOWN, this, t); }, destroy() { this.settings.status = s.DESTROYED, this.settings.active = !1, this.settings.visible = !1, this.events.emit(o.DESTROY, this), this.events.removeAllListeners(); for (let t = ['scene', 'game', 'anims', 'cache', 'plugins', 'registry', 'sound', 'textures', 'add', 'camera', 'displayList', 'events', 'make', 'scenePlugin', 'updateList'], e = 0; e < t.length; e++) this[t[e]] = null; },\n    }); t.exports = c;\n  }, function (t, e) { t.exports = function (t) { return t && t[0].toUpperCase() + t.slice(1); }; }, function (t, e, i) {\n    const n = i(0); const a = i(94); const o = i(378); const s = 'Texture.frame missing: '; const r = new n({\n      initialize(t, e, i, n, s) { Array.isArray(i) || (i = [i]), this.manager = t, this.key = e, this.source = [], this.dataSource = [], this.frames = {}, this.customData = {}, this.firstFrame = '__BASE'; for (let r = this.frameTotal = 0; r < i.length; r++) this.source.push(new o(this, i[r], n, s)); }, add(t, e, i, n, s, r) { if (this.has(t)) return null; const o = new a(this, t, e, i, n, s, r); return this.frames[t] = o, this.firstFrame === '__BASE' && (this.firstFrame = t), this.frameTotal++, o; }, remove(t) { return !!this.has(t) && (this.get(t).destroy(), delete this.frames[t], !0); }, has(t) { return this.frames[t]; }, get(t) { t = t || this.firstFrame; let e = this.frames[t]; return e || (console.warn(s + t), e = this.frames[this.firstFrame]), e; }, getTextureSourceIndex(t) { for (let e = 0; e < this.source.length; e++) if (this.source[e] === t) return e; return -1; }, getFramesFromTextureSource(t, e) { void 0 === e && (e = !1); let i; const n = []; for (const s in this.frames) { s === '__BASE' && !e || (i = this.frames[s]).sourceIndex === t && n.push(i); } return n; }, getFrameNames(t) { void 0 === t && (t = !1); let e; const i = Object.keys(this.frames); return t || (e = i.indexOf('__BASE')) !== -1 && i.splice(e, 1), i; }, getSourceImage(t) { t != null && this.frameTotal !== 1 || (t = '__BASE'); const e = this.frames[t]; return e ? e.source.image : (console.warn(s + t), this.frames.__BASE.source.image); }, getDataSourceImage(t) { t != null && this.frameTotal !== 1 || (t = '__BASE'); const e = this.frames[t]; const i = e ? e.sourceIndex : (console.warn(s + t), this.frames.__BASE.sourceIndex); return this.dataSource[i].image; }, setDataSource(t) { Array.isArray(t) || (t = [t]); for (let e = 0; e < t.length; e++) { const i = this.source[e]; this.dataSource.push(new o(this, t[e], i.width, i.height)); } }, setFilter(t) { for (var e = 0; e < this.source.length; e++) this.source[e].setFilter(t); for (e = 0; e < this.dataSource.length; e++) this.dataSource[e].setFilter(t); }, destroy() { for (var t = 0; t < this.source.length; t++) this.source[t].destroy(); for (t = 0; t < this.dataSource.length; t++) this.dataSource[t].destroy(); for (const e in this.frames) { this.frames[e].destroy(); } this.source = [], this.dataSource = [], this.frames = {}, this.manager.removeKey(this.key), this.manager = null; },\n    }); t.exports = r;\n  }, function (t, e, i) {\n    t.exports = {\n      Matrix: i(916), Add: i(923), AddAt: i(924), BringToTop: i(925), CountAllMatching: i(926), Each: i(927), EachInRange: i(928), FindClosestInSorted: i(270), GetAll: i(382), GetFirst: i(383), GetRandom: i(185), MoveDown: i(929), MoveTo: i(930), MoveUp: i(931), NumberArray: i(932), NumberArrayStep: i(933), QuickSelect: i(391), Range: i(392), Remove: i(123), RemoveAt: i(934), RemoveBetween: i(935), RemoveRandomElement: i(936), Replace: i(937), RotateLeft: i(286), RotateRight: i(287), SafeRange: i(68), SendToBack: i(938), SetAll: i(939), Shuffle: i(114), SpliceOne: i(80), StableSort: i(131), Swap: i(940),\n    };\n  }, function (t, e) { t.exports = function (t) { if (!Array.isArray(t) || t.length < 2 || !Array.isArray(t[0])) return !1; for (let e = t[0].length, i = 1; i < t.length; i++) if (t[i].length !== e) return !1; return !0; }; }, function (t, e) { t.exports = function (t, e, i) { void 0 === e && (e = 0), void 0 === i && (i = t.length); const n = e + Math.floor(Math.random() * i); return void 0 === t[n] ? null : t[n]; }; }, function (t, e, i) {\n    const n = i(0); const s = i(10); const r = i(942); const o = new n({\n      Extends: s, initialize() { s.call(this), this._pending = [], this._active = [], this._destroy = [], this._toProcess = 0; }, add(t) { return this._pending.push(t), this._toProcess++, t; }, remove(t) { return this._destroy.push(t), this._toProcess++, t; }, removeAll() { for (let t = this._active, e = this._destroy, i = t.length; i--;)e.push(t[i]), this._toProcess++; return this; }, update() { if (this._toProcess === 0) return this._active; for (var t, e = this._destroy, i = this._active, n = 0; n < e.length; n++) { t = e[n]; const s = i.indexOf(t); s !== -1 && (i.splice(s, 1), this.emit(r.REMOVE, t)); } for (e.length = 0, e = this._pending, n = 0; n < e.length; n++)t = e[n], this._active.push(t), this.emit(r.ADD, t); return e.length = 0, this._toProcess = 0, this._active; }, getActive() { return this._active; }, length: { get() { return this._active.length; } }, destroy() { this._toProcess = 0, this._pending = [], this._active = [], this._destroy = []; },\n    }); t.exports = o;\n  }, function (t, e) {\n    function _(t, e) { return parseInt(t.getAttribute(e), 10); }t.exports = function (t, e, i, n) {\n      void 0 === e && (e = 0), void 0 === i && (i = 0); const s = {}; const r = t.getElementsByTagName('info')[0]; const o = t.getElementsByTagName('common')[0]; s.font = r.getAttribute('face'), s.size = _(r, 'size'), s.lineHeight = _(o, 'lineHeight') + i, s.chars = {}; let a; let h; const l = t.getElementsByTagName('char'); const u = void 0 !== n && n.trimmed; u && (a = n.height, h = n.width); for (var c = 0; c < l.length; c++) {\n        const d = l[c]; const f = _(d, 'id'); const p = _(d, 'x'); const g = _(d, 'y'); const v = _(d, 'width'); const m = _(d, 'height'); u && (p < h && (h = p), g < a && (a = g)), s.chars[f] = {\n          x: p, y: g, width: v, height: m, centerX: Math.floor(v / 2), centerY: Math.floor(m / 2), xOffset: _(d, 'xoffset'), yOffset: _(d, 'yoffset'), xAdvance: _(d, 'xadvance') + e, data: {}, kerning: {},\n        };\n      } if (u && a !== 0 && h !== 0) for (const y in s.chars) { const x = s.chars[y]; x.x -= n.x, x.y -= n.y; } for (var T = t.getElementsByTagName('kerning'), c = 0; c < T.length; c++) { const w = T[c]; const b = _(w, 'first'); const E = _(w, 'second'); const S = _(w, 'amount'); s.chars[E].kerning[b] = S; } return s;\n    };\n  }, function (t, e, i) {\n    const n = i(950); const o = i(953); const s = i(0); const r = i(12); const a = i(94); const h = i(14); const l = i(129); const u = new s({\n      Extends: h, Mixins: [r.Alpha, r.BlendMode, r.Depth, r.Mask, r.Pipeline, r.ScrollFactor, r.Size, r.Texture, r.Transform, r.Visible, n], initialize(t, e, i, n, s) { h.call(this, t, 'Blitter'), this.setTexture(n, s), this.setPosition(e, i), this.initPipeline(), this.children = new l(), this.renderList = [], this.dirty = !1; }, create(t, e, i, n, s) { void 0 === n && (n = !0), void 0 === s && (s = this.children.length), void 0 === i ? i = this.frame : i instanceof a || (i = this.texture.get(i)); const r = new o(this, t, e, i, n); return this.children.addAt(r, s, !1), this.dirty = !0, r; }, createFromCallback(t, e, i, n) { for (var s = this.createMultiple(e, i, n), r = 0; r < s.length; r++) { const o = s[r]; t.call(this, o, r); } return s; }, createMultiple(i, t, n) { void 0 === t && (t = this.frame.name), void 0 === n && (n = !0), Array.isArray(t) || (t = [t]); const s = []; const r = this; return t.forEach((t) => { for (let e = 0; e < i; e++)s.push(r.create(0, 0, t, n)); }), s; }, childCanRender(t) { return t.visible && t.alpha > 0; }, getRenderList() { return this.dirty && (this.renderList = this.children.list.filter(this.childCanRender, this), this.dirty = !1), this.renderList; }, clear() { this.children.removeAll(), this.dirty = !0; }, preDestroy() { this.children.destroy(), this.renderList = []; },\n    }); t.exports = u;\n  }, function (t, e, i) {\n    const r = i(183); const s = i(52); const n = i(0); const o = i(12); const a = i(90); const h = i(14); const l = i(11); const u = i(954); const c = i(394); const d = i(3); const f = new n({\n      Extends: h, Mixins: [o.AlphaSingle, o.BlendMode, o.ComputedSize, o.Depth, o.Mask, o.Transform, o.Visible, u], initialize(t, e, i, n) { h.call(this, t, 'Container'), this.list = [], this.exclusive = !0, this.maxSize = -1, this.position = 0, this.localTransform = new o.TransformMatrix(), this.tempTransformMatrix = new o.TransformMatrix(), this._displayList = t.sys.displayList, this._sortKey = '', this._sysEvents = t.sys.events, this.scrollFactorX = 1, this.scrollFactorY = 1, this.setPosition(e, i), this.clearAlpha(), this.setBlendMode(s.SKIP_CHECK), n && this.add(n); }, originX: { get() { return 0.5; } }, originY: { get() { return 0.5; } }, displayOriginX: { get() { return 0.5 * this.width; } }, displayOriginY: { get() { return 0.5 * this.height; } }, setExclusive(t) { return void 0 === t && (t = !0), this.exclusive = t, this; }, getBounds(t) { let e; if (void 0 === t && (t = new l()), t.setTo(this.x, this.y, 0, 0), this.parentContainer && (e = this.parentContainer.getBoundsTransformMatrix().transformPoint(this.x, this.y), t.setTo(e.x, e.y, 0, 0)), this.list.length > 0) { const i = this.list; const n = new l(); let s = !1; t.setEmpty(); for (let r = 0; r < i.length; r++) { const o = i[r]; o.getBounds && (o.getBounds(n), s ? c(n, t, t) : (t.setTo(n.x, n.y, n.width, n.height), s = !0)); } } return t; }, addHandler(t) { t.once(a.DESTROY, this.remove, this), this.exclusive && (this._displayList.remove(t), t.parentContainer && t.parentContainer.remove(t), t.parentContainer = this); }, removeHandler(t) { t.off(a.DESTROY, this.remove), this.exclusive && (t.parentContainer = null); }, pointToContainer(t, e) { void 0 === e && (e = new d()), this.parentContainer ? this.parentContainer.pointToContainer(t, e) : e = new d(t.x, t.y); const i = this.tempTransformMatrix; return i.applyITRS(this.x, this.y, this.rotation, this.scaleX, this.scaleY), i.invert(), i.transformPoint(t.x, t.y, e), e; }, getBoundsTransformMatrix() { return this.getWorldTransformMatrix(this.tempTransformMatrix, this.localTransform); }, add(t) { return r.Add(this.list, t, this.maxSize, this.addHandler, this), this; }, addAt(t, e) { return r.AddAt(this.list, t, e, this.maxSize, this.addHandler, this), this; }, getAt(t) { return this.list[t]; }, getIndex(t) { return this.list.indexOf(t); }, sort(i, t) { return i && (void 0 === t && (t = function (t, e) { return t[i] - e[i]; }), r.StableSort.inplace(this.list, t)), this; }, getByName(t) { return r.GetFirst(this.list, 'name', t); }, getRandom(t, e) { return r.GetRandom(this.list, t, e); }, getFirst(t, e, i, n) { return r.GetFirst(this.list, t, e, i, n); }, getAll(t, e, i, n) { return r.GetAll(this.list, t, e, i, n); }, count(t, e, i, n) { return r.CountAllMatching(this.list, t, e, i, n); }, swap(t, e) { return r.Swap(this.list, t, e), this; }, moveTo(t, e) { return r.MoveTo(this.list, t, e), this; }, remove(t, e) { let i = r.Remove(this.list, t, this.removeHandler, this); if (e && i) { Array.isArray(i) || (i = [i]); for (let n = 0; n < i.length; n++)i[n].destroy(); } return this; }, removeAt(t, e) { const i = r.RemoveAt(this.list, t, this.removeHandler, this); return e && i && i.destroy(), this; }, removeBetween(t, e, i) { const n = r.RemoveBetween(this.list, t, e, this.removeHandler, this); if (i) for (let s = 0; s < n.length; s++)n[s].destroy(); return this; }, removeAll(t) { const e = r.RemoveBetween(this.list, 0, this.list.length, this.removeHandler, this); if (t) for (let i = 0; i < e.length; i++)e[i].destroy(); return this; }, bringToTop(t) { return r.BringToTop(this.list, t), this; }, sendToBack(t) { return r.SendToBack(this.list, t), this; }, moveUp(t) { return r.MoveUp(this.list, t), this; }, moveDown(t) { return r.MoveDown(this.list, t), this; }, reverse() { return this.list.reverse(), this; }, shuffle() { return r.Shuffle(this.list), this; }, replace(t, e, i) { return r.Replace(this.list, t, e) && (this.addHandler(e), this.removeHandler(t), i && t.destroy()), this; }, exists(t) { return this.list.indexOf(t) > -1; }, setAll(t, e, i, n) { return r.SetAll(this.list, t, e, i, n), this; }, each(t, e) { for (var i = [null], n = this.list.slice(), s = n.length, r = 2; r < arguments.length; r++)i.push(arguments[r]); for (r = 0; r < s; r++)i[0] = n[r], t.apply(e, i); return this; }, iterate(t, e) { for (var i = [null], n = 2; n < arguments.length; n++)i.push(arguments[n]); for (n = 0; n < this.list.length; n++)i[0] = this.list[n], t.apply(e, i); return this; }, setScrollFactor(t, e, i) { return void 0 === e && (e = t), void 0 === i && (i = !1), this.scrollFactorX = t, this.scrollFactorY = e, i && (r.SetAll(this.list, 'scrollFactorX', t), r.SetAll(this.list, 'scrollFactorY', e)), this; }, length: { get() { return this.list.length; } }, first: { get() { return (this.position = 0) < this.list.length ? this.list[0] : null; } }, last: { get() { return this.list.length > 0 ? (this.position = this.list.length - 1, this.list[this.position]) : null; } }, next: { get() { return this.position < this.list.length ? (this.position++, this.list[this.position]) : null; } }, previous: { get() { return this.position > 0 ? (this.position--, this.list[this.position]) : null; } }, preDestroy() { this.removeAll(!!this.exclusive), this.localTransform.destroy(), this.tempTransformMatrix.destroy(), this.list = [], this._displayList = null; },\n    }); t.exports = f;\n  }, function (t, e, i) {\n    const a = i(132); const n = i(0); const s = i(959); const r = new n({\n      Extends: a,\n      Mixins: [s],\n      initialize(t, e, i, n, s, r, o) {\n        a.call(this, t, e, i, n, s, r, o), this.type = 'DynamicBitmapText', this.scrollX = 0, this.scrollY = 0, this.cropWidth = 0, this.cropHeight = 0, this.displayCallback, this.callbackData = {\n          parent: this,\n          color: 0,\n          tint: {\n            topLeft: 0, topRight: 0, bottomLeft: 0, bottomRight: 0,\n          },\n          index: 0,\n          charCode: 0,\n          x: 0,\n          y: 0,\n          scale: 0,\n          rotation: 0,\n          data: 0,\n        };\n      },\n      setSize(t, e) { return this.cropWidth = t, this.cropHeight = e, this; },\n      setDisplayCallback(t) { return this.displayCallback = t, this; },\n      setScrollX(t) { return this.scrollX = t, this; },\n      setScrollY(t) { return this.scrollY = t, this; },\n    }); t.exports = r;\n  }, function (t, e, i) {\n    const n = i(91); const s = i(0); const a = i(192); const r = i(269); const o = i(272); const h = i(273); const l = i(277); const u = i(156); const c = i(282); const d = i(283); const f = i(280); const p = i(29); const g = i(95); const v = i(14); const m = i(2); const y = i(6); const x = i(13); const T = i(965); var w = new s({\n      Extends: v, Mixins: [r, o, h, l, u, c, d, f, T], initialize(t, e) { const i = y(e, 'x', 0); const n = y(e, 'y', 0); v.call(this, t, 'Graphics'), this.setPosition(i, n), this.initPipeline(), this.displayOriginX = 0, this.displayOriginY = 0, this.commandBuffer = [], this.defaultFillColor = -1, this.defaultFillAlpha = 1, this.defaultStrokeWidth = 1, this.defaultStrokeColor = -1, this.defaultStrokeAlpha = 1, this._lineWidth = 1, this._tempMatrix1 = new p(), this._tempMatrix2 = new p(), this._tempMatrix3 = new p(), this.setDefaultStyles(e); }, setDefaultStyles(t) { return y(t, 'lineStyle', null) && (this.defaultStrokeWidth = y(t, 'lineStyle.width', 1), this.defaultStrokeColor = y(t, 'lineStyle.color', 16777215), this.defaultStrokeAlpha = y(t, 'lineStyle.alpha', 1), this.lineStyle(this.defaultStrokeWidth, this.defaultStrokeColor, this.defaultStrokeAlpha)), y(t, 'fillStyle', null) && (this.defaultFillColor = y(t, 'fillStyle.color', 16777215), this.defaultFillAlpha = y(t, 'fillStyle.alpha', 1), this.fillStyle(this.defaultFillColor, this.defaultFillAlpha)), this; }, lineStyle(t, e, i) { return void 0 === i && (i = 1), this.commandBuffer.push(a.LINE_STYLE, t, e, i), this._lineWidth = t, this; }, fillStyle(t, e) { return void 0 === e && (e = 1), this.commandBuffer.push(a.FILL_STYLE, t, e), this; }, fillGradientStyle(t, e, i, n, s) { return void 0 === s && (s = 1), this.commandBuffer.push(a.GRADIENT_FILL_STYLE, s, t, e, i, n), this; }, lineGradientStyle(t, e, i, n, s, r) { return void 0 === r && (r = 1), this.commandBuffer.push(a.GRADIENT_LINE_STYLE, t, r, e, i, n, s), this; }, setTexture(t, e, i) { let n; return void 0 === i && (i = 0), void 0 === t ? this.commandBuffer.push(a.CLEAR_TEXTURE) : (n = this.scene.sys.textures.getFrame(t, e)) && (i === 2 && (i = 3), this.commandBuffer.push(a.SET_TEXTURE, n, i)), this; }, beginPath() { return this.commandBuffer.push(a.BEGIN_PATH), this; }, closePath() { return this.commandBuffer.push(a.CLOSE_PATH), this; }, fillPath() { return this.commandBuffer.push(a.FILL_PATH), this; }, fill() { return this.commandBuffer.push(a.FILL_PATH), this; }, strokePath() { return this.commandBuffer.push(a.STROKE_PATH), this; }, stroke() { return this.commandBuffer.push(a.STROKE_PATH), this; }, fillCircleShape(t) { return this.fillCircle(t.x, t.y, t.radius); }, strokeCircleShape(t) { return this.strokeCircle(t.x, t.y, t.radius); }, fillCircle(t, e, i) { return this.beginPath(), this.arc(t, e, i, 0, x.PI2), this.fillPath(), this; }, strokeCircle(t, e, i) { return this.beginPath(), this.arc(t, e, i, 0, x.PI2), this.strokePath(), this; }, fillRectShape(t) { return this.fillRect(t.x, t.y, t.width, t.height); }, strokeRectShape(t) { return this.strokeRect(t.x, t.y, t.width, t.height); }, fillRect(t, e, i, n) { return this.commandBuffer.push(a.FILL_RECT, t, e, i, n), this; }, strokeRect(t, e, i, n) { const s = this._lineWidth / 2; const r = t - s; const o = t + s; return this.beginPath(), this.moveTo(t, e), this.lineTo(t, e + n), this.strokePath(), this.beginPath(), this.moveTo(t + i, e), this.lineTo(t + i, e + n), this.strokePath(), this.beginPath(), this.moveTo(r, e), this.lineTo(o + i, e), this.strokePath(), this.beginPath(), this.moveTo(r, e + n), this.lineTo(o + i, e + n), this.strokePath(), this; }, fillRoundedRect(t, e, i, n, s) { void 0 === s && (s = 20); let r = s; let o = s; let a = s; let h = s; return typeof s !== 'number' && (r = m(s, 'tl', 20), o = m(s, 'tr', 20), a = m(s, 'bl', 20), h = m(s, 'br', 20)), this.beginPath(), this.moveTo(t + r, e), this.lineTo(t + i - o, e), this.arc(t + i - o, e + o, o, -x.TAU, 0), this.lineTo(t + i, e + n - h), this.arc(t + i - h, e + n - h, h, 0, x.TAU), this.lineTo(t + a, e + n), this.arc(t + a, e + n - a, a, x.TAU, Math.PI), this.lineTo(t, e + r), this.arc(t + r, e + r, r, -Math.PI, -x.TAU), this.fillPath(), this; }, strokeRoundedRect(t, e, i, n, s) { void 0 === s && (s = 20); let r = s; let o = s; let a = s; let h = s; return typeof s !== 'number' && (r = m(s, 'tl', 20), o = m(s, 'tr', 20), a = m(s, 'bl', 20), h = m(s, 'br', 20)), this.beginPath(), this.moveTo(t + r, e), this.lineTo(t + i - o, e), this.arc(t + i - o, e + o, o, -x.TAU, 0), this.lineTo(t + i, e + n - h), this.arc(t + i - h, e + n - h, h, 0, x.TAU), this.lineTo(t + a, e + n), this.arc(t + a, e + n - a, a, x.TAU, Math.PI), this.lineTo(t, e + r), this.arc(t + r, e + r, r, -Math.PI, -x.TAU), this.strokePath(), this; }, fillPointShape(t, e) { return this.fillPoint(t.x, t.y, e); }, fillPoint(t, e, i) { return !i || i < 1 ? i = 1 : (t -= i / 2, e -= i / 2), this.commandBuffer.push(a.FILL_RECT, t, e, i, i), this; }, fillTriangleShape(t) { return this.fillTriangle(t.x1, t.y1, t.x2, t.y2, t.x3, t.y3); }, strokeTriangleShape(t) { return this.strokeTriangle(t.x1, t.y1, t.x2, t.y2, t.x3, t.y3); }, fillTriangle(t, e, i, n, s, r) { return this.commandBuffer.push(a.FILL_TRIANGLE, t, e, i, n, s, r), this; }, strokeTriangle(t, e, i, n, s, r) { return this.commandBuffer.push(a.STROKE_TRIANGLE, t, e, i, n, s, r), this; }, strokeLineShape(t) { return this.lineBetween(t.x1, t.y1, t.x2, t.y2); }, lineBetween(t, e, i, n) { return this.beginPath(), this.moveTo(t, e), this.lineTo(i, n), this.strokePath(), this; }, lineTo(t, e) { return this.commandBuffer.push(a.LINE_TO, t, e), this; }, moveTo(t, e) { return this.commandBuffer.push(a.MOVE_TO, t, e), this; }, strokePoints(t, e, i, n) { void 0 === e && (e = !1), void 0 === i && (i = !1), void 0 === n && (n = t.length), this.beginPath(), this.moveTo(t[0].x, t[0].y); for (let s = 1; s < n; s++) this.lineTo(t[s].x, t[s].y); return e && this.lineTo(t[0].x, t[0].y), i && this.closePath(), this.strokePath(), this; }, fillPoints(t, e, i, n) { void 0 === e && (e = !1), void 0 === i && (i = !1), void 0 === n && (n = t.length), this.beginPath(), this.moveTo(t[0].x, t[0].y); for (let s = 1; s < n; s++) this.lineTo(t[s].x, t[s].y); return e && this.lineTo(t[0].x, t[0].y), i && this.closePath(), this.fillPath(), this; }, strokeEllipseShape(t, e) { void 0 === e && (e = 32); const i = t.getPoints(e); return this.strokePoints(i, !0); }, strokeEllipse(t, e, i, n, s) { void 0 === s && (s = 32); const r = new g(t, e, i, n).getPoints(s); return this.strokePoints(r, !0); }, fillEllipseShape(t, e) { void 0 === e && (e = 32); const i = t.getPoints(e); return this.fillPoints(i, !0); }, fillEllipse(t, e, i, n, s) { void 0 === s && (s = 32); const r = new g(t, e, i, n).getPoints(s); return this.fillPoints(r, !0); }, arc(t, e, i, n, s, r, o) { return void 0 === r && (r = !1), void 0 === o && (o = 0), this.commandBuffer.push(a.ARC, t, e, i, n, s, r, o), this; }, slice(t, e, i, n, s, r, o) { return void 0 === r && (r = !1), void 0 === o && (o = 0), this.commandBuffer.push(a.BEGIN_PATH), this.commandBuffer.push(a.MOVE_TO, t, e), this.commandBuffer.push(a.ARC, t, e, i, n, s, r, o), this.commandBuffer.push(a.CLOSE_PATH), this; }, save() { return this.commandBuffer.push(a.SAVE), this; }, restore() { return this.commandBuffer.push(a.RESTORE), this; }, translateCanvas(t, e) { return this.commandBuffer.push(a.TRANSLATE, t, e), this; }, scaleCanvas(t, e) { return this.commandBuffer.push(a.SCALE, t, e), this; }, rotateCanvas(t) { return this.commandBuffer.push(a.ROTATE, t), this; }, clear() { return this.commandBuffer.length = 0, this.defaultFillColor > -1 && this.fillStyle(this.defaultFillColor, this.defaultFillAlpha), this.defaultStrokeColor > -1 && this.lineStyle(this.defaultStrokeWidth, this.defaultStrokeColor, this.defaultStrokeAlpha), this; }, generateTexture(t, e, i) { let n; let s; let r; const o = this.scene.sys; const a = o.game.renderer; return void 0 === e && (e = o.scale.width), void 0 === i && (i = o.scale.height), w.TargetCamera.setScene(this.scene), w.TargetCamera.setViewport(0, 0, e, i), w.TargetCamera.scrollX = this.x, w.TargetCamera.scrollY = this.y, typeof t === 'string' ? o.textures.exists(t) ? (r = (n = o.textures.get(t)).getSourceImage()) instanceof HTMLCanvasElement && (s = r.getContext('2d')) : s = (n = o.textures.createCanvas(t, e, i)).getSourceImage().getContext('2d') : t instanceof HTMLCanvasElement && (s = t.getContext('2d')), s && (this.renderCanvas(a, this, 0, w.TargetCamera, null, s, !1), n && n.refresh()), this; }, preDestroy() { this.commandBuffer = []; },\n    }); w.TargetCamera = new n(), t.exports = w;\n  }, function (t, e) {\n    t.exports = {\n      ARC: 0, BEGIN_PATH: 1, CLOSE_PATH: 2, FILL_RECT: 3, LINE_TO: 4, MOVE_TO: 5, LINE_STYLE: 6, FILL_STYLE: 7, FILL_PATH: 8, STROKE_PATH: 9, FILL_TRIANGLE: 10, STROKE_TRIANGLE: 11, SAVE: 14, RESTORE: 15, TRANSLATE: 16, SCALE: 17, ROTATE: 18, SET_TEXTURE: 19, CLEAR_TEXTURE: 20, GRADIENT_FILL_STYLE: 21, GRADIENT_LINE_STYLE: 22,\n    };\n  }, function (t, e, i) { const r = i(4); t.exports = function (t, e, i) { void 0 === i && (i = new r()); const n = t.width / 2; const s = t.height / 2; return i.x = t.x + n * Math.cos(e), i.y = t.y + s * Math.sin(e), i; }; }, function (t, e, i) {\n    const n = i(0); const s = i(12); const r = i(14); const o = i(402); const a = i(129); const h = i(404); const l = i(975); const u = new n({\n      Extends: r, Mixins: [s.Depth, s.Mask, s.Pipeline, s.Transform, s.Visible, l], initialize(t, e, i, n) { if (r.call(this, t, 'ParticleEmitterManager'), this.blendMode = -1, this.timeScale = 1, this.texture = null, this.frame = null, this.frameNames = [], i === null || typeof i !== 'object' && !Array.isArray(i) || (n = i, i = null), this.setTexture(e, i), this.initPipeline(), this.emitters = new a(this), this.wells = new a(this), n) { Array.isArray(n) || (n = [n]); for (let s = 0; s < n.length; s++) this.createEmitter(n[s]); } }, setTexture(t, e) { return this.texture = this.scene.sys.textures.get(t), this.setFrame(e); }, setFrame(t) { this.frame = this.texture.get(t); const e = this.texture.getFramesFromTextureSource(this.frame.sourceIndex); const i = []; return e.forEach((t) => { i.push(t.name); }), this.frameNames = i, this.defaultFrame = this.frame, this; }, setEmitterFrames(t, e) { Array.isArray(t) || (t = [t]); for (var i = e.frames, n = i.length = 0; n < t.length; n++) { const s = t[n]; this.frameNames.indexOf(s) !== -1 && i.push(this.texture.get(s)); } return i.length > 0 ? e.defaultFrame = i[0] : e.defaultFrame = this.defaultFrame, this; }, addEmitter(t) { return this.emitters.add(t); }, createEmitter(t) { return this.addEmitter(new h(this, t)); }, removeEmitter(t) { return this.emitters.remove(t, !0); }, addGravityWell(t) { return this.wells.add(t); }, createGravityWell(t) { return this.addGravityWell(new o(t)); }, emitParticle(t, e, i) { for (let n = this.emitters.list, s = 0; s < n.length; s++) { const r = n[s]; r.active && r.emitParticle(t, e, i); } return this; }, emitParticleAt(t, e, i) { return this.emitParticle(i, t, e); }, pause() { return this.active = !1, this; }, resume() { return this.active = !0, this; }, getProcessors() { return this.wells.getAll('active', !0); }, preUpdate(t, e) { e *= this.timeScale; for (let i = this.emitters.list, n = 0; n < i.length; n++) { const s = i[n]; s.active && s.preUpdate(t, e); } }, setAlpha() {}, setScrollFactor() {}, setBlendMode() {},\n    }); t.exports = u;\n  }, function (t, e, i) {\n    const o = i(52); const l = i(91); const u = i(26); const n = i(0); const s = i(12); const c = i(33); const a = i(94); const d = i(14); const f = i(1); const r = i(979); const v = i(9); const p = i(196); const h = new n({\n      Extends: d, Mixins: [s.Alpha, s.BlendMode, s.ComputedSize, s.Crop, s.Depth, s.Flip, s.GetBounds, s.Mask, s.Origin, s.Pipeline, s.ScrollFactor, s.Tint, s.Transform, s.Visible, r], initialize(t, e, i, n, s, r, o) { void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === n && (n = 32), void 0 === s && (s = 32), d.call(this, t, 'RenderTexture'), this.renderer = t.sys.game.renderer, this.textureManager = t.sys.textures, this.globalTint = 16777215, this.globalAlpha = 1, this.canvas = null, this.framebuffer = null, this.dirty = !1, this._crop = this.resetCropObject(), this.texture = null, this.frame = null, this._saved = !1, void 0 === r ? (this.canvas = u.create2D(this, n, s), this.texture = t.sys.textures.addCanvas(p(), this.canvas), this.frame = this.texture.get()) : (this.texture = t.sys.textures.get(r), this.frame = this.texture.get(o), this.canvas = this.frame.source.image, this._saved = !0, this.dirty = !0, this.width = this.frame.cutWidth, this.height = this.frame.cutHeight), this.context = this.canvas.getContext('2d'), this._eraseMode = !1, this.camera = new l(0, 0, n, s), this.gl = null, this.glTexture = null; let a; const h = this.renderer; h ? h.type === c.WEBGL ? (a = h.gl, this.gl = a, this.glTexture = this.frame.source.glTexture, this.drawGameObject = this.batchGameObjectWebGL, this.framebuffer = h.createFramebuffer(n, s, this.glTexture, !1)) : h.type === c.CANVAS && (this.drawGameObject = this.batchGameObjectCanvas) : this.drawGameObject = f, this.camera.setScene(t), this.setPosition(e, i), void 0 === r && this.setSize(n, s), this.setOrigin(0, 0), this.initPipeline(); }, setSize(t, e) { return this.resize(t, e); }, resize(t, e) { let i; let n; let s; void 0 === e && (e = t), t !== this.width || e !== this.height ? this.frame.name === '__BASE' && (this.canvas.width = t, this.canvas.height = e, this.texture.width = t, this.texture.height = e, this.gl && (i = this.gl, this.renderer.deleteTexture(this.frame.source.glTexture), this.renderer.deleteFramebuffer(this.framebuffer), n = this.renderer.createTexture2D(0, i.NEAREST, i.NEAREST, i.CLAMP_TO_EDGE, i.CLAMP_TO_EDGE, i.RGBA, null, t, e, !1), this.framebuffer = this.renderer.createFramebuffer(t, e, n, !1), this.frame.source.isRenderTexture = !0, this.frame.glTexture = n, this.glTexture = n), this.frame.source.width = t, this.frame.source.height = e, this.camera.setSize(t, e), this.frame.setSize(t, e), this.width = t, this.height = e) : (s = this.texture.getSourceImage(), this.frame.cutX + t > s.width && (t = s.width - this.frame.cutX), this.frame.cutY + e > s.height && (e = s.height - this.frame.cutY), this.frame.setSize(t, e, this.frame.cutX, this.frame.cutY)), this.updateDisplayOrigin(); const r = this.input; return r && !r.customHitArea && (r.hitArea.width = t, r.hitArea.height = e), this; }, setGlobalTint(t) { return this.globalTint = t, this; }, setGlobalAlpha(t) { return this.globalAlpha = t, this; }, saveTexture(t) { return this.textureManager.renameTexture(this.texture.key, t), this._saved = !0, this.texture; }, fill(t, e, i, n, s, r) { void 0 === e && (e = 1), void 0 === i && (i = 0), void 0 === n && (n = 0), void 0 === s && (s = this.frame.cutWidth), void 0 === r && (r = this.frame.cutHeight); let o; let a; let h; let l; let u; const c = 255 & (t >> 16 | 0); const d = 255 & (t >> 8 | 0); const f = 255 & (0 | t); const p = this.gl; const g = this.frame; return this.camera.preRender(1, 1), p ? (o = this.camera._cx, a = this.camera._cy, h = this.camera._cw, l = this.camera._ch, this.renderer.setFramebuffer(this.framebuffer, !1), this.renderer.pushScissor(o, a, h, l, l), (u = this.pipeline).projOrtho(0, this.texture.width, 0, this.texture.height, -1e3, 1e3), u.drawFillRect(i, n, s, r, v.getTintFromFloats(c / 255, d / 255, f / 255, 1), e), this.renderer.setFramebuffer(null, !1), this.renderer.popScissor(), u.projOrtho(0, u.width, u.height, 0, -1e3, 1e3)) : (this.renderer.setContext(this.context), this.context.fillStyle = `rgba(${c},${d},${f},${e})`, this.context.fillRect(i + g.cutX, n + g.cutY, s, r), this.renderer.setContext()), this.dirty = !0, this; }, clear() { let t; let e; let i; return this.dirty && ((t = this.gl) ? ((e = this.renderer).setFramebuffer(this.framebuffer, !0), this.frame.cutWidth === this.canvas.width && this.frame.cutHeight === this.canvas.height || t.scissor(this.frame.cutX, this.frame.cutY, this.frame.cutWidth, this.frame.cutHeight), t.clearColor(0, 0, 0, 0), t.clear(t.COLOR_BUFFER_BIT), e.setFramebuffer(null, !0)) : ((i = this.context).save(), i.setTransform(1, 0, 0, 1, 0, 0), i.clearRect(this.frame.cutX, this.frame.cutY, this.frame.cutWidth, this.frame.cutHeight), i.restore()), this.dirty = !1), this; }, erase(t, e, i) { this._eraseMode = !0; const n = this.renderer.currentBlendMode; return this.renderer.setBlendMode(o.ERASE), this.draw(t, e, i, 1, 16777215), this.renderer.setBlendMode(n), this._eraseMode = !1, this; }, draw(t, e, i, n, s) { void 0 === n && (n = this.globalAlpha), s = void 0 === s ? (this.globalTint >> 16) + (65280 & this.globalTint) + ((255 & this.globalTint) << 16) : (s >> 16) + (65280 & s) + ((255 & s) << 16), Array.isArray(t) || (t = [t]); let r; let o; let a; let h; let l; const u = this.gl; return this.camera.preRender(1, 1), u ? (r = this.camera._cx, o = this.camera._cy, a = this.camera._cw, h = this.camera._ch, this.renderer.setFramebuffer(this.framebuffer, !1), this.renderer.pushScissor(r, o, a, h, h), (l = this.pipeline).projOrtho(0, this.texture.width, 0, this.texture.height, -1e3, 1e3), this.batchList(t, e, i, n, s), l.flush(), this.renderer.setFramebuffer(null, !1), this.renderer.popScissor(), l.projOrtho(0, l.width, l.height, 0, -1e3, 1e3)) : (this.renderer.setContext(this.context), this.batchList(t, e, i, n, s), this.renderer.setContext()), this.dirty = !0, this; }, drawFrame(t, e, i, n, s, r) { void 0 === i && (i = 0), void 0 === n && (n = 0), void 0 === s && (s = this.globalAlpha), r = void 0 === r ? (this.globalTint >> 16) + (65280 & this.globalTint) + ((255 & this.globalTint) << 16) : (r >> 16) + (65280 & r) + ((255 & r) << 16); let o; let a; let h; let l; let u; const c = this.gl; const d = this.textureManager.getFrame(t, e); return d && (this.camera.preRender(1, 1), c ? (o = this.camera._cx, a = this.camera._cy, h = this.camera._cw, l = this.camera._ch, this.renderer.setFramebuffer(this.framebuffer, !1), this.renderer.pushScissor(o, a, h, l, l), (u = this.pipeline).projOrtho(0, this.texture.width, 0, this.texture.height, -1e3, 1e3), u.batchTextureFrame(d, i + this.frame.cutX, n + this.frame.cutY, r, s, this.camera.matrix, null), u.flush(), this.renderer.setFramebuffer(null, !1), this.renderer.popScissor(), u.projOrtho(0, u.width, u.height, 0, -1e3, 1e3)) : this.batchTextureFrame(d, i + this.frame.cutX, n + this.frame.cutY, s, r), this.dirty = !0), this; }, batchList(t, e, i, n, s) { for (let r = 0; r < t.length; r++) { const o = t[r]; o && o !== this && (o.renderWebGL || o.renderCanvas ? this.drawGameObject(o, e, i) : o.isParent || o.list ? this.batchGroup(o.getChildren(), e, i) : typeof o === 'string' ? this.batchTextureFrameKey(o, null, e, i, n, s) : o instanceof a ? this.batchTextureFrame(o, e, i, n, s) : Array.isArray(o) && this.batchList(o, e, i, n, s)); } }, batchGroup(t, e, i) { void 0 === e && (e = 0), void 0 === i && (i = 0), e += this.frame.cutX, i += this.frame.cutY; for (let n = 0; n < t.length; n++) { var s; var r; const o = t[n]; o.willRender() && (s = o.x + e, r = o.y + i, this.drawGameObject(o, s, r)); } }, batchGameObjectWebGL(t, e, i) { void 0 === e && (e = t.x), void 0 === i && (i = t.y); const n = t.x; const s = t.y; this._eraseMode || this.renderer.setBlendMode(t.blendMode), t.setPosition(e + this.frame.cutX, i + this.frame.cutY), t.renderWebGL(this.renderer, t, 0, this.camera, null), t.setPosition(n, s); }, batchGameObjectCanvas(t, e, i) { void 0 === e && (e = t.x), void 0 === i && (i = t.y); let n; const s = t.x; const r = t.y; this._eraseMode && (n = t.blendMode, t.blendMode = o.ERASE), t.setPosition(e + this.frame.cutX, i + this.frame.cutY), t.renderCanvas(this.renderer, t, 0, this.camera, null), t.setPosition(s, r), this._eraseMode && (t.blendMode = n); }, batchTextureFrameKey(t, e, i, n, s, r) { const o = this.textureManager.getFrame(t, e); o && this.batchTextureFrame(o, i, n, s, r); }, batchTextureFrame(t, e, i, n, s) { let r; let o; let a; let h; void 0 === e && (e = 0), void 0 === i && (i = 0), e += this.frame.cutX, i += this.frame.cutY, this.gl ? this.pipeline.batchTextureFrame(t, e, i, s, n, this.camera.matrix, null) : (r = this.context, o = t.canvasData, a = t.source.image, h = this.camera.matrix, r.globalAlpha = this.globalAlpha, r.setTransform(h[0], h[1], h[2], h[3], h[4], h[5]), r.drawImage(a, o.x, o.y, o.width, o.height, e, i, o.width, o.height)); }, snapshotArea(t, e, i, n, s, r, o) { return this.gl ? this.renderer.snapshotFramebuffer(this.framebuffer, this.width, this.height, s, !1, t, e, i, n, r, o) : this.renderer.snapshotCanvas(this.canvas, s, !1, t, e, i, n, r, o), this; }, snapshot(t, e, i) { return this.gl ? this.renderer.snapshotFramebuffer(this.framebuffer, this.width, this.height, t, !1, 0, 0, this.width, this.height, e, i) : this.renderer.snapshotCanvas(this.canvas, t, !1, 0, 0, this.width, this.height, e, i), this; }, snapshotPixel(t, e, i) { return this.gl ? this.renderer.snapshotFramebuffer(this.framebuffer, this.width, this.height, i, !0, t, e) : this.renderer.snapshotCanvas(this.canvas, i, !0, t, e), this; }, preDestroy() { this._saved || (u.remove(this.canvas), this.gl && this.renderer.deleteFramebuffer(this.framebuffer), this.texture.destroy(), this.camera.destroy(), this.canvas = null, this.context = null, this.framebuffer = null, this.texture = null, this.glTexture = null); },\n    }); t.exports = h;\n  }, function (t, e) { t.exports = function () { return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (t) => { const e = 16 * Math.random() | 0; return (t === 'x' ? e : 3 & e | 8).toString(16); }); }; }, function (t, e, i) {\n    const n = i(0); const l = i(12); const u = i(14); const s = i(985); const c = i(3); const r = new n({\n      Extends: u, Mixins: [l.AlphaSingle, l.BlendMode, l.Depth, l.Flip, l.Mask, l.Pipeline, l.Size, l.Texture, l.Transform, l.Visible, l.ScrollFactor, s], initialize(t, e, i, n, s, r, o, a, h) { void 0 === n && (n = '__DEFAULT'), void 0 === r && (r = 2), void 0 === o && (o = !0), u.call(this, t, 'Rope'), this.anims = new l.Animation(this), this.points = r, this.vertices, this.uv, this.colors, this.alphas, this.tintFill = n === '__DEFAULT' ? 2 : 0, this.dirty = !1, this.horizontal = o, this._flipX = !1, this._flipY = !1, this._perp = new c(), this.debugCallback = null, this.debugGraphic = null, this.setTexture(n, s), this.setPosition(e, i), this.setSizeToFrame(), this.initPipeline('TextureTintStripPipeline'), Array.isArray(r) && this.resizeArrays(r.length), this.setPoints(r, a, h), this.updateVertices(); }, preUpdate(t, e) { const i = this.anims.currentFrame; this.anims.update(t, e), this.anims.currentFrame !== i && (this.updateUVs(), this.updateVertices()); }, play(t, e, i) { return this.anims.play(t, e, i), this; }, setDirty() { return this.dirty = !0, this; }, setHorizontal(t, e, i) { return void 0 === t && (t = this.points.length), this.horizontal ? this : (this.horizontal = !0, this.setPoints(t, e, i)); }, setVertical(t, e, i) { return void 0 === t && (t = this.points.length), this.horizontal ? (this.horizontal = !1, this.setPoints(t, e, i)) : this; }, setTintFill(t) { return void 0 === t && (t = 0), this.tintFill = t, this; }, setAlphas(t, e) { const i = this.points.length; if (i < 1) return this; const n = this.alphas; void 0 === t ? t = [1] : Array.isArray(t) || void 0 !== e || (t = [t]); let s = 0; if (void 0 !== e) for (o = 0; o < i; o++)n[s = 2 * o] = t, n[s + 1] = e; else if (t.length === i) for (o = 0; o < i; o++)n[s = 2 * o] = t[o], n[s + 1] = t[o]; else for (var r = t[0], o = 0; o < i; o++)s = 2 * o, t.length > s && (r = t[s]), n[s] = r, t.length > s + 1 && (r = t[s + 1]), n[s + 1] = r; return this; }, setColors(t) { const e = this.points.length; if (e < 1) return this; const i = this.colors; void 0 === t ? t = [16777215] : Array.isArray(t) || (t = [t]); let n = 0; if (t.length === e) for (r = 0; r < e; r++)i[n = 2 * r] = t[r], i[n + 1] = t[r]; else for (var s = t[0], r = 0; r < e; r++)n = 2 * r, t.length > n && (s = t[n]), i[n] = s, t.length > n + 1 && (s = t[n + 1]), i[n + 1] = s; return this; }, setPoints(t, e, i) { if (void 0 === t && (t = 2), typeof t === 'number') { let n; let s; let r; let o = t; if (o < 2 && (o = 2), t = [], this.horizontal) for (r = -this.frame.halfWidth, s = this.frame.width / (o - 1), n = 0; n < o; n++)t.push({ x: r + n * s, y: 0 }); else for (r = -this.frame.halfHeight, s = this.frame.height / (o - 1), n = 0; n < o; n++)t.push({ x: 0, y: r + n * s }); } let a = t.length; const h = this.points.length; return a < 1 ? console.warn('Rope: Not enough points given') : (a === 1 && (t.unshift({ x: 0, y: 0 }), a++), h !== a && this.resizeArrays(a), this.points = t, this.updateUVs(), e != null && this.setColors(e), i != null && this.setAlphas(i)), this; }, updateUVs() { for (let t = this.uv, e = this.points.length, i = this.frame.u0, n = this.frame.v0, s = this.frame.u1, r = this.frame.v1, o = (s - i) / (e - 1), a = (r - n) / (e - 1), h = 0; h < e; h++) { var l; var u; var c; const d = 4 * h; const f = this.horizontal ? (c = l = this._flipX ? s - h * o : i + h * o, this._flipY ? (u = r, n) : (u = n, r)) : (c = this._flipX ? (l = i, s) : (l = s, i), u = this._flipY ? r - h * a : n + h * a); t[0 + d] = l, t[1 + d] = u, t[2 + d] = c, t[3 + d] = f; } return this; }, resizeArrays(t) { let e = this.colors; let i = this.alphas; this.vertices = new Float32Array(4 * t), this.uv = new Float32Array(4 * t), e = new Uint32Array(2 * t), i = new Float32Array(2 * t); for (let n = 0; n < 2 * t; n++)e[n] = 16777215, i[n] = 1; return this.colors = e, this.alphas = i, this.dirty = !0, this; }, updateVertices() { const t = this._perp; const e = this.points; const i = this.vertices; const n = e.length; if (this.dirty = !1, !(n < 1)) { for (let s = e[0], r = this.horizontal ? this.frame.halfHeight : this.frame.halfWidth, o = 0; o < n; o++) { const a = e[o]; const h = 4 * o; const l = o < n - 1 ? e[o + 1] : a; t.x = l.y - s.y, t.y = -(l.x - s.x); const u = t.length(); t.x /= u, t.y /= u, t.x *= r, t.y *= r, i[h] = a.x + t.x, i[1 + h] = a.y + t.y, i[2 + h] = a.x - t.x, i[3 + h] = a.y - t.y, s = a; } return this; } }, setDebug(t, e) { return this.debugGraphic = t, this.debugCallback = t || e ? e || this.renderDebugVerts : null, this; }, renderDebugVerts(t, e, i) { const n = t.debugGraphic; let s = i[0]; let r = i[1]; let o = i[2]; let a = i[3]; n.lineBetween(s, r, o, a); for (let h = 4; h < e; h += 4) { const l = i[h + 0]; const u = i[h + 1]; const c = i[h + 2]; const d = i[h + 3]; n.lineBetween(s, r, l, u), n.lineBetween(o, a, c, d), n.lineBetween(o, a, l, u), n.lineBetween(l, u, c, d), s = l, r = u, o = c, a = d; } }, preDestroy() { this.anims.destroy(), this.anims = void 0, this.points = null, this.vertices = null, this.uv = null, this.colors = null, this.alphas = null, this.debugCallback = null, this.debugGraphic = null; }, flipX: { get() { return this._flipX; }, set(t) { return this._flipX = t, this.updateUVs(); } }, flipY: { get() { return this._flipY; }, set(t) { return this._flipY = t, this.updateUVs(); } },\n    }); t.exports = r;\n  }, function (t, e, i) {\n    const n = i(122); const r = i(26); const s = i(0); const o = i(12); const a = i(20); const h = i(14); const b = i(988); const l = i(6); const u = i(178); const c = i(989); const d = i(992); const f = new s({\n      Extends: h,\n      Mixins: [o.Alpha, o.BlendMode, o.ComputedSize, o.Crop, o.Depth, o.Flip, o.GetBounds, o.Mask, o.Origin, o.Pipeline, o.ScrollFactor, o.Tint, o.Transform, o.Visible, c],\n      initialize(t, e, i, n, s) {\n        void 0 === e && (e = 0), void 0 === i && (i = 0), h.call(this, t, 'Text'), this.renderer = t.sys.game.renderer, this.setPosition(e, i), this.setOrigin(0, 0), this.initPipeline(), this.canvas = r.create(this), this.context = this.canvas.getContext('2d'), this.style = new d(this, s), this.autoRound = !0, this.splitRegExp = /(?:\\r\\n|\\r|\\n)/, this._text = void 0, this.padding = {\n          left: 0, right: 0, top: 0, bottom: 0,\n        }, this.width = 1, this.height = 1, this.lineSpacing = 0, this.dirty = !1, this.style.resolution === 0 && (this.style.resolution = t.sys.game.config.resolution), this._crop = this.resetCropObject(), this.texture = t.sys.textures.addCanvas(null, this.canvas, !0), this.frame = this.texture.get(), this.frame.source.resolution = this.style.resolution, this.renderer && this.renderer.gl && (this.renderer.deleteTexture(this.frame.source.glTexture), this.frame.source.glTexture = null), this.initRTL(), this.setText(n), s && s.padding && this.setPadding(s.padding), s && s.lineSpacing && this.setLineSpacing(s.lineSpacing), t.sys.game.events.on(a.CONTEXT_RESTORED, function () { this.dirty = !0; }, this);\n      },\n      initRTL() { this.style.rtl && (this.canvas.dir = 'rtl', this.context.direction = 'rtl', this.canvas.style.display = 'none', n(this.canvas, this.scene.sys.canvas), this.originX = 1); },\n      runWordWrap(t) { const e = this.style; if (e.wordWrapCallback) { let i = e.wordWrapCallback.call(e.wordWrapCallbackScope, t, this); return Array.isArray(i) && (i = i.join('\\n')), i; } return e.wordWrapWidth ? e.wordWrapUseAdvanced ? this.advancedWordWrap(t, this.context, this.style.wordWrapWidth) : this.basicWordWrap(t, this.context, this.style.wordWrapWidth) : t; },\n      advancedWordWrap(t, e, i) { for (var n = '', s = t.replace(/ +/gi, ' ').split(this.splitRegExp), r = s.length, o = 0; o < r; o++) { let a = ''; var h = (h = s[o]).replace(/^ *|\\s*$/gi, ''); if (e.measureText(h).width < i)n += `${h}\\n`; else { for (let l = i, u = h.split(' '), c = 0; c < u.length; c++) { const d = u[c]; const f = `${d} `; let p = e.measureText(f).width; if (l < p) { if (c === 0) { for (var g = f; g.length && (g = g.slice(0, -1), !((p = e.measureText(g).width) <= l)););if (!g.length) throw new Error(\"This text's wordWrapWidth setting is less than a single character!\"); const v = d.substr(g.length); u[c] = v, a += g; } const m = u[c].length ? c : c + 1; const y = u.slice(m).join(' ').replace(/[ \\n]*$/gi, ''); s[o + 1] = `${y} ${s[o + 1] || ''}`, r = s.length; break; }a += f, l -= p; }n += `${a.replace(/[ \\n]*$/gi, '')}\\n`; } } return n = n.replace(/[\\s|\\n]*$/gi, ''); },\n      basicWordWrap(t, e, i) { for (var n = '', s = t.split(this.splitRegExp), r = s.length - 1, o = e.measureText(' ').width, a = 0; a <= r; a++) { for (let h = i, l = s[a].split(' '), u = l.length - 1, c = 0; c <= u; c++) { const d = l[c]; const f = e.measureText(d).width; const p = f + o; h < p && c > 0 && (n += '\\n', h = i), n += d, c < u ? (n += ' ', h -= p) : h -= f; }a < r && (n += '\\n'); } return n; },\n      getWrappedText(t) { return void 0 === t && (t = this._text), this.style.syncFont(this.canvas, this.context), this.runWordWrap(t).split(this.splitRegExp); },\n      setText(t) { return t || t === 0 || (t = ''), Array.isArray(t) && (t = t.join('\\n')), t !== this._text && (this._text = t.toString(), this.updateText()), this; },\n      setStyle(t) { return this.style.setStyle(t); },\n      setFont(t) { return this.style.setFont(t); },\n      setFontFamily(t) { return this.style.setFontFamily(t); },\n      setFontSize(t) { return this.style.setFontSize(t); },\n      setFontStyle(t) { return this.style.setFontStyle(t); },\n      setFixedSize(t, e) { return this.style.setFixedSize(t, e); },\n      setBackgroundColor(t) { return this.style.setBackgroundColor(t); },\n      setFill(t) { return this.style.setFill(t); },\n      setColor(t) { return this.style.setColor(t); },\n      setStroke(t, e) { return this.style.setStroke(t, e); },\n      setShadow(t, e, i, n, s, r) { return this.style.setShadow(t, e, i, n, s, r); },\n      setShadowOffset(t, e) { return this.style.setShadowOffset(t, e); },\n      setShadowColor(t) { return this.style.setShadowColor(t); },\n      setShadowBlur(t) { return this.style.setShadowBlur(t); },\n      setShadowStroke(t) { return this.style.setShadowStroke(t); },\n      setShadowFill(t) { return this.style.setShadowFill(t); },\n      setWordWrapWidth(t, e) { return this.style.setWordWrapWidth(t, e); },\n      setWordWrapCallback(t, e) { return this.style.setWordWrapCallback(t, e); },\n      setAlign(t) { return this.style.setAlign(t); },\n      setResolution(t) { return this.style.setResolution(t); },\n      setLineSpacing(t) { return this.lineSpacing = t, this.updateText(); },\n      setPadding(t, e, i, n) { let s; let r; let o; return typeof t === 'object' ? (i = (r = l(s = t, 'x', null)) !== null ? t = r : (t = l(s, 'left', 0), l(s, 'right', t)), n = (o = l(s, 'y', null)) !== null ? e = o : (e = l(s, 'top', 0), l(s, 'bottom', e))) : (void 0 === t && (t = 0), void 0 === e && (e = t), void 0 === i && (i = t), void 0 === n && (n = e)), this.padding.left = t, this.padding.top = e, this.padding.right = i, this.padding.bottom = n, this.updateText(); },\n      setMaxLines(t) { return this.style.setMaxLines(t); },\n      updateText() { const t = this.canvas; const e = this.context; const i = this.style; const n = i.resolution; const s = i.metrics; i.syncFont(t, e); let r = this._text; (i.wordWrapWidth || i.wordWrapCallback) && (r = this.runWordWrap(this._text)); let o; const a = r.split(this.splitRegExp); const h = b(this, s, a); const l = this.padding; i.fixedWidth === 0 ? (this.width = h.width + l.left + l.right, o = h.width) : (this.width = i.fixedWidth, (o = this.width - l.left - l.right) < h.width && (o = h.width)), i.fixedHeight === 0 ? this.height = h.height + l.top + l.bottom : this.height = i.fixedHeight; let u; let c; let d = this.width; let f = this.height; this.updateDisplayOrigin(), d *= n, f *= n, d = Math.max(d, 1), f = Math.max(f, 1), t.width !== d || t.height !== f ? (t.width = d, t.height = f, this.frame.setSize(d, f), i.syncFont(t, e)) : e.clearRect(0, 0, d, f), e.save(), e.scale(n, n), i.backgroundColor && (e.fillStyle = i.backgroundColor, e.fillRect(0, 0, d, f)), i.syncStyle(t, e), e.textBaseline = 'alphabetic', e.translate(l.left, l.top); for (let p = 0; p < h.lines; p++) { if (u = i.strokeThickness / 2, c = i.strokeThickness / 2 + p * h.lineHeight + s.ascent, p > 0 && (c += h.lineSpacing * p), i.rtl)u = d - u; else if (i.align === 'right')u += o - h.lineWidths[p]; else if (i.align === 'center')u += (o - h.lineWidths[p]) / 2; else if (i.align === 'justify') { if (h.lineWidths[p] / h.width >= 0.85) { let g = h.width - h.lineWidths[p]; const v = e.measureText(' ').width; const m = a[p].trim(); const y = m.split(' '); g += (a[p].length - m.length) * v; for (let x = Math.floor(g / v), T = 0; x > 0;)y[T] += ' ', T = (T + 1) % (y.length - 1 || 1), --x; a[p] = y.join(' '); } } this.autoRound && (u = Math.round(u), c = Math.round(c)), i.strokeThickness && (this.style.syncShadow(e, i.shadowStroke), e.strokeText(a[p], u, c)), i.color && (this.style.syncShadow(e, i.shadowFill), e.fillText(a[p], u, c)); }e.restore(), this.renderer && this.renderer.gl && (this.frame.source.glTexture = this.renderer.canvasToTexture(t, this.frame.source.glTexture, !0), this.frame.glTexture = this.frame.source.glTexture), this.dirty = !0; const w = this.input; return w && !w.customHitArea && (w.hitArea.width = this.width, w.hitArea.height = this.height), this; },\n      getTextMetrics() { return this.style.getTextMetrics(); },\n      text: { get() { return this._text; }, set(t) { this.setText(t); } },\n      toJSON() {\n        const t = o.ToJSON(this); const e = {\n          autoRound: this.autoRound,\n          text: this._text,\n          style: this.style.toJSON(),\n          padding: {\n            left: this.padding.left, right: this.padding.right, top: this.padding.top, bottom: this.padding.bottom,\n          },\n        }; return t.data = e, t;\n      },\n      preDestroy() { this.style.rtl && u(this.canvas), r.remove(this.canvas), this.texture.destroy(); },\n    }); t.exports = f;\n  }, function (t, e, i) {\n    const u = i(26); const n = i(0); const s = i(12); const c = i(20); const d = i(14); const f = i(329); const o = i(167); const r = i(994); const p = i(3); const a = new n({\n      Extends: d, Mixins: [s.Alpha, s.BlendMode, s.ComputedSize, s.Crop, s.Depth, s.Flip, s.GetBounds, s.Mask, s.Origin, s.Pipeline, s.ScrollFactor, s.Tint, s.Transform, s.Visible, r], initialize(t, e, i, n, s, r, o) { const a = t.sys.game.renderer; d.call(this, t, 'TileSprite'); const h = t.sys.textures.get(r); const l = h.get(o); s = n && s ? (n = Math.floor(n), Math.floor(s)) : (n = l.width, l.height), this._tilePosition = new p(), this._tileScale = new p(1, 1), this.dirty = !1, this.renderer = a, this.canvas = u.create(this, n, s), this.context = this.canvas.getContext('2d'), this.displayTexture = h, this.displayFrame = l, this._crop = this.resetCropObject(), this.texture = t.sys.textures.addCanvas(null, this.canvas, !0), this.frame = this.texture.get(), this.potWidth = f(l.width), this.potHeight = f(l.height), this.fillCanvas = u.create2D(this, this.potWidth, this.potHeight), this.fillContext = this.fillCanvas.getContext('2d'), this.fillPattern = null, this.setPosition(e, i), this.setSize(n, s), this.setFrame(o), this.setOriginFromFrame(), this.initPipeline(), t.sys.game.events.on(c.CONTEXT_RESTORED, function (t) { const e = t.gl; this.dirty = !0, this.fillPattern = null, this.fillPattern = t.createTexture2D(0, e.LINEAR, e.LINEAR, e.REPEAT, e.REPEAT, e.RGBA, this.fillCanvas, this.potWidth, this.potHeight); }, this); }, setTexture(t, e) { return this.displayTexture = this.scene.sys.textures.get(t), this.setFrame(e); }, setFrame(t) { const e = this.displayTexture.get(t); return this.potWidth = f(e.width), this.potHeight = f(e.height), this.canvas.width = 0, e.cutWidth && e.cutHeight ? this.renderFlags |= 8 : this.renderFlags &= -9, this.displayFrame = e, this.dirty = !0, this.updateTileTexture(), this; }, setTilePosition(t, e) { return void 0 !== t && (this.tilePositionX = t), void 0 !== e && (this.tilePositionY = e), this; }, setTileScale(t, e) { return void 0 === t && (t = this.tileScaleX), void 0 === e && (e = t), this.tileScaleX = t, this.tileScaleY = e, this; }, updateTileTexture() { if (this.dirty && this.renderer) { const t = this.displayFrame; if (t.source.isRenderTexture || t.source.isGLTexture) return console.warn('TileSprites can only use Image or Canvas based textures'), void (this.dirty = !1); const e = this.fillContext; const i = this.fillCanvas; let n = this.potWidth; let s = this.potHeight; this.renderer.gl || (n = t.cutWidth, s = t.cutHeight), e.clearRect(0, 0, n, s), i.width = n, i.height = s, e.drawImage(t.source.image, t.cutX, t.cutY, t.cutWidth, t.cutHeight, 0, 0, n, s), this.renderer.gl ? this.fillPattern = this.renderer.canvasToTexture(i, this.fillPattern) : this.fillPattern = e.createPattern(i, 'repeat'), this.updateCanvas(), this.dirty = !1; } }, updateCanvas() { let t; let e; let i; let n; let s; const r = this.canvas; r.width === this.width && r.height === this.height || (r.width = this.width, r.height = this.height, this.frame.setSize(this.width, this.height), this.updateDisplayOrigin(), this.dirty = !0), !this.dirty || this.renderer && this.renderer.gl || (t = this.context, this.scene.sys.game.config.antialias || o.disable(t), e = this._tileScale.x, i = this._tileScale.y, n = this._tilePosition.x, s = this._tilePosition.y, t.clearRect(0, 0, this.width, this.height), t.save(), t.scale(e, i), t.translate(-n, -s), t.fillStyle = this.fillPattern, t.fillRect(n, s, this.width / e, this.height / i), t.restore()), this.dirty = !1; }, preDestroy() { this.renderer && this.renderer.gl && this.renderer.deleteTexture(this.fillPattern), u.remove(this.canvas), u.remove(this.fillCanvas), this.fillPattern = null, this.fillContext = null, this.fillCanvas = null, this.displayTexture = null, this.displayFrame = null, this.texture.destroy(), this.renderer = null; }, tilePositionX: { get() { return this._tilePosition.x; }, set(t) { this._tilePosition.x = t, this.dirty = !0; } }, tilePositionY: { get() { return this._tilePosition.y; }, set(t) { this._tilePosition.y = t, this.dirty = !0; } }, tileScaleX: { get() { return this._tileScale.x; }, set(t) { this._tileScale.x = t, this.dirty = !0; } }, tileScaleY: { get() { return this._tileScale.y; }, set(t) { this._tileScale.y = t, this.dirty = !0; } },\n    }); t.exports = a;\n  }, function (t, e, i) {\n    const n = i(0); const s = i(19); const r = i(12); const o = i(90); const a = i(20); const h = i(14); const l = i(59); const u = i(196); const c = i(997); const d = i(13); const f = new n({\n      Extends: h,\n      Mixins: [r.Alpha, r.BlendMode, r.Depth, r.Flip, r.GetBounds, r.Mask, r.Origin, r.Pipeline, r.ScrollFactor, r.Size, r.TextureCrop, r.Tint, r.Transform, r.Visible, c],\n      initialize(t, e, i, n) {\n        h.call(this, t, 'Video'), this.video = null, this.videoTexture = null, this.videoTextureSource = null, this.snapshotTexture = null, this.flipY = !1, this._key = u(), this.touchLocked = !0, this.playWhenUnlocked = !1, this.retryLimit = 20, this.retry = 0, this.retryInterval = 500, this._retryID = null, this._systemMuted = !1, this._codeMuted = !1, this._systemPaused = !1, this._codePaused = !1, this._callbacks = {\n          play: this.playHandler.bind(this), error: this.loadErrorHandler.bind(this), end: this.completeHandler.bind(this), time: this.timeUpdateHandler.bind(this), seeking: this.seekingHandler.bind(this), seeked: this.seekedHandler.bind(this),\n        }, this._crop = this.resetCropObject(), this.markers = {}, this._markerIn = -1, this._markerOut = d.MAX_SAFE_INTEGER, this._lastUpdate = 0, this._cacheKey = '', this._isSeeking = !1, this.removeVideoElementOnDestroy = !1, this.setPosition(e, i), this.initPipeline(), n && this.changeSource(n, !1); const s = t.sys.game.events; s.on(a.PAUSE, this.globalPause, this), s.on(a.RESUME, this.globalResume, this); const r = t.sys.sound; r && r.on(l.GLOBAL_MUTE, this.globalMute, this);\n      },\n      play(t, e, i) { if (this.touchLocked && this.playWhenUnlocked || this.isPlaying()) return this; const n = this.video; if (!n) return console.warn('Video not loaded'), this; void 0 === t && (t = n.loop); const s = this.scene.sys.sound; s && s.mute && this.setMute(!0), isNaN(e) || (this._markerIn = e), !isNaN(i) && e < i && (this._markerOut = i), n.loop = t; const r = this._callbacks; const o = n.play(); return void 0 !== o ? o.then(this.playPromiseSuccessHandler.bind(this)).catch(this.playPromiseErrorHandler.bind(this)) : (n.addEventListener('playing', r.play, !0), n.readyState < 2 && (this.retry = this.retryLimit, this._retryID = window.setTimeout(this.checkVideoProgress.bind(this), this.retryInterval))), n.addEventListener('ended', r.end, !0), n.addEventListener('timeupdate', r.time, !0), n.addEventListener('seeking', r.seeking, !0), n.addEventListener('seeked', r.seeked, !0), this; },\n      changeSource(t, e, i, n, s) { void 0 === e && (e = !0), this.video && this.stop(); const r = this.scene.sys.cache.video.get(t); return r ? (this.video = r, this._cacheKey = t, this._codePaused = r.paused, this._codeMuted = r.muted, this.videoTexture ? (this.scene.sys.textures.remove(this._key), this.videoTexture = this.scene.sys.textures.create(this._key, r, r.videoWidth, r.videoHeight), this.videoTextureSource = this.videoTexture.source[0], this.videoTexture.add('__BASE', 0, 0, 0, r.videoWidth, r.videoHeight), this.setTexture(this.videoTexture), this.setSizeToFrame(), this.updateDisplayOrigin(), this.emit(o.VIDEO_CREATED, this, r.videoWidth, r.videoHeight)) : this.updateTexture(), r.currentTime = 0, this._lastUpdate = 0, e && this.play(i, n, s)) : this.video = null, this; },\n      addMarker(t, e, i) { return !isNaN(e) && e >= 0 && !isNaN(i) && (this.markers[t] = [e, i]), this; },\n      playMarker(t, e) { const i = this.markers[t]; return i && this.play(e, i[0], i[1]), this; },\n      removeMarker(t) { return delete this.markers[t], this; },\n      snapshot(t, e) { return void 0 === t && (t = this.width), void 0 === e && (e = this.height), this.snapshotArea(0, 0, this.width, this.height, t, e); },\n      snapshotArea(t, e, i, n, s, r) { void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = this.width), void 0 === n && (n = this.height), void 0 === s && (s = i), void 0 === r && (r = n); const o = this.video; let a = this.snapshotTexture; return a ? a.setSize(s, r) : (a = this.scene.sys.textures.createCanvas(u(), s, r), this.snapshotTexture = a), o && a.context.drawImage(o, t, e, i, n, 0, 0, s, r), a.update(); },\n      saveSnapshotTexture(t) { return this.snapshotTexture ? this.scene.sys.textures.renameTexture(this.snapshotTexture.key, t) : this.snapshotTexture = this.scene.sys.textures.createCanvas(t, this.width, this.height), this.snapshotTexture; },\n      loadURL(t, e, i) { void 0 === e && (e = 'loadeddata'), void 0 === i && (i = !1), this.video && this.stop(), this.videoTexture && this.scene.sys.textures.remove(this._key); const n = document.createElement('video'); return n.controls = !1, i && (n.muted = !0, n.defaultMuted = !0, n.setAttribute('autoplay', 'autoplay')), n.setAttribute('playsinline', 'playsinline'), n.setAttribute('preload', 'auto'), n.addEventListener('error', this._callbacks.error, !0), n.src = t, n.load(), this.video = n, this; },\n      playPromiseSuccessHandler() { this.touchLocked = !1, this.emit(o.VIDEO_PLAY, this), this._markerIn > -1 && (this.video.currentTime = this._markerIn); },\n      playPromiseErrorHandler(t) { this.scene.sys.input.once('pointerdown', this.unlockHandler, this), this.touchLocked = !0, this.playWhenUnlocked = !0, this.emit(o.VIDEO_ERROR, this, t); },\n      playHandler() { this.touchLocked = !1, this.emit(o.VIDEO_PLAY, this), this.video.removeEventListener('playing', this._callbacks.play, !0); },\n      loadErrorHandler(t) { this.stop(), this.emit(o.VIDEO_ERROR, this, t); },\n      unlockHandler() { this.touchLocked = !1, this.playWhenUnlocked = !1, this.emit(o.VIDEO_UNLOCKED, this), this._markerIn > -1 && (this.video.currentTime = this._markerIn), this.video.play(), this.emit(o.VIDEO_PLAY, this); },\n      completeHandler() { this.emit(o.VIDEO_COMPLETE, this); },\n      timeUpdateHandler() { this.video && this.video.currentTime < this._lastUpdate && (this.emit(o.VIDEO_LOOP, this), this._lastUpdate = 0); },\n      preUpdate() { let t; const e = this.video; !e || (t = e.currentTime) !== this._lastUpdate && (this._lastUpdate = t, this.updateTexture(), t >= this._markerOut && (e.loop ? (e.currentTime = this._markerIn, this.updateTexture(), this._lastUpdate = t, this.emit(o.VIDEO_LOOP, this)) : (this.emit(o.VIDEO_COMPLETE, this), this.stop()))); },\n      checkVideoProgress() { this.video.readyState >= 2 ? this.updateTexture() : (this.retry--, this.retry > 0 ? this._retryID = window.setTimeout(this.checkVideoProgress.bind(this), this.retryInterval) : this.emit(o.VIDEO_TIMEOUT, this)); },\n      updateTexture() { let t; const e = this.video; const i = e.videoWidth; const n = e.videoHeight; this.videoTexture ? ((t = this.videoTextureSource).source !== e && (t.source = e, t.width = i, t.height = n), t.update()) : (this.videoTexture = this.scene.sys.textures.create(this._key, e, i, n), this.videoTextureSource = this.videoTexture.source[0], this.videoTexture.add('__BASE', 0, 0, 0, i, n), this.setTexture(this.videoTexture), this.setSizeToFrame(), this.updateDisplayOrigin(), this.emit(o.VIDEO_CREATED, this, i, n)); },\n      getVideoKey() { return this._cacheKey; },\n      seekTo(t) { let e; let i; const n = this.video; return n && ((e = n.duration) === 1 / 0 || isNaN(e) || (i = e * t, this.setCurrentTime(i))), this; },\n      getCurrentTime() { return this.video ? this.video.currentTime : 0; },\n      setCurrentTime(t) { let e; let i; const n = this.video; return n && (typeof t === 'string' && (e = t[0], i = parseFloat(t.substr(1)), e === '+' ? t = n.currentTime + i : e === '-' && (t = n.currentTime - i)), n.currentTime = t, this._lastUpdate = t), this; },\n      isSeeking() { return this._isSeeking; },\n      seekingHandler() { this._isSeeking = !0, this.emit(o.VIDEO_SEEKING, this); },\n      seekedHandler() { this._isSeeking = !1, this.emit(o.VIDEO_SEEKED, this), this.video && this.updateTexture(); },\n      getProgress() { const t = this.video; if (t) { const e = t.currentTime; const i = t.duration; if (i !== 1 / 0 && !isNaN(i)) return e / i; } return 0; },\n      getDuration() { return this.video ? this.video.duration : 0; },\n      setMute(t) { void 0 === t && (t = !0), this._codeMuted = t; const e = this.video; return e && (e.muted = !!this._systemMuted || t), this; },\n      isMuted() { return this._codeMuted; },\n      globalMute(t, e) { this._systemMuted = e; const i = this.video; i && (i.muted = !!this._codeMuted || e); },\n      globalPause() { this._systemPaused = !0, this.video && this.video.pause(); },\n      globalResume() { this._systemPaused = !1, this.video && !this._codePaused && this.video.play(); },\n      setPaused(t) { void 0 === t && (t = !0); const e = this.video; return this._codePaused = t, e && (t ? e.paused || e.pause() : t || e.paused && !this._systemPaused && e.play()), this; },\n      getVolume() { return this.video ? this.video.volume : 1; },\n      setVolume(t) { return void 0 === t && (t = 1), this.video && (this.video.volume = s(t, 0, 1)), this; },\n      getPlaybackRate() { return this.video ? this.video.playbackRate : 1; },\n      setPlaybackRate(t) { return this.video && (this.video.playbackRate = t), this; },\n      getLoop() { return !!this.video && this.video.loop; },\n      setLoop(t) { return void 0 === t && (t = !0), this.video && (this.video.loop = t), this; },\n      isPlaying() { return !!this.video && !(this.video.paused || this.video.ended); },\n      isPaused() { return this.video && this.video.paused || this._codePaused || this._systemPaused; },\n      saveTexture(t, e) { return void 0 === e && (e = !1), this.videoTexture && this.scene.sys.textures.renameTexture(this._key, t), this._key = t, this.flipY = e, this.videoTextureSource && this.videoTextureSource.setFlipY(e), this.videoTexture; },\n      stop() { const t = this.video; if (t) { const e = this._callbacks; for (const i in e)t.removeEventListener(i, e[i], !0); t.pause(); } return this._retryID && window.clearTimeout(this._retryID), this.emit(o.VIDEO_STOP, this), this; },\n      removeVideoElement() { const t = this.video; if (t) { for (t.parentNode && t.parentNode.removeChild(t); t.hasChildNodes();)t.removeChild(t.firstChild); t.removeAttribute('autoplay'), t.removeAttribute('src'), this.video = null; } },\n      preDestroy() { this.stop(), this.removeVideoElementOnDestroy && this.removeVideoElement(); const t = this.scene.sys.game.events; t.off(a.PAUSE, this.globalPause, this), t.off(a.RESUME, this.globalResume, this); const e = this.scene.sys.sound; e && e.off(l.GLOBAL_MUTE, this.globalMute, this), this._retryID && window.clearTimeout(this._retryID); },\n    }); t.exports = f;\n  }, function (t, e, i) {\n    const n = i(0); const s = i(202); const r = i(419); const o = i(47); const a = new n({\n      initialize(t) { this.type = o.POLYGON, this.area = 0, this.points = [], t && this.setTo(t); }, contains(t, e) { return s(this, t, e); }, setTo(t) { if (this.area = 0, this.points = [], typeof t === 'string' && (t = t.split(' ')), !Array.isArray(t)) return this; for (var e, i = Number.MAX_VALUE, n = 0; n < t.length; n++)e = { x: 0, y: 0 }, typeof t[n] === 'number' || typeof t[n] === 'string' ? (e.x = parseFloat(t[n]), e.y = parseFloat(t[n + 1]), n++) : Array.isArray(t[n]) ? (e.x = t[n][0], e.y = t[n][1]) : (e.x = t[n].x, e.y = t[n].y), this.points.push(e), e.y < i && (i = e.y); return this.calculateArea(i), this; }, calculateArea() { if (this.points.length < 3) return this.area = 0, this.area; for (var t, e, i = 0, n = 0; n < this.points.length - 1; n++)t = this.points[n], i += ((e = this.points[n + 1]).x - t.x) * (t.y + e.y); return t = this.points[0], e = this.points[this.points.length - 1], i += (t.x - e.x) * (e.y + t.y), this.area = 0.5 * -i, this.area; }, getPoints(t, e, i) { return r(this, t, e, i); },\n    }); t.exports = a;\n  }, function (t, e) { t.exports = function (t, e, i) { for (var n = !1, s = -1, r = t.points.length - 1; ++s < t.points.length; r = s) { const o = t.points[s].x; const a = t.points[s].y; const h = t.points[r].x; const l = t.points[r].y; (a <= i && i < l || l <= i && i < a) && e < (h - o) * (i - a) / (l - a) + o && (n = !n); } return n; }; }, function (t, e, i) {\n    const n = i(0); const r = i(134); const s = new n({\n      Extends: r, initialize(t, e, i, n, s) { r.call(this, t, e, i, [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0], [16777215, 16777215, 16777215, 16777215, 16777215, 16777215], [1, 1, 1, 1, 1, 1], n, s), this.resetPosition(); }, setFrame(t) { return this.frame = this.texture.get(t), this.frame.cutWidth && this.frame.cutHeight ? this.renderFlags |= 8 : this.renderFlags &= -9, t = this.frame, this.uv[0] = t.u0, this.uv[1] = t.v0, this.uv[2] = t.u0, this.uv[3] = t.v1, this.uv[4] = t.u1, this.uv[5] = t.v1, this.uv[6] = t.u0, this.uv[7] = t.v0, this.uv[8] = t.u1, this.uv[9] = t.v1, this.uv[10] = t.u1, this.uv[11] = t.v0, this; }, topLeftX: { get() { return this.x + this.vertices[0]; }, set(t) { this.vertices[0] = t - this.x, this.vertices[6] = t - this.x; } }, topLeftY: { get() { return this.y + this.vertices[1]; }, set(t) { this.vertices[1] = t - this.y, this.vertices[7] = t - this.y; } }, topRightX: { get() { return this.x + this.vertices[10]; }, set(t) { this.vertices[10] = t - this.x; } }, topRightY: { get() { return this.y + this.vertices[11]; }, set(t) { this.vertices[11] = t - this.y; } }, bottomLeftX: { get() { return this.x + this.vertices[2]; }, set(t) { this.vertices[2] = t - this.x; } }, bottomLeftY: { get() { return this.y + this.vertices[3]; }, set(t) { this.vertices[3] = t - this.y; } }, bottomRightX: { get() { return this.x + this.vertices[4]; }, set(t) { this.vertices[4] = t - this.x, this.vertices[8] = t - this.x; } }, bottomRightY: { get() { return this.y + this.vertices[5]; }, set(t) { this.vertices[5] = t - this.y, this.vertices[9] = t - this.y; } }, topLeftAlpha: { get() { return this.alphas[0]; }, set(t) { this.alphas[0] = t, this.alphas[3] = t; } }, topRightAlpha: { get() { return this.alphas[5]; }, set(t) { this.alphas[5] = t; } }, bottomLeftAlpha: { get() { return this.alphas[1]; }, set(t) { this.alphas[1] = t; } }, bottomRightAlpha: { get() { return this.alphas[2]; }, set(t) { this.alphas[2] = t, this.alphas[4] = t; } }, topLeftColor: { get() { return this.colors[0]; }, set(t) { this.colors[0] = t, this.colors[3] = t; } }, topRightColor: { get() { return this.colors[5]; }, set(t) { this.colors[5] = t; } }, bottomLeftColor: { get() { return this.colors[1]; }, set(t) { this.colors[1] = t; } }, bottomRightColor: { get() { return this.colors[2]; }, set(t) { this.colors[2] = t, this.colors[4] = t; } }, setTopLeft(t, e) { return this.topLeftX = t, this.topLeftY = e, this; }, setTopRight(t, e) { return this.topRightX = t, this.topRightY = e, this; }, setBottomLeft(t, e) { return this.bottomLeftX = t, this.bottomLeftY = e, this; }, setBottomRight(t, e) { return this.bottomRightX = t, this.bottomRightY = e, this; }, resetPosition() { const t = this.x; const e = this.y; const i = Math.floor(this.width / 2); const n = Math.floor(this.height / 2); return this.setTopLeft(t - i, e - n), this.setTopRight(t + i, e - n), this.setBottomLeft(t - i, e + n), this.setBottomRight(t + i, e + n), this; }, resetAlpha() { const t = this.alphas; return t[0] = 1, t[1] = 1, t[2] = 1, t[3] = 1, t[4] = 1, t[5] = 1, this; }, resetColors() { const t = this.colors; return t[0] = 16777215, t[1] = 16777215, t[2] = 16777215, t[3] = 16777215, t[4] = 16777215, t[5] = 16777215, this; }, reset() { return this.resetPosition(), this.resetAlpha(), this.resetColors(); },\n    }); t.exports = s;\n  }, function (t, e, i) {\n    const n = i(0); const s = i(12); const l = i(14); const c = i(2); const u = i(18); const r = i(427); const o = i(1080); const d = i(29); const a = new n({\n      Extends: l,\n      Mixins: [s.ComputedSize, s.Depth, s.GetBounds, s.Mask, s.Origin, s.ScrollFactor, s.Transform, s.Visible, o],\n      initialize(t, e, i, n, s, r, o, a) { void 0 === i && (i = 0), void 0 === n && (n = 0), void 0 === s && (s = 128), void 0 === r && (r = 128), l.call(this, t, 'Shader'), this.blendMode = -1, this.shader; const h = t.sys.renderer; this.renderer = h, this.gl = h.gl, this.vertexData = new ArrayBuffer(2 * Float32Array.BYTES_PER_ELEMENT * 6), this.vertexBuffer = h.createVertexBuffer(this.vertexData.byteLength, this.gl.STREAM_DRAW), this.program = null, this.bytes = new Uint8Array(this.vertexData), this.vertexViewF32 = new Float32Array(this.vertexData), this._tempMatrix1 = new d(), this._tempMatrix2 = new d(), this._tempMatrix3 = new d(), this.viewMatrix = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]), this.projectionMatrix = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]), this.uniforms = {}, this.pointer = null, this._rendererWidth = h.width, this._rendererHeight = h.height, this._textureCount = 0, this.framebuffer = null, this.glTexture = null, this.renderToTexture = !1, this.texture = null, this.setPosition(i, n), this.setSize(s, r), this.setOrigin(0.5, 0.5), this.setShader(e, o, a); },\n      willRender(t) { return !!this.renderToTexture || !(l.RENDER_MASK !== this.renderFlags || this.cameraFilter !== 0 && this.cameraFilter & t.id); },\n      setRenderToTexture(t, e) { let i; let n; let s; let r; return void 0 === e && (e = !1), this.renderToTexture || (i = this.width, n = this.height, s = this.renderer, this.glTexture = s.createTextureFromSource(null, i, n, 0), this.glTexture.flipY = e, this.framebuffer = s.createFramebuffer(i, n, this.glTexture, !1), this._rendererWidth = i, this._rendererHeight = n, this.renderToTexture = !0, this.projOrtho(0, this.width, this.height, 0), t && (this.texture = this.scene.sys.textures.addGLTexture(t, this.glTexture, i, n))), this.shader && (r = s.currentPipeline, s.clearPipeline(), this.load(), this.flush(), s.rebindPipeline(r)), this; },\n      setShader(t, e, i) {\n        if (void 0 === e && (e = []), typeof t === 'string') { const n = this.scene.sys.cache.shader; if (!n.has(t)) return console.warn(`Shader missing: ${t}`), this; this.shader = n.get(t); } else this.shader = t; const s = this.gl; const r = this.renderer; this.program && s.deleteProgram(this.program); const o = r.createProgram(this.shader.vertexSrc, this.shader.fragmentSrc); r.setMatrix4(o, 'uViewMatrix', !1, this.viewMatrix), r.setMatrix4(o, 'uProjectionMatrix', !1, this.projectionMatrix), r.setFloat2(o, 'uResolution', this.width, this.height), this.program = o; const a = new Date(); const\n          h = {\n            resolution: { type: '2f', value: { x: this.width, y: this.height } }, time: { type: '1f', value: 0 }, mouse: { type: '2f', value: { x: this.width / 2, y: this.height / 2 } }, date: { type: '4fv', value: [a.getFullYear(), a.getMonth(), a.getDate(), 60 * a.getHours() * 60 + 60 * a.getMinutes() + a.getSeconds()] }, sampleRate: { type: '1f', value: 44100 }, iChannel0: { type: 'sampler2D', value: null, textureData: { repeat: !0 } }, iChannel1: { type: 'sampler2D', value: null, textureData: { repeat: !0 } }, iChannel2: { type: 'sampler2D', value: null, textureData: { repeat: !0 } }, iChannel3: { type: 'sampler2D', value: null, textureData: { repeat: !0 } },\n          }; this.shader.uniforms ? this.uniforms = u(!0, {}, this.shader.uniforms, h) : this.uniforms = h; for (let l = 0; l < 4; l++)e[l] && this.setSampler2D(`iChannel${l}`, e[l], l, i); return this.initUniforms(), this.projOrtho(0, this._rendererWidth, this._rendererHeight, 0), this;\n      },\n      setPointer(t) { return this.pointer = t, this; },\n      projOrtho(t, e, i, n) { const s = 1 / (t - e); const r = 1 / (i - n); const o = this.projectionMatrix; o[0] = -2 * s, o[5] = -2 * r, o[10] = -0.001, o[12] = (t + e) * s, o[13] = (n + i) * r, o[14] = -0; const a = this.program; this.renderer.setMatrix4(a, 'uProjectionMatrix', !1, this.projectionMatrix), this._rendererWidth = e, this._rendererHeight = i; },\n      initUniforms() { const t = this.gl; const e = this.renderer.glFuncMap; const i = this.program; for (const n in this._textureCount = 0, this.uniforms) { const s = this.uniforms[n]; const r = s.type; const o = e[r]; s.uniformLocation = t.getUniformLocation(i, n), r !== 'sampler2D' && (s.glMatrix = o.matrix, s.glValueLength = o.length, s.glFunc = o.func); } },\n      setSampler2DBuffer(t, e, i, n, s, r) { void 0 === s && (s = 0), void 0 === r && (r = {}); const o = this.uniforms[t]; return o.value = e, r.width = i, r.height = n, o.textureData = r, this._textureCount = s, this.initSampler2D(o), this; },\n      setSampler2D(t, e, i, n) { void 0 === i && (i = 0); let s; let r; let o; const a = this.scene.sys.textures; return a.exists(e) && (s = a.getFrame(e), r = this.uniforms[t], o = s.source, r.textureKey = e, r.source = o.image, r.value = s.glTexture, o.isGLTexture && ((n = n || {}).width = o.width, n.height = o.height), n && (r.textureData = n), this._textureCount = i, this.initSampler2D(r)), this; },\n      setUniform(t, e) { return r(this.uniforms, t, e), this; },\n      getUniform(t) { return c(this.uniforms, t, null); },\n      setChannel0(t, e) { return this.setSampler2D('iChannel0', t, 0, e); },\n      setChannel1(t, e) { return this.setSampler2D('iChannel1', t, 1, e); },\n      setChannel2(t, e) { return this.setSampler2D('iChannel2', t, 2, e); },\n      setChannel3(t, e) { return this.setSampler2D('iChannel3', t, 3, e); },\n      initSampler2D(t) { let e; let i; let n; let s; let r; let o; let a; let h; let l; let u; t.value && ((e = this.gl).activeTexture(e.TEXTURE0 + this._textureCount), e.bindTexture(e.TEXTURE_2D, t.value), (i = t.textureData) && (n = e[c(i, 'magFilter', 'linear').toUpperCase()], s = e[c(i, 'minFilter', 'linear').toUpperCase()], r = e[c(i, 'wrapS', 'repeat').toUpperCase()], o = e[c(i, 'wrapT', 'repeat').toUpperCase()], a = e[c(i, 'format', 'rgba').toUpperCase()], i.repeat && (r = e.REPEAT, o = e.REPEAT), e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL, !!i.flipY), i.width ? (h = c(i, 'width', 512), l = c(i, 'height', 2), u = c(i, 'border', 0), e.texImage2D(e.TEXTURE_2D, 0, a, h, l, u, a, e.UNSIGNED_BYTE, null)) : e.texImage2D(e.TEXTURE_2D, 0, a, e.RGBA, e.UNSIGNED_BYTE, t.source), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, n), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, s), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, r), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, o)), this.renderer.setProgram(this.program), e.uniform1i(t.uniformLocation, this._textureCount), this._textureCount++); },\n      syncUniforms() { let t; let e; let i; let n; let s; const r = this.gl; const o = this.uniforms; let a = 0; for (const h in o)i = (t = o[h]).glFunc, e = t.glValueLength, n = t.uniformLocation, (s = t.value) !== null && (e === 1 ? t.glMatrix ? i.call(r, n, t.transpose, s) : i.call(r, n, s) : e === 2 ? i.call(r, n, s.x, s.y) : e === 3 ? i.call(r, n, s.x, s.y, s.z) : e === 4 ? i.call(r, n, s.x, s.y, s.z, s.w) : t.type === 'sampler2D' && (r.activeTexture(r[`TEXTURE${a}`]), r.bindTexture(r.TEXTURE_2D, s), r.uniform1i(n, a), a++)); },\n      load(t) { let e; let i; const n = this.gl; const s = this.width; const r = this.height; const o = this.renderer; const a = this.program; const h = this.viewMatrix; this.renderToTexture || (e = -this._displayOriginX, i = -this._displayOriginY, h[0] = t[0], h[1] = t[1], h[4] = t[2], h[5] = t[3], h[8] = t[4], h[9] = t[5], h[12] = h[0] * e + h[4] * i, h[13] = h[1] * e + h[5] * i), n.useProgram(a), n.uniformMatrix4fv(n.getUniformLocation(a, 'uViewMatrix'), !1, h), n.uniform2f(n.getUniformLocation(a, 'uResolution'), this.width, this.height); const l = this.uniforms; const u = l.resolution; u.value.x = s, u.value.y = r, l.time.value = o.game.loop.getDuration(); let c; let d; let f; const p = this.pointer; p && (c = l.mouse, d = p.x / s, f = 1 - p.y / r, c.value.x = d.toFixed(2), c.value.y = f.toFixed(2)), this.syncUniforms(); },\n      flush() { const t = this.width; const e = this.height; const i = this.program; const n = this.gl; const s = this.vertexBuffer; const r = this.renderer; const o = 2 * Float32Array.BYTES_PER_ELEMENT; this.renderToTexture && (r.setFramebuffer(this.framebuffer), n.clearColor(0, 0, 0, 0), n.clear(n.COLOR_BUFFER_BIT)), n.bindBuffer(n.ARRAY_BUFFER, s); const a = n.getAttribLocation(i, 'inPosition'); a !== -1 && (n.enableVertexAttribArray(a), n.vertexAttribPointer(a, 2, n.FLOAT, !1, o, 0)); const h = this.vertexViewF32; h[3] = e, h[4] = t, h[5] = e, h[8] = t, h[9] = e, h[10] = t; n.bufferSubData(n.ARRAY_BUFFER, 0, this.bytes.subarray(0, 6 * o)), n.drawArrays(n.TRIANGLES, 0, 6), this.renderToTexture && r.setFramebuffer(null, !1); },\n      setAlpha() {},\n      setBlendMode() {},\n      preDestroy() { const t = this.gl; t.deleteProgram(this.program), t.deleteBuffer(this.vertexBuffer), this.renderToTexture && (this.renderer.deleteFramebuffer(this.framebuffer), this.texture.destroy(), this.framebuffer = null, this.glTexture = null, this.texture = null); },\n    }); t.exports = a;\n  }, function (t, e, i) { const n = i(53); t.exports = function (t, e) { return n(t.x, t.y, e.x, e.y) <= t.radius + e.radius; }; }, function (t, e) { t.exports = function (t, e) { const i = e.width / 2; const n = e.height / 2; const s = Math.abs(t.x - e.x - i); const r = Math.abs(t.y - e.y - n); const o = i + t.radius; const a = n + t.radius; if (o < s || a < r) return !1; if (s <= i || r <= n) return !0; const h = s - i; const l = r - n; return h * h + l * l <= t.radius * t.radius; }; }, function (t, e, i) { const T = i(4); const w = i(208); t.exports = function (t, e, i) { let n; let s; let r; let o; let a; let h; let l; let u; let c; let d; let f; let p; let g; let v; let m; let y; let x; return void 0 === i && (i = []), w(t, e) && (n = t.x1, s = t.y1, r = t.x2, o = t.y2, (p = (f = 2 * ((h = r - n) * (u = n - e.x) + (l = o - s) * (c = s - e.y))) * f - 4 * (d = h * h + l * l) * (u * u + c * c - (a = e.radius) * a)) == 0 ? (v = n + (g = -f / (2 * d)) * h, m = s + g * l, g >= 0 && g <= 1 && i.push(new T(v, m))) : p > 0 && (v = n + (y = (-f - Math.sqrt(p)) / (2 * d)) * h, m = s + y * l, y >= 0 && y <= 1 && i.push(new T(v, m)), v = n + (x = (-f + Math.sqrt(p)) / (2 * d)) * h, m = s + x * l, x >= 0 && x <= 1 && i.push(new T(v, m)))), i; }; }, function (t, e, i) { const c = i(55); const d = new (i(4))(); t.exports = function (t, e, i) { if (void 0 === i && (i = d), c(e, t.x1, t.y1)) return i.x = t.x1, i.y = t.y1, !0; if (c(e, t.x2, t.y2)) return i.x = t.x2, i.y = t.y2, !0; let n; const s = t.x2 - t.x1; const r = t.y2 - t.y1; const o = e.x - t.x1; const a = e.y - t.y1; const h = s * s + r * r; let l = s; let u = r; return h > 0 && (l *= n = (o * s + a * r) / h, u *= n), i.x = t.x1 + l, i.y = t.y1 + u, l * l + u * u <= h && l * s + u * r >= 0 && c(e, i.x, i.y); }; }, function (t, e, i) { const u = i(4); const c = i(84); const d = i(432); t.exports = function (t, e, i) { if (void 0 === i && (i = []), d(t, e)) for (let n = e.getLineA(), s = e.getLineB(), r = e.getLineC(), o = e.getLineD(), a = [new u(), new u(), new u(), new u()], h = [c(n, t, a[0]), c(s, t, a[1]), c(r, t, a[2]), c(o, t, a[3])], l = 0; l < 4; l++)h[l] && i.push(a[l]); return i; }; }, function (t, e) { t.exports = function (t, e, i, n) { void 0 === i && (i = !1), void 0 === n && (n = []); for (var s, r, o, a, h, l, u = t.x3 - t.x1, c = t.y3 - t.y1, d = t.x2 - t.x1, f = t.y2 - t.y1, p = u * u + c * c, g = u * d + c * f, v = d * d + f * f, m = p * v - g * g, y = m == 0 ? 0 : 1 / m, x = t.x1, T = t.y1, w = 0; w < e.length && (r = (p * (l = d * (o = e[w].x - x) + f * (a = e[w].y - T)) - g * (h = u * o + c * a)) * y, !((s = (v * h - g * l) * y) >= 0 && r >= 0 && s + r < 1 && (n.push({ x: e[w].x, y: e[w].y }), i))); w++);return n; }; }, function (t, e) { t.exports = function (t, e, i, n) { const s = Math.cos(n); const r = Math.sin(n); let o = t.x1 - e; let a = t.y1 - i; return t.x1 = o * s - a * r + e, t.y1 = o * r + a * s + i, o = t.x2 - e, a = t.y2 - i, t.x2 = o * s - a * r + e, t.y2 = o * r + a * s + i, t; }; }, function (t, e) { t.exports = function (t) { return t.height === 0 ? NaN : t.width / t.height; }; }, function (t, e) { t.exports = function (t, e, i, n) { const s = Math.cos(n); const r = Math.sin(n); let o = t.x1 - e; let a = t.y1 - i; return t.x1 = o * s - a * r + e, t.y1 = o * r + a * s + i, o = t.x2 - e, a = t.y2 - i, t.x2 = o * s - a * r + e, t.y2 = o * r + a * s + i, o = t.x3 - e, a = t.y3 - i, t.x3 = o * s - a * r + e, t.y3 = o * r + a * s + i, t; }; }, function (t, e, i) {\n    t.exports = {\n      BUTTON_DOWN: i(1203), BUTTON_UP: i(1204), CONNECTED: i(1205), DISCONNECTED: i(1206), GAMEPAD_BUTTON_DOWN: i(1207), GAMEPAD_BUTTON_UP: i(1208),\n    };\n  }, function (t, e, i) { const s = i(18); const r = i(139); t.exports = function (t, e) { const i = void 0 === t ? r() : s({}, t); if (e) for (const n in e) void 0 !== e[n] && (i[n] = e[n]); return i; }; }, function (t, e, i) {\n    const n = i(0); const s = i(17); const a = i(21); const r = i(8); const h = i(2); const l = i(7); const o = i(364); const u = new n({\n      Extends: a,\n      initialize(t, e, i, n) {\n        let s; let r = 'xml'; l(e) && (e = h(s = e, 'key'), i = h(s, 'url'), n = h(s, 'xhrSettings'), r = h(s, 'extension', r)); const o = {\n          type: 'xml', cache: t.cacheManager.xml, extension: r, responseType: 'text', key: e, url: i, xhrSettings: n,\n        }; a.call(this, t, o);\n      },\n      onProcess() { this.state = s.FILE_PROCESSING, this.data = o(this.xhrLoader.responseText), this.data ? this.onProcessComplete() : (console.warn(`Invalid XMLFile: ${this.key}`), this.onProcessError()); },\n    }); r.register('xml', function (t, e, i) { if (Array.isArray(t)) for (let n = 0; n < t.length; n++) this.addFile(new u(this, t[n])); else this.addFile(new u(this, t, e, i)); return this; }), t.exports = u;\n  }, function (t, e, i) {\n    t.exports = {\n      Acceleration: i(1263), Angular: i(1264), Bounce: i(1265), Debug: i(1266), Drag: i(1267), Enable: i(1268), Friction: i(1269), Gravity: i(1270), Immovable: i(1271), Mass: i(1272), Size: i(1273), Velocity: i(1274),\n    };\n  }, function (t, e, i) {\n    t.exports = {\n      COLLIDE: i(1276), OVERLAP: i(1277), PAUSE: i(1278), RESUME: i(1279), TILE_COLLIDE: i(1280), TILE_OVERLAP: i(1281), WORLD_BOUNDS: i(1282), WORLD_STEP: i(1283),\n    };\n  }, function (t, e, i) {\n    const w = {}; t.exports = w; const o = i(86); const b = i(99); const a = i(239); const h = i(100); const l = i(513); const u = i(42); w._warming = 0.4, w._torqueDampen = 1, w._minLength = 1e-6, w.create = function (t) {\n      const e = t; e.bodyA && !e.pointA && (e.pointA = { x: 0, y: 0 }), e.bodyB && !e.pointB && (e.pointB = { x: 0, y: 0 }); const i = e.bodyA ? b.add(e.bodyA.position, e.pointA) : e.pointA; const n = e.bodyB ? b.add(e.bodyB.position, e.pointB) : e.pointB; const s = b.magnitude(b.sub(i, n)); e.length = void 0 !== e.length ? e.length : s, e.id = e.id || u.nextId(), e.label = e.label || 'Constraint', e.type = 'constraint', e.stiffness = e.stiffness || (e.length > 0 ? 1 : 0.7), e.damping = e.damping || 0, e.angularStiffness = e.angularStiffness || 0, e.angleA = e.bodyA ? e.bodyA.angle : e.angleA, e.angleB = e.bodyB ? e.bodyB.angle : e.angleB, e.plugin = {}; const r = {\n        visible: !0, type: 'line', anchors: !0, lineColor: null, lineOpacity: null, lineThickness: null, pinSize: null, anchorColor: null, anchorSize: null,\n      }; return e.length === 0 && e.stiffness > 0.1 ? (r.type = 'pin', r.anchors = !1) : e.stiffness < 0.9 && (r.type = 'spring'), e.render = u.extend(r, e.render), e;\n    }, w.preSolveAll = function (t) { for (let e = 0; e < t.length; e += 1) { const i = t[e]; const n = i.constraintImpulse; i.isStatic || n.x === 0 && n.y === 0 && n.angle === 0 || (i.position.x += n.x, i.position.y += n.y, i.angle += n.angle); } }, w.solveAll = function (t, e) { for (var i = 0; i < t.length; i += 1) { var n = t[i]; var s = !n.bodyA || n.bodyA && n.bodyA.isStatic; var r = !n.bodyB || n.bodyB && n.bodyB.isStatic; (s || r) && w.solve(t[i], e); } for (i = 0; i < t.length; i += 1)s = !(n = t[i]).bodyA || n.bodyA && n.bodyA.isStatic, r = !n.bodyB || n.bodyB && n.bodyB.isStatic, s || r || w.solve(t[i], e); }, w.solve = function (t, e) { let i; let n; let s; let r; let o; let a; let h; let l; let u; let c; let d; let f; let p; let g; let v; const m = t.bodyA; const y = t.bodyB; const x = t.pointA; const T = t.pointB; (m || y) && (m && !m.isStatic && (b.rotate(x, m.angle - t.angleA, x), t.angleA = m.angle), y && !y.isStatic && (b.rotate(T, y.angle - t.angleB, T), t.angleB = y.angle), i = x, n = T, m && (i = b.add(m.position, x)), y && (n = b.add(y.position, T)), i && n && (s = b.sub(i, n), (r = b.magnitude(s)) < w._minLength && (r = w._minLength), o = (r - t.length) / r, a = t.stiffness < 1 ? t.stiffness * e : t.stiffness, h = b.mult(s, o * a), u = (l = (m ? m.inverseMass : 0) + (y ? y.inverseMass : 0)) + ((m ? m.inverseInertia : 0) + (y ? y.inverseInertia : 0)), t.damping && (f = b.create(), p = b.div(s, r), g = b.sub(y && b.sub(y.position, y.positionPrev) || f, m && b.sub(m.position, m.positionPrev) || f), v = b.dot(p, g)), m && !m.isStatic && (d = m.inverseMass / l, m.constraintImpulse.x -= h.x * d, m.constraintImpulse.y -= h.y * d, m.position.x -= h.x * d, m.position.y -= h.y * d, t.damping && (m.positionPrev.x -= t.damping * p.x * v * d, m.positionPrev.y -= t.damping * p.y * v * d), c = b.cross(x, h) / u * w._torqueDampen * m.inverseInertia * (1 - t.angularStiffness), m.constraintImpulse.angle -= c, m.angle -= c), y && !y.isStatic && (d = y.inverseMass / l, y.constraintImpulse.x += h.x * d, y.constraintImpulse.y += h.y * d, y.position.x += h.x * d, y.position.y += h.y * d, t.damping && (y.positionPrev.x += t.damping * p.x * v * d, y.positionPrev.y += t.damping * p.y * v * d), c = b.cross(T, h) / u * w._torqueDampen * y.inverseInertia * (1 - t.angularStiffness), y.constraintImpulse.angle += c, y.angle += c))); }, w.postSolveAll = function (t) { for (let e = 0; e < t.length; e++) { const i = t[e]; const n = i.constraintImpulse; if (!(i.isStatic || n.x === 0 && n.y === 0 && n.angle === 0)) { a.set(i, !1); for (let s = 0; s < i.parts.length; s++) { const r = i.parts[s]; o.translate(r.vertices, n), s > 0 && (r.position.x += n.x, r.position.y += n.y), n.angle !== 0 && (o.rotate(r.vertices, n.angle, i.position), l.rotate(r.axes, n.angle), s > 0 && b.rotateAbout(r.position, n.angle, i.position, r.position)), h.update(r.bounds, r.vertices, i.velocity); }n.angle *= w._warming, n.x *= w._warming, n.y *= w._warming; } } }, w.pointAWorld = function (t) { return { x: (t.bodyA ? t.bodyA.position.x : 0) + t.pointA.x, y: (t.bodyA ? t.bodyA.position.y : 0) + t.pointA.y }; }, w.pointBWorld = function (t) { return { x: (t.bodyB ? t.bodyB.position.x : 0) + t.pointB.x, y: (t.bodyB ? t.bodyB.position.y : 0) + t.pointB.y }; };\n  }, function (t, e, i) { const l = i(142); t.exports = function (t, e, i) { const n = l(t, e, !0, i); const s = l(t, e - 1, !0, i); const r = l(t, e + 1, !0, i); const o = l(t - 1, e, !0, i); const a = l(t + 1, e, !0, i); const h = n && n.collides; return h && (n.faceTop = !0, n.faceBottom = !0, n.faceLeft = !0, n.faceRight = !0), s && s.collides && (h && (n.faceTop = !1), s.faceBottom = !h), r && r.collides && (h && (n.faceBottom = !1), r.faceTop = !h), o && o.collides && (h && (n.faceLeft = !1), o.faceRight = !h), a && a.collides && (h && (n.faceRight = !1), a.faceLeft = !h), n && !n.collides && n.resetFaces(), n; }; }, function (t, e, i) { const u = i(74); const c = i(101); const d = i(220); const f = i(73); t.exports = function (t, e, i, n, s) { if (!c(e, i, s)) return null; void 0 === n && (n = !0); let r; const o = s.data[i][e]; const a = o && o.collides; t instanceof u ? (s.data[i][e] === null && (s.data[i][e] = new u(s, t.index, e, i, t.width, t.height)), s.data[i][e].copy(t)) : (r = t, s.data[i][e] === null ? s.data[i][e] = new u(s, r, e, i, s.tileWidth, s.tileHeight) : s.data[i][e].index = r); const h = s.data[i][e]; const l = s.collideIndexes.indexOf(h.index) !== -1; return f(h, l), n && a !== h.collides && d(e, i, s), h; }; }, function (t, e) { t.exports = function (t, e, i) { const n = i.collideIndexes.indexOf(t); e && n === -1 ? i.collideIndexes.push(t) : e || n === -1 || i.collideIndexes.splice(n, 1); }; }, function (t, e, i) {\n    const p = i(32); const g = i(102); const v = i(103); const m = i(74); t.exports = function (t, e, i, n, s) {\n      for (var r = new g({ tileWidth: i, tileHeight: n }), o = new v({\n          name: t, tileWidth: i, tileHeight: n, format: p.ARRAY_2D, layers: [r],\n        }), a = [], h = e.length, l = 0, u = 0; u < e.length; u++) { a[u] = []; for (var c = e[u], d = 0; d < c.length; d++) { const f = parseInt(c[d], 10); isNaN(f) || f === -1 ? a[u][d] = s ? null : new m(r, -1, d, u, i, n) : a[u][d] = new m(r, f, d, u, i, n); }l === 0 && (l = c.length); } return o.width = r.width = l, o.height = r.height = h, o.widthInPixels = r.widthInPixels = l * i, o.heightInPixels = r.heightInPixels = h * n, r.data = a, o;\n    };\n  }, function (t, e) {\n    t.exports = function (t) {\n      const e = Boolean(2147483648 & t); const i = Boolean(1073741824 & t); const n = Boolean(536870912 & t); t &= 536870911; let s = 0; let r = !1; return e && i && n ? (s = Math.PI / 2, r = !0) : e && i && !n ? (s = Math.PI, r = !1) : e && !i && n ? (s = Math.PI / 2, r = !1) : !e || i || n ? !e && i && n ? (s = 3 * Math.PI / 2, r = !1) : e || !i || n ? e || i || !n ? e || i || n || (s = 0, r = !1) : (s = 3 * Math.PI / 2, r = !0) : (s = Math.PI, r = !0) : r = !(s = 0), {\n        gid: t, flippedHorizontal: e, flippedVertical: i, flippedAntiDiagonal: n, rotation: s, flipped: r,\n      };\n    };\n  }, function (t, e, i) {\n    const r = i(2); t.exports = function (t, e, i) {\n      if (!e) {\n        return {\n          i: 0, layers: t.layers, name: '', opacity: 1, visible: !0, x: 0, y: 0,\n        };\n      } const n = e.x + r(e, 'startx', 0) * t.tilewidth + r(e, 'offsetx', 0); const s = e.y + r(e, 'starty', 0) * t.tileheight + r(e, 'offsety', 0); return {\n        i: 0, layers: e.layers, name: `${i.name + e.name}/`, opacity: i.opacity * e.opacity, visible: i.visible && e.visible, x: i.x + n, y: i.y + s,\n      };\n    };\n  }, function (t, e, i) { function r(t) { return { x: t.x, y: t.y }; } const o = i(486); const a = i(224); const h = ['id', 'name', 'type', 'rotation', 'properties', 'visible', 'x', 'y', 'width', 'height']; t.exports = function (t, e, i) { void 0 === e && (e = 0), void 0 === i && (i = 0); let n; const s = o(t, h); return s.x += e, s.y += i, t.gid ? (n = a(t.gid), s.gid = n.gid, s.flippedHorizontal = n.flippedHorizontal, s.flippedVertical = n.flippedVertical, s.flippedAntiDiagonal = n.flippedAntiDiagonal) : t.polyline ? s.polyline = t.polyline.map(r) : t.polygon ? s.polygon = t.polygon.map(r) : t.ellipse ? s.ellipse = t.ellipse : t.text ? s.text = t.text : t.point ? s.point = !0 : s.rectangle = !0, s; }; }, function (t, e, i) {\n    const u = i(32); const c = i(103); const d = i(478); const f = i(494); t.exports = function (t, e, i, n, s, r, o, a) {\n      void 0 === i && (i = 32), void 0 === n && (n = 32), void 0 === s && (s = 10), void 0 === r && (r = 10), void 0 === a && (a = !1); let h; let l = null; return Array.isArray(o) ? l = d(void 0 !== e ? e : 'map', u.ARRAY_2D, o, i, n, a) : void 0 !== e && ((h = t.cache.tilemap.get(e)) ? l = d(e, h.format, h.data, i, n, a) : console.warn(`No map data found for key ${e}`)), l === null && (l = new c({\n        tileWidth: i, tileHeight: n, width: s, height: r,\n      })), new f(t, l);\n    };\n  }, function (t, e, i) { const n = i(6); t.exports = function (t) { let e = n(t, 'targets', null); return e === null || (typeof e === 'function' && (e = e.call()), Array.isArray(e) || (e = [e])), e; }; }, function (t, e) { function g(t) { return !!t.getActive && typeof t.getActive === 'function'; } function v(t) { return !!t.getStart && typeof t.getStart === 'function'; } function m(t) { return !!t.getEnd && typeof t.getEnd === 'function'; } var y = function (t, e) { let i; let n; let s; let r; let o; let a; let h; let l = function (t, e, i) { return i; }; let u = function (t, e, i) { return i; }; let c = null; const d = typeof e; if (d == 'number')l = function () { return e; }; else if (d == 'string') { const f = e[0]; const p = parseFloat(e.substr(2)); switch (f) { case '+': l = function (t, e, i) { return i + p; }; break; case '-': l = function (t, e, i) { return i - p; }; break; case '*': l = function (t, e, i) { return i * p; }; break; case '/': l = function (t, e, i) { return i / p; }; break; default: l = function () { return parseFloat(e); }; } } else { d == 'function' ? l = e : d == 'object' && (v(h = e) || m(h) || g(h) ? (g(e) && (c = e.getActive), m(e) && (l = e.getEnd), v(e) && (u = e.getStart)) : e.hasOwnProperty('value') ? a = y(t, e.value) : (i = e.hasOwnProperty('to'), n = e.hasOwnProperty('from'), s = e.hasOwnProperty('start'), i && (n || s) && (a = y(t, e.to), s && (r = y(t, e.start), a.getActive = r.getEnd), n && (o = y(t, e.from), a.getStart = o.getEnd)))); } return a = a || { getActive: c, getEnd: l, getStart: u }; }; t.exports = y; }, function (t, e) {\n    t.exports = {\n      targets: null, delay: 0, duration: 1e3, ease: 'Power0', easeParams: null, hold: 0, repeat: 0, repeatDelay: 0, yoyo: !1, flipX: !1, flipY: !1,\n    };\n  }, function (t, e, i) {\n    const n = i(0); const s = i(10); const u = i(232); const r = i(16); const o = i(5); const c = i(89); const a = i(13); const h = new n({\n      Extends: s,\n      initialize(t, e, i) {\n        s.call(this), this.parent = t, this.parentIsTimeline = t.hasOwnProperty('isTimeline'), this.data = e, this.totalData = e.length, this.targets = i, this.totalTargets = i.length, this.useFrames = !1, this.timeScale = 1, this.loop = 0, this.loopDelay = 0, this.loopCounter = 0, this.startDelay = 0, this.hasStarted = !1, this.isSeeking = !1, this.completeDelay = 0, this.countdown = 0, this.offset = 0, this.calculatedOffset = 0, this.state = c.PENDING_ADD, this._pausedState = c.INIT, this.paused = !1, this.elapsed = 0, this.totalElapsed = 0, this.duration = 0, this.progress = 0, this.totalDuration = 0, this.totalProgress = 0, this.callbacks = {\n          onActive: null, onComplete: null, onLoop: null, onRepeat: null, onStart: null, onStop: null, onUpdate: null, onYoyo: null,\n        }, this.callbackScope;\n      },\n      getValue(t) { return void 0 === t && (t = 0), this.data[t].current; },\n      setTimeScale(t) { return this.timeScale = t, this; },\n      getTimeScale() { return this.timeScale; },\n      isPlaying() { return this.state === c.ACTIVE; },\n      isPaused() { return this.state === c.PAUSED; },\n      hasTarget(t) { return this.targets.indexOf(t) !== -1; },\n      updateTo(t, e, i) { void 0 === i && (i = !1); for (let n = 0; n < this.totalData; n++) { const s = this.data[n]; s.key === t && (s.end = e, i && (s.start = s.current)); } return this; },\n      restart() { return this.elapsed = 0, this.progress = 0, this.totalElapsed = 0, this.totalProgress = 0, this.state === c.ACTIVE ? this.seek(0) : this.state === c.REMOVED ? (this.seek(0), this.parent.makeActive(this), this) : this.state === c.PENDING_ADD ? this : this.play(); },\n      calcDuration() { for (var t = 0, e = a.MAX_SAFE_INTEGER, i = this.data, n = 0; n < this.totalData; n++) { const s = i[n]; s.t1 = s.duration + s.hold, s.yoyo && (s.t1 += s.duration), s.t2 = s.t1 + s.repeatDelay, s.totalDuration = s.delay + s.t1, s.repeat === -1 ? s.totalDuration += 999999999999 * s.t2 : s.repeat > 0 && (s.totalDuration += s.t2 * s.repeat), s.totalDuration > t && (t = s.totalDuration), s.delay < e && (e = s.delay); } this.duration = Math.max(t, 0.001), this.loopCounter = this.loop === -1 ? 999999999999 : this.loop, this.loopCounter > 0 ? this.totalDuration = this.duration + this.completeDelay + (this.duration + this.loopDelay) * this.loopCounter : this.totalDuration = this.duration + this.completeDelay, this.startDelay = e; },\n      init() { if (this.paused && !this.parentIsTimeline) return this.state = c.PENDING_ADD, this._pausedState = c.INIT, !1; for (let t = this.data, e = this.totalTargets, i = 0; i < this.totalData; i++) { const n = t[i]; const s = n.target; const r = n.gen; const o = n.key; const a = n.index; n.delay = r.delay(s, o, 0, a, e, this), n.duration = Math.max(r.duration(s, o, 0, a, e, this), 0.001), n.hold = r.hold(s, o, 0, a, e, this), n.repeat = r.repeat(s, o, 0, a, e, this), n.repeatDelay = r.repeatDelay(s, o, 0, a, e, this); } return this.calcDuration(), this.progress = 0, this.totalProgress = 0, this.elapsed = 0, this.totalElapsed = 0, this.state = c.INIT, !0; },\n      makeActive() { this.parent.makeActive(this), this.dispatchTweenEvent(u.TWEEN_ACTIVE, this.callbacks.onActive); },\n      nextState() { this.loopCounter > 0 ? (this.elapsed = 0, this.progress = 0, this.loopCounter--, this.resetTweenData(!0), this.loopDelay > 0 ? (this.countdown = this.loopDelay, this.state = c.LOOP_DELAY) : (this.state = c.ACTIVE, this.dispatchTweenEvent(u.TWEEN_LOOP, this.callbacks.onLoop))) : this.completeDelay > 0 ? (this.state = c.COMPLETE_DELAY, this.countdown = this.completeDelay) : (this.state = c.PENDING_REMOVE, this.dispatchTweenEvent(u.TWEEN_COMPLETE, this.callbacks.onComplete)); },\n      pause() { return this.state === c.PAUSED || (this.paused = !0, this._pausedState = this.state, this.state = c.PAUSED), this; },\n      play(t) { void 0 === t && (t = !1); const e = this.state; return e !== c.INIT || this.parentIsTimeline ? e === c.ACTIVE || e === c.PENDING_ADD && this._pausedState === c.PENDING_ADD || (this.parentIsTimeline || e !== c.PENDING_REMOVE && e !== c.REMOVED ? this.parentIsTimeline ? (this.resetTweenData(t), this.calculatedOffset === 0 ? this.state = c.ACTIVE : (this.countdown = this.calculatedOffset, this.state = c.OFFSET_DELAY)) : (this.paused ? this.paused = !1 : (this.resetTweenData(t), this.state = c.ACTIVE), this.makeActive()) : (this.seek(0), this.parent.makeActive(this))) : (this.resetTweenData(!1), this.state = c.ACTIVE), this; },\n      resetTweenData(t) { for (let e = this.data, i = this.totalData, n = this.totalTargets, s = 0; s < i; s++) { const r = e[s]; const o = r.target; const a = r.key; const h = r.index; r.progress = 0, r.elapsed = 0, r.repeatCounter = r.repeat === -1 ? 999999999999 : r.repeat, t ? (r.start = r.getStartValue(o, a, r.start, h, n, this), r.end = r.getEndValue(o, a, r.end, h, n, this), r.current = r.start, r.state = c.PLAYING_FORWARD) : r.state = c.PENDING_RENDER, r.delay > 0 && (r.elapsed = r.delay, r.state = c.DELAY), r.getActiveValue && (o[a] = r.getActiveValue(r.target, r.key, r.start)); } },\n      resume() { return this.state === c.PAUSED ? (this.paused = !1, this.state = this._pausedState) : this.play(), this; },\n      seek(t, e) { if (void 0 === e && (e = 16.6), this.totalDuration >= 36e5) return console.warn('Tween.seek duration too long'), this; this.state === c.REMOVED && this.makeActive(), this.elapsed = 0, this.progress = 0, this.totalElapsed = 0, this.totalProgress = 0; for (let i = this.data, n = this.totalTargets, s = 0; s < this.totalData; s++) { const r = i[s]; const o = r.target; const a = r.gen; const h = r.key; const l = r.index; r.progress = 0, r.elapsed = 0, r.repeatCounter = r.repeat === -1 ? 999999999999 : r.repeat, r.delay = a.delay(o, h, 0, l, n, this), r.duration = Math.max(a.duration(o, h, 0, l, n, this), 0.001), r.hold = a.hold(o, h, 0, l, n, this), r.repeat = a.repeat(o, h, 0, l, n, this), r.repeatDelay = a.repeatDelay(o, h, 0, l, n, this), r.current = r.start, r.state = c.PLAYING_FORWARD, this.updateTweenData(this, r, 0, l, n), r.delay > 0 && (r.elapsed = r.delay, r.state = c.DELAY); } this.calcDuration(); let u = !1; for (this.state === c.PAUSED && (u = !0, this.state = c.ACTIVE), this.isSeeking = !0; this.update(0, e), this.totalProgress < t;);return this.isSeeking = !1, u && (this.state = c.PAUSED), this; },\n      setCallback(t, e, i, n) { return this.callbacks[t] = { func: e, scope: n, params: i }, this; },\n      complete(t) { return void 0 === t && (t = 0), t ? (this.state = c.COMPLETE_DELAY, this.countdown = t) : (this.state = c.PENDING_REMOVE, this.dispatchTweenEvent(u.TWEEN_COMPLETE, this.callbacks.onComplete)), this; },\n      remove() { return this.parent.remove(this), this; },\n      stop(t) { return this.state === c.ACTIVE && void 0 !== t && this.seek(t), this.state !== c.REMOVED && (this.state !== c.PAUSED && this.state !== c.PENDING_ADD || (this.parentIsTimeline ? (this.parent.manager._destroy.push(this), this.parent.manager._toProcess++) : (this.parent._destroy.push(this), this.parent._toProcess++)), this.dispatchTweenEvent(u.TWEEN_STOP, this.callbacks.onStop), this.removeAllListeners(), this.state = c.PENDING_REMOVE), this; },\n      update(t, e) { if (this.state === c.PAUSED) return !1; switch (this.useFrames && (e = +this.parent.timeScale), e *= this.timeScale, this.elapsed += e, this.progress = Math.min(this.elapsed / this.duration, 1), this.totalElapsed += e, this.totalProgress = Math.min(this.totalElapsed / this.totalDuration, 1), this.state) { case c.ACTIVE: this.hasStarted || this.isSeeking || (this.startDelay -= e, this.startDelay <= 0 && (this.hasStarted = !0, this.dispatchTweenEvent(u.TWEEN_START, this.callbacks.onStart))); for (var i = !1, n = 0; n < this.totalData; n++) { const s = this.data[n]; this.updateTweenData(this, s, e) && (i = !0); }i || this.nextState(); break; case c.LOOP_DELAY: this.countdown -= e, this.countdown <= 0 && (this.state = c.ACTIVE, this.dispatchTweenEvent(u.TWEEN_LOOP, this.callbacks.onLoop)); break; case c.OFFSET_DELAY: this.countdown -= e, this.countdown <= 0 && (this.state = c.ACTIVE); break; case c.COMPLETE_DELAY: this.countdown -= e, this.countdown <= 0 && (this.state = c.PENDING_REMOVE, this.dispatchTweenEvent(u.TWEEN_COMPLETE, this.callbacks.onComplete)); } return this.state === c.PENDING_REMOVE; },\n      dispatchTweenDataEvent(t, e, i) { this.isSeeking || (this.emit(t, this, i.key, i.target, i.current, i.previous), e && (e.params[1] = i.target, e.func.apply(e.scope, e.params))); },\n      dispatchTweenEvent(t, e) { this.isSeeking || (this.emit(t, this, this.targets), e && (e.params[1] = this.targets, e.func.apply(e.scope, e.params))); },\n      setStateFromEnd(t, e, i) { return e.yoyo ? (e.elapsed = i, e.progress = i / e.duration, e.flipX && e.target.toggleFlipX(), e.flipY && e.target.toggleFlipY(), this.dispatchTweenDataEvent(u.TWEEN_YOYO, t.callbacks.onYoyo, e), e.start = e.getStartValue(e.target, e.key, e.start, e.index, t.totalTargets, t), c.PLAYING_BACKWARD) : e.repeatCounter > 0 ? (e.repeatCounter--, e.elapsed = i, e.progress = i / e.duration, e.flipX && e.target.toggleFlipX(), e.flipY && e.target.toggleFlipY(), e.start = e.getStartValue(e.target, e.key, e.start, e.index, t.totalTargets, t), e.end = e.getEndValue(e.target, e.key, e.start, e.index, t.totalTargets, t), e.repeatDelay > 0 ? (e.elapsed = e.repeatDelay - i, e.current = e.start, e.target[e.key] = e.current, c.REPEAT_DELAY) : (this.dispatchTweenDataEvent(u.TWEEN_REPEAT, t.callbacks.onRepeat, e), c.PLAYING_FORWARD)) : c.COMPLETE; },\n      setStateFromStart(t, e, i) { return e.repeatCounter > 0 ? (e.repeatCounter--, e.elapsed = i, e.progress = i / e.duration, e.flipX && e.target.toggleFlipX(), e.flipY && e.target.toggleFlipY(), e.end = e.getEndValue(e.target, e.key, e.start, e.index, t.totalTargets, t), e.repeatDelay > 0 ? (e.elapsed = e.repeatDelay - i, e.current = e.start, e.target[e.key] = e.current, c.REPEAT_DELAY) : (this.dispatchTweenDataEvent(u.TWEEN_REPEAT, t.callbacks.onRepeat, e), c.PLAYING_FORWARD)) : c.COMPLETE; },\n      updateTweenData(t, e, i) { const n = e.target; switch (e.state) { case c.PLAYING_FORWARD: case c.PLAYING_BACKWARD: if (!n) { e.state = c.COMPLETE; break; } var s = e.elapsed; var r = e.duration; var o = 0; r < (s += i) && (o = s - r, s = r); var a; var h = e.state === c.PLAYING_FORWARD; var l = s / r; e.elapsed = s, e.progress = l, e.previous = e.current, l == 1 ? h ? (e.current = e.end, n[e.key] = e.end, e.hold > 0 ? (e.elapsed = e.hold - o, e.state = c.HOLD_DELAY) : e.state = this.setStateFromEnd(t, e, o)) : (e.current = e.start, n[e.key] = e.start, e.state = this.setStateFromStart(t, e, o)) : (a = h ? e.ease(l) : e.ease(1 - l), e.current = e.start + (e.end - e.start) * a, n[e.key] = e.current), this.dispatchTweenDataEvent(u.TWEEN_UPDATE, t.callbacks.onUpdate, e); break; case c.DELAY: e.elapsed -= i, e.elapsed <= 0 && (e.elapsed = Math.abs(e.elapsed), e.state = c.PENDING_RENDER); break; case c.REPEAT_DELAY: e.elapsed -= i, e.elapsed <= 0 && (e.elapsed = Math.abs(e.elapsed), e.state = c.PLAYING_FORWARD, this.dispatchTweenDataEvent(u.TWEEN_REPEAT, t.callbacks.onRepeat, e)); break; case c.HOLD_DELAY: e.elapsed -= i, e.elapsed <= 0 && (e.state = this.setStateFromEnd(t, e, Math.abs(e.elapsed))); break; case c.PENDING_RENDER: n ? (e.start = e.getStartValue(n, e.key, n[e.key], e.index, t.totalTargets, t), e.end = e.getEndValue(n, e.key, e.start, e.index, t.totalTargets, t), e.current = e.start, n[e.key] = e.start, e.state = c.PLAYING_FORWARD) : e.state = c.COMPLETE; } return e.state !== c.COMPLETE; },\n    }); h.TYPES = ['onActive', 'onComplete', 'onLoop', 'onRepeat', 'onStart', 'onStop', 'onUpdate', 'onYoyo'], o.register('tween', function (t) { return this.scene.sys.tweens.add(t); }), r.register('tween', function (t) { return this.scene.sys.tweens.create(t); }), t.exports = h;\n  }, function (t, e, i) {\n    t.exports = {\n      TIMELINE_COMPLETE: i(1358), TIMELINE_LOOP: i(1359), TIMELINE_PAUSE: i(1360), TIMELINE_RESUME: i(1361), TIMELINE_START: i(1362), TIMELINE_UPDATE: i(1363), TWEEN_ACTIVE: i(1364), TWEEN_COMPLETE: i(1365), TWEEN_LOOP: i(1366), TWEEN_REPEAT: i(1367), TWEEN_START: i(1368), TWEEN_STOP: i(1369), TWEEN_UPDATE: i(1370), TWEEN_YOYO: i(1371),\n    };\n  }, function (t, e) {\n    t.exports = function (t, e, i, n, s, r, o, a, h, l, u, c, d, f, p) {\n      return {\n        target: t,\n        index: e,\n        key: i,\n        getActiveValue: r,\n        getEndValue: n,\n        getStartValue: s,\n        ease: o,\n        duration: 0,\n        totalDuration: 0,\n        delay: 0,\n        yoyo: l,\n        hold: 0,\n        repeat: 0,\n        repeatDelay: 0,\n        flipX: f,\n        flipY: p,\n        progress: 0,\n        elapsed: 0,\n        repeatCounter: 0,\n        start: 0,\n        previous: 0,\n        current: 0,\n        end: 0,\n        t1: 0,\n        t2: 0,\n        gen: {\n          delay: a, duration: h, hold: u, repeat: c, repeatDelay: d,\n        },\n        state: 0,\n      };\n    };\n  }, function (t, e) { t.exports = { DEFAULT: 0, LINEAR: 0, NEAREST: 1 }; }, function (t, e, i) { const n = i(58); t.exports = function (t) { return n(t, -Math.PI, Math.PI); }; }, function (t, e, i) { const n = i(58); t.exports = function (t) { return n(t, -180, 180); }; }, function (t, e, i) {\n    const n = i(0); const D = i(66); const s = i(2); const r = i(238); const o = i(340); const a = i(341); const h = i(29); const Y = i(9); const l = i(147); const u = new n({\n      Extends: l,\n      Mixins: [r],\n      initialize(t) {\n        const e = t.renderer.config; l.call(this, {\n          game: t.game,\n          renderer: t.renderer,\n          gl: t.renderer.gl,\n          topology: s(t, 'topology', t.renderer.gl.TRIANGLES),\n          vertShader: s(t, 'vertShader', a),\n          fragShader: s(t, 'fragShader', o),\n          vertexCapacity: s(t, 'vertexCapacity', 6 * e.batchSize),\n          vertexSize: s(t, 'vertexSize', 5 * Float32Array.BYTES_PER_ELEMENT + 4 * Uint8Array.BYTES_PER_ELEMENT),\n          attributes: [{\n            name: 'inPosition', size: 2, type: t.renderer.gl.FLOAT, normalized: !1, offset: 0,\n          }, {\n            name: 'inTexCoord', size: 2, type: t.renderer.gl.FLOAT, normalized: !1, offset: 2 * Float32Array.BYTES_PER_ELEMENT,\n          }, {\n            name: 'inTintEffect', size: 1, type: t.renderer.gl.FLOAT, normalized: !1, offset: 4 * Float32Array.BYTES_PER_ELEMENT,\n          }, {\n            name: 'inTint', size: 4, type: t.renderer.gl.UNSIGNED_BYTE, normalized: !0, offset: 5 * Float32Array.BYTES_PER_ELEMENT,\n          }],\n        }), this.vertexViewF32 = new Float32Array(this.vertexData), this.vertexViewU32 = new Uint32Array(this.vertexData), this.maxQuads = e.batchSize, this.batches = [], this._tempMatrix1 = new h(), this._tempMatrix2 = new h(), this._tempMatrix3 = new h(), this._tempMatrix4 = new h(), this.tempTriangle = [{ x: 0, y: 0, width: 0 }, { x: 0, y: 0, width: 0 }, { x: 0, y: 0, width: 0 }, { x: 0, y: 0, width: 0 }], this.tintEffect = 2, this.strokeTint = {\n          TL: 0, TR: 0, BL: 0, BR: 0,\n        }, this.fillTint = {\n          TL: 0, TR: 0, BL: 0, BR: 0,\n        }, this.currentFrame = {\n          u0: 0, v0: 0, u1: 1, v1: 1,\n        }, this.firstQuad = [0, 0, 0, 0, 0], this.prevQuad = [0, 0, 0, 0, 0], this.polygonCache = [], this.mvpInit();\n      },\n      onBind() { return l.prototype.onBind.call(this), this.mvpUpdate(), this; },\n      resize(t, e, i) { return l.prototype.resize.call(this, t, e, i), this.projOrtho(0, this.width, this.height, 0, -1e3, 1e3), this; },\n      setTexture2D(t, e) { return void 0 === t && (t = this.renderer.blankTexture.glTexture), void 0 === e && (e = 0), this.requireTextureBatch(t, e) && this.pushBatch(t, e), this; },\n      requireTextureBatch(t, e) { const i = this.batches; const n = i.length; return !(n > 0) || !((e > 0 ? i[n - 1].textures[e - 1] : i[n - 1].texture) === t); },\n      pushBatch(t, e) { let i; e === 0 ? this.batches.push({ first: this.vertexCount, texture: t, textures: [] }) : ((i = [])[e - 1] = t, this.batches.push({ first: this.vertexCount, texture: null, textures: i })); },\n      flush() { if (this.flushLocked) return this; this.flushLocked = !0; let t; let e; let i; const n = this.gl; const s = this.vertexCount; const r = this.topology; const o = this.vertexSize; const a = this.renderer; const h = this.batches; const l = h.length; let u = 0; let c = null; if (l === 0 || s === 0) return this.flushLocked = !1, this; n.bufferSubData(n.ARRAY_BUFFER, 0, this.bytes.subarray(0, s * o)); for (let d = 0; d < l - 1; d++) { if (c = h[d], t = h[d + 1], c.textures.length > 0) { for (e = 0; e < c.textures.length; ++e)(i = c.textures[e]) && a.setTexture2D(i, 1 + e, !1); n.activeTexture(n.TEXTURE0); }u = t.first - c.first, c.texture === null || u <= 0 || (a.setTexture2D(c.texture, 0, !1), n.drawArrays(r, c.first, u)); } if ((c = h[l - 1]).textures.length > 0) { for (e = 0; e < c.textures.length; ++e)(i = c.textures[e]) && a.setTexture2D(i, 1 + e, !1); n.activeTexture(n.TEXTURE0); } return u = s - c.first, c.texture && u > 0 && (a.setTexture2D(c.texture, 0, !1), n.drawArrays(r, c.first, u)), this.vertexCount = 0, h.length = 0, this.flushLocked = !1, this; },\n      batchSprite(t, e, i) { this.renderer.setPipeline(this); let n; const s = this._tempMatrix1; const r = this._tempMatrix2; const o = this._tempMatrix3; const a = t.frame; const h = a.glTexture; let l = a.u0; let u = a.v0; let c = a.u1; let d = a.v1; const f = a.x; const p = a.y; let g = a.cutWidth; let v = a.cutHeight; const m = a.customPivot; const y = t.displayOriginX; const x = t.displayOriginY; let T = -y + f; let w = -x + p; t.isCropped && ((n = t._crop).flipX === t.flipX && n.flipY === t.flipY || a.updateCropUVs(n, t.flipX, t.flipY), l = n.u0, u = n.v0, c = n.u1, d = n.v1, g = n.width, v = n.height, T = -y + n.x, w = -x + n.y); let b = 1; let E = 1; t.flipX && (m || (T += -a.realWidth + 2 * y), b = -1), (t.flipY || a.source.isGLTexture && !h.flipY) && (m || (w += -a.realHeight + 2 * x), E = -1), r.applyITRS(t.x, t.y, t.rotation, t.scaleX * b, t.scaleY * E), s.copyFrom(e.matrix), i ? (s.multiplyWithOffset(i, -e.scrollX * t.scrollFactorX, -e.scrollY * t.scrollFactorY), r.e = t.x, r.f = t.y) : (r.e -= e.scrollX * t.scrollFactorX, r.f -= e.scrollY * t.scrollFactorY), s.multiply(r, o); const S = T + g; const _ = w + v; let A = o.getX(T, w); let C = o.getY(T, w); let M = o.getX(T, _); let P = o.getY(T, _); let O = o.getX(S, _); let R = o.getY(S, _); let L = o.getX(S, w); let k = o.getY(S, w); const D = Y.getTintAppendFloatAlpha(t._tintTL, e.alpha * t._alphaTL); const F = Y.getTintAppendFloatAlpha(t._tintTR, e.alpha * t._alphaTR); const I = Y.getTintAppendFloatAlpha(t._tintBL, e.alpha * t._alphaBL); const B = Y.getTintAppendFloatAlpha(t._tintBR, e.alpha * t._alphaBR); e.roundPixels && (A = Math.round(A), C = Math.round(C), M = Math.round(M), P = Math.round(P), O = Math.round(O), R = Math.round(R), L = Math.round(L), k = Math.round(k)), this.setTexture2D(h, 0); const N = t._isTinted && t.tintFill; this.batchQuad(A, C, M, P, O, R, L, k, l, u, c, d, D, F, I, B, N, h, 0); },\n      batchQuad(t, e, i, n, s, r, o, a, h, l, u, c, d, f, p, g, v, m, y) { let x = !1; this.vertexCount + 6 > this.vertexCapacity && (this.flush(), x = !0, this.setTexture2D(m, y)); const T = this.vertexViewF32; const w = this.vertexViewU32; let b = this.vertexCount * this.vertexComponentCount - 1; return T[++b] = t, T[++b] = e, T[++b] = h, T[++b] = l, T[++b] = v, w[++b] = d, T[++b] = i, T[++b] = n, T[++b] = h, T[++b] = c, T[++b] = v, w[++b] = p, T[++b] = s, T[++b] = r, T[++b] = u, T[++b] = c, T[++b] = v, w[++b] = g, T[++b] = t, T[++b] = e, T[++b] = h, T[++b] = l, T[++b] = v, w[++b] = d, T[++b] = s, T[++b] = r, T[++b] = u, T[++b] = c, T[++b] = v, w[++b] = g, T[++b] = o, T[++b] = a, T[++b] = u, T[++b] = l, T[++b] = v, w[++b] = f, this.vertexCount += 6, x; },\n      batchTri(t, e, i, n, s, r, o, a, h, l, u, c, d, f, p, g) { let v = !1; this.vertexCount + 3 > this.vertexCapacity && (this.flush(), this.setTexture2D(p, g), v = !0); const m = this.vertexViewF32; const y = this.vertexViewU32; let x = this.vertexCount * this.vertexComponentCount - 1; return m[++x] = t, m[++x] = e, m[++x] = o, m[++x] = a, m[++x] = f, y[++x] = u, m[++x] = i, m[++x] = n, m[++x] = o, m[++x] = l, m[++x] = f, y[++x] = c, m[++x] = s, m[++x] = r, m[++x] = h, m[++x] = l, m[++x] = f, y[++x] = d, this.vertexCount += 3, v; },\n      batchTexture(t, e, i, n, s, r, o, a, h, l, u, c, d, f, p, g, v, m, y, x, T, w, b, E, S, _, A, C, M, P, O) { this.renderer.setPipeline(this, t); let R; let L; let k; const D = this._tempMatrix1; const F = this._tempMatrix2; const I = this._tempMatrix3; let B = m / i + A; let N = y / n + C; let Y = (m + x) / i + A; let X = (y + T) / n + C; let U = o; let z = a; let G = -g; let W = -v; t.isCropped && (U = (R = t._crop).width, z = R.height, o = R.width, a = R.height, L = m = R.x, k = y = R.y, c && (L = x - R.x - R.width), d && !e.isRenderTexture && (k = T - R.y - R.height), B = L / i + A, N = k / n + C, Y = (L + R.width) / i + A, X = (k + R.height) / n + C, G = -g + m, W = -v + y), c && (U *= -1, G += o), (d ^= !O && e.isRenderTexture ? 1 : 0) && (z *= -1, W += a); const V = G + U; const H = W + z; F.applyITRS(s, r, u, h, l), D.copyFrom(M.matrix), P ? (D.multiplyWithOffset(P, -M.scrollX * f, -M.scrollY * p), F.e = s, F.f = r) : (F.e -= M.scrollX * f, F.f -= M.scrollY * p), D.multiply(F, I); let j = I.getX(G, W); let q = I.getY(G, W); let K = I.getX(G, H); let J = I.getY(G, H); let Z = I.getX(V, H); let Q = I.getY(V, H); let $ = I.getX(V, W); let tt = I.getY(V, W); M.roundPixels && (j = Math.round(j), q = Math.round(q), K = Math.round(K), J = Math.round(J), Z = Math.round(Z), Q = Math.round(Q), $ = Math.round($), tt = Math.round(tt)), this.setTexture2D(e, 0), this.batchQuad(j, q, K, J, Z, Q, $, tt, B, N, Y, X, w, b, E, S, _, e, 0); },\n      batchTextureFrame(t, e, i, n, s, r, o) { this.renderer.setPipeline(this); const a = this._tempMatrix1.copyFrom(r); let h = this._tempMatrix2; const l = e + t.width; const u = i + t.height; o ? a.multiply(o, h) : h = a; const c = h.getX(e, i); const d = h.getY(e, i); const f = h.getX(e, u); const p = h.getY(e, u); const g = h.getX(l, u); const v = h.getY(l, u); const m = h.getX(l, i); const y = h.getY(l, i); this.setTexture2D(t.glTexture, 0), n = Y.getTintAppendFloatAlpha(n, s), this.batchQuad(c, d, f, p, g, v, m, y, t.u0, t.v0, t.u1, t.v1, n, n, n, n, 0, t.glTexture, 0); },\n      drawFillRect(t, e, i, n, s, r) { const o = t + i; const a = e + n; this.setTexture2D(); const h = Y.getTintAppendFloatAlphaAndSwap(s, r); this.batchQuad(t, e, t, a, o, a, o, e, 0, 0, 1, 1, h, h, h, h, 2); },\n      batchFillRect(t, e, i, n, s, r) { this.renderer.setPipeline(this); const o = this._tempMatrix3; r && r.multiply(s, o); const a = t + i; const h = e + n; const l = o.getX(t, e); const u = o.getY(t, e); const c = o.getX(t, h); const d = o.getY(t, h); const f = o.getX(a, h); const p = o.getY(a, h); const g = o.getX(a, e); const v = o.getY(a, e); const m = this.currentFrame; const y = m.u0; const x = m.v0; const T = m.u1; const w = m.v1; this.batchQuad(l, u, c, d, f, p, g, v, y, x, T, w, this.fillTint.TL, this.fillTint.TR, this.fillTint.BL, this.fillTint.BR, this.tintEffect); },\n      batchFillTriangle(t, e, i, n, s, r, o, a) { this.renderer.setPipeline(this); const h = this._tempMatrix3; a && a.multiply(o, h); const l = h.getX(t, e); const u = h.getY(t, e); const c = h.getX(i, n); const d = h.getY(i, n); const f = h.getX(s, r); const p = h.getY(s, r); const g = this.currentFrame; const v = g.u0; const m = g.v0; const y = g.u1; const x = g.v1; this.batchTri(l, u, c, d, f, p, v, m, y, x, this.fillTint.TL, this.fillTint.TR, this.fillTint.BL, this.tintEffect); },\n      batchStrokeTriangle(t, e, i, n, s, r, o, a, h) { const l = this.tempTriangle; l[0].x = t, l[0].y = e, l[0].width = o, l[1].x = i, l[1].y = n, l[1].width = o, l[2].x = s, l[2].y = r, l[2].width = o, l[3].x = t, l[3].y = e, l[3].width = o, this.batchStrokePath(l, o, !1, a, h); },\n      batchFillPath(t, e, i) { this.renderer.setPipeline(this); const n = this._tempMatrix3; i && i.multiply(e, n); for (var s, r, o = t.length, a = this.polygonCache, h = this.fillTint.TL, l = this.fillTint.TR, u = this.fillTint.BL, c = this.tintEffect, d = 0; d < o; ++d)r = t[d], a.push(r.x, r.y); o = (s = D(a)).length; for (let f = this.currentFrame, p = 0; p < o; p += 3) { const g = 2 * s[p + 0]; const v = 2 * s[p + 1]; const m = 2 * s[p + 2]; const y = a[0 + g]; const x = a[1 + g]; const T = a[0 + v]; const w = a[1 + v]; const b = a[0 + m]; const E = a[1 + m]; const S = n.getX(y, x); const _ = n.getY(y, x); const A = n.getX(T, w); const C = n.getY(T, w); const M = n.getX(b, E); const P = n.getY(b, E); const O = f.u0; const R = f.v0; const L = f.u1; const k = f.v1; this.batchTri(S, _, A, C, M, P, O, R, L, k, h, l, u, c); }a.length = 0; },\n      batchStrokePath(t, e, i, n, s) { this.renderer.setPipeline(this), this.prevQuad[4] = 0, this.firstQuad[4] = 0; for (let r = t.length - 1, o = 0; o < r; o++) { const a = t[o]; const h = t[o + 1]; this.batchLine(a.x, a.y, h.x, h.y, a.width / 2, h.width / 2, e, o, !i && o === r - 1, n, s); } },\n      batchLine(t, e, i, n, s, r, o, a, h, l, u) { this.renderer.setPipeline(this); const c = this._tempMatrix3; u && u.multiply(l, c); let d; let f; const p = i - t; const g = n - e; const v = Math.sqrt(p * p + g * g); const m = s * (n - e) / v; const y = s * (t - i) / v; const x = r * (n - e) / v; const T = r * (t - i) / v; const w = i - x; const b = n - T; const E = t - m; const S = e - y; const _ = i + x; const A = n + T; const C = t + m; const M = e + y; const P = c.getX(w, b); const O = c.getY(w, b); const R = c.getX(E, S); const L = c.getY(E, S); const k = c.getX(_, A); const D = c.getY(_, A); const F = c.getX(C, M); const I = c.getY(C, M); const B = this.strokeTint; const N = this.tintEffect; const Y = B.TL; const X = B.TR; const U = B.BL; const z = B.BR; const G = this.currentFrame; const W = G.u0; const V = G.v0; const H = G.u1; const j = G.v1; this.batchQuad(F, I, R, L, P, O, k, D, W, V, H, j, Y, X, U, z, N), o <= 2 || (d = this.prevQuad, f = this.firstQuad, a > 0 && d[4] ? this.batchQuad(F, I, R, L, d[0], d[1], d[2], d[3], W, V, H, j, Y, X, U, z, N) : (f[0] = F, f[1] = I, f[2] = R, f[3] = L, f[4] = 1), h && f[4] ? this.batchQuad(P, O, k, D, f[0], f[1], f[2], f[3], W, V, H, j, Y, X, U, z, N) : (d[0] = P, d[1] = O, d[2] = k, d[3] = D, d[4] = 1)); },\n    }); t.exports = u;\n  }, function (t, e) {\n    const i = {\n      modelMatrixDirty: !1, viewMatrixDirty: !1, projectionMatrixDirty: !1, modelMatrix: null, viewMatrix: null, projectionMatrix: null, mvpInit() { return this.modelMatrixDirty = !0, this.viewMatrixDirty = !0, this.projectionMatrixDirty = !0, this.modelMatrix = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]), this.viewMatrix = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]), this.projectionMatrix = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]), this; }, mvpUpdate() { const t = this.program; return this.modelMatrixDirty && (this.renderer.setMatrix4(t, 'uModelMatrix', !1, this.modelMatrix), this.modelMatrixDirty = !1), this.viewMatrixDirty && (this.renderer.setMatrix4(t, 'uViewMatrix', !1, this.viewMatrix), this.viewMatrixDirty = !1), this.projectionMatrixDirty && (this.renderer.setMatrix4(t, 'uProjectionMatrix', !1, this.projectionMatrix), this.projectionMatrixDirty = !1), this; }, modelIdentity() { const t = this.modelMatrix; return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = 1, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 1, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this.modelMatrixDirty = !0, this; }, modelScale(t, e, i) { const n = this.modelMatrix; return n[0] *= t, n[1] *= t, n[2] *= t, n[3] *= t, n[4] *= e, n[5] *= e, n[6] *= e, n[7] *= e, n[8] *= i, n[9] *= i, n[10] *= i, n[11] *= i, this.modelMatrixDirty = !0, this; }, modelTranslate(t, e, i) { const n = this.modelMatrix; return n[12] = n[0] * t + n[4] * e + n[8] * i + n[12], n[13] = n[1] * t + n[5] * e + n[9] * i + n[13], n[14] = n[2] * t + n[6] * e + n[10] * i + n[14], n[15] = n[3] * t + n[7] * e + n[11] * i + n[15], this.modelMatrixDirty = !0, this; }, modelRotateX(t) { const e = this.modelMatrix; const i = Math.sin(t); const n = Math.cos(t); const s = e[4]; const r = e[5]; const o = e[6]; const a = e[7]; const h = e[8]; const l = e[9]; const u = e[10]; const c = e[11]; return e[4] = s * n + h * i, e[5] = r * n + l * i, e[6] = o * n + u * i, e[7] = a * n + c * i, e[8] = h * n - s * i, e[9] = l * n - r * i, e[10] = u * n - o * i, e[11] = c * n - a * i, this.modelMatrixDirty = !0, this; }, modelRotateY(t) { const e = this.modelMatrix; const i = Math.sin(t); const n = Math.cos(t); const s = e[0]; const r = e[1]; const o = e[2]; const a = e[3]; const h = e[8]; const l = e[9]; const u = e[10]; const c = e[11]; return e[0] = s * n - h * i, e[1] = r * n - l * i, e[2] = o * n - u * i, e[3] = a * n - c * i, e[8] = s * i + h * n, e[9] = r * i + l * n, e[10] = o * i + u * n, e[11] = a * i + c * n, this.modelMatrixDirty = !0, this; }, modelRotateZ(t) { const e = this.modelMatrix; const i = Math.sin(t); const n = Math.cos(t); const s = e[0]; const r = e[1]; const o = e[2]; const a = e[3]; const h = e[4]; const l = e[5]; const u = e[6]; const c = e[7]; return e[0] = s * n + h * i, e[1] = r * n + l * i, e[2] = o * n + u * i, e[3] = a * n + c * i, e[4] = h * n - s * i, e[5] = l * n - r * i, e[6] = u * n - o * i, e[7] = c * n - a * i, this.modelMatrixDirty = !0, this; }, viewIdentity() { const t = this.viewMatrix; return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = 1, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 1, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this.viewMatrixDirty = !0, this; }, viewScale(t, e, i) { const n = this.viewMatrix; return n[0] *= t, n[1] *= t, n[2] *= t, n[3] *= t, n[4] *= e, n[5] *= e, n[6] *= e, n[7] *= e, n[8] *= i, n[9] *= i, n[10] *= i, n[11] *= i, this.viewMatrixDirty = !0, this; }, viewTranslate(t, e, i) { const n = this.viewMatrix; return n[12] = n[0] * t + n[4] * e + n[8] * i + n[12], n[13] = n[1] * t + n[5] * e + n[9] * i + n[13], n[14] = n[2] * t + n[6] * e + n[10] * i + n[14], n[15] = n[3] * t + n[7] * e + n[11] * i + n[15], this.viewMatrixDirty = !0, this; }, viewRotateX(t) { const e = this.viewMatrix; const i = Math.sin(t); const n = Math.cos(t); const s = e[4]; const r = e[5]; const o = e[6]; const a = e[7]; const h = e[8]; const l = e[9]; const u = e[10]; const c = e[11]; return e[4] = s * n + h * i, e[5] = r * n + l * i, e[6] = o * n + u * i, e[7] = a * n + c * i, e[8] = h * n - s * i, e[9] = l * n - r * i, e[10] = u * n - o * i, e[11] = c * n - a * i, this.viewMatrixDirty = !0, this; }, viewRotateY(t) { const e = this.viewMatrix; const i = Math.sin(t); const n = Math.cos(t); const s = e[0]; const r = e[1]; const o = e[2]; const a = e[3]; const h = e[8]; const l = e[9]; const u = e[10]; const c = e[11]; return e[0] = s * n - h * i, e[1] = r * n - l * i, e[2] = o * n - u * i, e[3] = a * n - c * i, e[8] = s * i + h * n, e[9] = r * i + l * n, e[10] = o * i + u * n, e[11] = a * i + c * n, this.viewMatrixDirty = !0, this; }, viewRotateZ(t) { const e = this.viewMatrix; const i = Math.sin(t); const n = Math.cos(t); const s = e[0]; const r = e[1]; const o = e[2]; const a = e[3]; const h = e[4]; const l = e[5]; const u = e[6]; const c = e[7]; return e[0] = s * n + h * i, e[1] = r * n + l * i, e[2] = o * n + u * i, e[3] = a * n + c * i, e[4] = h * n - s * i, e[5] = l * n - r * i, e[6] = u * n - o * i, e[7] = c * n - a * i, this.viewMatrixDirty = !0, this; }, viewLoad2D(t) { const e = this.viewMatrix; return e[0] = t[0], e[1] = t[1], e[2] = 0, e[3] = 0, e[4] = t[2], e[5] = t[3], e[6] = 0, e[7] = 0, e[8] = t[4], e[9] = t[5], e[10] = 1, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this.viewMatrixDirty = !0, this; }, viewLoad(t) { const e = this.viewMatrix; return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4], e[5] = t[5], e[6] = t[6], e[7] = t[7], e[8] = t[8], e[9] = t[9], e[10] = t[10], e[11] = t[11], e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15], this.viewMatrixDirty = !0, this; }, projIdentity() { const t = this.projectionMatrix; return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = 1, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 1, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this.projectionMatrixDirty = !0, this; }, projOrtho(t, e, i, n, s, r) { const o = this.projectionMatrix; const a = 1 / (t - e); const h = 1 / (i - n); const l = 1 / (s - r); return o[0] = -2 * a, o[1] = 0, o[2] = 0, o[3] = 0, o[4] = 0, o[5] = -2 * h, o[6] = 0, o[7] = 0, o[8] = 0, o[9] = 0, o[10] = 2 * l, o[11] = 0, o[12] = (t + e) * a, o[13] = (n + i) * h, o[14] = (r + s) * l, o[15] = 1, this.projectionMatrixDirty = !0, this; }, projPersp(t, e, i, n) { const s = this.projectionMatrix; const r = 1 / Math.tan(t / 2); const o = 1 / (i - n); return s[0] = r / e, s[1] = 0, s[2] = 0, s[3] = 0, s[4] = 0, s[5] = r, s[6] = 0, s[7] = 0, s[8] = 0, s[9] = 0, s[10] = (n + i) * o, s[11] = -1, s[12] = 0, s[13] = 0, s[14] = 2 * n * i * o, s[15] = 0, this.projectionMatrixDirty = !0, this; },\n    }; t.exports = i;\n  }, function (t, e, i) { const u = {}; t.exports = u; const n = i(240); u._motionWakeThreshold = 0.18, u._motionSleepThreshold = 0.08, u._minBias = 0.9, u.update = function (t, e) { for (let i = e * e * e, n = 0; n < t.length; n++) { var s; var r; const o = t[n]; const a = o.speed * o.speed + o.angularSpeed * o.angularSpeed; o.force.x === 0 && o.force.y === 0 ? (s = Math.min(o.motion, a), r = Math.max(o.motion, a), o.motion = u._minBias * s + (1 - u._minBias) * r, o.sleepThreshold > 0 && o.motion < u._motionSleepThreshold * i ? (o.sleepCounter += 1, o.sleepCounter >= o.sleepThreshold && u.set(o, !0)) : o.sleepCounter > 0 && --o.sleepCounter) : u.set(o, !1); } }, u.afterCollisions = function (t, e) { for (let i = e * e * e, n = 0; n < t.length; n++) { var s; var r; var o; var a; var h; const l = t[n]; l.isActive && (r = (s = l.collision).bodyA.parent, o = s.bodyB.parent, r.isSleeping && o.isSleeping || r.isStatic || o.isStatic || (r.isSleeping || o.isSleeping) && (h = (a = r.isSleeping && !r.isStatic ? r : o) === r ? o : r, !a.isStatic && h.motion > u._motionWakeThreshold * i && u.set(a, !1))); } }, u.set = function (t, e) { const i = t.isSleeping; e ? (t.isSleeping = !0, t.sleepCounter = t.sleepThreshold, t.positionImpulse.x = 0, t.positionImpulse.y = 0, t.positionPrev.x = t.position.x, t.positionPrev.y = t.position.y, t.anglePrev = t.angle, t.speed = 0, t.angularSpeed = 0, t.motion = 0, i || n.trigger(t, 'sleepStart')) : (t.isSleeping = !1, t.sleepCounter = 0, i && n.trigger(t, 'sleepEnd')); }; }, function (t, e, i) { const n = {}; t.exports = n; const u = i(42); n.on = function (t, e, i) { for (var n, s = e.split(' '), r = 0; r < s.length; r++)n = s[r], t.events = t.events || {}, t.events[n] = t.events[n] || [], t.events[n].push(i); return i; }, n.off = function (t, e, i) { if (e) { typeof e === 'function' && (i = e, e = u.keys(t.events).join(' ')); for (let n = e.split(' '), s = 0; s < n.length; s++) { const r = t.events[n[s]]; const o = []; if (i && r) for (let a = 0; a < r.length; a++)r[a] !== i && o.push(r[a]); t.events[n[s]] = o; } } else t.events = {}; }, n.trigger = function (t, e, i) { let n; let s; let r; let o; const a = t.events; if (a && u.keys(a).length > 0) { i = i || {}, n = e.split(' '); for (let h = 0; h < n.length; h++) if (r = a[s = n[h]]) { (o = u.clone(i, !1)).name = s, o.source = t; for (let l = 0; l < r.length; l++)r[l].apply(t, [o]); } } }; }, function (t, e, i) {\n    t.exports = {\n      AlignTo: i(527), Angle: i(528), Call: i(529), GetFirst: i(530), GetLast: i(531), GridAlign: i(532), IncAlpha: i(593), IncX: i(594), IncXY: i(595), IncY: i(596), PlaceOnCircle: i(597), PlaceOnEllipse: i(598), PlaceOnLine: i(599), PlaceOnRectangle: i(600), PlaceOnTriangle: i(601), PlayAnimation: i(602), PropertyValueInc: i(38), PropertyValueSet: i(25), RandomCircle: i(603), RandomEllipse: i(604), RandomLine: i(605), RandomRectangle: i(606), RandomTriangle: i(607), Rotate: i(608), RotateAround: i(609), RotateAroundDistance: i(610), ScaleX: i(611), ScaleXY: i(612), ScaleY: i(613), SetAlpha: i(614), SetBlendMode: i(615), SetDepth: i(616), SetHitArea: i(617), SetOrigin: i(618), SetRotation: i(619), SetScale: i(620), SetScaleX: i(621), SetScaleY: i(622), SetScrollFactor: i(623), SetScrollFactorX: i(624), SetScrollFactorY: i(625), SetTint: i(626), SetVisible: i(627), SetX: i(628), SetXY: i(629), SetY: i(630), ShiftPosition: i(631), Shuffle: i(632), SmootherStep: i(633), SmoothStep: i(634), Spread: i(635), ToggleVisible: i(636), WrapInRectangle: i(637),\n    };\n  }, function (t, e, i) { const n = i(105); const r = []; r[n.BOTTOM_CENTER] = i(243), r[n.BOTTOM_LEFT] = i(244), r[n.BOTTOM_RIGHT] = i(245), r[n.LEFT_BOTTOM] = i(246), r[n.LEFT_CENTER] = i(247), r[n.LEFT_TOP] = i(248), r[n.RIGHT_BOTTOM] = i(249), r[n.RIGHT_CENTER] = i(250), r[n.RIGHT_TOP] = i(251), r[n.TOP_CENTER] = i(252), r[n.TOP_LEFT] = i(253), r[n.TOP_RIGHT] = i(254); t.exports = function (t, e, i, n, s) { return r[i](t, e, n, s); }; }, function (t, e, i) { const s = i(34); const r = i(76); const o = i(77); const a = i(43); t.exports = function (t, e, i, n) { return void 0 === i && (i = 0), void 0 === n && (n = 0), o(t, r(e) + i), a(t, s(e) + n), t; }; }, function (t, e, i) { const s = i(34); const r = i(35); const o = i(44); const a = i(43); t.exports = function (t, e, i, n) { return void 0 === i && (i = 0), void 0 === n && (n = 0), o(t, r(e) - i), a(t, s(e) + n), t; }; }, function (t, e, i) { const s = i(34); const r = i(36); const o = i(45); const a = i(43); t.exports = function (t, e, i, n) { return void 0 === i && (i = 0), void 0 === n && (n = 0), o(t, r(e) + i), a(t, s(e) + n), t; }; }, function (t, e, i) { const s = i(34); const r = i(35); const o = i(46); const a = i(45); t.exports = function (t, e, i, n) { return void 0 === i && (i = 0), void 0 === n && (n = 0), a(t, r(e) - i), o(t, s(e) + n), t; }; }, function (t, e, i) { const s = i(78); const r = i(35); const o = i(79); const a = i(45); t.exports = function (t, e, i, n) { return void 0 === i && (i = 0), void 0 === n && (n = 0), a(t, r(e) - i), o(t, s(e) + n), t; }; }, function (t, e, i) { const s = i(35); const r = i(37); const o = i(45); const a = i(43); t.exports = function (t, e, i, n) { return void 0 === i && (i = 0), void 0 === n && (n = 0), o(t, s(e) - i), a(t, r(e) - n), t; }; }, function (t, e, i) { const s = i(34); const r = i(36); const o = i(46); const a = i(44); t.exports = function (t, e, i, n) { return void 0 === i && (i = 0), void 0 === n && (n = 0), a(t, r(e) + i), o(t, s(e) + n), t; }; }, function (t, e, i) { const s = i(78); const r = i(36); const o = i(79); const a = i(44); t.exports = function (t, e, i, n) { return void 0 === i && (i = 0), void 0 === n && (n = 0), a(t, r(e) + i), o(t, s(e) + n), t; }; }, function (t, e, i) { const s = i(36); const r = i(37); const o = i(44); const a = i(43); t.exports = function (t, e, i, n) { return void 0 === i && (i = 0), void 0 === n && (n = 0), o(t, s(e) + i), a(t, r(e) - n), t; }; }, function (t, e, i) { const s = i(76); const r = i(37); const o = i(46); const a = i(77); t.exports = function (t, e, i, n) { return void 0 === i && (i = 0), void 0 === n && (n = 0), a(t, s(e) + i), o(t, r(e) - n), t; }; }, function (t, e, i) { const s = i(35); const r = i(37); const o = i(46); const a = i(44); t.exports = function (t, e, i, n) { return void 0 === i && (i = 0), void 0 === n && (n = 0), a(t, s(e) - i), o(t, r(e) - n), t; }; }, function (t, e, i) { const s = i(36); const r = i(37); const o = i(46); const a = i(45); t.exports = function (t, e, i, n) { return void 0 === i && (i = 0), void 0 === n && (n = 0), a(t, s(e) + i), o(t, r(e) - n), t; }; }, function (t, e, i) { const n = i(105); const r = []; r[n.BOTTOM_CENTER] = i(256), r[n.BOTTOM_LEFT] = i(257), r[n.BOTTOM_RIGHT] = i(258), r[n.CENTER] = i(259), r[n.LEFT_CENTER] = i(261), r[n.RIGHT_CENTER] = i(262), r[n.TOP_CENTER] = i(263), r[n.TOP_LEFT] = i(264), r[n.TOP_RIGHT] = i(265), r[n.LEFT_BOTTOM] = r[n.BOTTOM_LEFT], r[n.LEFT_TOP] = r[n.TOP_LEFT], r[n.RIGHT_BOTTOM] = r[n.BOTTOM_RIGHT], r[n.RIGHT_TOP] = r[n.TOP_RIGHT]; t.exports = function (t, e, i, n, s) { return r[i](t, e, n, s); }; }, function (t, e, i) { const s = i(34); const r = i(76); const o = i(46); const a = i(77); t.exports = function (t, e, i, n) { return void 0 === i && (i = 0), void 0 === n && (n = 0), a(t, r(e) + i), o(t, s(e) + n), t; }; }, function (t, e, i) { const s = i(34); const r = i(35); const o = i(46); const a = i(44); t.exports = function (t, e, i, n) { return void 0 === i && (i = 0), void 0 === n && (n = 0), a(t, r(e) - i), o(t, s(e) + n), t; }; }, function (t, e, i) { const s = i(34); const r = i(36); const o = i(46); const a = i(45); t.exports = function (t, e, i, n) { return void 0 === i && (i = 0), void 0 === n && (n = 0), a(t, r(e) + i), o(t, s(e) + n), t; }; }, function (t, e, i) { const s = i(260); const r = i(76); const o = i(78); t.exports = function (t, e, i, n) { return void 0 === i && (i = 0), void 0 === n && (n = 0), s(t, r(e) + i, o(e) + n), t; }; }, function (t, e, i) { const n = i(77); const s = i(79); t.exports = function (t, e, i) { return n(t, e), s(t, i); }; }, function (t, e, i) { const s = i(78); const r = i(35); const o = i(79); const a = i(44); t.exports = function (t, e, i, n) { return void 0 === i && (i = 0), void 0 === n && (n = 0), a(t, r(e) - i), o(t, s(e) + n), t; }; }, function (t, e, i) { const s = i(78); const r = i(36); const o = i(79); const a = i(45); t.exports = function (t, e, i, n) { return void 0 === i && (i = 0), void 0 === n && (n = 0), a(t, r(e) + i), o(t, s(e) + n), t; }; }, function (t, e, i) { const s = i(76); const r = i(37); const o = i(77); const a = i(43); t.exports = function (t, e, i, n) { return void 0 === i && (i = 0), void 0 === n && (n = 0), o(t, s(e) + i), a(t, r(e) - n), t; }; }, function (t, e, i) { const s = i(35); const r = i(37); const o = i(44); const a = i(43); t.exports = function (t, e, i, n) { return void 0 === i && (i = 0), void 0 === n && (n = 0), o(t, s(e) - i), a(t, r(e) - n), t; }; }, function (t, e, i) { const s = i(36); const r = i(37); const o = i(45); const a = i(43); t.exports = function (t, e, i, n) { return void 0 === i && (i = 0), void 0 === n && (n = 0), o(t, s(e) + i), a(t, r(e) - n), t; }; }, function (t, e, i) { const s = i(149); const r = i(87); const o = i(13); const a = i(4); t.exports = function (t, e, i) { void 0 === i && (i = new a()); const n = r(e, 0, o.PI2); return s(t, n, i); }; }, function (t, e, i) { const o = i(268); const a = i(149); const h = i(87); const l = i(13); t.exports = function (t, e, i, n) { void 0 === n && (n = []), !e && i > 0 && (e = o(t) / i); for (let s = 0; s < e; s++) { const r = h(s / e, 0, l.PI2); n.push(a(t, r)); } return n; }; }, function (t, e) { t.exports = function (t) { return Math.PI * t.radius * 2; }; }, function (t, e, i) {\n    const n = i(19); const s = {\n      _alpha: 1, clearAlpha() { return this.setAlpha(1); }, setAlpha(t) { return void 0 === t && (t = 1), this.alpha = t, this; }, alpha: { get() { return this._alpha; }, set(t) { const e = n(t, 0, 1); (this._alpha = e) === 0 ? this.renderFlags &= -3 : this.renderFlags |= 2; } },\n    }; t.exports = s;\n  }, function (t, e) { t.exports = function (t, e, i) { if (!e.length) return NaN; if (e.length === 1) return e[0]; let n; let s; let r = 1; if (i) { if (t < e[0][i]) return e[0]; for (;e[r][i] < t;)r++; } else for (;e[r] < t;)r++; return r > e.length && (r = e.length), i ? (n = e[r - 1][i], (s = e[r][i]) - t <= t - n ? e[r] : e[r - 1]) : (n = e[r - 1], (s = e[r]) - t <= t - n ? s : n); }; }, function (t, e, i) { const n = new (i(0))({ initialize(t, e, i, n) { this.textureKey = t, this.textureFrame = e, this.index = i, this.frame = n, this.isFirst = !1, this.isLast = !1, this.prevFrame = null, this.nextFrame = null, this.duration = 0, this.progress = 0; }, toJSON() { return { key: this.textureKey, frame: this.textureFrame, duration: this.duration }; }, destroy() { this.frame = void 0; } }); t.exports = n; }, function (t, e, i) { const n = i(52); const s = { _blendMode: n.NORMAL, blendMode: { get() { return this._blendMode; }, set(t) { typeof t === 'string' && (t = n[t]), (t |= 0) >= -1 && (this._blendMode = t); } }, setBlendMode(t) { return this.blendMode = t, this; } }; t.exports = s; }, function (t, e) { const i = { _depth: 0, depth: { get() { return this._depth; }, set(t) { this.scene.sys.queueDepthSort(), this._depth = t; } }, setDepth(t) { return void 0 === t && (t = 0), this.depth = t, this; } }; t.exports = i; }, function (t, e, i) { const o = i(152); const a = i(112); t.exports = function (t, e, i, n) { void 0 === n && (n = []), !e && i > 0 && (e = a(t) / i); for (let s = 0; s < e; s++) { const r = s / e; n.push(o(t, r)); } return n; }; }, function (t, e, i) { const n = i(4); t.exports = function (t, e, i) { return void 0 === i && (i = new n()), i.x = t.x1 + (t.x2 - t.x1) * e, i.y = t.y1 + (t.y2 - t.y1) * e, i; }; }, function (t, e) { t.exports = function (t, e, i, n) { const s = Math.cos(n); const r = Math.sin(n); const o = t.x - e; const a = t.y - i; return t.x = o * s - a * r + e, t.y = o * r + a * s + i, t; }; }, function (t, e, i) {\n    const n = i(278); const s = i(279); const r = {\n      mask: null, setMask(t) { return this.mask = t, this; }, clearMask(t) { return void 0 === t && (t = !1), t && this.mask && this.mask.destroy(), this.mask = null, this; }, createBitmapMask(t) { return void 0 === t && (this.texture || this.shader) && (t = this), new n(this.scene, t); }, createGeometryMask(t) { return void 0 === t && this.type === 'Graphics' && (t = this), new s(this.scene, t); },\n    }; t.exports = r;\n  }, function (t, e, i) {\n    const n = i(0); const l = i(20); const s = new n({\n      initialize(t, e) { let i; let n; let s; let r; let o; let a; const h = t.sys.game.renderer; this.renderer = h, this.bitmapMask = e, this.maskTexture = null, this.mainTexture = null, this.dirty = !0, this.mainFramebuffer = null, this.maskFramebuffer = null, this.prevFramebuffer = null, this.invertAlpha = !1, this.isStencil = !1, h && h.gl && (i = h.width, n = h.height, s = (i & i - 1) == 0 && (n & n - 1) == 0, r = h.gl, o = s ? r.REPEAT : r.CLAMP_TO_EDGE, a = r.LINEAR, this.mainTexture = h.createTexture2D(0, a, a, o, o, r.RGBA, null, i, n), this.maskTexture = h.createTexture2D(0, a, a, o, o, r.RGBA, null, i, n), this.mainFramebuffer = h.createFramebuffer(i, n, this.mainTexture, !0), this.maskFramebuffer = h.createFramebuffer(i, n, this.maskTexture, !0), t.sys.game.events.on(l.CONTEXT_RESTORED, function (t) { const e = t.width; const i = t.height; const n = (e & e - 1) == 0 && (i & i - 1) == 0; const s = t.gl; const r = n ? s.REPEAT : s.CLAMP_TO_EDGE; const o = s.LINEAR; this.mainTexture = t.createTexture2D(0, o, o, r, r, s.RGBA, null, e, i), this.maskTexture = t.createTexture2D(0, o, o, r, r, s.RGBA, null, e, i), this.mainFramebuffer = t.createFramebuffer(e, i, this.mainTexture, !0), this.maskFramebuffer = t.createFramebuffer(e, i, this.maskTexture, !0); }, this)); }, setBitmap(t) { this.bitmapMask = t; }, preRenderWebGL(t, e, i) { t.pipelines.BitmapMaskPipeline.beginMask(this, e, i); }, postRenderWebGL(t, e) { t.pipelines.BitmapMaskPipeline.endMask(this, e); }, preRenderCanvas() {}, postRenderCanvas() {}, destroy() { this.bitmapMask = null; const t = this.renderer; t && t.gl && (t.deleteTexture(this.mainTexture), t.deleteTexture(this.maskTexture), t.deleteFramebuffer(this.mainFramebuffer), t.deleteFramebuffer(this.maskFramebuffer)), this.mainTexture = null, this.maskTexture = null, this.mainFramebuffer = null, this.maskFramebuffer = null, this.prevFramebuffer = null, this.renderer = null; },\n    }); t.exports = s;\n  }, function (t, e, i) {\n    const n = new (i(0))({\n      initialize(t, e) { this.geometryMask = e, this.invertAlpha = !1, this.isStencil = !0, this.level = 0; }, setShape(t) { return this.geometryMask = t, this; }, setInvertAlpha(t) { return void 0 === t && (t = !0), this.invertAlpha = t, this; }, preRenderWebGL(t, e, i) { const n = t.gl; t.flush(), t.maskStack.length === 0 && (n.enable(n.STENCIL_TEST), n.clear(n.STENCIL_BUFFER_BIT), t.maskCount = 0), t.currentCameraMask.mask !== this && (t.currentMask.mask = this), t.maskStack.push({ mask: this, camera: i }), this.applyStencil(t, i, !0), t.maskCount++; }, applyStencil(t, e, i) { const n = t.gl; const s = this.geometryMask; const r = t.maskCount; n.colorMask(!1, !1, !1, !1), i ? (n.stencilFunc(n.EQUAL, r, 255), n.stencilOp(n.KEEP, n.KEEP, n.INCR)) : (n.stencilFunc(n.EQUAL, r + 1, 255), n.stencilOp(n.KEEP, n.KEEP, n.DECR)), s.renderWebGL(t, s, 0, e), t.flush(), n.colorMask(!0, !0, !0, !0), n.stencilOp(n.KEEP, n.KEEP, n.KEEP), i ? this.invertAlpha ? n.stencilFunc(n.NOTEQUAL, r + 1, 255) : n.stencilFunc(n.EQUAL, r + 1, 255) : this.invertAlpha ? n.stencilFunc(n.NOTEQUAL, r, 255) : n.stencilFunc(n.EQUAL, r, 255); }, postRenderWebGL(t) { let e; const i = t.gl; t.maskStack.pop(), t.maskCount--, t.maskStack.length === 0 ? (t.flush(), t.currentMask.mask = null, i.disable(i.STENCIL_TEST)) : (t.flush(), (e = t.maskStack[t.maskStack.length - 1]).mask.applyStencil(t, e.camera, !1), t.currentCameraMask.mask !== e.mask ? (t.currentMask.mask = e.mask, t.currentMask.camera = e.camera) : t.currentMask.mask = null); }, preRenderCanvas(t, e, i) { const n = this.geometryMask; t.currentContext.save(), n.renderCanvas(t, n, 0, i, null, null, !0), t.currentContext.clip(); }, postRenderCanvas(t) { t.currentContext.restore(); }, destroy() { this.geometryMask = null; },\n    }); t.exports = n;\n  }, function (t, e) { const i = { scrollFactorX: 1, scrollFactorY: 1, setScrollFactor(t, e) { return void 0 === e && (e = t), this.scrollFactorX = t, this.scrollFactorY = e, this; } }; t.exports = i; }, function (t, e) {\n    t.exports = function (t) {\n      const e = {\n        name: t.name, type: t.type, x: t.x, y: t.y, depth: t.depth, scale: { x: t.scaleX, y: t.scaleY }, origin: { x: t.originX, y: t.originY }, flipX: t.flipX, flipY: t.flipY, rotation: t.rotation, alpha: t.alpha, visible: t.visible, blendMode: t.blendMode, textureKey: '', frameKey: '', data: {},\n      }; return t.texture && (e.textureKey = t.texture.key, e.frameKey = t.frame.name), e;\n    };\n  }, function (t, e, i) {\n    const n = i(13); const s = i(29); const r = i(235); const o = i(236); const a = {\n      _scaleX: 1, _scaleY: 1, _rotation: 0, x: 0, y: 0, z: 0, w: 0, scale: { get() { return (this._scaleX + this._scaleY) / 2; }, set(t) { this._scaleX = t, (this._scaleY = t) === 0 ? this.renderFlags &= -5 : this.renderFlags |= 4; } }, scaleX: { get() { return this._scaleX; }, set(t) { (this._scaleX = t) === 0 ? this.renderFlags &= -5 : this.renderFlags |= 4; } }, scaleY: { get() { return this._scaleY; }, set(t) { (this._scaleY = t) === 0 ? this.renderFlags &= -5 : this.renderFlags |= 4; } }, angle: { get() { return o(this._rotation * n.RAD_TO_DEG); }, set(t) { this.rotation = o(t) * n.DEG_TO_RAD; } }, rotation: { get() { return this._rotation; }, set(t) { this._rotation = r(t); } }, setPosition(t, e, i, n) { return void 0 === t && (t = 0), void 0 === e && (e = t), void 0 === i && (i = 0), void 0 === n && (n = 0), this.x = t, this.y = e, this.z = i, this.w = n, this; }, setRandomPosition(t, e, i, n) { return void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = this.scene.sys.scale.width), void 0 === n && (n = this.scene.sys.scale.height), this.x = t + Math.random() * i, this.y = e + Math.random() * n, this; }, setRotation(t) { return void 0 === t && (t = 0), this.rotation = t, this; }, setAngle(t) { return void 0 === t && (t = 0), this.angle = t, this; }, setScale(t, e) { return void 0 === t && (t = 1), void 0 === e && (e = t), this.scaleX = t, this.scaleY = e, this; }, setX(t) { return void 0 === t && (t = 0), this.x = t, this; }, setY(t) { return void 0 === t && (t = 0), this.y = t, this; }, setZ(t) { return void 0 === t && (t = 0), this.z = t, this; }, setW(t) { return void 0 === t && (t = 0), this.w = t, this; }, getLocalTransformMatrix(t) { return void 0 === t && (t = new s()), t.applyITRS(this.x, this.y, this._rotation, this._scaleX, this._scaleY); }, getWorldTransformMatrix(t, e) { void 0 === t && (t = new s()), void 0 === e && (e = new s()); let i = this.parentContainer; if (!i) return this.getLocalTransformMatrix(t); for (t.applyITRS(this.x, this.y, this._rotation, this._scaleX, this._scaleY); i;)e.applyITRS(i.x, i.y, i._rotation, i._scaleX, i._scaleY), e.multiply(t, t), i = i.parentContainer; return t; }, getParentRotation() { for (var t = 0, e = this.parentContainer; e;)t += e.rotation, e = e.parentContainer; return t; },\n    }; t.exports = a;\n  }, function (t, e) { const i = { _visible: !0, visible: { get() { return this._visible; }, set(t) { t ? (this._visible = !0, this.renderFlags |= 1) : (this._visible = !1, this.renderFlags &= -2); } }, setVisible(t) { return this.visible = t, this; } }; t.exports = i; }, function (t, e, i) {\n    t.exports = {\n      CHANGE_DATA: i(578), CHANGE_DATA_KEY: i(579), REMOVE_DATA: i(580), SET_DATA: i(581),\n    };\n  }, function (t, e, i) { const h = i(112); const l = i(4); t.exports = function (t, e, i, n) { if (void 0 === n && (n = []), !e && !i) return n; e ? i = Math.round(h(t) / e) : e = h(t) / i; for (let s = t.x, r = t.y, o = 0, a = 0; a < i; a++) switch (n.push(new l(s, r)), o) { case 0: (s += e) >= t.right && (o = 1, r += s - t.right, s = t.right); break; case 1: (r += e) >= t.bottom && (o = 2, s -= r - t.bottom, r = t.bottom); break; case 2: (s -= e) <= t.left && (o = 3, r -= t.left - s, s = t.left); break; case 3: (r -= e) <= t.top && (o = 0, r = t.top); } return n; }; }, function (t, e) { t.exports = function (t, e) { void 0 === e && (e = 1); for (var i = null, n = 0; n < e; n++)i = t.shift(), t.push(i); return i; }; }, function (t, e) { t.exports = function (t, e) { void 0 === e && (e = 1); for (var i = null, n = 0; n < e; n++)i = t.pop(), t.unshift(i); return i; }; }, function (t, e) { t.exports = function (t, e, i) { void 0 === e && (e = 1), void 0 === i && (i = []); let n = Math.round(t.x1); let s = Math.round(t.y1); const r = Math.round(t.x2); const o = Math.round(t.y2); const a = Math.abs(r - n); const h = Math.abs(o - s); const l = n < r ? 1 : -1; const u = s < o ? 1 : -1; let c = a - h; i.push({ x: n, y: s }); for (let d = 1; n !== r || s !== o;) { const f = c << 1; -h < f && (c -= h, n += l), f < a && (c += a, s += u), d % e == 0 && i.push({ x: n, y: s }), d++; } return i; }; }, function (t, e, i) {\n    const n = i(151); const s = i(0); const r = i(162); const o = i(10); const a = i(111); const h = i(20); const f = i(6); const p = i(163); const l = new s({\n      Extends: o, initialize(t) { o.call(this), this.game = t, this.textureManager = null, this.globalTimeScale = 1, this.anims = new r(), this.paused = !1, this.name = 'AnimationManager', t.events.once(h.BOOT, this.boot, this); }, boot() { this.textureManager = this.game.textures, this.game.events.once(h.DESTROY, this.destroy, this); }, add(t, e) { return this.anims.has(t) ? console.warn(`Animation key exists: ${t}`) : (e.key = t, this.anims.set(t, e), this.emit(a.ADD_ANIMATION, t, e)), this; }, exists(t) { return this.anims.has(t); }, create(t) { const e = t.key; let i = !1; return e && ((i = this.get(e)) || (i = new n(this, e, t), this.anims.set(e, i), this.emit(a.ADD_ANIMATION, e, i))), i; }, fromJSON(t, e) { void 0 === e && (e = !1), e && this.anims.clear(), typeof t === 'string' && (t = JSON.parse(t)); const i = []; if (t.hasOwnProperty('anims') && Array.isArray(t.anims)) { for (let n = 0; n < t.anims.length; n++)i.push(this.create(t.anims[n])); t.hasOwnProperty('globalTimeScale') && (this.globalTimeScale = t.globalTimeScale); } else t.hasOwnProperty('key') && t.type === 'frame' && i.push(this.create(t)); return i; }, generateFrameNames(t, e) { const i = f(e, 'prefix', ''); const n = f(e, 'start', 0); let s = f(e, 'end', 0); const r = f(e, 'suffix', ''); const o = f(e, 'zeroPad', 0); const a = f(e, 'outputArray', []); let h = f(e, 'frames', !1); const l = this.textureManager.get(t); if (!l) return a; let u; let c; const d = n < s ? 1 : -1; if (s += d, e) if (Array.isArray(h)) for (u = 0; u < h.length; u++)c = i + p(h[u], o, '0', 1) + r, l.has(c) && a.push({ key: t, frame: c }); else for (u = n; u !== s; u += d)c = i + p(u, o, '0', 1) + r, l.has(c) && a.push({ key: t, frame: c }); else for (h = l.getFrameNames(), u = 0; u < h.length; u++)a.push({ key: t, frame: h[u] }); return a; }, generateFrameNumbers(t, e) { let i; const n = f(e, 'start', 0); let s = f(e, 'end', -1); const r = f(e, 'first', !1); const o = f(e, 'outputArray', []); const a = f(e, 'frames', !1); const h = this.textureManager.get(t); if (!h) return o; if (r && h.has(r) && o.push({ key: t, frame: r }), Array.isArray(a)) for (i = 0; i < a.length; i++)h.has(a[i]) && o.push({ key: t, frame: a[i] }); else { s === -1 && (s = h.frameTotal); const l = n < s ? 1 : -1; for (s += l, i = n; i !== s; i += l)h.has(i) && o.push({ key: t, frame: i }); } return o; }, get(t) { return this.anims.get(t); }, load(t, e, i) { const n = this.get(e); return n ? n.load(t, i) : console.warn(`Missing animation: ${e}`), t; }, pauseAll() { return this.paused || (this.paused = !0, this.emit(a.PAUSE_ALL)), this; }, play(t, e) { if (Array.isArray(e) || (e = [e]), !this.get(t)) return this; for (let i = 0; i < e.length; i++)e[i].anims.play(t); return this; }, remove(t) { const e = this.get(t); return e && (this.emit(a.REMOVE_ANIMATION, t, e), this.anims.delete(t)), e; }, resumeAll() { return this.paused && (this.paused = !1, this.emit(a.RESUME_ALL)), this; }, staggerPlay(t, e, i) { if (void 0 === i && (i = 0), Array.isArray(e) || (e = [e]), !this.get(t)) return this; for (let n = 0; n < e.length; n++)e[n].anims.delayedPlay(i * n, t); return this; }, toJSON(t) { const i = { anims: [], globalTimeScale: this.globalTimeScale }; return void 0 !== t && t !== '' ? i.anims.push(this.anims.get(t).toJSON()) : this.anims.each((t, e) => { i.anims.push(e.toJSON()); }), i; }, destroy() { this.anims.clear(), this.textureManager = null, this.game = null; },\n    }); t.exports = l;\n  }, function (t, e, i) {\n    const n = i(0); const s = i(162); const r = i(10); const o = i(291); const a = new n({\n      initialize() { this.entries = new s(), this.events = new r(); }, add(t, e) { return this.entries.set(t, e), this.events.emit(o.ADD, this, t, e), this; }, has(t) { return this.entries.has(t); }, exists(t) { return this.entries.has(t); }, get(t) { return this.entries.get(t); }, remove(t) { const e = this.get(t); return e && (this.entries.delete(t), this.events.emit(o.REMOVE, this, t, e.data)), this; }, getKeys() { return this.entries.keys(); }, destroy() { this.entries.clear(), this.events.removeAllListeners(), this.entries = null, this.events = null; },\n    }); t.exports = a;\n  }, function (t, e, i) { t.exports = { ADD: i(640), REMOVE: i(641) }; }, function (t, e, i) { const n = i(290); const s = i(0); const r = i(20); const o = new s({ initialize(t) { this.game = t, this.binary = new n(), this.bitmapFont = new n(), this.json = new n(), this.physics = new n(), this.shader = new n(), this.audio = new n(), this.video = new n(), this.text = new n(), this.html = new n(), this.obj = new n(), this.tilemap = new n(), this.xml = new n(), this.custom = {}, this.game.events.once(r.DESTROY, this.destroy, this); }, addCustom(t) { return this.custom.hasOwnProperty(t) || (this.custom[t] = new n()), this.custom[t]; }, destroy() { for (let t = ['binary', 'bitmapFont', 'json', 'physics', 'shader', 'audio', 'video', 'text', 'html', 'obj', 'tilemap', 'xml'], e = 0; e < t.length; e++) this[t[e]].destroy(), this[t[e]] = null; for (const i in this.custom) this.custom[i].destroy(); this.custom = null, this.game = null; } }); t.exports = o; }, function (t, e, i) {\n    const s = i(91); const n = i(26); const x = i(168); const u = i(19); const r = i(0); const o = i(12); const a = i(301); const T = i(116); const h = i(11); const l = i(3); const c = new r({\n      Extends: s, Mixins: [o.Flip, o.Tint], initialize(t, e, i, n) { s.call(this, t, e, i, n), this.inputEnabled = !0, this.fadeEffect = new a.Fade(this), this.flashEffect = new a.Flash(this), this.shakeEffect = new a.Shake(this), this.panEffect = new a.Pan(this), this.rotateToEffect = new a.RotateTo(this), this.zoomEffect = new a.Zoom(this), this.lerp = new l(1, 1), this.followOffset = new l(), this.deadzone = null, this._follow = null, this.renderToTexture = !1, this.renderToGame = !0, this.canvas = null, this.context = null, this.glTexture = null, this.framebuffer = null, this.pipeline = null; }, setRenderToTexture(t, e) { void 0 === e && (e = !0); const i = this.scene.sys.game.renderer; return i.gl ? (this.glTexture = i.createTextureFromSource(null, this.width, this.height, 0), this.framebuffer = i.createFramebuffer(this.width, this.height, this.glTexture, !1)) : (this.canvas = n.create2D(this, this.width, this.height), this.context = this.canvas.getContext('2d')), this.renderToTexture = !0, this.renderToGame = e, t && this.setPipeline(t), this; }, setPipeline(t) { let e; return typeof t === 'string' ? (e = this.scene.sys.game.renderer).gl && e.hasPipeline(t) && (this.pipeline = e.getPipeline(t)) : this.pipeline = t, this; }, clearRenderToTexture() { if (this.scene) { const t = this.scene.sys.game.renderer; if (t) return t.gl ? (this.framebuffer && t.deleteFramebuffer(this.framebuffer), this.glTexture && t.deleteTexture(this.glTexture), this.framebuffer = null, this.glTexture = null, this.pipeline = null) : (n.remove(this), this.canvas = null, this.context = null), this.renderToTexture = !1, this; } }, setDeadzone(t, e) { let i; let n; let s; let r; return void 0 === t ? this.deadzone = null : (this.deadzone ? (this.deadzone.width = t, this.deadzone.height = e) : this.deadzone = new h(0, 0, t, e), this._follow && (i = this.width / 2, n = this.height / 2, s = this._follow.x - this.followOffset.x, r = this._follow.y - this.followOffset.y, this.midPoint.set(s, r), this.scrollX = s - i, this.scrollY = r - n), x(this.deadzone, this.midPoint.x, this.midPoint.y)), this; }, fadeIn(t, e, i, n, s, r) { return this.fadeEffect.start(!1, t, e, i, n, !0, s, r); }, fadeOut(t, e, i, n, s, r) { return this.fadeEffect.start(!0, t, e, i, n, !0, s, r); }, fadeFrom(t, e, i, n, s, r, o) { return this.fadeEffect.start(!1, t, e, i, n, s, r, o); }, fade(t, e, i, n, s, r, o) { return this.fadeEffect.start(!0, t, e, i, n, s, r, o); }, flash(t, e, i, n, s, r, o) { return this.flashEffect.start(t, e, i, n, s, r, o); }, shake(t, e, i, n, s) { return this.shakeEffect.start(t, e, i, n, s); }, pan(t, e, i, n, s, r, o) { return this.panEffect.start(t, e, i, n, s, r, o); }, rotateTo(t, e, i, n, s, r, o) { return this.rotateToEffect.start(t, e, i, n, s, r, o); }, zoomTo(t, e, i, n, s, r) { return this.zoomEffect.start(t, e, i, n, s, r); }, preRender(t) { let e; let i; const n = this.width; const s = this.height; const r = 0.5 * n; const o = 0.5 * s; const a = this.zoom * t; const h = this.matrix; let l = n * this.originX; let u = s * this.originY; const c = this._follow; const d = this.deadzone; let f = this.scrollX; let p = this.scrollY; d && x(d, this.midPoint.x, this.midPoint.y), c && !this.panEffect.isRunning && (e = c.x - this.followOffset.x, i = c.y - this.followOffset.y, d ? (e < d.x ? f = T(f, f - (d.x - e), this.lerp.x) : e > d.right && (f = T(f, f + (e - d.right), this.lerp.x)), i < d.y ? p = T(p, p - (d.y - i), this.lerp.y) : i > d.bottom && (p = T(p, p + (i - d.bottom), this.lerp.y))) : (f = T(f, e - l, this.lerp.x), p = T(p, i - u, this.lerp.y))), this.useBounds && (f = this.clampX(f), p = this.clampY(p)), this.roundPixels && (l = Math.round(l), u = Math.round(u)); const g = (this.scrollX = f) + r; const v = (this.scrollY = p) + o; this.midPoint.set(g, v); const m = n / a; const y = s / a; this.worldView.setTo(g - m / 2, v - y / 2, m, y), h.applyITRS(this.x + l, this.y + u, this.rotation, a, a), h.translate(-l, -u), this.shakeEffect.preRender(); }, setLerp(t, e) { return void 0 === t && (t = 1), void 0 === e && (e = t), this.lerp.set(t, e), this; }, setFollowOffset(t, e) { return void 0 === t && (t = 0), void 0 === e && (e = 0), this.followOffset.set(t, e), this; }, startFollow(t, e, i, n, s, r) { void 0 === e && (e = !1), void 0 === i && (i = 1), void 0 === n && (n = i), void 0 === s && (s = 0), void 0 === r && (r = s), this._follow = t, this.roundPixels = e, i = u(i, 0, 1), n = u(n, 0, 1), this.lerp.set(i, n), this.followOffset.set(s, r); const o = this.width / 2; const a = this.height / 2; const h = t.x - s; const l = t.y - r; return this.midPoint.set(h, l), this.scrollX = h - o, this.scrollY = l - a, this.useBounds && (this.scrollX = this.clampX(this.scrollX), this.scrollY = this.clampY(this.scrollY)), this; }, stopFollow() { return this._follow = null, this; }, resetFX() { return this.rotateToEffect.reset(), this.panEffect.reset(), this.shakeEffect.reset(), this.flashEffect.reset(), this.fadeEffect.reset(), this; }, update(t, e) { this.visible && (this.rotateToEffect.update(t, e), this.panEffect.update(t, e), this.zoomEffect.update(t, e), this.shakeEffect.update(t, e), this.flashEffect.update(t, e), this.fadeEffect.update(t, e)); }, destroy() { this.clearRenderToTexture(), this.resetFX(), s.prototype.destroy.call(this), this._follow = null, this.deadzone = null; },\n    }); t.exports = c;\n  }, function (t, e, i) { const o = i(31); t.exports = function (t) { const e = new o(); t = t.replace(/^(?:#|0x)?([a-f\\d])([a-f\\d])([a-f\\d])$/i, (t, e, i, n) => e + e + i + i + n + n); let i; let n; let s; const r = /^(?:#|0x)?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(t); return r && (i = parseInt(r[1], 16), n = parseInt(r[2], 16), s = parseInt(r[3], 16), e.setTo(i, n, s)), e; }; }, function (t, e) { t.exports = function (t, e, i, n) { return n << 24 | t << 16 | e << 8 | i; }; }, function (t, e) { t.exports = function (t, e, i, n) { void 0 === n && (n = { h: 0, s: 0, v: 0 }), t /= 255, e /= 255, i /= 255; const s = Math.min(t, e, i); const r = Math.max(t, e, i); const o = r - s; let a = 0; const h = r === 0 ? 0 : o / r; const l = r; return r !== s && (r === t ? a = (e - i) / o + (e < i ? 6 : 0) : r === e ? a = (i - t) / o + 2 : r === i && (a = (t - e) / o + 4), a /= 6), n.hasOwnProperty('_h') ? (n._h = a, n._s = h, n._v = l) : (n.h = a, n.s = h, n.v = l), n; }; }, function (t, e, i) { const n = i(31); const s = i(298); t.exports = function (t) { const e = s(t); return new n(e.r, e.g, e.b, e.a); }; }, function (t, e) {\n    t.exports = function (t) {\n      return t > 16777215 ? {\n        a: t >>> 24, r: t >> 16 & 255, g: t >> 8 & 255, b: 255 & t,\n      } : {\n        a: 255, r: t >> 16 & 255, g: t >> 8 & 255, b: 255 & t,\n      };\n    };\n  }, function (t, e, i) { const n = i(31); t.exports = function (t) { return new n(t.r, t.g, t.b, t.a); }; }, function (t, e, i) { const a = i(31); t.exports = function (t) { let e; let i; let n; let s; const r = new a(); const o = /^rgba?\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*(?:,\\s*(\\d+(?:\\.\\d+)?))?\\s*\\)$/.exec(t.toLowerCase()); return o && (e = parseInt(o[1], 10), i = parseInt(o[2], 10), n = parseInt(o[3], 10), s = void 0 !== o[4] ? parseFloat(o[4]) : 1, r.setTo(e, i, n, 255 * s)), r; }; }, function (t, e, i) {\n    t.exports = {\n      Fade: i(664), Flash: i(665), Pan: i(666), Shake: i(699), RotateTo: i(700), Zoom: i(701),\n    };\n  }, function (t, e, i) { t.exports = { In: i(667), Out: i(668), InOut: i(669) }; }, function (t, e, i) { t.exports = { In: i(670), Out: i(671), InOut: i(672) }; }, function (t, e, i) { t.exports = { In: i(673), Out: i(674), InOut: i(675) }; }, function (t, e, i) { t.exports = { In: i(676), Out: i(677), InOut: i(678) }; }, function (t, e, i) { t.exports = { In: i(679), Out: i(680), InOut: i(681) }; }, function (t, e, i) { t.exports = { In: i(682), Out: i(683), InOut: i(684) }; }, function (t, e, i) { t.exports = i(685); }, function (t, e, i) { t.exports = { In: i(686), Out: i(687), InOut: i(688) }; }, function (t, e, i) { t.exports = { In: i(689), Out: i(690), InOut: i(691) }; }, function (t, e, i) { t.exports = { In: i(692), Out: i(693), InOut: i(694) }; }, function (t, e, i) { t.exports = { In: i(695), Out: i(696), InOut: i(697) }; }, function (t, e, i) { t.exports = i(698); }, function (t, e, i) { const n = i(0); const a = i(33); const h = i(315); const l = i(2); const u = i(6); const c = i(7); const d = i(170); const f = i(1); const p = i(175); const g = i(164); const s = new n({ initialize(t) { void 0 === t && (t = {}); this.width = u(t, 'width', 1024), this.height = u(t, 'height', 768), this.zoom = u(t, 'zoom', 1), this.resolution = u(t, 'resolution', 1), this.parent = u(t, 'parent', void 0), this.scaleMode = u(t, 'scaleMode', 0), this.expandParent = u(t, 'expandParent', !0), this.autoRound = u(t, 'autoRound', !1), this.autoCenter = u(t, 'autoCenter', 0), this.resizeInterval = u(t, 'resizeInterval', 500), this.fullscreenTarget = u(t, 'fullscreenTarget', null), this.minWidth = u(t, 'minWidth', 0), this.maxWidth = u(t, 'maxWidth', 0), this.minHeight = u(t, 'minHeight', 0), this.maxHeight = u(t, 'maxHeight', 0); const e = u(t, 'scale', null); e && (this.width = u(e, 'width', this.width), this.height = u(e, 'height', this.height), this.zoom = u(e, 'zoom', this.zoom), this.resolution = u(e, 'resolution', this.resolution), this.parent = u(e, 'parent', this.parent), this.scaleMode = u(e, 'mode', this.scaleMode), this.expandParent = u(e, 'expandParent', this.expandParent), this.autoRound = u(e, 'autoRound', this.autoRound), this.autoCenter = u(e, 'autoCenter', this.autoCenter), this.resizeInterval = u(e, 'resizeInterval', this.resizeInterval), this.fullscreenTarget = u(e, 'fullscreenTarget', this.fullscreenTarget), this.minWidth = u(e, 'min.width', this.minWidth), this.maxWidth = u(e, 'max.width', this.maxWidth), this.minHeight = u(e, 'min.height', this.minHeight), this.maxHeight = u(e, 'max.height', this.maxHeight)), this.renderType = u(t, 'type', a.AUTO), this.canvas = u(t, 'canvas', null), this.context = u(t, 'context', null), this.canvasStyle = u(t, 'canvasStyle', null), this.customEnvironment = u(t, 'customEnvironment', !1), this.sceneConfig = u(t, 'scene', null), this.seed = u(t, 'seed', [(Date.now() * Math.random()).toString()]), d.RND = new d.RandomDataGenerator(this.seed), this.gameTitle = u(t, 'title', ''), this.gameURL = u(t, 'url', 'https://phaser.io'), this.gameVersion = u(t, 'version', ''), this.autoFocus = u(t, 'autoFocus', !0), this.domCreateContainer = u(t, 'dom.createContainer', !1), this.domBehindCanvas = u(t, 'dom.behindCanvas', !1), this.inputKeyboard = u(t, 'input.keyboard', !0), this.inputKeyboardEventTarget = u(t, 'input.keyboard.target', window), this.inputKeyboardCapture = u(t, 'input.keyboard.capture', []), this.inputMouse = u(t, 'input.mouse', !0), this.inputMouseEventTarget = u(t, 'input.mouse.target', null), this.inputMouseCapture = u(t, 'input.mouse.capture', !0), this.inputTouch = u(t, 'input.touch', h.input.touch), this.inputTouchEventTarget = u(t, 'input.touch.target', null), this.inputTouchCapture = u(t, 'input.touch.capture', !0), this.inputActivePointers = u(t, 'input.activePointers', 1), this.inputSmoothFactor = u(t, 'input.smoothFactor', 0), this.inputWindowEvents = u(t, 'input.windowEvents', !0), this.inputGamepad = u(t, 'input.gamepad', !1), this.inputGamepadEventTarget = u(t, 'input.gamepad.target', window), this.disableContextMenu = u(t, 'disableContextMenu', !1), this.audio = u(t, 'audio'), this.hideBanner = !1 === u(t, 'banner', null), this.hidePhaser = u(t, 'banner.hidePhaser', !1), this.bannerTextColor = u(t, 'banner.text', '#ffffff'), this.bannerBackgroundColor = u(t, 'banner.background', ['#ff0000', '#ffff00', '#00ff00', '#00ffff', '#000000']), this.gameTitle === '' && this.hidePhaser && (this.hideBanner = !0), this.fps = u(t, 'fps', null); const i = u(t, 'render', t); this.antialias = u(i, 'antialias', !0), this.antialiasGL = u(i, 'antialiasGL', !0), this.mipmapFilter = u(i, 'mipmapFilter', 'LINEAR'), this.desynchronized = u(i, 'desynchronized', !1), this.roundPixels = u(i, 'roundPixels', !1), this.pixelArt = u(i, 'pixelArt', this.zoom !== 1), this.pixelArt && (this.antialias = !1, this.roundPixels = !0), this.transparent = u(i, 'transparent', !1), this.clearBeforeRender = u(i, 'clearBeforeRender', !0), this.premultipliedAlpha = u(i, 'premultipliedAlpha', !0), this.failIfMajorPerformanceCaveat = u(i, 'failIfMajorPerformanceCaveat', !1), this.powerPreference = u(i, 'powerPreference', 'default'), this.batchSize = u(i, 'batchSize', 2e3), this.maxLights = u(i, 'maxLights', 10); const n = u(t, 'backgroundColor', 0); this.backgroundColor = g(n), n === 0 && this.transparent && (this.backgroundColor.alpha = 0), this.preBoot = u(t, 'callbacks.preBoot', f), this.postBoot = u(t, 'callbacks.postBoot', f), this.physics = u(t, 'physics', {}), this.defaultPhysicsSystem = u(this.physics, 'default', !1), this.loaderBaseURL = u(t, 'loader.baseURL', ''), this.loaderPath = u(t, 'loader.path', ''), this.loaderMaxParallelDownloads = u(t, 'loader.maxParallelDownloads', 32), this.loaderCrossOrigin = u(t, 'loader.crossOrigin', void 0), this.loaderResponseType = u(t, 'loader.responseType', ''), this.loaderAsync = u(t, 'loader.async', !0), this.loaderUser = u(t, 'loader.user', ''), this.loaderPassword = u(t, 'loader.password', ''), this.loaderTimeout = u(t, 'loader.timeout', 0), this.loaderWithCredentials = u(t, 'loader.withCredentials', !1), this.installGlobalPlugins = [], this.installScenePlugins = []; const s = u(t, 'plugins', null); let r = p.DefaultScene; s && (Array.isArray(s) ? this.defaultPlugins = s : c(s) && (this.installGlobalPlugins = l(s, 'global', []), this.installScenePlugins = l(s, 'scene', []), Array.isArray(s.default) ? r = s.default : Array.isArray(s.defaultMerge) && (r = r.concat(s.defaultMerge)))), this.defaultPlugins = r; const o = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAg'; this.defaultImage = u(t, 'images.default', `${o}AQMAAABJtOi3AAAAA1BMVEX///+nxBvIAAAAAXRSTlMAQObYZgAAABVJREFUeF7NwIEAAAAAgKD9qdeocAMAoAABm3DkcAAAAABJRU5ErkJggg==`), this.missingImage = u(t, 'images.missing', `${o}CAIAAAD8GO2jAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJ9JREFUeNq01ssOwyAMRFG46v//Mt1ESmgh+DFmE2GPOBARKb2NVjo+17PXLD8a1+pl5+A+wSgFygymWYHBb0FtsKhJDdZlncG2IzJ4ayoMDv20wTmSMzClEgbWYNTAkQ0Z+OJ+A/eWnAaR9+oxCF4Os0H8htsMUp+pwcgBBiMNnAwF8GqIgL2hAzaGFFgZauDPKABmowZ4GL369/0rwACp2yA/ttmvsQAAAABJRU5ErkJggg==`), window && (window.FORCE_WEBGL ? this.renderType = a.WEBGL : window.FORCE_CANVAS && (this.renderType = a.CANVAS)); } }); t.exports = s; }, function (t, e, i) {\n    t.exports = {\n      os: i(117), browser: i(118), features: i(169), input: i(730), audio: i(731), video: i(732), fullscreen: i(733), canvasFeatures: i(316),\n    };\n  }, function (t, e, i) { let n; let s; let r; const o = i(26); const a = { supportInverseAlpha: !1, supportNewBlendModes: !1 }; t.exports = (void 0 !== document && (a.supportNewBlendModes = (n = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAABAQMAAADD8p2OAAAAA1BMVEX/', s = 'AAAACklEQVQI12NgAAAAAgAB4iG8MwAAAABJRU5ErkJggg==', (r = new Image()).onload = function () { const i = new Image(); i.onload = function () { const t = o.create(i, 6, 1).getContext('2d'); if (t.globalCompositeOperation = 'multiply', t.drawImage(r, 0, 0), t.drawImage(i, 2, 0), !t.getImageData(2, 0, 1, 1)) return !1; const e = t.getImageData(2, 0, 1, 1).data; o.remove(i), a.supportNewBlendModes = e[0] === 255 && e[1] === 0 && e[2] === 0; }, i.src = `${n}/wCKxvRF${s}`; }, r.src = `${n}AP804Oa6${s}`, !1), a.supportInverseAlpha = (function () { const t = o.create(this, 2, 1).getContext('2d'); t.fillStyle = 'rgba(10, 20, 30, 0.5)', t.fillRect(0, 0, 1, 1); const e = t.getImageData(0, 0, 1, 1); if (e === null) return !1; t.putImageData(e, 1, 0); const i = t.getImageData(1, 0, 1, 1); return i.data[0] === e.data[0] && i.data[1] === e.data[1] && i.data[2] === e.data[2] && i.data[3] === e.data[3]; }())), a); }, function (t, e) { t.exports = function (t, e, i, n) { return Math.atan2(n - e, i - t); }; }, function (t, e) { t.exports = function (t, e) { return Math.atan2(e.y - t.y, e.x - t.x); }; }, function (t, e) { t.exports = function (t) { return (t %= 2 * Math.PI) >= 0 ? t : t + 2 * Math.PI; }; }, function (t, e) { t.exports = function (t, e) { const i = t.x - e.x; const n = t.y - e.y; return Math.sqrt(i * i + n * n); }; }, function (t, e) { t.exports = function (t, e, i, n) { const s = t - i; const r = e - n; return s * s + r * r; }; }, function (t, e) { t.exports = function (t, e, i) { return void 0 === i && (i = 1e-4), e - i < t; }; }, function (t, e) { t.exports = function (t, e, i) { return void 0 === i && (i = 1e-4), t < e + i; }; }, function (t, e, i) { const n = i(325); t.exports = function (t, e) { return n(t) / n(e) / n(t - e); }; }, function (t, e) { t.exports = function (t) { if (t === 0) return 1; for (var e = t; --t;)e *= t; return e; }; }, function (t, e) { t.exports = function (t, e, i, n, s) { return (l = 1 - t) * l * l * e + 3 * (h = 1 - (a = t)) * h * a * i + 3 * (1 - (o = t)) * o * o * n + (r = t) * r * r * s; let r; let o; let a; let h; let l; }; }, function (t, e) { t.exports = function (t, e, i, n) { return (o = 1 - t) * o * e + 2 * (1 - (r = t)) * r * i + (s = t) * s * n; let s; let r; let o; }; }, function (t, e, i) { const n = i(161); t.exports = function (t, e, i) { return e + (i - e) * n(t, 0, 1); }; }, function (t, e) { t.exports = function (t) { const e = Math.log(t) / 0.6931471805599453; return 1 << Math.ceil(e); }; }, function (t, e) { t.exports = function (t, e, i, n) { return void 0 === i && (i = 0), e === 0 ? t : (t -= i, t = e * Math.ceil(t / e), n ? (i + t) / e : i + t); }; }, function (t, e) { t.exports = function (t, e) { const i = t.x; const n = t.y; return t.x = i * Math.cos(e) - n * Math.sin(e), t.y = i * Math.sin(e) + n * Math.cos(e), t; }; }, function (t, e) { t.exports = function (t) { return t > 0 ? Math.ceil(t) : Math.floor(t); }; }, function (t, e, i) { const g = i(3); t.exports = function (t, e, i, n, s, r, o, a) { void 0 === a && (a = new g()); const h = Math.sin(s); const l = Math.cos(s); const u = l * r; const c = h * r; const d = -h * o; const f = l * o; const p = 1 / (u * f + d * -c); return a.x = f * p * t + -d * p * e + (n * d - i * f) * p, a.y = u * p * e + -c * p * t + (-n * u + i * c) * p, a; }; }, function (t, e, i) {\n    var n = new (i(0))({\n      initialize(t, e, i, n) { this.x = 0, this.y = 0, this.z = 0, this.w = 0, typeof t === 'object' ? (this.x = t.x || 0, this.y = t.y || 0, this.z = t.z || 0, this.w = t.w || 0) : (this.x = t || 0, this.y = e || 0, this.z = i || 0, this.w = n || 0); }, clone() { return new n(this.x, this.y, this.z, this.w); }, copy(t) { return this.x = t.x, this.y = t.y, this.z = t.z || 0, this.w = t.w || 0, this; }, equals(t) { return this.x === t.x && this.y === t.y && this.z === t.z && this.w === t.w; }, set(t, e, i, n) { return typeof t === 'object' ? (this.x = t.x || 0, this.y = t.y || 0, this.z = t.z || 0, this.w = t.w || 0) : (this.x = t || 0, this.y = e || 0, this.z = i || 0, this.w = n || 0), this; }, add(t) { return this.x += t.x, this.y += t.y, this.z += t.z || 0, this.w += t.w || 0, this; }, subtract(t) { return this.x -= t.x, this.y -= t.y, this.z -= t.z || 0, this.w -= t.w || 0, this; }, scale(t) { return this.x *= t, this.y *= t, this.z *= t, this.w *= t, this; }, length() { const t = this.x; const e = this.y; const i = this.z; const n = this.w; return Math.sqrt(t * t + e * e + i * i + n * n); }, lengthSq() { const t = this.x; const e = this.y; const i = this.z; const n = this.w; return t * t + e * e + i * i + n * n; }, normalize() { const t = this.x; const e = this.y; const i = this.z; const n = this.w; let s = t * t + e * e + i * i + n * n; return s > 0 && (s = 1 / Math.sqrt(s), this.x = t * s, this.y = e * s, this.z = i * s, this.w = n * s), this; }, dot(t) { return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w; }, lerp(t, e) { void 0 === e && (e = 0); const i = this.x; const n = this.y; const s = this.z; const r = this.w; return this.x = i + e * (t.x - i), this.y = n + e * (t.y - n), this.z = s + e * (t.z - s), this.w = r + e * (t.w - r), this; }, multiply(t) { return this.x *= t.x, this.y *= t.y, this.z *= t.z || 1, this.w *= t.w || 1, this; }, divide(t) { return this.x /= t.x, this.y /= t.y, this.z /= t.z || 1, this.w /= t.w || 1, this; }, distance(t) { const e = t.x - this.x; const i = t.y - this.y; const n = t.z - this.z || 0; const s = t.w - this.w || 0; return Math.sqrt(e * e + i * i + n * n + s * s); }, distanceSq(t) { const e = t.x - this.x; const i = t.y - this.y; const n = t.z - this.z || 0; const s = t.w - this.w || 0; return e * e + i * i + n * n + s * s; }, negate() { return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this; }, transformMat4(t) { const e = this.x; const i = this.y; const n = this.z; const s = this.w; const r = t.val; return this.x = r[0] * e + r[4] * i + r[8] * n + r[12] * s, this.y = r[1] * e + r[5] * i + r[9] * n + r[13] * s, this.z = r[2] * e + r[6] * i + r[10] * n + r[14] * s, this.w = r[3] * e + r[7] * i + r[11] * n + r[15] * s, this; }, transformQuat(t) { const e = this.x; const i = this.y; const n = this.z; const s = t.x; const r = t.y; const o = t.z; const a = t.w; const h = a * e + r * n - o * i; const l = a * i + o * e - s * n; const u = a * n + s * i - r * e; const c = -s * e - r * i - o * n; return this.x = h * a + c * -s + l * -o - u * -r, this.y = l * a + c * -r + u * -s - h * -o, this.z = u * a + c * -o + h * -r - l * -s, this; }, reset() { return this.x = 0, this.y = 0, this.z = 0, this.w = 0, this; },\n    }); n.prototype.sub = n.prototype.subtract, n.prototype.mul = n.prototype.multiply, n.prototype.div = n.prototype.divide, n.prototype.dist = n.prototype.distance, n.prototype.distSq = n.prototype.distanceSq, n.prototype.len = n.prototype.length, n.prototype.lenSq = n.prototype.lengthSq, t.exports = n;\n  }, function (t, e, i) {\n    var n = new (i(0))({\n      initialize(t) { this.val = new Float32Array(9), t ? this.copy(t) : this.identity(); }, clone() { return new n(this); }, set(t) { return this.copy(t); }, copy(t) { const e = this.val; const i = t.val; return e[0] = i[0], e[1] = i[1], e[2] = i[2], e[3] = i[3], e[4] = i[4], e[5] = i[5], e[6] = i[6], e[7] = i[7], e[8] = i[8], this; }, fromMat4(t) { const e = t.val; const i = this.val; return i[0] = e[0], i[1] = e[1], i[2] = e[2], i[3] = e[4], i[4] = e[5], i[5] = e[6], i[6] = e[8], i[7] = e[9], i[8] = e[10], this; }, fromArray(t) { const e = this.val; return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4], e[5] = t[5], e[6] = t[6], e[7] = t[7], e[8] = t[8], this; }, identity() { const t = this.val; return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 1, t[5] = 0, t[6] = 0, t[7] = 0, t[8] = 1, this; }, transpose() { const t = this.val; const e = t[1]; const i = t[2]; const n = t[5]; return t[1] = t[3], t[2] = t[6], t[3] = e, t[5] = t[7], t[6] = i, t[7] = n, this; }, invert() { const t = this.val; const e = t[0]; const i = t[1]; const n = t[2]; const s = t[3]; const r = t[4]; const o = t[5]; const a = t[6]; const h = t[7]; const l = t[8]; const u = l * r - o * h; const c = -l * s + o * a; const d = h * s - r * a; let f = e * u + i * c + n * d; return f ? (f = 1 / f, t[0] = u * f, t[1] = (-l * i + n * h) * f, t[2] = (o * i - n * r) * f, t[3] = c * f, t[4] = (l * e - n * a) * f, t[5] = (-o * e + n * s) * f, t[6] = d * f, t[7] = (-h * e + i * a) * f, t[8] = (r * e - i * s) * f, this) : null; }, adjoint() { const t = this.val; const e = t[0]; const i = t[1]; const n = t[2]; const s = t[3]; const r = t[4]; const o = t[5]; const a = t[6]; const h = t[7]; const l = t[8]; return t[0] = r * l - o * h, t[1] = n * h - i * l, t[2] = i * o - n * r, t[3] = o * a - s * l, t[4] = e * l - n * a, t[5] = n * s - e * o, t[6] = s * h - r * a, t[7] = i * a - e * h, t[8] = e * r - i * s, this; }, determinant() { const t = this.val; const e = t[0]; const i = t[1]; const n = t[2]; const s = t[3]; const r = t[4]; const o = t[5]; const a = t[6]; const h = t[7]; const l = t[8]; return e * (l * r - o * h) + i * (-l * s + o * a) + n * (h * s - r * a); }, multiply(t) { const e = this.val; const i = e[0]; const n = e[1]; const s = e[2]; const r = e[3]; const o = e[4]; const a = e[5]; const h = e[6]; const l = e[7]; const u = e[8]; const c = t.val; const d = c[0]; const f = c[1]; const p = c[2]; const g = c[3]; const v = c[4]; const m = c[5]; const y = c[6]; const x = c[7]; const T = c[8]; return e[0] = d * i + f * r + p * h, e[1] = d * n + f * o + p * l, e[2] = d * s + f * a + p * u, e[3] = g * i + v * r + m * h, e[4] = g * n + v * o + m * l, e[5] = g * s + v * a + m * u, e[6] = y * i + x * r + T * h, e[7] = y * n + x * o + T * l, e[8] = y * s + x * a + T * u, this; }, translate(t) { const e = this.val; const i = t.x; const n = t.y; return e[6] = i * e[0] + n * e[3] + e[6], e[7] = i * e[1] + n * e[4] + e[7], e[8] = i * e[2] + n * e[5] + e[8], this; }, rotate(t) { const e = this.val; const i = e[0]; const n = e[1]; const s = e[2]; const r = e[3]; const o = e[4]; const a = e[5]; const h = Math.sin(t); const l = Math.cos(t); return e[0] = l * i + h * r, e[1] = l * n + h * o, e[2] = l * s + h * a, e[3] = l * r - h * i, e[4] = l * o - h * n, e[5] = l * a - h * s, this; }, scale(t) { const e = this.val; const i = t.x; const n = t.y; return e[0] = i * e[0], e[1] = i * e[1], e[2] = i * e[2], e[3] = n * e[3], e[4] = n * e[4], e[5] = n * e[5], this; }, fromQuat(t) { const e = t.x; const i = t.y; const n = t.z; const s = t.w; const r = e + e; const o = i + i; const a = n + n; const h = e * r; const l = e * o; const u = e * a; const c = i * o; const d = i * a; const f = n * a; const p = s * r; const g = s * o; const v = s * a; const m = this.val; return m[0] = 1 - (c + f), m[3] = l + v, m[6] = u - g, m[1] = l - v, m[4] = 1 - (h + f), m[7] = d + p, m[2] = u + g, m[5] = d - p, m[8] = 1 - (h + c), this; }, normalFromMat4(t) { const e = t.val; const i = this.val; const n = e[0]; const s = e[1]; const r = e[2]; const o = e[3]; const a = e[4]; const h = e[5]; const l = e[6]; const u = e[7]; const c = e[8]; const d = e[9]; const f = e[10]; const p = e[11]; const g = e[12]; const v = e[13]; const m = e[14]; const y = e[15]; const x = n * h - s * a; const T = n * l - r * a; const w = n * u - o * a; const b = s * l - r * h; const E = s * u - o * h; const S = r * u - o * l; const _ = c * v - d * g; const A = c * m - f * g; const C = c * y - p * g; const M = d * m - f * v; const P = d * y - p * v; const O = f * y - p * m; let R = x * O - T * P + w * M + b * C - E * A + S * _; return R ? (R = 1 / R, i[0] = (h * O - l * P + u * M) * R, i[1] = (l * C - a * O - u * A) * R, i[2] = (a * P - h * C + u * _) * R, i[3] = (r * P - s * O - o * M) * R, i[4] = (n * O - r * C + o * A) * R, i[5] = (s * C - n * P - o * _) * R, i[6] = (v * S - m * E + y * b) * R, i[7] = (m * w - g * S - y * T) * R, i[8] = (g * E - v * w + y * x) * R, this) : null; },\n    }); t.exports = n;\n  }, function (t, e, i) {\n    const n = i(0); var s = new n({\n      initialize(t) { this.val = new Float32Array(16), t ? this.copy(t) : this.identity(); }, clone() { return new s(this); }, set(t) { return this.copy(t); }, copy(t) { const e = this.val; const i = t.val; return e[0] = i[0], e[1] = i[1], e[2] = i[2], e[3] = i[3], e[4] = i[4], e[5] = i[5], e[6] = i[6], e[7] = i[7], e[8] = i[8], e[9] = i[9], e[10] = i[10], e[11] = i[11], e[12] = i[12], e[13] = i[13], e[14] = i[14], e[15] = i[15], this; }, fromArray(t) { const e = this.val; return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4], e[5] = t[5], e[6] = t[6], e[7] = t[7], e[8] = t[8], e[9] = t[9], e[10] = t[10], e[11] = t[11], e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15], this; }, zero() { const t = this.val; return t[0] = 0, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = 0, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 0, this; }, xyz(t, e, i) { this.identity(); const n = this.val; return n[12] = t, n[13] = e, n[14] = i, this; }, scaling(t, e, i) { this.zero(); const n = this.val; return n[0] = t, n[5] = e, n[10] = i, n[15] = 1, this; }, identity() { const t = this.val; return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = 1, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 1, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this; }, transpose() { const t = this.val; const e = t[1]; const i = t[2]; const n = t[3]; const s = t[6]; const r = t[7]; const o = t[11]; return t[1] = t[4], t[2] = t[8], t[3] = t[12], t[4] = e, t[6] = t[9], t[7] = t[13], t[8] = i, t[9] = s, t[11] = t[14], t[12] = n, t[13] = r, t[14] = o, this; }, invert() { const t = this.val; const e = t[0]; const i = t[1]; const n = t[2]; const s = t[3]; const r = t[4]; const o = t[5]; const a = t[6]; const h = t[7]; const l = t[8]; const u = t[9]; const c = t[10]; const d = t[11]; const f = t[12]; const p = t[13]; const g = t[14]; const v = t[15]; const m = e * o - i * r; const y = e * a - n * r; const x = e * h - s * r; const T = i * a - n * o; const w = i * h - s * o; const b = n * h - s * a; const E = l * p - u * f; const S = l * g - c * f; const _ = l * v - d * f; const A = u * g - c * p; const C = u * v - d * p; const M = c * v - d * g; let P = m * M - y * C + x * A + T * _ - w * S + b * E; return P ? (P = 1 / P, t[0] = (o * M - a * C + h * A) * P, t[1] = (n * C - i * M - s * A) * P, t[2] = (p * b - g * w + v * T) * P, t[3] = (c * w - u * b - d * T) * P, t[4] = (a * _ - r * M - h * S) * P, t[5] = (e * M - n * _ + s * S) * P, t[6] = (g * x - f * b - v * y) * P, t[7] = (l * b - c * x + d * y) * P, t[8] = (r * C - o * _ + h * E) * P, t[9] = (i * _ - e * C - s * E) * P, t[10] = (f * w - p * x + v * m) * P, t[11] = (u * x - l * w - d * m) * P, t[12] = (o * S - r * A - a * E) * P, t[13] = (e * A - i * S + n * E) * P, t[14] = (p * y - f * T - g * m) * P, t[15] = (l * T - u * y + c * m) * P, this) : null; }, adjoint() { const t = this.val; const e = t[0]; const i = t[1]; const n = t[2]; const s = t[3]; const r = t[4]; const o = t[5]; const a = t[6]; const h = t[7]; const l = t[8]; const u = t[9]; const c = t[10]; const d = t[11]; const f = t[12]; const p = t[13]; const g = t[14]; const v = t[15]; return t[0] = o * (c * v - d * g) - u * (a * v - h * g) + p * (a * d - h * c), t[1] = -(i * (c * v - d * g) - u * (n * v - s * g) + p * (n * d - s * c)), t[2] = i * (a * v - h * g) - o * (n * v - s * g) + p * (n * h - s * a), t[3] = -(i * (a * d - h * c) - o * (n * d - s * c) + u * (n * h - s * a)), t[4] = -(r * (c * v - d * g) - l * (a * v - h * g) + f * (a * d - h * c)), t[5] = e * (c * v - d * g) - l * (n * v - s * g) + f * (n * d - s * c), t[6] = -(e * (a * v - h * g) - r * (n * v - s * g) + f * (n * h - s * a)), t[7] = e * (a * d - h * c) - r * (n * d - s * c) + l * (n * h - s * a), t[8] = r * (u * v - d * p) - l * (o * v - h * p) + f * (o * d - h * u), t[9] = -(e * (u * v - d * p) - l * (i * v - s * p) + f * (i * d - s * u)), t[10] = e * (o * v - h * p) - r * (i * v - s * p) + f * (i * h - s * o), t[11] = -(e * (o * d - h * u) - r * (i * d - s * u) + l * (i * h - s * o)), t[12] = -(r * (u * g - c * p) - l * (o * g - a * p) + f * (o * c - a * u)), t[13] = e * (u * g - c * p) - l * (i * g - n * p) + f * (i * c - n * u), t[14] = -(e * (o * g - a * p) - r * (i * g - n * p) + f * (i * a - n * o)), t[15] = e * (o * c - a * u) - r * (i * c - n * u) + l * (i * a - n * o), this; }, determinant() { const t = this.val; const e = t[0]; const i = t[1]; const n = t[2]; const s = t[3]; const r = t[4]; const o = t[5]; const a = t[6]; const h = t[7]; const l = t[8]; const u = t[9]; const c = t[10]; const d = t[11]; const f = t[12]; const p = t[13]; const g = t[14]; const v = t[15]; return (e * o - i * r) * (c * v - d * g) - (e * a - n * r) * (u * v - d * p) + (e * h - s * r) * (u * g - c * p) + (i * a - n * o) * (l * v - d * f) - (i * h - s * o) * (l * g - c * f) + (n * h - s * a) * (l * p - u * f); }, multiply(t) { const e = this.val; const i = e[0]; const n = e[1]; const s = e[2]; const r = e[3]; const o = e[4]; const a = e[5]; const h = e[6]; const l = e[7]; const u = e[8]; const c = e[9]; const d = e[10]; const f = e[11]; const p = e[12]; const g = e[13]; const v = e[14]; const m = e[15]; const y = t.val; let x = y[0]; let T = y[1]; let w = y[2]; let b = y[3]; return e[0] = x * i + T * o + w * u + b * p, e[1] = x * n + T * a + w * c + b * g, e[2] = x * s + T * h + w * d + b * v, e[3] = x * r + T * l + w * f + b * m, x = y[4], T = y[5], w = y[6], b = y[7], e[4] = x * i + T * o + w * u + b * p, e[5] = x * n + T * a + w * c + b * g, e[6] = x * s + T * h + w * d + b * v, e[7] = x * r + T * l + w * f + b * m, x = y[8], T = y[9], w = y[10], b = y[11], e[8] = x * i + T * o + w * u + b * p, e[9] = x * n + T * a + w * c + b * g, e[10] = x * s + T * h + w * d + b * v, e[11] = x * r + T * l + w * f + b * m, x = y[12], T = y[13], w = y[14], b = y[15], e[12] = x * i + T * o + w * u + b * p, e[13] = x * n + T * a + w * c + b * g, e[14] = x * s + T * h + w * d + b * v, e[15] = x * r + T * l + w * f + b * m, this; }, multiplyLocal(t) { const e = []; const i = this.val; const n = t.val; return e[0] = i[0] * n[0] + i[1] * n[4] + i[2] * n[8] + i[3] * n[12], e[1] = i[0] * n[1] + i[1] * n[5] + i[2] * n[9] + i[3] * n[13], e[2] = i[0] * n[2] + i[1] * n[6] + i[2] * n[10] + i[3] * n[14], e[3] = i[0] * n[3] + i[1] * n[7] + i[2] * n[11] + i[3] * n[15], e[4] = i[4] * n[0] + i[5] * n[4] + i[6] * n[8] + i[7] * n[12], e[5] = i[4] * n[1] + i[5] * n[5] + i[6] * n[9] + i[7] * n[13], e[6] = i[4] * n[2] + i[5] * n[6] + i[6] * n[10] + i[7] * n[14], e[7] = i[4] * n[3] + i[5] * n[7] + i[6] * n[11] + i[7] * n[15], e[8] = i[8] * n[0] + i[9] * n[4] + i[10] * n[8] + i[11] * n[12], e[9] = i[8] * n[1] + i[9] * n[5] + i[10] * n[9] + i[11] * n[13], e[10] = i[8] * n[2] + i[9] * n[6] + i[10] * n[10] + i[11] * n[14], e[11] = i[8] * n[3] + i[9] * n[7] + i[10] * n[11] + i[11] * n[15], e[12] = i[12] * n[0] + i[13] * n[4] + i[14] * n[8] + i[15] * n[12], e[13] = i[12] * n[1] + i[13] * n[5] + i[14] * n[9] + i[15] * n[13], e[14] = i[12] * n[2] + i[13] * n[6] + i[14] * n[10] + i[15] * n[14], e[15] = i[12] * n[3] + i[13] * n[7] + i[14] * n[11] + i[15] * n[15], this.fromArray(e); }, translate(t) { const e = t.x; const i = t.y; const n = t.z; const s = this.val; return s[12] = s[0] * e + s[4] * i + s[8] * n + s[12], s[13] = s[1] * e + s[5] * i + s[9] * n + s[13], s[14] = s[2] * e + s[6] * i + s[10] * n + s[14], s[15] = s[3] * e + s[7] * i + s[11] * n + s[15], this; }, translateXYZ(t, e, i) { const n = this.val; return n[12] = n[0] * t + n[4] * e + n[8] * i + n[12], n[13] = n[1] * t + n[5] * e + n[9] * i + n[13], n[14] = n[2] * t + n[6] * e + n[10] * i + n[14], n[15] = n[3] * t + n[7] * e + n[11] * i + n[15], this; }, scale(t) { const e = t.x; const i = t.y; const n = t.z; const s = this.val; return s[0] *= e, s[1] *= e, s[2] *= e, s[3] *= e, s[4] *= i, s[5] *= i, s[6] *= i, s[7] *= i, s[8] *= n, s[9] *= n, s[10] *= n, s[11] *= n, this; }, scaleXYZ(t, e, i) { const n = this.val; return n[0] *= t, n[1] *= t, n[2] *= t, n[3] *= t, n[4] *= e, n[5] *= e, n[6] *= e, n[7] *= e, n[8] *= i, n[9] *= i, n[10] *= i, n[11] *= i, this; }, makeRotationAxis(t, e) { const i = Math.cos(e); const n = Math.sin(e); const s = 1 - i; const r = t.x; const o = t.y; const a = t.z; const h = s * r; const l = s * o; return this.fromArray([h * r + i, h * o - n * a, h * a + n * o, 0, h * o + n * a, l * o + i, l * a - n * r, 0, h * a - n * o, l * a + n * r, s * a * a + i, 0, 0, 0, 0, 1]), this; }, rotate(t, e) { const i = this.val; let n = e.x; let s = e.y; let r = e.z; let o = Math.sqrt(n * n + s * s + r * r); if (Math.abs(o) < 1e-6) return null; n *= o = 1 / o, s *= o, r *= o; const a = Math.sin(t); const h = Math.cos(t); const l = 1 - h; const u = i[0]; const c = i[1]; const d = i[2]; const f = i[3]; const p = i[4]; const g = i[5]; const v = i[6]; const m = i[7]; const y = i[8]; const x = i[9]; const T = i[10]; const w = i[11]; const b = n * n * l + h; const E = s * n * l + r * a; const S = r * n * l - s * a; const _ = n * s * l - r * a; const A = s * s * l + h; const C = r * s * l + n * a; const M = n * r * l + s * a; const P = s * r * l - n * a; const O = r * r * l + h; return i[0] = u * b + p * E + y * S, i[1] = c * b + g * E + x * S, i[2] = d * b + v * E + T * S, i[3] = f * b + m * E + w * S, i[4] = u * _ + p * A + y * C, i[5] = c * _ + g * A + x * C, i[6] = d * _ + v * A + T * C, i[7] = f * _ + m * A + w * C, i[8] = u * M + p * P + y * O, i[9] = c * M + g * P + x * O, i[10] = d * M + v * P + T * O, i[11] = f * M + m * P + w * O, this; }, rotateX(t) { const e = this.val; const i = Math.sin(t); const n = Math.cos(t); const s = e[4]; const r = e[5]; const o = e[6]; const a = e[7]; const h = e[8]; const l = e[9]; const u = e[10]; const c = e[11]; return e[4] = s * n + h * i, e[5] = r * n + l * i, e[6] = o * n + u * i, e[7] = a * n + c * i, e[8] = h * n - s * i, e[9] = l * n - r * i, e[10] = u * n - o * i, e[11] = c * n - a * i, this; }, rotateY(t) { const e = this.val; const i = Math.sin(t); const n = Math.cos(t); const s = e[0]; const r = e[1]; const o = e[2]; const a = e[3]; const h = e[8]; const l = e[9]; const u = e[10]; const c = e[11]; return e[0] = s * n - h * i, e[1] = r * n - l * i, e[2] = o * n - u * i, e[3] = a * n - c * i, e[8] = s * i + h * n, e[9] = r * i + l * n, e[10] = o * i + u * n, e[11] = a * i + c * n, this; }, rotateZ(t) { const e = this.val; const i = Math.sin(t); const n = Math.cos(t); const s = e[0]; const r = e[1]; const o = e[2]; const a = e[3]; const h = e[4]; const l = e[5]; const u = e[6]; const c = e[7]; return e[0] = s * n + h * i, e[1] = r * n + l * i, e[2] = o * n + u * i, e[3] = a * n + c * i, e[4] = h * n - s * i, e[5] = l * n - r * i, e[6] = u * n - o * i, e[7] = c * n - a * i, this; }, fromRotationTranslation(t, e) { const i = this.val; const n = t.x; const s = t.y; const r = t.z; const o = t.w; const a = n + n; const h = s + s; const l = r + r; const u = n * a; const c = n * h; const d = n * l; const f = s * h; const p = s * l; const g = r * l; const v = o * a; const m = o * h; const y = o * l; return i[0] = 1 - (f + g), i[1] = c + y, i[2] = d - m, i[3] = 0, i[4] = c - y, i[5] = 1 - (u + g), i[6] = p + v, i[7] = 0, i[8] = d + m, i[9] = p - v, i[10] = 1 - (u + f), i[11] = 0, i[12] = e.x, i[13] = e.y, i[14] = e.z, i[15] = 1, this; }, fromQuat(t) { const e = this.val; const i = t.x; const n = t.y; const s = t.z; const r = t.w; const o = i + i; const a = n + n; const h = s + s; const l = i * o; const u = i * a; const c = i * h; const d = n * a; const f = n * h; const p = s * h; const g = r * o; const v = r * a; const m = r * h; return e[0] = 1 - (d + p), e[1] = u + m, e[2] = c - v, e[3] = 0, e[4] = u - m, e[5] = 1 - (l + p), e[6] = f + g, e[7] = 0, e[8] = c + v, e[9] = f - g, e[10] = 1 - (l + d), e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this; }, frustum(t, e, i, n, s, r) { const o = this.val; const a = 1 / (e - t); const h = 1 / (n - i); const l = 1 / (s - r); return o[0] = 2 * s * a, o[1] = 0, o[2] = 0, o[3] = 0, o[4] = 0, o[5] = 2 * s * h, o[6] = 0, o[7] = 0, o[8] = (e + t) * a, o[9] = (n + i) * h, o[10] = (r + s) * l, o[11] = -1, o[12] = 0, o[13] = 0, o[14] = r * s * 2 * l, o[15] = 0, this; }, perspective(t, e, i, n) { const s = this.val; const r = 1 / Math.tan(t / 2); const o = 1 / (i - n); return s[0] = r / e, s[1] = 0, s[2] = 0, s[3] = 0, s[4] = 0, s[5] = r, s[6] = 0, s[7] = 0, s[8] = 0, s[9] = 0, s[10] = (n + i) * o, s[11] = -1, s[12] = 0, s[13] = 0, s[14] = 2 * n * i * o, s[15] = 0, this; }, perspectiveLH(t, e, i, n) { const s = this.val; return s[0] = 2 * i / t, s[1] = 0, s[2] = 0, s[3] = 0, s[4] = 0, s[5] = 2 * i / e, s[6] = 0, s[7] = 0, s[8] = 0, s[9] = 0, s[10] = -n / (i - n), s[11] = 1, s[12] = 0, s[13] = 0, s[14] = i * n / (i - n), s[15] = 0, this; }, ortho(t, e, i, n, s, r) { const o = this.val; var a = (a = t - e) === 0 ? a : 1 / a; var h = (h = i - n) === 0 ? h : 1 / h; var l = (l = s - r) === 0 ? l : 1 / l; return o[0] = -2 * a, o[1] = 0, o[2] = 0, o[3] = 0, o[4] = 0, o[5] = -2 * h, o[6] = 0, o[7] = 0, o[8] = 0, o[9] = 0, o[10] = 2 * l, o[11] = 0, o[12] = (t + e) * a, o[13] = (n + i) * h, o[14] = (r + s) * l, o[15] = 1, this; }, lookAt(t, e, i) { const n = this.val; const s = t.x; const r = t.y; const o = t.z; const a = i.x; const h = i.y; const l = i.z; const u = e.x; const c = e.y; const d = e.z; if (Math.abs(s - u) < 1e-6 && Math.abs(r - c) < 1e-6 && Math.abs(o - d) < 1e-6) return this.identity(); let f = s - u; let p = r - c; let g = o - d; let v = 1 / Math.sqrt(f * f + p * p + g * g); let m = h * (g *= v) - l * (p *= v); let y = l * (f *= v) - a * g; let x = a * p - h * f; (v = Math.sqrt(m * m + y * y + x * x)) ? (m *= v = 1 / v, y *= v, x *= v) : x = y = m = 0; let T = p * x - g * y; let w = g * m - f * x; let b = f * y - p * m; return (v = Math.sqrt(T * T + w * w + b * b)) ? (T *= v = 1 / v, w *= v, b *= v) : b = w = T = 0, n[0] = m, n[1] = T, n[2] = f, n[3] = 0, n[4] = y, n[5] = w, n[6] = p, n[7] = 0, n[8] = x, n[9] = b, n[10] = g, n[11] = 0, n[12] = -(m * s + y * r + x * o), n[13] = -(T * s + w * r + b * o), n[14] = -(f * s + p * r + g * o), n[15] = 1, this; }, yawPitchRoll(t, e, i) { this.zero(), h.zero(), l.zero(); const n = this.val; const s = h.val; const r = l.val; let o = Math.sin(i); let a = Math.cos(i); return n[10] = 1, n[15] = 1, n[0] = a, n[1] = o, n[4] = -o, n[5] = a, o = Math.sin(e), a = Math.cos(e), s[0] = 1, s[15] = 1, s[5] = a, s[10] = a, s[9] = -o, s[6] = o, o = Math.sin(t), a = Math.cos(t), r[5] = 1, r[15] = 1, r[0] = a, r[2] = -o, r[8] = o, r[10] = a, this.multiplyLocal(h), this.multiplyLocal(l), this; }, setWorldMatrix(t, e, i, n, s) { return this.yawPitchRoll(t.y, t.x, t.z), h.scaling(i.x, i.y, i.z), l.xyz(e.x, e.y, e.z), this.multiplyLocal(h), this.multiplyLocal(l), void 0 !== n && this.multiplyLocal(n), void 0 !== s && this.multiplyLocal(s), this; },\n    }); var h = new s(); var l = new s(); t.exports = s;\n  }, function (t, e, i) {\n    const n = i(0); const s = i(174); const r = i(335); const a = new Int8Array([1, 2, 0]); const h = new Float32Array([0, 0, 0]); const o = new s(1, 0, 0); const l = new s(0, 1, 0); const u = new s(); const c = new r(); const d = new n({\n      initialize(t, e, i, n) { typeof t === 'object' ? (this.x = t.x || 0, this.y = t.y || 0, this.z = t.z || 0, this.w = t.w || 0) : (this.x = t || 0, this.y = e || 0, this.z = i || 0, this.w = n || 0); }, copy(t) { return this.x = t.x, this.y = t.y, this.z = t.z, this.w = t.w, this; }, set(t, e, i, n) { return typeof t === 'object' ? (this.x = t.x || 0, this.y = t.y || 0, this.z = t.z || 0, this.w = t.w || 0) : (this.x = t || 0, this.y = e || 0, this.z = i || 0, this.w = n || 0), this; }, add(t) { return this.x += t.x, this.y += t.y, this.z += t.z, this.w += t.w, this; }, subtract(t) { return this.x -= t.x, this.y -= t.y, this.z -= t.z, this.w -= t.w, this; }, scale(t) { return this.x *= t, this.y *= t, this.z *= t, this.w *= t, this; }, length() { const t = this.x; const e = this.y; const i = this.z; const n = this.w; return Math.sqrt(t * t + e * e + i * i + n * n); }, lengthSq() { const t = this.x; const e = this.y; const i = this.z; const n = this.w; return t * t + e * e + i * i + n * n; }, normalize() { const t = this.x; const e = this.y; const i = this.z; const n = this.w; let s = t * t + e * e + i * i + n * n; return s > 0 && (s = 1 / Math.sqrt(s), this.x = t * s, this.y = e * s, this.z = i * s, this.w = n * s), this; }, dot(t) { return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w; }, lerp(t, e) { void 0 === e && (e = 0); const i = this.x; const n = this.y; const s = this.z; const r = this.w; return this.x = i + e * (t.x - i), this.y = n + e * (t.y - n), this.z = s + e * (t.z - s), this.w = r + e * (t.w - r), this; }, rotationTo(t, e) { const i = t.x * e.x + t.y * e.y + t.z * e.z; return i < -0.999999 ? (u.copy(o).cross(t).length() < 1e-6 && u.copy(l).cross(t), u.normalize(), this.setAxisAngle(u, Math.PI)) : i > 0.999999 ? (this.x = 0, this.y = 0, this.z = 0, this.w = 1, this) : (u.copy(t).cross(e), this.x = u.x, this.y = u.y, this.z = u.z, this.w = 1 + i, this.normalize()); }, setAxes(t, e, i) { const n = c.val; return n[0] = e.x, n[3] = e.y, n[6] = e.z, n[1] = i.x, n[4] = i.y, n[7] = i.z, n[2] = -t.x, n[5] = -t.y, n[8] = -t.z, this.fromMat3(c).normalize(); }, identity() { return this.x = 0, this.y = 0, this.z = 0, this.w = 1, this; }, setAxisAngle(t, e) { e *= 0.5; const i = Math.sin(e); return this.x = i * t.x, this.y = i * t.y, this.z = i * t.z, this.w = Math.cos(e), this; }, multiply(t) { const e = this.x; const i = this.y; const n = this.z; const s = this.w; const r = t.x; const o = t.y; const a = t.z; const h = t.w; return this.x = e * h + s * r + i * a - n * o, this.y = i * h + s * o + n * r - e * a, this.z = n * h + s * a + e * o - i * r, this.w = s * h - e * r - i * o - n * a, this; }, slerp(t, e) { const i = this.x; const n = this.y; const s = this.z; const r = this.w; let o = t.x; let a = t.y; let h = t.z; let l = t.w; let u = i * o + n * a + s * h + r * l; u < 0 && (u = -u, o = -o, a = -a, h = -h, l = -l); let c; let d; let f = 1 - e; let p = e; return 1 - u > 1e-6 && (c = Math.acos(u), d = Math.sin(c), f = Math.sin((1 - e) * c) / d, p = Math.sin(e * c) / d), this.x = f * i + p * o, this.y = f * n + p * a, this.z = f * s + p * h, this.w = f * r + p * l, this; }, invert() { const t = this.x; const e = this.y; const i = this.z; const n = this.w; const s = t * t + e * e + i * i + n * n; const r = s ? 1 / s : 0; return this.x = -t * r, this.y = -e * r, this.z = -i * r, this.w = n * r, this; }, conjugate() { return this.x = -this.x, this.y = -this.y, this.z = -this.z, this; }, rotateX(t) { t *= 0.5; const e = this.x; const i = this.y; const n = this.z; const s = this.w; const r = Math.sin(t); const o = Math.cos(t); return this.x = e * o + s * r, this.y = i * o + n * r, this.z = n * o - i * r, this.w = s * o - e * r, this; }, rotateY(t) { t *= 0.5; const e = this.x; const i = this.y; const n = this.z; const s = this.w; const r = Math.sin(t); const o = Math.cos(t); return this.x = e * o - n * r, this.y = i * o + s * r, this.z = n * o + e * r, this.w = s * o - i * r, this; }, rotateZ(t) { t *= 0.5; const e = this.x; const i = this.y; const n = this.z; const s = this.w; const r = Math.sin(t); const o = Math.cos(t); return this.x = e * o + i * r, this.y = i * o - e * r, this.z = n * o + s * r, this.w = s * o - n * r, this; }, calculateW() { const t = this.x; const e = this.y; const i = this.z; return this.w = -Math.sqrt(1 - t * t - e * e - i * i), this; }, fromMat3(t) { let e; let i; let n; let s; const r = t.val; const o = r[0] + r[4] + r[8]; return o > 0 ? (s = Math.sqrt(o + 1), this.w = 0.5 * s, s = 0.5 / s, this.x = (r[7] - r[5]) * s, this.y = (r[2] - r[6]) * s, this.z = (r[3] - r[1]) * s) : (e = 0, r[4] > r[0] && (e = 1), r[8] > r[3 * e + e] && (e = 2), i = a[e], n = a[i], s = Math.sqrt(r[3 * e + e] - r[3 * i + i] - r[3 * n + n] + 1), h[e] = 0.5 * s, s = 0.5 / s, h[i] = (r[3 * i + e] + r[3 * e + i]) * s, h[n] = (r[3 * n + e] + r[3 * e + n]) * s, this.x = h[0], this.y = h[1], this.z = h[2], this.w = (r[3 * n + i] - r[3 * i + n]) * s), this; },\n    }); t.exports = d;\n  }, function (t, e, a) { const h = a(339); const l = a(26); const u = a(33); const c = a(169); t.exports = function (t) { const e = t.config; if ((e.customEnvironment || e.canvas) && e.renderType === u.AUTO) throw new Error('Must set explicit renderType in custom environment'); if (!e.customEnvironment && !e.canvas && e.renderType !== u.HEADLESS) if (e.renderType === u.CANVAS || e.renderType !== u.CANVAS && !c.webGL) { if (!c.canvas) throw new Error('Cannot create Canvas or WebGL context, aborting.'); e.renderType = u.CANVAS; } else e.renderType = u.WEBGL; e.antialias || l.disableSmoothing(); let i; let n; const s = t.scale.baseSize; const r = s.width; const o = s.height; e.canvas ? (t.canvas = e.canvas, t.canvas.width = r, t.canvas.height = o) : t.canvas = l.create(t, r, o, e.renderType), e.canvasStyle && (t.canvas.style = e.canvasStyle), e.antialias || h.setCrisp(t.canvas), e.renderType !== u.HEADLESS && (i = a(505), n = a(508), e.renderType === u.WEBGL ? t.renderer = new n(t) : (t.renderer = new i(t), t.context = t.renderer.gameContext)); }; }, function (t, e) { t.exports = { setCrisp(e) { return ['optimizeSpeed', '-moz-crisp-edges', '-o-crisp-edges', '-webkit-optimize-contrast', 'optimize-contrast', 'crisp-edges', 'pixelated'].forEach((t) => { e.style['image-rendering'] = t; }), e.style.msInterpolationMode = 'nearest-neighbor', e; }, setBicubic(t) { return t.style['image-rendering'] = 'auto', t.style.msInterpolationMode = 'bicubic', t; } }; }, function (t, e) { t.exports = ['#define SHADER_NAME PHASER_TEXTURE_TINT_FS', '', 'precision mediump float;', '', 'uniform sampler2D uMainSampler;', '', 'varying vec2 outTexCoord;', 'varying float outTintEffect;', 'varying vec4 outTint;', '', 'void main()', '{', '    vec4 texture = texture2D(uMainSampler, outTexCoord);', '    vec4 texel = vec4(outTint.rgb * outTint.a, outTint.a);', '    vec4 color = texture;', '', '    if (outTintEffect == 0.0)', '    {', '        //  Multiply texture tint', '        color = texture * texel;', '    }', '    else if (outTintEffect == 1.0)', '    {', '        //  Solid color + texture alpha', '        color.rgb = mix(texture.rgb, outTint.rgb * outTint.a, texture.a);', '        color.a = texture.a * texel.a;', '    }', '    else if (outTintEffect == 2.0)', '    {', '        //  Solid color, no texture', '        color = texel;', '    }', '', '    gl_FragColor = color;', '}', ''].join('\\n'); }, function (t, e) { t.exports = ['#define SHADER_NAME PHASER_TEXTURE_TINT_VS', '', 'precision mediump float;', '', 'uniform mat4 uProjectionMatrix;', 'uniform mat4 uViewMatrix;', 'uniform mat4 uModelMatrix;', '', 'attribute vec2 inPosition;', 'attribute vec2 inTexCoord;', 'attribute float inTintEffect;', 'attribute vec4 inTint;', '', 'varying vec2 outTexCoord;', 'varying float outTintEffect;', 'varying vec4 outTint;', '', 'void main ()', '{', '    gl_Position = uProjectionMatrix * uViewMatrix * uModelMatrix * vec4(inPosition, 1.0, 1.0);', '', '    outTexCoord = inTexCoord;', '    outTint = inTint;', '    outTintEffect = inTintEffect;', '}', '', ''].join('\\n'); }, function (t, e, i) { const l = i(33); t.exports = function (t) { let e; let i; let n; let s; let r; let o; let a; const h = t.config; h.hideBanner || (e = 'WebGL', h.renderType === l.CANVAS ? e = 'Canvas' : h.renderType === l.HEADLESS && (e = 'Headless'), i = h.audio, a = !(n = t.device.audio).webAudio || i && i.disableWebAudio ? i && i.noAudio || !n.webAudio && !n.audioData ? 'No Audio' : 'HTML5 Audio' : 'Web Audio', t.device.browser.ie ? window.console && console.log(`Phaser v${l.VERSION} / https://phaser.io`) : (r = [s = ''], Array.isArray(h.bannerBackgroundColor) ? (h.bannerBackgroundColor.forEach((t) => { s = s.concat('%c '), r.push(`background: ${t}`), o = t; }), r[r.length - 1] = `color: ${h.bannerTextColor}; background: ${o}`) : (s = s.concat('%c '), r.push(`color: ${h.bannerTextColor}; background: ${h.bannerBackgroundColor}`)), r.push('background: #fff'), h.gameTitle && (s = s.concat(h.gameTitle), h.gameVersion && (s = s.concat(` v${h.gameVersion}`)), h.hidePhaser || (s = s.concat(' / '))), h.hidePhaser || (s = s.concat(`Phaser v${l.VERSION} (${e} | ${a})`)), s = s.concat(` %c ${h.gameURL}`), r[0] = s, console.log.apply(console, r))); }; }, function (t, e, i) {\n    const n = i(0); const s = i(6); const r = i(1); const o = i(344); const a = new n({\n      initialize(t, e) { this.game = t, this.raf = new o(), this.started = !1, this.running = !1, this.minFps = s(e, 'min', 5), this.targetFps = s(e, 'target', 60), this._min = 1e3 / this.minFps, this._target = 1e3 / this.targetFps, this.actualFps = this.targetFps, this.nextFpsUpdate = 0, this.framesThisSecond = 0, this.callback = r, this.forceSetTimeOut = s(e, 'forceSetTimeOut', !1), this.time = 0, this.startTime = 0, this.lastTime = 0, this.frame = 0, this.inFocus = !0, this._pauseTime = 0, this._coolDown = 0, this.delta = 0, this.deltaIndex = 0, this.deltaHistory = [], this.deltaSmoothingMax = s(e, 'deltaHistory', 10), this.panicMax = s(e, 'panicMax', 120), this.rawDelta = 0, this.now = 0, this.smoothStep = s(e, 'smoothStep', !0); }, blur() { this.inFocus = !1; }, focus() { this.inFocus = !0, this.resetDelta(); }, pause() { this._pauseTime = window.performance.now(); }, resume() { this.resetDelta(), this.startTime += this.time - this._pauseTime; }, resetDelta() { const t = window.performance.now(); this.time = t, this.lastTime = t, this.nextFpsUpdate = t + 1e3; for (let e = this.framesThisSecond = 0; e < this.deltaSmoothingMax; e++) this.deltaHistory[e] = Math.min(this._target, this.deltaHistory[e]); this.delta = 0, this.deltaIndex = 0, this._coolDown = this.panicMax; }, start(t) { if (this.started) return this; this.started = !0, this.running = !0; for (let e = 0; e < this.deltaSmoothingMax; e++) this.deltaHistory[e] = this._target; this.resetDelta(), this.startTime = window.performance.now(), this.callback = t, this.raf.start(this.step.bind(this), this.forceSetTimeOut, this._target); }, step() { const t = window.performance.now(); let e = (this.now = t) - this.lastTime; e < 0 && (e = 0), this.rawDelta = e; const i = this.deltaIndex; const n = this.deltaHistory; const s = this.deltaSmoothingMax; let r = e; let o = e; if (this.smoothStep) { (this._coolDown > 0 || !this.inFocus) && (this._coolDown--, r = Math.min(r, this._target)), r > this._min && (r = n[i], r = Math.min(r, this._min)), n[i] = r, this.deltaIndex++, this.deltaIndex > s && (this.deltaIndex = 0); for (let a = o = 0; a < s; a++)o += n[a]; o /= s; } this.delta = o, this.time += this.rawDelta, t > this.nextFpsUpdate && (this.actualFps = 0.25 * this.framesThisSecond + 0.75 * this.actualFps, this.nextFpsUpdate = t + 1e3, this.framesThisSecond = 0), this.framesThisSecond++; const h = o / this._target; this.callback(t, o, h), this.lastTime = t, this.frame++; }, tick() { this.step(); }, sleep() { this.running && (this.raf.stop(), this.running = !1); }, wake(t) { this.running || (t && (this.startTime += -this.lastTime + (this.lastTime + window.performance.now())), this.raf.start(this.step.bind(this), this.useRAF), this.running = !0, this.step()); }, getDuration() { return Math.round(this.lastTime - this.startTime) / 1e3; }, getDurationMS() { return Math.round(this.lastTime - this.startTime); }, stop() { return this.running = !1, this.started = !1, this.raf.stop(), this; }, destroy() { this.stop(), this.callback = r, this.raf = null, this.game = null; },\n    }); t.exports = a;\n  }, function (t, e, i) {\n    const n = i(0); const s = i(1); const r = new n({\n      initialize() { this.isRunning = !1, this.callback = s, this.tick = 0, this.isSetTimeOut = !1, this.timeOutID = null, this.lastTime = 0, this.target = 0; const n = this; this.step = function t() { const e = window.performance.now(); n.lastTime = n.tick, n.tick = e, n.callback(e), n.timeOutID = window.requestAnimationFrame(t); }, this.stepTimeout = function t() { const e = Date.now(); const i = Math.min(Math.max(2 * n.target + n.tick - e, 0), n.target); n.lastTime = n.tick, n.tick = e, n.callback(e), n.timeOutID = window.setTimeout(t, i); }; }, start(t, e, i) { this.isRunning || (this.callback = t, this.isSetTimeOut = e, this.target = i, this.isRunning = !0, this.timeOutID = e ? window.setTimeout(this.stepTimeout, 0) : window.requestAnimationFrame(this.step)); }, stop() { this.isRunning = !1, this.isSetTimeOut ? clearTimeout(this.timeOutID) : window.cancelAnimationFrame(this.timeOutID); }, destroy() { this.stop(), this.callback = s; },\n    }); t.exports = r;\n  }, function (t, e, i) { const n = i(20); t.exports = function (t) { let e; const i = t.events; void 0 !== document.hidden ? e = 'visibilitychange' : ['webkit', 'moz', 'ms'].forEach((t) => { void 0 !== document[`${t}Hidden`] && (document.hidden = function () { return document[`${t}Hidden`]; }, e = `${t}visibilitychange`); }); e && document.addEventListener(e, (t) => { document.hidden || t.type === 'pause' ? i.emit(n.HIDDEN) : i.emit(n.VISIBLE); }, !1), window.onblur = function () { i.emit(n.BLUR); }, window.onfocus = function () { i.emit(n.FOCUS); }, window.focus && t.config.autoFocus && window.focus(); }; }, function (t, e, i) { const m = i(347); const y = i(26); const x = i(6); t.exports = function (t) { const e = x(t, 'data', []); let i = x(t, 'canvas', null); const n = x(t, 'palette', m); const s = x(t, 'pixelWidth', 1); const r = x(t, 'pixelHeight', s); let o = x(t, 'resizeCanvas', !0); let a = x(t, 'clearCanvas', !0); const h = x(t, 'preRender', null); const l = x(t, 'postRender', null); const u = Math.floor(Math.abs(e[0].length * s)); const c = Math.floor(Math.abs(e.length * r)); i || (i = y.create2D(this, u, c), a = o = !1), o && (i.width = u, i.height = c); const d = i.getContext('2d'); a && d.clearRect(0, 0, u, c), h && h(i, d); for (let f = 0; f < e.length; f++) for (let p = e[f], g = 0; g < p.length; g++) { const v = p[g]; v !== '.' && v !== ' ' && (d.fillStyle = n[v], d.fillRect(g * s, f * r, s, r)); } return l && l(i, d), i; }; }, function (t, e) {\n    t.exports = {\n      0: '#000', 1: '#9D9D9D', 2: '#FFF', 3: '#BE2633', 4: '#E06F8B', 5: '#493C2B', 6: '#A46422', 7: '#EB8931', 8: '#F7E26B', 9: '#2F484E', A: '#44891A', B: '#A3CE27', C: '#1B2632', D: '#005784', E: '#31A2F2', F: '#B2DCEF',\n    };\n  }, function (t, e, i) {\n    const n = i(0); const o = i(326); const s = i(81); const a = i(3); const h = new n({\n      Extends: s, initialize(t, e, i, n) { s.call(this, 'CubicBezierCurve'), Array.isArray(t) && (n = new a(t[6], t[7]), i = new a(t[4], t[5]), e = new a(t[2], t[3]), t = new a(t[0], t[1])), this.p0 = t, this.p1 = e, this.p2 = i, this.p3 = n; }, getStartPoint(t) { return void 0 === t && (t = new a()), t.copy(this.p0); }, getResolution(t) { return t; }, getPoint(t, e) { void 0 === e && (e = new a()); const i = this.p0; const n = this.p1; const s = this.p2; const r = this.p3; return e.set(o(t, i.x, n.x, s.x, r.x), o(t, i.y, n.y, s.y, r.y)); }, draw(t, e) { void 0 === e && (e = 32); const i = this.getPoints(e); t.beginPath(), t.moveTo(this.p0.x, this.p0.y); for (let n = 1; n < i.length; n++)t.lineTo(i[n].x, i[n].y); return t.strokePath(), t; }, toJSON() { return { type: this.type, points: [this.p0.x, this.p0.y, this.p1.x, this.p1.y, this.p2.x, this.p2.y, this.p3.x, this.p3.y] }; },\n    }); h.fromJSON = function (t) { const e = t.points; const i = new a(e[0], e[1]); const n = new a(e[2], e[3]); const s = new a(e[4], e[5]); const r = new a(e[6], e[7]); return new h(i, n, s, r); }, t.exports = h;\n  }, function (t, e, i) {\n    const n = i(0); const l = i(81); const u = i(39); const c = i(6); const s = i(173); const d = i(3); const r = new n({\n      Extends: l,\n      initialize(t, e, i, n, s, r, o, a) { let h; typeof t === 'object' ? (t = c(h = t, 'x', 0), e = c(h, 'y', 0), i = c(h, 'xRadius', 0), n = c(h, 'yRadius', i), s = c(h, 'startAngle', 0), r = c(h, 'endAngle', 360), o = c(h, 'clockwise', !1), a = c(h, 'rotation', 0)) : (void 0 === n && (n = i), void 0 === s && (s = 0), void 0 === r && (r = 360), void 0 === o && (o = !1), void 0 === a && (a = 0)), l.call(this, 'EllipseCurve'), this.p0 = new d(t, e), this._xRadius = i, this._yRadius = n, this._startAngle = u(s), this._endAngle = u(r), this._clockwise = o, this._rotation = u(a); },\n      getStartPoint(t) { return void 0 === t && (t = new d()), this.getPoint(0, t); },\n      getResolution(t) { return 2 * t; },\n      getPoint(t, e) { void 0 === e && (e = new d()); for (var i = 2 * Math.PI, n = this._endAngle - this._startAngle, s = Math.abs(n) < Number.EPSILON; n < 0;)n += i; for (;i < n;)n -= i; n < Number.EPSILON && (n = s ? 0 : i), this._clockwise && !s && (n === i ? n = -i : n -= i); let r; let o; let a; let h; const l = this._startAngle + t * n; let u = this.p0.x + this._xRadius * Math.cos(l); let c = this.p0.y + this._yRadius * Math.sin(l); return this._rotation !== 0 && (r = Math.cos(this._rotation), o = Math.sin(this._rotation), u = (a = u - this.p0.x) * r - (h = c - this.p0.y) * o + this.p0.x, c = a * o + h * r + this.p0.y), e.set(u, c); },\n      setXRadius(t) { return this.xRadius = t, this; },\n      setYRadius(t) { return this.yRadius = t, this; },\n      setWidth(t) { return this.xRadius = t / 2, this; },\n      setHeight(t) { return this.yRadius = t / 2, this; },\n      setStartAngle(t) { return this.startAngle = t, this; },\n      setEndAngle(t) { return this.endAngle = t, this; },\n      setClockwise(t) { return this.clockwise = t, this; },\n      setRotation(t) { return this.rotation = t, this; },\n      x: { get() { return this.p0.x; }, set(t) { this.p0.x = t; } },\n      y: { get() { return this.p0.y; }, set(t) { this.p0.y = t; } },\n      xRadius: { get() { return this._xRadius; }, set(t) { this._xRadius = t; } },\n      yRadius: { get() { return this._yRadius; }, set(t) { this._yRadius = t; } },\n      startAngle: { get() { return s(this._startAngle); }, set(t) { this._startAngle = u(t); } },\n      endAngle: { get() { return s(this._endAngle); }, set(t) { this._endAngle = u(t); } },\n      clockwise: { get() { return this._clockwise; }, set(t) { this._clockwise = t; } },\n      angle: { get() { return s(this._rotation); }, set(t) { this._rotation = u(t); } },\n      rotation: { get() { return this._rotation; }, set(t) { this._rotation = t; } },\n      toJSON() {\n        return {\n          type: this.type, x: this.p0.x, y: this.p0.y, xRadius: this._xRadius, yRadius: this._yRadius, startAngle: s(this._startAngle), endAngle: s(this._endAngle), clockwise: this._clockwise, rotation: s(this._rotation),\n        };\n      },\n    }); r.fromJSON = function (t) { return new r(t); }, t.exports = r;\n  }, function (t, e, i) {\n    const n = i(0); const s = i(81); const r = i(176); const o = i(11); const a = i(3); const h = new a(); const l = new n({\n      Extends: s, initialize(t, e) { s.call(this, 'LineCurve'), Array.isArray(t) && (e = new a(t[2], t[3]), t = new a(t[0], t[1])), this.p0 = t, this.p1 = e, this.arcLengthDivisions = 1; }, getBounds(t) { return void 0 === t && (t = new o()), r([this.p0, this.p1], t); }, getStartPoint(t) { return void 0 === t && (t = new a()), t.copy(this.p0); }, getResolution(t) { return void 0 === t && (t = 1), t; }, getPoint(t, e) { return void 0 === e && (e = new a()), t === 1 ? e.copy(this.p1) : (e.copy(this.p1).subtract(this.p0).scale(t).add(this.p0), e); }, getPointAt(t, e) { return this.getPoint(t, e); }, getTangent() { return h.copy(this.p1).subtract(this.p0).normalize(); }, getUtoTmapping(t, e, i) { let n; let s; return e ? (s = (n = this.getLengths(i))[n.length - 1], Math.min(e, s) / s) : t; }, draw(t) { return t.lineBetween(this.p0.x, this.p0.y, this.p1.x, this.p1.y), t; }, toJSON() { return { type: this.type, points: [this.p0.x, this.p0.y, this.p1.x, this.p1.y] }; },\n    }); l.fromJSON = function (t) { const e = t.points; const i = new a(e[0], e[1]); const n = new a(e[2], e[3]); return new l(i, n); }, t.exports = l;\n  }, function (t, e, i) {\n    const n = i(0); const s = i(81); const r = i(327); const o = i(3); const a = new n({\n      Extends: s, initialize(t, e, i) { s.call(this, 'QuadraticBezier'), Array.isArray(t) && (i = new o(t[4], t[5]), e = new o(t[2], t[3]), t = new o(t[0], t[1])), this.p0 = t, this.p1 = e, this.p2 = i; }, getStartPoint(t) { return void 0 === t && (t = new o()), t.copy(this.p0); }, getResolution(t) { return t; }, getPoint(t, e) { void 0 === e && (e = new o()); const i = this.p0; const n = this.p1; const s = this.p2; return e.set(r(t, i.x, n.x, s.x), r(t, i.y, n.y, s.y)); }, draw(t, e) { void 0 === e && (e = 32); const i = this.getPoints(e); t.beginPath(), t.moveTo(this.p0.x, this.p0.y); for (let n = 1; n < i.length; n++)t.lineTo(i[n].x, i[n].y); return t.strokePath(), t; }, toJSON() { return { type: this.type, points: [this.p0.x, this.p0.y, this.p1.x, this.p1.y, this.p2.x, this.p2.y] }; },\n    }); a.fromJSON = function (t) { const e = t.points; const i = new o(e[0], e[1]); const n = new o(e[2], e[3]); const s = new o(e[4], e[5]); return new a(i, n, s); }, t.exports = a;\n  }, function (t, e, i) {\n    const u = i(171); const n = i(0); const s = i(81); const c = i(3); const r = new n({\n      Extends: s, initialize(t) { void 0 === t && (t = []), s.call(this, 'SplineCurve'), this.points = [], this.addPoints(t); }, addPoints(t) { for (let e = 0; e < t.length; e++) { const i = new c(); typeof t[e] === 'number' ? (i.x = t[e], i.y = t[e + 1], e++) : Array.isArray(t[e]) ? (i.x = t[e][0], i.y = t[e][1]) : (i.x = t[e].x, i.y = t[e].y), this.points.push(i); } return this; }, addPoint(t, e) { const i = new c(t, e); return this.points.push(i), i; }, getStartPoint(t) { return void 0 === t && (t = new c()), t.copy(this.points[0]); }, getResolution(t) { return t * this.points.length; }, getPoint(t, e) { void 0 === e && (e = new c()); const i = this.points; const n = (i.length - 1) * t; const s = Math.floor(n); const r = n - s; const o = i[s === 0 ? s : s - 1]; const a = i[s]; const h = i[s > i.length - 2 ? i.length - 1 : s + 1]; const l = i[s > i.length - 3 ? i.length - 1 : s + 2]; return e.set(u(r, o.x, a.x, h.x, l.x), u(r, o.y, a.y, h.y, l.y)); }, toJSON() { for (var t = [], e = 0; e < this.points.length; e++)t.push(this.points[e].x), t.push(this.points[e].y); return { type: this.type, points: t }; },\n    }); r.fromJSON = function (t) { return new r(t.points); }, t.exports = r;\n  }, function (t, e, i) { const n = new (i(0))({ initialize(t, e, i, n) { e && e !== '' || (e = ['precision mediump float;', 'uniform vec2 resolution;', 'varying vec2 fragCoord;', 'void main () {', '    vec2 uv = fragCoord / resolution.xy;', '    gl_FragColor = vec4(uv.xyx, 1.0);', '}'].join('\\n')), i && i !== '' || (i = ['precision mediump float;', 'uniform mat4 uProjectionMatrix;', 'uniform mat4 uViewMatrix;', 'uniform vec2 uResolution;', 'attribute vec2 inPosition;', 'varying vec2 fragCoord;', 'void main () {', 'gl_Position = uProjectionMatrix * uViewMatrix * vec4(inPosition, 1.0, 1.0);', 'fragCoord = vec2(inPosition.x, uResolution.y - inPosition.y);', '}'].join('\\n')), void 0 === n && (n = null), this.key = t, this.fragmentSrc = e, this.vertexSrc = i, this.uniforms = n; } }); t.exports = n; }, function (t, e, i) { const n = i(31); n.ColorToRGBA = i(811), n.ComponentToHex = i(355), n.GetColor = i(165), n.GetColor32 = i(295), n.HexStringToColor = i(294), n.HSLToColor = i(812), n.HSVColorWheel = i(813), n.HSVToRGB = i(166), n.HueToComponent = i(356), n.IntegerToColor = i(297), n.IntegerToRGB = i(298), n.Interpolate = i(814), n.ObjectToColor = i(299), n.RandomRGB = i(815), n.RGBStringToColor = i(300), n.RGBToHSV = i(296), n.RGBToString = i(816), n.ValueToColor = i(164), t.exports = n; }, function (t, e) { t.exports = function (t) { const e = t.toString(16); return e.length === 1 ? `0${e}` : e; }; }, function (t, e) { t.exports = function (t, e, i) { return i < 0 && (i += 1), i > 1 && --i, i < 1 / 6 ? t + 6 * (e - t) * i : i < 0.5 ? e : i < 2 / 3 ? t + (e - t) * (2 / 3 - i) * 6 : t; }; }, function (t, e, i) { const n = i(117); t.exports = function (t) { let e; document.readyState !== 'complete' && document.readyState !== 'interactive' ? (e = function () { document.removeEventListener('deviceready', e, !0), document.removeEventListener('DOMContentLoaded', e, !0), window.removeEventListener('load', e, !0), t(); }, document.body ? n.cordova ? document.addEventListener('deviceready', e, !1) : (document.addEventListener('DOMContentLoaded', e, !0), window.addEventListener('load', e, !0)) : window.setTimeout(e, 20)) : t(); }; }, function (t, e, i) { const s = i(177); t.exports = function (t, e) { const i = window.screen; const n = !!i && (i.orientation || i.mozOrientation || i.msOrientation); if (n && typeof n.type === 'string') return n.type; if (typeof n === 'string') return n; if (i) return i.height > i.width ? s.ORIENTATION.PORTRAIT : s.ORIENTATION.LANDSCAPE; if (typeof window.orientation === 'number') return window.orientation === 0 || window.orientation === 180 ? s.ORIENTATION.PORTRAIT : s.ORIENTATION.LANDSCAPE; if (window.matchMedia) { if (window.matchMedia('(orientation: portrait)').matches) return s.ORIENTATION.PORTRAIT; if (window.matchMedia('(orientation: landscape)').matches) return s.ORIENTATION.LANDSCAPE; } return t < e ? s.ORIENTATION.PORTRAIT : s.ORIENTATION.LANDSCAPE; }; }, function (t, e) {\n    t.exports = {\n      NO_CENTER: 0, CENTER_BOTH: 1, CENTER_HORIZONTALLY: 2, CENTER_VERTICALLY: 3,\n    };\n  }, function (t, e) { t.exports = { LANDSCAPE: 'landscape-primary', PORTRAIT: 'portrait-primary' }; }, function (t, e) {\n    t.exports = {\n      NONE: 0, WIDTH_CONTROLS_HEIGHT: 1, HEIGHT_CONTROLS_WIDTH: 2, FIT: 3, ENVELOP: 4, RESIZE: 5,\n    };\n  }, function (t, e) {\n    t.exports = {\n      NO_ZOOM: 1, ZOOM_2X: 2, ZOOM_4X: 4, MAX_ZOOM: -1,\n    };\n  }, function (t, e) { t.exports = function (t) { let e; return t !== '' && (typeof t === 'string' ? e = document.getElementById(t) : t && t.nodeType === 1 && (e = t)), e = e || document.body; }; }, function (t, e) { t.exports = function (t) { let e = ''; try { window.DOMParser ? e = (new DOMParser()).parseFromString(t, 'text/xml') : (e = new ActiveXObject('Microsoft.XMLDOM')).loadXML(t); } catch (t) { e = null; } return e && e.documentElement && !e.getElementsByTagName('parsererror').length ? e : null; }; }, function (t, e, i) {\n    const n = i(0); const a = i(179); const s = i(10); const r = i(54); const o = i(20); const h = i(366); const l = i(367); const u = i(368); const c = i(369); const d = i(29); const v = i(333); const f = new n({\n      initialize(t, e) { this.game = t, this.scaleManager, this.canvas, this.config = e, this.enabled = !0, this.events = new s(), this.isOver = !0, this.defaultCursor = '', this.keyboard = e.inputKeyboard ? new h(this) : null, this.mouse = e.inputMouse ? new l(this) : null, this.touch = e.inputTouch ? new c(this) : null, this.pointers = [], this.pointersTotal = e.inputActivePointers, e.inputTouch && this.pointersTotal === 1 && (this.pointersTotal = 2); for (let i = 0; i <= this.pointersTotal; i++) { const n = new u(this, i); n.smoothFactor = e.inputSmoothFactor, this.pointers.push(n); } this.mousePointer = e.inputMouse ? this.pointers[0] : null, this.activePointer = this.pointers[0], this.globalTopOnly = !0, this.time = 0, this._tempPoint = { x: 0, y: 0 }, this._tempHitTest = [], this._tempMatrix = new d(), this._tempMatrix2 = new d(), this._tempSkip = !1, this.mousePointerContainer = [this.mousePointer], t.events.once(o.BOOT, this.boot, this); }, boot() { this.canvas = this.game.canvas, this.scaleManager = this.game.scale, this.events.emit(r.MANAGER_BOOT), this.game.events.on(o.PRE_RENDER, this.preRender, this), this.game.events.once(o.DESTROY, this.destroy, this); }, setCanvasOver(t) { this.isOver = !0, this.events.emit(r.GAME_OVER, t); }, setCanvasOut(t) { this.isOver = !1, this.events.emit(r.GAME_OUT, t); }, preRender() { const t = this.game.loop.now; const e = this.game.loop.delta; const i = this.game.scene.getScenes(!0, !0); this.time = t, this.events.emit(r.MANAGER_UPDATE); for (let n = 0; n < i.length; n++) { const s = i[n]; if (s.sys.input && s.sys.input.updatePoll(t, e) && this.globalTopOnly) return; } }, setDefaultCursor(t) { this.defaultCursor = t, this.canvas.style.cursor !== t && (this.canvas.style.cursor = t); }, setCursor(t) { t.cursor && (this.canvas.style.cursor = t.cursor); }, resetCursor(t) { t.cursor && this.canvas && (this.canvas.style.cursor = this.defaultCursor); }, addPointer(t) { void 0 === t && (t = 1); const e = []; this.pointersTotal + t > 10 && (t = 10 - this.pointersTotal); for (let i = 0; i < t; i++) { const n = this.pointers.length; const s = new u(this, n); s.smoothFactor = this.config.inputSmoothFactor, this.pointers.push(s), this.pointersTotal++, e.push(s); } return e; }, updateInputPlugins(t, e) { const i = this.game.scene.getScenes(!0, !0); this._tempSkip = !1; for (let n = 0; n < i.length; n++) { const s = i[n]; if (s.sys.input) if (s.sys.input.update(t, e) && this.globalTopOnly || this._tempSkip) return; } }, onTouchStart(t) { for (var e = this.pointers, i = [], n = 0; n < t.changedTouches.length; n++) for (let s = t.changedTouches[n], r = 1; r < this.pointersTotal; r++) { const o = e[r]; if (!o.active) { o.touchstart(s, t), this.activePointer = o, i.push(o); break; } } this.updateInputPlugins(a.TOUCH_START, i); }, onTouchMove(t) { for (var e = this.pointers, i = [], n = 0; n < t.changedTouches.length; n++) for (let s = t.changedTouches[n], r = 1; r < this.pointersTotal; r++) { const o = e[r]; if (o.active && o.identifier === s.identifier) { o.touchmove(s, t), this.activePointer = o, i.push(o); break; } } this.updateInputPlugins(a.TOUCH_MOVE, i); }, onTouchEnd(t) { for (var e = this.pointers, i = [], n = 0; n < t.changedTouches.length; n++) for (let s = t.changedTouches[n], r = 1; r < this.pointersTotal; r++) { const o = e[r]; if (o.active && o.identifier === s.identifier) { o.touchend(s, t), i.push(o); break; } } this.updateInputPlugins(a.TOUCH_END, i); }, onTouchCancel(t) { for (var e = this.pointers, i = [], n = 0; n < t.changedTouches.length; n++) for (let s = t.changedTouches[n], r = 1; r < this.pointersTotal; r++) { const o = e[r]; if (o.active && o.identifier === s.identifier) { o.touchcancel(s, t), i.push(o); break; } } this.updateInputPlugins(a.TOUCH_CANCEL, i); }, onMouseDown(t) { this.mousePointer.down(t), this.mousePointer.updateMotion(), this.updateInputPlugins(a.MOUSE_DOWN, this.mousePointerContainer); }, onMouseMove(t) { this.mousePointer.move(t), this.mousePointer.updateMotion(), this.updateInputPlugins(a.MOUSE_MOVE, this.mousePointerContainer); }, onMouseUp(t) { this.mousePointer.up(t), this.mousePointer.updateMotion(), this.updateInputPlugins(a.MOUSE_UP, this.mousePointerContainer); }, onMouseWheel(t) { this.mousePointer.wheel(t), this.updateInputPlugins(a.MOUSE_WHEEL, this.mousePointerContainer); }, onPointerLockChange(t) { const e = this.mouse.locked; this.mousePointer.locked = e, this.events.emit(r.POINTERLOCK_CHANGE, t, e); }, inputCandidate(t, e) { const i = t.input; if (!i || !i.enabled || !i.alwaysEnabled && !t.willRender(e)) return !1; let n = !0; let s = t.parentContainer; if (s) do { if (!s.willRender(e)) { n = !1; break; }s = s.parentContainer; } while (s);return n; }, hitTest(t, e, i, n) { void 0 === n && (n = this._tempHitTest); const s = this._tempPoint; const r = i.scrollX; const o = i.scrollY; n.length = 0; let a = t.x; let h = t.y; i.resolution !== 1 && (a += i._x, h += i._y), i.getWorldPoint(a, h, s), t.worldX = s.x, t.worldY = s.y; for (let l = { x: 0, y: 0 }, u = this._tempMatrix, c = this._tempMatrix2, d = 0; d < e.length; d++) { var f; var p; const g = e[d]; this.inputCandidate(g, i) && (f = s.x + r * g.scrollFactorX - r, p = s.y + o * g.scrollFactorY - o, g.parentContainer ? (g.getWorldTransformMatrix(u, c), u.applyInverse(f, p, l)) : v(f, p, g.x, g.y, g.rotation, g.scaleX, g.scaleY, l), this.pointWithinHitArea(g, l.x, l.y) && n.push(g)); } return n; }, pointWithinHitArea(t, e, i) { e += t.displayOriginX, i += t.displayOriginY; const n = t.input; return !(!n || !n.hitAreaCallback(n.hitArea, e, i, t)) && (n.localX = e, n.localY = i, !0); }, pointWithinInteractiveObject(t, e, i) { return !!t.hitArea && (e += t.gameObject.displayOriginX, i += t.gameObject.displayOriginY, t.localX = e, t.localY = i, t.hitAreaCallback(t.hitArea, e, i, t)); }, transformPointer(t, e, i, n) { const s = t.position; const r = t.prevPosition; r.x = s.x, r.y = s.y; const o = this.scaleManager.transformX(e); const a = this.scaleManager.transformY(i); const h = t.smoothFactor; n && h !== 0 ? (s.x = o * h + r.x * (1 - h), s.y = a * h + r.y * (1 - h)) : (s.x = o, s.y = a); }, destroy() { this.events.removeAllListeners(), this.game.events.off(o.PRE_RENDER), this.keyboard && this.keyboard.destroy(), this.mouse && this.mouse.destroy(), this.touch && this.touch.destroy(); for (let t = 0; t < this.pointers.length; t++) this.pointers[t].destroy(); this.pointers = [], this._tempHitTest = [], this._tempMatrix.destroy(), this.canvas = null, this.game = null; },\n    }); t.exports = f;\n  }, function (t, e, i) {\n    const s = i(123); const n = i(0); const r = i(20); const o = i(54); const a = i(124); const h = i(1); const l = new n({\n      initialize(t) { this.manager = t, this.queue = [], this.preventDefault = !0, this.captures = [], this.enabled = !1, this.target, this.onKeyDown = h, this.onKeyUp = h, t.events.once(o.MANAGER_BOOT, this.boot, this); }, boot() { const t = this.manager.config; this.enabled = t.inputKeyboard, this.target = t.inputKeyboardEventTarget, this.addCapture(t.inputKeyboardCapture), !this.target && window && (this.target = window), this.enabled && this.target && this.startListeners(), this.manager.game.events.on(r.POST_STEP, this.postUpdate, this); }, startListeners() { const i = this; this.onKeyDown = function (t) { let e; !t.defaultPrevented && i.enabled && i.manager && (i.queue.push(t), i.manager.useQueue || i.manager.events.emit(o.MANAGER_PROCESS), e = t.altKey || t.ctrlKey || t.shiftKey || t.metaKey, i.preventDefault && !e && i.captures.indexOf(t.keyCode) > -1 && t.preventDefault()); }, this.onKeyUp = function (t) { let e; !t.defaultPrevented && i.enabled && i.manager && (i.queue.push(t), i.manager.useQueue || i.manager.events.emit(o.MANAGER_PROCESS), e = t.altKey || t.ctrlKey || t.shiftKey || t.metaKey, i.preventDefault && !e && i.captures.indexOf(t.keyCode) > -1 && t.preventDefault()); }; const t = this.target; t && (t.addEventListener('keydown', this.onKeyDown, !1), t.addEventListener('keyup', this.onKeyUp, !1), this.enabled = !0); }, stopListeners() { const t = this.target; t.removeEventListener('keydown', this.onKeyDown, !1), t.removeEventListener('keyup', this.onKeyUp, !1), this.enabled = !1; }, postUpdate() { this.queue = []; }, addCapture(t) { typeof t === 'string' && (t = t.split(',')), Array.isArray(t) || (t = [t]); for (var e = this.captures, i = 0; i < t.length; i++) { let n = t[i]; typeof n === 'string' && (n = a[n.trim().toUpperCase()]), e.indexOf(n) === -1 && e.push(n); } this.preventDefault = e.length > 0; }, removeCapture(t) { typeof t === 'string' && (t = t.split(',')), Array.isArray(t) || (t = [t]); for (var e = this.captures, i = 0; i < t.length; i++) { let n = t[i]; typeof n === 'string' && (n = a[n.toUpperCase()]), s(e, n); } this.preventDefault = e.length > 0; }, clearCaptures() { this.captures = [], this.preventDefault = !1; }, destroy() { this.stopListeners(), this.clearCaptures(), this.queue = [], this.manager.game.events.off(r.POST_RENDER, this.postUpdate, this), this.target = null, this.enabled = !1, this.manager = null; },\n    }); t.exports = l;\n  }, function (t, e, i) {\n    const n = i(0); const o = i(169); const s = i(54); const r = i(1); const a = new n({\n      initialize(t) { this.manager = t, this.capture = !0, this.enabled = !1, this.target, this.locked = !1, this.onMouseMove = r, this.onMouseDown = r, this.onMouseUp = r, this.onMouseDownWindow = r, this.onMouseUpWindow = r, this.onMouseOver = r, this.onMouseOut = r, this.onMouseWheel = r, this.pointerLockChange = r, t.events.once(s.MANAGER_BOOT, this.boot, this); }, boot() { const t = this.manager.config; this.enabled = t.inputMouse, this.target = t.inputMouseEventTarget, this.capture = t.inputMouseCapture, this.target ? typeof this.target === 'string' && (this.target = document.getElementById(this.target)) : this.target = this.manager.game.canvas, t.disableContextMenu && this.disableContextMenu(), this.enabled && this.target && this.startListeners(); }, disableContextMenu() { return document.body.addEventListener('contextmenu', (t) => (t.preventDefault(), !1)), this; }, requestPointerLock() { let t; o.pointerLock && ((t = this.target).requestPointerLock = t.requestPointerLock || t.mozRequestPointerLock || t.webkitRequestPointerLock, t.requestPointerLock()); }, releasePointerLock() { o.pointerLock && (document.exitPointerLock = document.exitPointerLock || document.mozExitPointerLock || document.webkitExitPointerLock, document.exitPointerLock()); }, startListeners() { const i = this; const e = this.manager.canvas; const n = window && window.focus && this.manager.game.config.autoFocus; this.onMouseMove = function (t) { !t.defaultPrevented && i.enabled && i.manager && i.manager.enabled && (i.manager.onMouseMove(t), i.capture && t.preventDefault()); }, this.onMouseDown = function (t) { n && window.focus(), !t.defaultPrevented && i.enabled && i.manager && i.manager.enabled && (i.manager.onMouseDown(t), i.capture && t.target === e && t.preventDefault()); }, this.onMouseDownWindow = function (t) { !t.defaultPrevented && i.enabled && i.manager && i.manager.enabled && t.target !== e && i.manager.onMouseDown(t); }, this.onMouseUp = function (t) { !t.defaultPrevented && i.enabled && i.manager && i.manager.enabled && (i.manager.onMouseUp(t), i.capture && t.target === e && t.preventDefault()); }, this.onMouseUpWindow = function (t) { !t.defaultPrevented && i.enabled && i.manager && i.manager.enabled && t.target !== e && i.manager.onMouseUp(t); }, this.onMouseOver = function (t) { !t.defaultPrevented && i.enabled && i.manager && i.manager.enabled && i.manager.setCanvasOver(t); }, this.onMouseOut = function (t) { !t.defaultPrevented && i.enabled && i.manager && i.manager.enabled && i.manager.setCanvasOut(t); }, this.onMouseWheel = function (t) { !t.defaultPrevented && i.enabled && i.manager && i.manager.enabled && i.manager.onMouseWheel(t); }; let t; let s; const r = this.target; r && (s = { passive: !(t = { passive: !0 }) }, r.addEventListener('mousemove', this.onMouseMove, this.capture ? s : t), r.addEventListener('mousedown', this.onMouseDown, this.capture ? s : t), r.addEventListener('mouseup', this.onMouseUp, this.capture ? s : t), r.addEventListener('mouseover', this.onMouseOver, this.capture ? s : t), r.addEventListener('mouseout', this.onMouseOut, this.capture ? s : t), r.addEventListener('wheel', this.onMouseWheel, this.capture ? s : t), window && this.manager.game.config.inputWindowEvents && (window.addEventListener('mousedown', this.onMouseDownWindow, s), window.addEventListener('mouseup', this.onMouseUpWindow, s)), o.pointerLock && (this.pointerLockChange = function (t) { const e = i.target; i.locked = document.pointerLockElement === e || document.mozPointerLockElement === e || document.webkitPointerLockElement === e, i.manager.onPointerLockChange(t); }, document.addEventListener('pointerlockchange', this.pointerLockChange, !0), document.addEventListener('mozpointerlockchange', this.pointerLockChange, !0), document.addEventListener('webkitpointerlockchange', this.pointerLockChange, !0)), this.enabled = !0); }, stopListeners() { const t = this.target; t.removeEventListener('mousemove', this.onMouseMove), t.removeEventListener('mousedown', this.onMouseDown), t.removeEventListener('mouseup', this.onMouseUp), t.removeEventListener('mouseover', this.onMouseOver), t.removeEventListener('mouseout', this.onMouseOut), window && (window.removeEventListener('mousedown', this.onMouseDownWindow), window.removeEventListener('mouseup', this.onMouseUpWindow)), o.pointerLock && (document.removeEventListener('pointerlockchange', this.pointerLockChange, !0), document.removeEventListener('mozpointerlockchange', this.pointerLockChange, !0), document.removeEventListener('webkitpointerlockchange', this.pointerLockChange, !0)); }, destroy() { this.stopListeners(), this.target = null, this.enabled = !1, this.manager = null; },\n    }); t.exports = a;\n  }, function (t, e, i) {\n    const h = i(317); const n = i(0); const s = i(53); const l = i(106); const u = i(328); const r = i(3); const o = new n({\n      initialize(t, e) { this.manager = t, this.id = e, this.event, this.downElement, this.upElement, this.camera = null, this.button = 0, this.buttons = 0, this.position = new r(), this.prevPosition = new r(), this.midPoint = new r(-1, -1), this.velocity = new r(), this.angle = 0, this.distance = 0, this.smoothFactor = 0, this.motionFactor = 0.2, this.worldX = 0, this.worldY = 0, this.moveTime = 0, this.downX = 0, this.downY = 0, this.downTime = 0, this.upX = 0, this.upY = 0, this.upTime = 0, this.primaryDown = !1, this.isDown = !1, this.wasTouch = !1, this.wasCanceled = !1, this.movementX = 0, this.movementY = 0, this.identifier = 0, this.pointerId = null, this.active = e === 0, this.locked = !1, this.deltaX = 0, this.deltaY = 0, this.deltaZ = 0; }, updateWorldPoint(t) { let e = this.x; let i = this.y; t.resolution !== 1 && (e += t._x, i += t._y); const n = t.getWorldPoint(e, i); return this.worldX = n.x, this.worldY = n.y, this; }, positionToCamera(t, e) { return t.getWorldPoint(this.x, this.y, e); }, updateMotion() { let t; let e; let i; let n; const s = this.position.x; const r = this.position.y; const o = this.midPoint.x; const a = this.midPoint.y; s === o && r === a || (t = u(this.motionFactor, o, s), e = u(this.motionFactor, a, r), l(t, s, 0.1) && (t = s), l(e, r, 0.1) && (e = r), this.midPoint.set(t, e), i = s - t, n = r - e, this.velocity.set(i, n), this.angle = h(t, e, s, r), this.distance = Math.sqrt(i * i + n * n)); }, up(t) { 'buttons' in t && (this.buttons = t.buttons), this.event = t, this.button = t.button, this.upElement = t.target, this.manager.transformPointer(this, t.pageX, t.pageY, !1), t.button === 0 && (this.primaryDown = !1, this.upX = this.x, this.upY = this.y, this.upTime = t.timeStamp), this.isDown = !1, this.wasTouch = !1; }, down(t) { 'buttons' in t && (this.buttons = t.buttons), this.event = t, this.button = t.button, this.downElement = t.target, this.manager.transformPointer(this, t.pageX, t.pageY, !1), t.button === 0 && (this.primaryDown = !0, this.downX = this.x, this.downY = this.y, this.downTime = t.timeStamp), this.isDown = !0, this.wasTouch = !1; }, move(t) { 'buttons' in t && (this.buttons = t.buttons), this.event = t, this.manager.transformPointer(this, t.pageX, t.pageY, !0), this.locked && (this.movementX = t.movementX || t.mozMovementX || t.webkitMovementX || 0, this.movementY = t.movementY || t.mozMovementY || t.webkitMovementY || 0), this.moveTime = t.timeStamp, this.wasTouch = !1; }, wheel(t) { 'buttons' in t && (this.buttons = t.buttons), this.event = t, this.manager.transformPointer(this, t.pageX, t.pageY, !1), this.deltaX = t.deltaX, this.deltaY = t.deltaY, this.deltaZ = t.deltaZ, this.wasTouch = !1; }, touchstart(t, e) { t.pointerId && (this.pointerId = t.pointerId), this.identifier = t.identifier, this.target = t.target, this.active = !0, this.buttons = 1, this.event = e, this.downElement = t.target, this.manager.transformPointer(this, t.pageX, t.pageY, !1), this.primaryDown = !0, this.downX = this.x, this.downY = this.y, this.downTime = e.timeStamp, this.isDown = !0, this.wasTouch = !0, this.wasCanceled = !1, this.updateMotion(); }, touchmove(t, e) { this.event = e, this.manager.transformPointer(this, t.pageX, t.pageY, !0), this.moveTime = e.timeStamp, this.wasTouch = !0, this.updateMotion(); }, touchend(t, e) { this.buttons = 0, this.event = e, this.upElement = t.target, this.manager.transformPointer(this, t.pageX, t.pageY, !1), this.primaryDown = !1, this.upX = this.x, this.upY = this.y, this.upTime = e.timeStamp, this.isDown = !1, this.wasTouch = !0, this.wasCanceled = !1, this.active = !1, this.updateMotion(); }, touchcancel(t, e) { this.buttons = 0, this.event = e, this.upElement = t.target, this.manager.transformPointer(this, t.pageX, t.pageY, !1), this.primaryDown = !1, this.upX = this.x, this.upY = this.y, this.upTime = e.timeStamp, this.isDown = !1, this.wasTouch = !0, this.wasCanceled = !0, this.active = !1; }, noButtonDown() { return this.buttons === 0; }, leftButtonDown() { return !!(1 & this.buttons); }, rightButtonDown() { return !!(2 & this.buttons); }, middleButtonDown() { return !!(4 & this.buttons); }, backButtonDown() { return !!(8 & this.buttons); }, forwardButtonDown() { return !!(16 & this.buttons); }, leftButtonReleased() { return this.button === 0 && !this.isDown; }, rightButtonReleased() { return this.button === 2 && !this.isDown; }, middleButtonReleased() { return this.button === 1 && !this.isDown; }, backButtonReleased() { return this.button === 3 && !this.isDown; }, forwardButtonReleased() { return this.button === 4 && !this.isDown; }, getDistance() { return this.isDown ? s(this.downX, this.downY, this.x, this.y) : s(this.downX, this.downY, this.upX, this.upY); }, getDistanceX() { return this.isDown ? Math.abs(this.downX - this.x) : Math.abs(this.downX - this.upX); }, getDistanceY() { return this.isDown ? Math.abs(this.downY - this.y) : Math.abs(this.downY - this.upY); }, getDuration() { return this.isDown ? this.manager.time - this.downTime : this.upTime - this.downTime; }, getAngle() { return this.isDown ? h(this.downX, this.downY, this.x, this.y) : h(this.downX, this.downY, this.upX, this.upY); }, getInterpolatedPosition(t, e) { void 0 === t && (t = 10), void 0 === e && (e = []); for (let i = this.prevPosition.x, n = this.prevPosition.y, s = this.position.x, r = this.position.y, o = 0; o < t; o++) { const a = 1 / t * o; e[o] = { x: u(a, i, s), y: u(a, n, r) }; } return e; }, destroy() { this.camera = null, this.manager = null, this.position = null; }, x: { get() { return this.position.x; }, set(t) { this.position.x = t; } }, y: { get() { return this.position.y; }, set(t) { this.position.y = t; } }, time: { get() { return this.event ? this.event.timeStamp : 0; } },\n    }); t.exports = o;\n  }, function (t, e, i) {\n    const n = i(0); const s = i(54); const r = i(1); const o = new n({\n      initialize(t) { this.manager = t, this.capture = !0, this.enabled = !1, this.target, this.onTouchStart = r, this.onTouchStartWindow = r, this.onTouchMove = r, this.onTouchEnd = r, this.onTouchEndWindow = r, this.onTouchCancel = r, this.onTouchCancelWindow = r, this.onTouchOver = r, this.onTouchOut = r, t.events.once(s.MANAGER_BOOT, this.boot, this); }, boot() { const t = this.manager.config; this.enabled = t.inputTouch, this.target = t.inputTouchEventTarget, this.capture = t.inputTouchCapture, this.target || (this.target = this.manager.game.canvas), t.disableContextMenu && this.disableContextMenu(), this.enabled && this.target && this.startListeners(); }, disableContextMenu() { return document.body.addEventListener('contextmenu', (t) => (t.preventDefault(), !1)), this; }, startListeners() { const e = this; const i = this.manager.canvas; const n = window && window.focus && this.manager.game.config.autoFocus; this.onTouchStart = function (t) { n && window.focus(), !t.defaultPrevented && e.enabled && e.manager && e.manager.enabled && (e.manager.onTouchStart(t), e.capture && t.cancelable && t.target === i && t.preventDefault()); }, this.onTouchStartWindow = function (t) { !t.defaultPrevented && e.enabled && e.manager && e.manager.enabled && t.target !== i && e.manager.onTouchStart(t); }, this.onTouchMove = function (t) { !t.defaultPrevented && e.enabled && e.manager && e.manager.enabled && (e.manager.onTouchMove(t), e.capture && t.cancelable && t.preventDefault()); }, this.onTouchEnd = function (t) { !t.defaultPrevented && e.enabled && e.manager && e.manager.enabled && (e.manager.onTouchEnd(t), e.capture && t.cancelable && t.target === i && t.preventDefault()); }, this.onTouchEndWindow = function (t) { !t.defaultPrevented && e.enabled && e.manager && e.manager.enabled && t.target !== i && e.manager.onTouchEnd(t); }, this.onTouchCancel = function (t) { !t.defaultPrevented && e.enabled && e.manager && e.manager.enabled && (e.manager.onTouchCancel(t), e.capture && t.preventDefault()); }, this.onTouchCancelWindow = function (t) { !t.defaultPrevented && e.enabled && e.manager && e.manager.enabled && e.manager.onTouchCancel(t); }, this.onTouchOver = function (t) { !t.defaultPrevented && e.enabled && e.manager && e.manager.enabled && e.manager.setCanvasOver(t); }, this.onTouchOut = function (t) { !t.defaultPrevented && e.enabled && e.manager && e.manager.enabled && e.manager.setCanvasOut(t); }; let t; let s; const r = this.target; r && (s = { passive: !(t = { passive: !0 }) }, r.addEventListener('touchstart', this.onTouchStart, this.capture ? s : t), r.addEventListener('touchmove', this.onTouchMove, this.capture ? s : t), r.addEventListener('touchend', this.onTouchEnd, this.capture ? s : t), r.addEventListener('touchcancel', this.onTouchCancel, this.capture ? s : t), r.addEventListener('touchover', this.onTouchOver, this.capture ? s : t), r.addEventListener('touchout', this.onTouchOut, this.capture ? s : t), window && this.manager.game.config.inputWindowEvents && (window.addEventListener('touchstart', this.onTouchStartWindow, s), window.addEventListener('touchend', this.onTouchEndWindow, s), window.addEventListener('touchcancel', this.onTouchCancelWindow, s)), this.enabled = !0); }, stopListeners() { const t = this.target; t.removeEventListener('touchstart', this.onTouchStart), t.removeEventListener('touchmove', this.onTouchMove), t.removeEventListener('touchend', this.onTouchEnd), t.removeEventListener('touchcancel', this.onTouchCancel), t.removeEventListener('touchover', this.onTouchOver), t.removeEventListener('touchout', this.onTouchOut), window && (window.removeEventListener('touchstart', this.onTouchStartWindow), window.removeEventListener('touchend', this.onTouchEndWindow)); }, destroy() { this.stopListeners(), this.target = null, this.enabled = !1, this.manager = null; },\n    }); t.exports = o;\n  }, function (t, e, i) {\n    const n = i(0); const l = i(20); const s = i(10); const r = i(8); const o = i(16); const a = i(5); const u = i(2); const p = i(23); const h = i(123); const c = new n({\n      Extends: s,\n      initialize(t) { s.call(this), this.game = t, this.plugins = [], this.scenePlugins = [], this._pendingGlobal = [], this._pendingScene = [], t.isBooted ? this.boot() : t.events.once(l.BOOT, this.boot, this); },\n      boot() { for (var t, e, i, n, s, r, o = this.game.config, a = (a = o.installGlobalPlugins).concat(this._pendingGlobal), h = 0; h < a.length; h++)t = a[h], e = u(t, 'key', null), i = u(t, 'plugin', null), n = u(t, 'start', !1), s = u(t, 'mapping', null), r = u(t, 'data', null), e && (i ? this.install(e, i, n, s, r) : console.warn(`Missing \\`plugin\\` for key: ${e}`)); for (a = (a = o.installScenePlugins).concat(this._pendingScene), h = 0; h < a.length; h++)t = a[h], e = u(t, 'key', null), i = u(t, 'plugin', null), s = u(t, 'mapping', null), e && (i ? this.installScenePlugin(e, i, s) : console.warn(`Missing \\`plugin\\` for key: ${e}`)); this._pendingGlobal = [], this._pendingScene = [], this.game.events.once(l.DESTROY, this.destroy, this); },\n      addToScene(t, e, i) { for (var n, s = this.game, r = t.scene, o = t.settings.map, a = t.settings.isBooted, h = 0; h < e.length; h++)s[d = e[h]] ? (t[d] = s[d], o.hasOwnProperty(d) && (r[o[d]] = t[d])) : d === 'game' && o.hasOwnProperty(d) && (r[o[d]] = s); for (let l = 0; l < i.length; l++) for (n = i[l], h = 0; h < n.length; h++) { var u; var c; var d = n[h]; p.hasCore(d) && (c = new ((u = p.getCore(d)).plugin)(r, this), t[u.mapping] = c, u.custom ? r[u.mapping] = c : o.hasOwnProperty(u.mapping) && (r[o[u.mapping]] = c), a && c.boot()); } for (n = this.plugins, h = 0; h < n.length; h++) { const f = n[h]; f.mapping && (r[f.mapping] = f.plugin); } },\n      getDefaultScenePlugins() { return this.game.config.defaultPlugins.concat(this.scenePlugins); },\n      installScenePlugin(t, e, i, n, s) { if (void 0 === s && (s = !1), typeof e === 'function') { if (p.hasCore(t)) { if (!s && p.hasCore(t)) return void console.warn(`Scene Plugin key in use: ${t}`); } else p.register(t, e, i, !0), this.scenePlugins.push(t); let r; n && (r = new e(n, this), n.sys[t] = r, i && i !== '' && (n[i] = r), r.boot()); } else console.warn(`Invalid Scene Plugin: ${t}`); },\n      install(t, e, i, n, s) {\n        if (void 0 === i && (i = !1), void 0 === n && (n = null), void 0 === s && (s = null), typeof e !== 'function') return console.warn(`Invalid Plugin: ${t}`), null; if (p.hasCustom(t)) return console.warn(`Plugin key in use: ${t}`), null; if (n !== null && (i = !0), this.game.isBooted) { if (p.registerCustom(t, e, n, s), i) return this.start(t); } else {\n          this._pendingGlobal.push({\n            key: t, plugin: e, start: i, mapping: n, data: s,\n          });\n        } return null;\n      },\n      getIndex(t) { for (let e = this.plugins, i = 0; i < e.length; i++) { if (e[i].key === t) return i; } return -1; },\n      getEntry(t) { const e = this.getIndex(t); if (e !== -1) return this.plugins[e]; },\n      isActive(t) { const e = this.getEntry(t); return e && e.active; },\n      start(t, e) { void 0 === e && (e = t); let i = this.getEntry(e); return i && !i.active ? (i.active = !0, i.plugin.start()) : i = i || this.createEntry(t, e), i ? i.plugin : null; },\n      createEntry(t, e) {\n        let i; let n = p.getCustom(t); return n && (n = {\n          key: e, plugin: i = new n.plugin(this), active: !0, mapping: n.mapping, data: n.data,\n        }, this.plugins.push(n), i.init(n.data), i.start()), n;\n      },\n      stop(t) { const e = this.getEntry(t); return e && e.active && (e.active = !1, e.plugin.stop()), this; },\n      get(t, e) { void 0 === e && (e = !0); let i = this.getEntry(t); if (i) return i.plugin; const n = this.getClass(t); return n && e ? (i = this.createEntry(t, t)) ? i.plugin : null : n || null; },\n      getClass(t) { return p.getCustomClass(t); },\n      removeGlobalPlugin(t) { const e = this.getEntry(t); e && h(this.plugins, e), p.removeCustom(t); },\n      removeScenePlugin(t) { h(this.scenePlugins, t), p.remove(t); },\n      registerGameObject(t, e, i) { return e && a.register(t, e), i && o.register(t, i), this; },\n      removeGameObject(t, e, i) { return void 0 === e && (e = !0), void 0 === i && (i = !0), e && a.remove(t), i && o.remove(t), this; },\n      registerFileType(t, e, i) { r.register(t, e), i && i.sys.load && (i.sys.load[t] = e); },\n      destroy() { for (let t = 0; t < this.plugins.length; t++) this.plugins[t].plugin.destroy(); p.destroyCustomPlugins(), this.game.noReturn && p.destroyCorePlugins(), this.game = null, this.plugins = [], this.scenePlugins = []; },\n    }); t.exports = c;\n  }, function (t, e, i) {\n    const c = i(177); const n = i(0); const s = i(10); const r = i(92); const o = i(20); const a = i(869); const h = i(363); const d = i(358); const l = i(1); const u = i(11); const f = i(372); const p = i(93); const g = i(3); const v = new n({\n      Extends: s,\n      initialize(t) {\n        s.call(this), this.game = t, this.canvas, this.canvasBounds = new u(), this.parent = null, this.parentIsWindow = !1, this.parentSize = new f(), this.gameSize = new f(), this.baseSize = new f(), this.displaySize = new f(), this.scaleMode = c.SCALE_MODE.NONE, this.resolution = 1, this.zoom = 1, this._resetZoom = !1, this.displayScale = new g(1, 1), this.autoRound = !1, this.autoCenter = c.CENTER.NO_CENTER, this.orientation = c.ORIENTATION.LANDSCAPE, this.fullscreen, this.fullscreenTarget = null, this._createdFullscreenTarget = !1, this.dirty = !1, this.resizeInterval = 500, this._lastCheck = 0, this._checkOrientation = !1, this.listeners = {\n          orientationChange: l, windowResize: l, fullScreenChange: l, fullScreenError: l,\n        };\n      },\n      preBoot() { this.parseConfig(this.game.config), this.game.events.once('boot', this.boot, this); },\n      boot() { const t = this.game; this.canvas = t.canvas, this.fullscreen = t.device.fullscreen, this.scaleMode !== c.SCALE_MODE.RESIZE && this.displaySize.setAspectMode(this.scaleMode), this.scaleMode === c.SCALE_MODE.NONE ? this.resize(this.width, this.height) : (this.getParentBounds(), this.parentSize.width > 0 && this.parentSize.height > 0 && this.displaySize.setParent(this.parentSize), this.refresh()), t.events.on(o.PRE_STEP, this.step, this), t.events.once(o.DESTROY, this.destroy, this), this.startListeners(); },\n      parseConfig(t) { this.getParent(t), this.getParentBounds(); let e; let i; let n; let s; let r = t.width; let o = t.height; const a = t.scaleMode; const h = t.resolution; let l = t.zoom; const u = t.autoRound; typeof r === 'string' && ((e = this.parentSize.width) === 0 && (e = window.innerWidth), i = parseInt(r, 10) / 100, r = Math.floor(e * i)), typeof o === 'string' && ((n = this.parentSize.height) === 0 && (n = window.innerHeight), s = parseInt(o, 10) / 100, o = Math.floor(n * s)), this.resolution = 1, this.scaleMode = a, this.autoRound = u, this.autoCenter = t.autoCenter, this.resizeInterval = t.resizeInterval, u && (r = Math.floor(r), o = Math.floor(o)), this.gameSize.setSize(r, o), l === c.ZOOM.MAX_ZOOM && (l = this.getMaxZoom()), (this.zoom = l) !== 1 && (this._resetZoom = !0), this.baseSize.setSize(r * h, o * h), u && (this.baseSize.width = Math.floor(this.baseSize.width), this.baseSize.height = Math.floor(this.baseSize.height)), t.minWidth > 0 && this.displaySize.setMin(t.minWidth * l, t.minHeight * l), t.maxWidth > 0 && this.displaySize.setMax(t.maxWidth * l, t.maxHeight * l), this.displaySize.setSize(r, o), this.orientation = d(r, o); },\n      getParent(t) { let e; const i = t.parent; i !== null && (this.parent = h(i), this.parentIsWindow = this.parent === document.body, t.expandParent && t.scaleMode !== c.SCALE_MODE.NONE && (e = this.parent.getBoundingClientRect(), !this.parentIsWindow && e.height !== 0 || (document.documentElement.style.height = '100%', document.body.style.height = '100%', e = this.parent.getBoundingClientRect(), this.parentIsWindow || e.height !== 0 || (this.parent.style.overflow = 'hidden', this.parent.style.width = '100%', this.parent.style.height = '100%'))), t.fullscreenTarget && !this.fullscreenTarget && (this.fullscreenTarget = h(t.fullscreenTarget))); },\n      getParentBounds() { if (!this.parent) return !1; const t = this.parentSize; const e = this.parent.getBoundingClientRect(); this.parentIsWindow && this.game.device.os.iOS && (e.height = a(!0)); const i = this.resolution; const n = e.width * i; const s = e.height * i; return (t.width !== n || t.height !== s) && (t.setSize(n, s), !0); },\n      lockOrientation(t) { const e = screen.lockOrientation || screen.mozLockOrientation || screen.msLockOrientation; return !!e && e.call(screen, t); },\n      setParentSize(t, e) { return this.parentSize.setSize(t, e), this.refresh(); },\n      setGameSize(t, e) { const i = this.autoRound; const n = this.resolution; i && (t = Math.floor(t), e = Math.floor(e)); const s = this.width; const r = this.height; return this.gameSize.resize(t, e), this.baseSize.resize(t * n, e * n), i && (this.baseSize.width = Math.floor(this.baseSize.width), this.baseSize.height = Math.floor(this.baseSize.height)), this.displaySize.setAspectRatio(t / e), this.canvas.width = this.baseSize.width, this.canvas.height = this.baseSize.height, this.refresh(s, r); },\n      resize(t, e) { const i = this.zoom; const n = this.resolution; const s = this.autoRound; s && (t = Math.floor(t), e = Math.floor(e)); const r = this.width; const o = this.height; this.gameSize.resize(t, e), this.baseSize.resize(t * n, e * n), s && (this.baseSize.width = Math.floor(this.baseSize.width), this.baseSize.height = Math.floor(this.baseSize.height)), this.displaySize.setSize(t * i * n, e * i * n), this.canvas.width = this.baseSize.width, this.canvas.height = this.baseSize.height; const a = this.canvas.style; let h = t * i; let l = e * i; return s && (h = Math.floor(h), l = Math.floor(l)), h === t && l === e || (a.width = `${h}px`, a.height = `${l}px`), this.refresh(r, o); },\n      setZoom(t) { return this.zoom = t, this._resetZoom = !0, this.refresh(); },\n      setMaxZoom() { return this.zoom = this.getMaxZoom(), this._resetZoom = !0, this.refresh(); },\n      refresh(t, e) { void 0 === t && (t = this.width), void 0 === e && (e = this.height), this.updateScale(), this.updateBounds(), this.updateOrientation(), this.displayScale.set(this.baseSize.width / this.canvasBounds.width, this.baseSize.height / this.canvasBounds.height); let i; let n; const s = this.game.domContainer; return s && (this.baseSize.setCSS(s), i = this.canvas.style, (n = s.style).transform = `scale(${this.displaySize.width / this.baseSize.width},${this.displaySize.height / this.baseSize.height})`, n.marginLeft = i.marginLeft, n.marginTop = i.marginTop), this.emit(r.RESIZE, this.gameSize, this.baseSize, this.displaySize, this.resolution, t, e), this; },\n      updateOrientation() { let t; this._checkOrientation && (this._checkOrientation = !1, (t = d(this.width, this.height)) !== this.orientation && (this.orientation = t, this.emit(r.ORIENTATION_CHANGE, t))); },\n      updateScale() { let t; let e; const i = this.canvas.style; const n = this.gameSize.width; const s = this.gameSize.height; const r = this.zoom; const o = this.autoRound; this.scaleMode === c.SCALE_MODE.NONE ? (this.displaySize.setSize(n * r * 1, s * r * 1), t = +this.displaySize.width, e = +this.displaySize.height, o && (t = Math.floor(t), e = Math.floor(e)), this._resetZoom && (i.width = `${t}px`, i.height = `${e}px`, this._resetZoom = !1)) : this.scaleMode === c.SCALE_MODE.RESIZE ? (this.displaySize.setSize(this.parentSize.width, this.parentSize.height), this.gameSize.setSize(this.displaySize.width, this.displaySize.height), this.baseSize.setSize(+this.displaySize.width, +this.displaySize.height), t = +this.displaySize.width, e = +this.displaySize.height, o && (t = Math.floor(t), e = Math.floor(e)), this.canvas.width = t, this.canvas.height = e) : (this.displaySize.setSize(this.parentSize.width, this.parentSize.height), t = +this.displaySize.width, e = +this.displaySize.height, o && (t = Math.floor(t), e = Math.floor(e)), i.width = `${t}px`, i.height = `${e}px`), this.getParentBounds(), this.updateCenter(); },\n      getMaxZoom() { const t = p(this.parentSize.width, this.gameSize.width, 0, !0); const e = p(this.parentSize.height, this.gameSize.height, 0, !0); return Math.max(Math.min(t, e), 1); },\n      updateCenter() { let t; let e; let i; let n; let s; let r; let o; const a = this.autoCenter; a !== c.CENTER.NO_CENTER && (e = (t = this.canvas).style, n = (i = t.getBoundingClientRect()).width, s = i.height, r = Math.floor((this.parentSize.width - n) / 2), o = Math.floor((this.parentSize.height - s) / 2), a === c.CENTER.CENTER_HORIZONTALLY ? o = 0 : a === c.CENTER.CENTER_VERTICALLY && (r = 0), e.marginLeft = `${r}px`, e.marginTop = `${o}px`); },\n      updateBounds() { const t = this.canvasBounds; const e = this.canvas.getBoundingClientRect(); t.x = e.left + (window.pageXOffset || 0) - (document.documentElement.clientLeft || 0), t.y = e.top + (window.pageYOffset || 0) - (document.documentElement.clientTop || 0), t.width = e.width, t.height = e.height; },\n      transformX(t) { return (t - this.canvasBounds.left) * this.displayScale.x; },\n      transformY(t) { return (t - this.canvasBounds.top) * this.displayScale.y; },\n      startFullscreen(t) { void 0 === t && (t = { navigationUI: 'hide' }); let e; const i = this.fullscreen; i.available ? i.active || (e = this.getFullscreenTarget(), i.keyboard ? e[i.request](Element.ALLOW_KEYBOARD_INPUT) : e[i.request](t)) : this.emit(r.FULLSCREEN_UNSUPPORTED); },\n      fullscreenSuccessHandler() { this.getParentBounds(), this.refresh(), this.emit(r.ENTER_FULLSCREEN); },\n      fullscreenErrorHandler(t) { this.removeFullscreenTarget(), this.emit(r.FULLSCREEN_FAILED, t); },\n      getFullscreenTarget() { let t; return this.fullscreenTarget || ((t = document.createElement('div')).style.margin = '0', t.style.padding = '0', t.style.width = '100%', t.style.height = '100%', this.fullscreenTarget = t, this._createdFullscreenTarget = !0), this._createdFullscreenTarget && (this.canvas.parentNode.insertBefore(this.fullscreenTarget, this.canvas), this.fullscreenTarget.appendChild(this.canvas)), this.fullscreenTarget; },\n      removeFullscreenTarget() { let t; let e; !this._createdFullscreenTarget || (t = this.fullscreenTarget) && t.parentNode && ((e = t.parentNode).insertBefore(this.canvas, t), e.removeChild(t)); },\n      stopFullscreen() { const t = this.fullscreen; if (!t.available) return this.emit(r.FULLSCREEN_UNSUPPORTED), !1; t.active && document[t.cancel](), this.removeFullscreenTarget(), this.getParentBounds(), this.emit(r.LEAVE_FULLSCREEN), this.refresh(); },\n      toggleFullscreen(t) { this.fullscreen.active ? this.stopFullscreen() : this.startFullscreen(t); },\n      startListeners() { const e = this; const i = this.listeners; i.orientationChange = function () { e._checkOrientation = !0, e.dirty = !0; }, i.windowResize = function () { e.dirty = !0; }, window.addEventListener('orientationchange', i.orientationChange, !1), window.addEventListener('resize', i.windowResize, !1), this.fullscreen.available && (i.fullScreenChange = function (t) { return e.onFullScreenChange(t); }, i.fullScreenError = function (t) { return e.onFullScreenError(t); }, ['webkit', 'moz', ''].forEach((t) => { document.addEventListener(`${t}fullscreenchange`, i.fullScreenChange, !1), document.addEventListener(`${t}fullscreenerror`, i.fullScreenError, !1); }), document.addEventListener('MSFullscreenChange', i.fullScreenChange, !1), document.addEventListener('MSFullscreenError', i.fullScreenError, !1)); },\n      onFullScreenChange() { document.fullscreenElement || document.webkitFullscreenElement || document.msFullscreenElement || document.mozFullScreenElement ? this.fullscreenSuccessHandler() : this.stopFullscreen(); },\n      onFullScreenError() { this.removeFullscreenTarget(); },\n      step(t, e) { this.parent && (this._lastCheck += e, (this.dirty || this._lastCheck > this.resizeInterval) && (this.getParentBounds() && this.refresh(), this.dirty = !1, this._lastCheck = 0)); },\n      stopListeners() { const e = this.listeners; window.removeEventListener('orientationchange', e.orientationChange, !1), window.removeEventListener('resize', e.windowResize, !1); ['webkit', 'moz', ''].forEach((t) => { document.removeEventListener(`${t}fullscreenchange`, e.fullScreenChange, !1), document.removeEventListener(`${t}fullscreenerror`, e.fullScreenError, !1); }), document.removeEventListener('MSFullscreenChange', e.fullScreenChange, !1), document.removeEventListener('MSFullscreenError', e.fullScreenError, !1); },\n      destroy() { this.removeAllListeners(), this.stopListeners(), this.game = null, this.canvas = null, this.canvasBounds = null, this.parent = null, this.fullscreenTarget = null, this.parentSize.destroy(), this.gameSize.destroy(), this.baseSize.destroy(), this.displaySize.destroy(); },\n      isFullscreen: { get() { return this.fullscreen.active; } },\n      width: { get() { return this.gameSize.width; } },\n      height: { get() { return this.gameSize.height; } },\n      isPortrait: { get() { return this.orientation === c.ORIENTATION.PORTRAIT; } },\n      isLandscape: { get() { return this.orientation === c.ORIENTATION.LANDSCAPE; } },\n      isGamePortrait: { get() { return this.height > this.width; } },\n      isGameLandscape: { get() { return this.width > this.height; } },\n    }); t.exports = v;\n  }, function (t, e, i) {\n    const n = i(19); const s = i(0); const r = i(93); const o = i(3); var a = new s({\n      initialize(t, e, i, n) { void 0 === t && (t = 0), void 0 === e && (e = t), void 0 === i && (i = 0), void 0 === n && (n = null), this._width = t, this._height = e, this._parent = n, this.aspectMode = i, this.aspectRatio = e === 0 ? 1 : t / e, this.minWidth = 0, this.minHeight = 0, this.maxWidth = Number.MAX_VALUE, this.maxHeight = Number.MAX_VALUE, this.snapTo = new o(); }, setAspectMode(t) { return void 0 === t && (t = 0), this.aspectMode = t, this.setSize(this._width, this._height); }, setSnap(t, e) { return void 0 === t && (t = 0), void 0 === e && (e = t), this.snapTo.set(t, e), this.setSize(this._width, this._height); }, setParent(t) { return this._parent = t, this.setSize(this._width, this._height); }, setMin(t, e) { return void 0 === t && (t = 0), void 0 === e && (e = t), this.minWidth = n(t, 0, this.maxWidth), this.minHeight = n(e, 0, this.maxHeight), this.setSize(this._width, this._height); }, setMax(t, e) { return void 0 === t && (t = Number.MAX_VALUE), void 0 === e && (e = t), this.maxWidth = n(t, this.minWidth, Number.MAX_VALUE), this.maxHeight = n(e, this.minHeight, Number.MAX_VALUE), this.setSize(this._width, this._height); }, setSize(t, e) { switch (void 0 === t && (t = 0), void 0 === e && (e = t), this.aspectMode) { case a.NONE: this._width = this.getNewWidth(r(t, this.snapTo.x)), this._height = this.getNewHeight(r(e, this.snapTo.y)), this.aspectRatio = this._height === 0 ? 1 : this._width / this._height; break; case a.WIDTH_CONTROLS_HEIGHT: this._width = this.getNewWidth(r(t, this.snapTo.x)), this._height = this.getNewHeight(this._width * (1 / this.aspectRatio), !1); break; case a.HEIGHT_CONTROLS_WIDTH: this._height = this.getNewHeight(r(e, this.snapTo.y)), this._width = this.getNewWidth(this._height * this.aspectRatio, !1); break; case a.FIT: this.constrain(t, e, !0); break; case a.ENVELOP: this.constrain(t, e, !1); } return this; }, setAspectRatio(t) { return this.aspectRatio = t, this.setSize(this._width, this._height); }, resize(t, e) { return this._width = this.getNewWidth(r(t, this.snapTo.x)), this._height = this.getNewHeight(r(e, this.snapTo.y)), this.aspectRatio = this._height === 0 ? 1 : this._width / this._height, this; }, getNewWidth(t, e) { return void 0 === e && (e = !0), t = n(t, this.minWidth, this.maxWidth), e && this._parent && t > this._parent.width && (t = Math.max(this.minWidth, this._parent.width)), t; }, getNewHeight(t, e) { return void 0 === e && (e = !0), t = n(t, this.minHeight, this.maxHeight), e && this._parent && t > this._parent.height && (t = Math.max(this.minHeight, this._parent.height)), t; }, constrain(t, e, i) { void 0 === t && (t = 0), void 0 === e && (e = t), void 0 === i && (i = !0), t = this.getNewWidth(t), e = this.getNewHeight(e); const n = this.snapTo; const s = e === 0 ? 1 : t / e; return i && this.aspectRatio > s || !i && this.aspectRatio < s ? (e = (t = r(t, n.x)) / this.aspectRatio, n.y > 0 && (t = (e = r(e, n.y)) * this.aspectRatio)) : (i && this.aspectRatio < s || !i && this.aspectRatio > s) && (t = (e = r(e, n.y)) * this.aspectRatio, n.x > 0 && (e = (t = r(t, n.x)) * (1 / this.aspectRatio))), this._width = t, this._height = e, this; }, fitTo(t, e) { return this.constrain(t, e, !0); }, envelop(t, e) { return this.constrain(t, e, !1); }, setWidth(t) { return this.setSize(t, this._height); }, setHeight(t) { return this.setSize(this._width, t); }, toString() { return `[{ Size (width=${this._width} height=${this._height} aspectRatio=${this.aspectRatio} aspectMode=${this.aspectMode}) }]`; }, setCSS(t) { t && t.style && (t.style.width = `${this._width}px`, t.style.height = `${this._height}px`); }, copy(t) { return t.setAspectMode(this.aspectMode), t.aspectRatio = this.aspectRatio, t.setSize(this.width, this.height); }, destroy() { this._parent = null, this.snapTo = null; }, width: { get() { return this._width; }, set(t) { this.setSize(t, this._height); } }, height: { get() { return this._height; }, set(t) { this.setSize(this._width, t); } },\n    }); a.NONE = 0, a.WIDTH_CONTROLS_HEIGHT = 1, a.HEIGHT_CONTROLS_WIDTH = 2, a.FIT = 3, a.ENVELOP = 4, t.exports = a;\n  }, function (t, e, i) {\n    const n = i(0); const r = i(125); const s = i(22); const o = i(20); const l = i(6); const a = i(82); const h = i(1); const u = i(374); const c = i(180); const d = new n({\n      initialize(t, e) {\n        if (this.game = t, this.keys = {}, this.scenes = [], this._pending = [], this._start = [], this._queue = [], this._data = {}, this.isProcessing = !1, this.isBooted = !1, this.customViewports = 0, e) {\n          Array.isArray(e) || (e = [e]); for (let i = 0; i < e.length; i++) {\n            this._pending.push({\n              key: 'default', scene: e[i], autoStart: i === 0, data: {},\n            });\n          }\n        }t.events.once(o.READY, this.bootQueue, this);\n      },\n      bootQueue() { if (!this.isBooted) { for (var t = 0; t < this._pending.length; t++) { var e; var i; var n; let s = (i = this._pending[t]).key; (n = i.scene) instanceof u ? e = this.createSceneFromInstance(s, n) : typeof n === 'object' ? e = this.createSceneFromObject(s, n) : typeof n === 'function' && (e = this.createSceneFromFunction(s, n)), s = e.sys.settings.key, this.keys[s] = e, this.scenes.push(e), this._data[s] && (e.sys.settings.data = this._data[s].data, this._data[s].autoStart && (i.autoStart = !0)), (i.autoStart || e.sys.settings.active) && this._start.push(s); } for (this._pending.length = 0, this._data = {}, this.isBooted = !0, t = 0; t < this._start.length; t++)i = this._start[t], this.start(i); this._start.length = 0; } },\n      processQueue() { let t; let e; const i = this._pending.length; const n = this._queue.length; if (i !== 0 || n !== 0) { if (i) { for (t = 0; t < i; t++)e = this._pending[t], this.add(e.key, e.scene, e.autoStart, e.data); for (t = 0; t < this._start.length; t++)e = this._start[t], this.start(e); return this._start.length = 0, void (this._pending.length = 0); } for (t = 0; t < this._queue.length; t++) this[(e = this._queue[t]).op](e.keyA, e.keyB); this._queue.length = 0; } },\n      add(t, e, i, n) {\n        return void 0 === i && (i = !1), void 0 === n && (n = {}), this.isProcessing || !this.isBooted ? (this._pending.push({\n          key: t, scene: e, autoStart: i, data: n,\n        }), this.isBooted || (this._data[t] = { data: n }), null) : (t = this.getKey(t, e), e instanceof u ? s = this.createSceneFromInstance(t, e) : typeof e === 'object' ? (e.key = t, s = this.createSceneFromObject(t, e)) : typeof e === 'function' && (s = this.createSceneFromFunction(t, e)), s.sys.settings.data = n, t = s.sys.settings.key, this.keys[t] = s, this.scenes.push(s), (i || s.sys.settings.active) && (this._pending.length ? this._start.push(t) : this.start(t)), s); let s;\n      },\n      remove(t) { if (this.isProcessing) this._queue.push({ op: 'remove', keyA: t, keyB: null }); else { const e = this.getScene(t); if (!e || e.sys.isTransitioning()) return this; let i = this.scenes.indexOf(e); const n = e.sys.settings.key; i > -1 && (delete this.keys[n], this.scenes.splice(i, 1), this._start.indexOf(n) > -1 && (i = this._start.indexOf(n), this._start.splice(i, 1)), e.sys.destroy()); } return this; },\n      bootScene(t) { let e; const i = t.sys; const n = i.settings; i.sceneUpdate = h, t.init && (t.init.call(t, n.data), n.status = r.INIT, n.isTransition && i.events.emit(s.TRANSITION_INIT, n.transitionFrom, n.transitionDuration)), i.load && (e = i.load).reset(), e && t.preload ? (t.preload.call(t), e.list.size === 0 ? this.create(t) : (n.status = r.LOADING, e.once(a.COMPLETE, this.loadComplete, this), e.start())) : this.create(t); },\n      loadComplete(t) { const e = t.scene; this.game.sound && this.game.sound.onBlurPausedSounds && this.game.sound.unlock(), this.create(e); },\n      payloadComplete(t) { this.bootScene(t.scene); },\n      update(t, e) { this.processQueue(), this.isProcessing = !0; for (let i = this.scenes.length - 1; i >= 0; i--) { const n = this.scenes[i].sys; n.settings.status > r.START && n.settings.status <= r.RUNNING && n.step(t, e); } },\n      render(t) { for (let e = 0; e < this.scenes.length; e++) { const i = this.scenes[e].sys; i.settings.visible && i.settings.status >= r.LOADING && i.settings.status < r.SLEEPING && i.render(t); } this.isProcessing = !1; },\n      create(t) { const e = t.sys; const i = e.settings; t.create && (i.status = r.CREATING, t.create.call(t, i.data), i.status === r.DESTROYED) || (i.isTransition && e.events.emit(s.TRANSITION_START, i.transitionFrom, i.transitionDuration), t.update && (e.sceneUpdate = t.update), i.status = r.RUNNING, e.events.emit(s.CREATE, t)); },\n      createSceneFromFunction(t, e) { const i = new e(); if (i instanceof u) { const n = i.sys.settings.key; if (n !== '' && (t = n), this.keys.hasOwnProperty(t)) throw new Error(`Cannot add a Scene with duplicate key: ${t}`); return this.createSceneFromInstance(t, i); } return i.sys = new c(i), i.sys.settings.key = t, i.sys.init(this.game), i; },\n      createSceneFromInstance(t, e) { return e.sys.settings.key === '' && (e.sys.settings.key = t), e.sys.init(this.game), e; },\n      createSceneFromObject(t, e) { const i = new u(e); const n = i.sys.settings.key; n !== '' ? t = n : i.sys.settings.key = t, i.sys.init(this.game); for (var s, r = ['init', 'preload', 'create', 'update', 'render'], o = 0; o < r.length; o++) { const a = l(e, r[o], null); a && (i[r[o]] = a); } if (e.hasOwnProperty('extend')) for (const h in e.extend) { e.extend.hasOwnProperty(h) && (s = e.extend[h], h === 'data' && i.hasOwnProperty('data') && typeof s === 'object' ? i.data.merge(s) : h !== 'sys' && (i[h] = s)); } return i; },\n      getKey(t, e) { if (t = t || 'default', typeof e === 'function') return t; if (e instanceof u ? t = e.sys.settings.key : typeof e === 'object' && e.hasOwnProperty('key') && (t = e.key), this.keys.hasOwnProperty(t)) throw new Error(`Cannot add a Scene with duplicate key: ${t}`); return t; },\n      getScenes(t, e) { void 0 === t && (t = !0), void 0 === e && (e = !1); for (var i = [], n = this.scenes, s = 0; s < n.length; s++) { const r = n[s]; r && (!t || t && r.sys.isActive()) && i.push(r); } return e ? i.reverse() : i; },\n      getScene(t) { if (typeof t === 'string') { if (this.keys[t]) return this.keys[t]; } else for (let e = 0; e < this.scenes.length; e++) if (t === this.scenes[e]) return t; return null; },\n      isActive(t) { const e = this.getScene(t); return e ? e.sys.isActive() : null; },\n      isPaused(t) { const e = this.getScene(t); return e ? e.sys.isPaused() : null; },\n      isVisible(t) { const e = this.getScene(t); return e ? e.sys.isVisible() : null; },\n      isSleeping(t) { const e = this.getScene(t); return e ? e.sys.isSleeping() : null; },\n      pause(t, e) { const i = this.getScene(t); return i && i.sys.pause(e), this; },\n      resume(t, e) { const i = this.getScene(t); return i && i.sys.resume(e), this; },\n      sleep(t, e) { const i = this.getScene(t); return i && !i.sys.isTransitioning() && i.sys.sleep(e), this; },\n      wake(t, e) { const i = this.getScene(t); return i && i.sys.wake(e), this; },\n      run(t, e) { const i = this.getScene(t); if (!i) { for (let n = 0; n < this._pending.length; n++) if (this._pending[n].key === t) { this.queueOp('start', t, e); break; } return this; }i.sys.isSleeping() ? i.sys.wake(e) : i.sys.isPaused() ? i.sys.resume(e) : this.start(t, e); },\n      start(t, e) { if (!this.isBooted) return this._data[t] = { autoStart: !0, data: e }, this; let i; const n = this.getScene(t); if (n) { if (n.sys.isActive() || n.sys.isPaused())n.sys.shutdown(), n.sys.start(e); else if (n.sys.start(e), n.sys.load && (i = n.sys.load), i && n.sys.settings.hasOwnProperty('pack') && (i.reset(), i.addPack({ payload: n.sys.settings.pack }))) return n.sys.settings.status = r.LOADING, i.once(a.COMPLETE, this.payloadComplete, this), i.start(), this; this.bootScene(n); } return this; },\n      stop(t, e) { const i = this.getScene(t); return i && !i.sys.isTransitioning() && i.sys.shutdown(e), this; },\n      switch(t, e) { const i = this.getScene(t); const n = this.getScene(e); return i && n && i !== n && (this.sleep(t), this.isSleeping(e) ? this.wake(e) : this.start(e)), this; },\n      getAt(t) { return this.scenes[t]; },\n      getIndex(t) { const e = this.getScene(t); return this.scenes.indexOf(e); },\n      bringToTop(t) { let e; let i; return this.isProcessing ? this._queue.push({ op: 'bringToTop', keyA: t, keyB: null }) : (e = this.getIndex(t)) !== -1 && e < this.scenes.length && (i = this.getScene(t), this.scenes.splice(e, 1), this.scenes.push(i)), this; },\n      sendToBack(t) { let e; let i; return this.isProcessing ? this._queue.push({ op: 'sendToBack', keyA: t, keyB: null }) : (e = this.getIndex(t)) !== -1 && e > 0 && (i = this.getScene(t), this.scenes.splice(e, 1), this.scenes.unshift(i)), this; },\n      moveDown(t) { let e; let i; let n; let s; return this.isProcessing ? this._queue.push({ op: 'moveDown', keyA: t, keyB: null }) : (e = this.getIndex(t)) > 0 && (i = e - 1, n = this.getScene(t), s = this.getAt(i), this.scenes[e] = s, this.scenes[i] = n), this; },\n      moveUp(t) { let e; let i; let n; let s; return this.isProcessing ? this._queue.push({ op: 'moveUp', keyA: t, keyB: null }) : (e = this.getIndex(t)) < this.scenes.length - 1 && (i = e + 1, n = this.getScene(t), s = this.getAt(i), this.scenes[e] = s, this.scenes[i] = n), this; },\n      moveAbove(t, e) { return t === e || (this.isProcessing ? this._queue.push({ op: 'moveAbove', keyA: t, keyB: e }) : (i = this.getIndex(t), n = this.getIndex(e), i !== -1 && n !== -1 && (s = this.getAt(n), this.scenes.splice(n, 1), this.scenes.splice(i + 1, 0, s)))), this; let i; let n; let s; },\n      moveBelow(t, e) { return t === e || (this.isProcessing ? this._queue.push({ op: 'moveBelow', keyA: t, keyB: e }) : (i = this.getIndex(t), n = this.getIndex(e), i !== -1 && n !== -1 && (s = this.getAt(n), this.scenes.splice(n, 1), i === 0 ? this.scenes.unshift(s) : this.scenes.splice(i, 0, s)))), this; let i; let n; let s; },\n      queueOp(t, e, i) { return this._queue.push({ op: t, keyA: e, keyB: i }), this; },\n      swapPosition(t, e) { return t === e || (this.isProcessing ? this._queue.push({ op: 'swapPosition', keyA: t, keyB: e }) : (i = this.getIndex(t)) !== (n = this.getIndex(e)) && i !== -1 && n !== -1 && (s = this.getAt(i), this.scenes[i] = this.scenes[n], this.scenes[n] = s)), this; let i; let n; let s; },\n      dump() { for (var t = [], e = ['pending', 'init', 'start', 'loading', 'creating', 'running', 'paused', 'sleeping', 'shutdown', 'destroyed'], i = 0; i < this.scenes.length; i++) { const n = this.scenes[i].sys; let s = !n.settings.visible || n.settings.status !== r.RUNNING && n.settings.status !== r.PAUSED ? '[-] ' : '[*] '; s += `${n.settings.key} (${e[n.settings.status]})`, t.push(s); }console.log(t.join('\\n')); },\n      destroy() { for (let t = 0; t < this.scenes.length; t++) { this.scenes[t].sys.destroy(); } this.update = h, this.scenes = [], this._pending = [], this._start = [], this._queue = [], this.game = null; },\n    }); t.exports = d;\n  }, function (t, e, i) { const n = i(0); const s = i(180); const r = new n({ initialize(t) { this.sys = new s(this, t), this.game, this.anims, this.cache, this.registry, this.sound, this.textures, this.events, this.cameras, this.add, this.make, this.scene, this.children, this.lights, this.data, this.input, this.load, this.time, this.tweens, this.physics, this.matter, this.scale, this.plugins; }, update() {} }); t.exports = r; }, function (t, e, i) {\n    const n = i(125); const s = i(6); const r = i(126); const o = i(882); const a = {\n      create(t) {\n        return typeof t === 'string' ? t = { key: t } : void 0 === t && (t = {}), {\n          status: n.PENDING, key: s(t, 'key', ''), active: s(t, 'active', !1), visible: s(t, 'visible', !0), isBooted: !1, isTransition: !1, transitionFrom: null, transitionDuration: 0, transitionAllowInput: !0, data: {}, pack: s(t, 'pack', !1), cameras: s(t, 'cameras', null), map: s(t, 'map', r(o, s(t, 'mapAdd', {}))), physics: s(t, 'physics', {}), loader: s(t, 'loader', {}), plugins: s(t, 'plugins', !1), input: s(t, 'input', {}),\n        };\n      },\n    }; t.exports = a;\n  }, function (t, e, i) {\n    const h = i(26); const s = i(377); const n = i(0); const l = i(31); const r = i(33); const o = i(10); const u = i(121); const a = i(20); const c = i(346); const d = i(6); const f = i(379); const p = i(182); const g = new n({\n      Extends: o, initialize(t) { o.call(this), this.game = t, this.name = 'TextureManager', this.list = {}, this._tempCanvas = h.create2D(this, 1, 1), this._tempContext = this._tempCanvas.getContext('2d'), this._pending = 0, t.events.once(a.BOOT, this.boot, this); }, boot() { this._pending = 2, this.on(u.LOAD, this.updatePending, this), this.on(u.ERROR, this.updatePending, this), this.addBase64('__DEFAULT', this.game.config.defaultImage), this.addBase64('__MISSING', this.game.config.missingImage), this.game.events.once(a.DESTROY, this.destroy, this); }, updatePending() { this._pending--, this._pending === 0 && (this.off(u.LOAD), this.off(u.ERROR), this.emit(u.READY)); }, checkKey(t) { return !this.exists(t) || (console.error(`Texture key already in use: ${t}`), !1); }, remove(t) { if (typeof t === 'string') { if (!this.exists(t)) return console.warn(`No texture found matching key: ${t}`), this; t = this.get(t); } return this.list.hasOwnProperty(t.key) && (t.destroy(), this.emit(u.REMOVE, t.key)), this; }, removeKey(t) { return this.list.hasOwnProperty(t) && delete this.list[t], this; }, addBase64(e, t) { let i; let n; return this.checkKey(e) && (i = this, (n = new Image()).onerror = function () { i.emit(u.ERROR, e); }, n.onload = function () { const t = i.create(e, n); f.Image(t, 0), i.emit(u.ADD, e, t), i.emit(u.LOAD, e, t); }, n.src = t), this; }, getBase64(t, e, i, n) { void 0 === i && (i = 'image/png'), void 0 === n && (n = 0.92); let s; let r; let o = ''; const a = this.getFrame(t, e); return a && (a.source.isRenderTexture || a.source.isGLTexture) ? console.warn('Cannot getBase64 from WebGL Texture') : a && (s = a.canvasData, (r = h.create2D(this, s.width, s.height)).getContext('2d').drawImage(a.source.image, s.x, s.y, s.width, s.height, 0, 0, s.width, s.height), o = r.toDataURL(i, n), h.remove(r)), o; }, addImage(t, e, i) { let n = null; return this.checkKey(t) && (n = this.create(t, e), f.Image(n, 0), i && n.setDataSource(i), this.emit(u.ADD, t, n)), n; }, addGLTexture(t, e, i, n) { let s = null; return this.checkKey(t) && ((s = this.create(t, e, i, n)).add('__BASE', 0, 0, 0, i, n), this.emit(u.ADD, t, s)), s; }, addRenderTexture(t, e) { let i = null; return this.checkKey(t) && ((i = this.create(t, e)).add('__BASE', 0, 0, 0, e.width, e.height), this.emit(u.ADD, t, i)), i; }, generate(t, e) { if (this.checkKey(t)) { const i = h.create(this, 1, 1); return e.canvas = i, c(e), this.addCanvas(t, i); } return null; }, createCanvas(t, e, i) { if (void 0 === e && (e = 256), void 0 === i && (i = 256), this.checkKey(t)) { const n = h.create(this, e, i, r.CANVAS, !0); return this.addCanvas(t, n); } return null; }, addCanvas(t, e, i) { void 0 === i && (i = !1); let n = null; return i ? n = new s(this, t, e, e.width, e.height) : this.checkKey(t) && (n = new s(this, t, e, e.width, e.height), this.list[t] = n, this.emit(u.ADD, t, n)), n; }, addAtlas(t, e, i, n) { return Array.isArray(i.textures) || Array.isArray(i.frames) ? this.addAtlasJSONArray(t, e, i, n) : this.addAtlasJSONHash(t, e, i, n); }, addAtlasJSONArray(t, e, i, n) { let s = null; if (this.checkKey(t)) { if (s = this.create(t, e), Array.isArray(i)) for (let r = i.length === 1, o = 0; o < s.source.length; o++) { const a = r ? i[0] : i[o]; f.JSONArray(s, o, a); } else f.JSONArray(s, 0, i); n && s.setDataSource(n), this.emit(u.ADD, t, s); } return s; }, addAtlasJSONHash(t, e, i, n) { let s = null; if (this.checkKey(t)) { if (s = this.create(t, e), Array.isArray(i)) for (let r = 0; r < i.length; r++)f.JSONHash(s, r, i[r]); else f.JSONHash(s, 0, i); n && s.setDataSource(n), this.emit(u.ADD, t, s); } return s; }, addAtlasXML(t, e, i, n) { let s = null; return this.checkKey(t) && (s = this.create(t, e), f.AtlasXML(s, 0, i), n && s.setDataSource(n), this.emit(u.ADD, t, s)), s; }, addUnityAtlas(t, e, i, n) { let s = null; return this.checkKey(t) && (s = this.create(t, e), f.UnityYAML(s, 0, i), n && s.setDataSource(n), this.emit(u.ADD, t, s)), s; }, addSpriteSheet(t, e, i) { let n; let s; let r = null; return this.checkKey(t) && (n = (r = this.create(t, e)).source[0].width, s = r.source[0].height, f.SpriteSheet(r, 0, 0, 0, n, s, i), this.emit(u.ADD, t, r)), r; }, addSpriteSheetFromAtlas(t, e) { if (!this.checkKey(t)) return null; const i = d(e, 'atlas', null); const n = d(e, 'frame', null); if (i && n) { const s = this.get(i).get(n); if (s) { const r = this.create(t, s.source.image); return s.trimmed ? f.SpriteSheetFromAtlas(r, s, e) : f.SpriteSheet(r, 0, s.cutX, s.cutY, s.cutWidth, s.cutHeight, e), this.emit(u.ADD, t, r), r; } } }, create(t, e, i, n) { let s = null; return this.checkKey(t) && (s = new p(this, t, e, i, n), this.list[t] = s), s; }, exists(t) { return this.list.hasOwnProperty(t); }, get(t) { return void 0 === t && (t = '__DEFAULT'), this.list[t] ? this.list[t] : t instanceof p ? t : this.list.__MISSING; }, cloneFrame(t, e) { if (this.list[t]) return this.list[t].get(e).clone(); }, getFrame(t, e) { if (this.list[t]) return this.list[t].get(e); }, getTextureKeys() { const t = []; for (const e in this.list)e !== '__DEFAULT' && e !== '__MISSING' && t.push(e); return t; }, getPixel(t, e, i, n) { const s = this.getFrame(i, n); if (s) { t -= s.x, e -= s.y; const r = s.data.cut; if (t += r.x, e += r.y, t >= r.x && t < r.r && e >= r.y && e < r.b) { const o = this._tempContext; o.clearRect(0, 0, 1, 1), o.drawImage(s.source.image, t, e, 1, 1, 0, 0, 1, 1); const a = o.getImageData(0, 0, 1, 1); return new l(a.data[0], a.data[1], a.data[2], a.data[3]); } } return null; }, getPixelAlpha(t, e, i, n) { const s = this.getFrame(i, n); if (s) { t -= s.x, e -= s.y; const r = s.data.cut; if (t += r.x, e += r.y, t >= r.x && t < r.r && e >= r.y && e < r.b) { const o = this._tempContext; return o.clearRect(0, 0, 1, 1), o.drawImage(s.source.image, t, e, 1, 1, 0, 0, 1, 1), o.getImageData(0, 0, 1, 1).data[3]; } } return null; }, setTexture(t, e, i) { return this.list[e] && (t.texture = this.list[e], t.frame = t.texture.get(i)), t; }, renameTexture(t, e) { const i = this.get(t); return !(!i || t === e) && (i.key = e, this.list[e] = i, delete this.list[t], !0); }, each(t, e) { for (var i = [null], n = 1; n < arguments.length; n++)i.push(arguments[n]); for (const s in this.list)i[0] = this.list[s], t.apply(e, i); }, destroy() { for (const t in this.list) this.list[t].destroy(); this.list = {}, this.game = null, h.remove(this._tempCanvas); },\n    }); t.exports = g;\n  }, function (t, e, i) {\n    const n = i(0); const f = i(19); const p = i(31); const s = i(33); const r = i(120); const o = i(182); const a = new n({\n      Extends: o,\n      initialize(t, e, i, n, s) { o.call(this, t, e, i, n, s), this.add('__BASE', 0, 0, 0, n, s), this._source = this.frames.__BASE.source, this.canvas = this._source.image, this.context = this.canvas.getContext('2d'), this.width = n, this.height = s, this.imageData = this.context.getImageData(0, 0, n, s), this.data = null, this.imageData && (this.data = this.imageData.data), this.pixels = null, this.buffer, this.data && (this.imageData.data.buffer ? (this.buffer = this.imageData.data.buffer, this.pixels = new Uint32Array(this.buffer)) : window.ArrayBuffer ? (this.buffer = new ArrayBuffer(this.imageData.data.length), this.pixels = new Uint32Array(this.buffer)) : this.pixels = this.imageData.data); },\n      update() { return this.imageData = this.context.getImageData(0, 0, this.width, this.height), this.data = this.imageData.data, this.imageData.data.buffer ? (this.buffer = this.imageData.data.buffer, this.pixels = new Uint32Array(this.buffer)) : window.ArrayBuffer ? (this.buffer = new ArrayBuffer(this.imageData.data.length), this.pixels = new Uint32Array(this.buffer)) : this.pixels = this.imageData.data, this.manager.game.config.renderType === s.WEBGL && this.refresh(), this; },\n      draw(t, e, i) { return this.context.drawImage(i, t, e), this.update(); },\n      drawFrame(t, e, i, n) { void 0 === i && (i = 0), void 0 === n && (n = 0); const s = this.manager.getFrame(t, e); if (s) { const r = s.canvasData; const o = s.cutWidth; const a = s.cutHeight; const h = s.source.resolution; return this.context.drawImage(s.source.image, r.x, r.y, o, a, i, n, o / h, a / h), this.update(); } return this; },\n      setPixel(t, e, i, n, s, r) { let o; return void 0 === r && (r = 255), t = Math.abs(Math.floor(t)), e = Math.abs(Math.floor(e)), this.getIndex(t, e) > -1 && ((o = this.context.getImageData(t, e, 1, 1)).data[0] = i, o.data[1] = n, o.data[2] = s, o.data[3] = r, this.context.putImageData(o, t, e)), this; },\n      putData(t, e, i, n, s, r, o) { return void 0 === n && (n = 0), void 0 === s && (s = 0), void 0 === r && (r = t.width), void 0 === o && (o = t.height), this.context.putImageData(t, e, i, n, s, r, o), this; },\n      getData(t, e, i, n) { return t = f(Math.floor(t), 0, this.width - 1), e = f(Math.floor(e), 0, this.height - 1), i = f(i, 1, this.width - t), n = f(n, 1, this.height - e), this.context.getImageData(t, e, i, n); },\n      getPixel(t, e, i) { i = i || new p(); let n; let s; let r; let o; let a; const h = this.getIndex(t, e); return h > -1 && (s = (n = this.data)[h + 0], r = n[h + 1], o = n[h + 2], a = n[h + 3], i.setTo(s, r, o, a)), i; },\n      getPixels(t, e, i, n) {\n        void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = this.width), void 0 === n && (n = i), t = Math.abs(Math.round(t)), e = Math.abs(Math.round(e)); for (var s = f(t, 0, this.width), r = f(t + i, 0, this.width), o = f(e, 0, this.height), a = f(e + n, 0, this.height), h = new p(), l = [], u = o; u < a; u++) {\n          for (var c = [], d = s; d < r; d++) {\n            h = this.getPixel(d, u, h), c.push({\n              x: d, y: u, color: h.color, alpha: h.alphaGL,\n            });\n          } l.push(c);\n        } return l;\n      },\n      getIndex(t, e) { return t = Math.abs(Math.round(t)), e = Math.abs(Math.round(e)), t < this.width && e < this.height ? 4 * (t + e * this.width) : -1; },\n      refresh() { return this._source.update(), this; },\n      getCanvas() { return this.canvas; },\n      getContext() { return this.context; },\n      clear(t, e, i, n) { return void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = this.width), void 0 === n && (n = this.height), this.context.clearRect(t, e, i, n), this.update(); },\n      setSize(t, e) { return void 0 === e && (e = t), t === this.width && e === this.height || (this.canvas.width = t, this.canvas.height = e, this._source.width = t, this._source.height = e, this._source.isPowerOf2 = r(t, e), this.frames.__BASE.setSize(t, e, 0, 0), this.width = t, this.height = e, this.refresh()), this; },\n      destroy() { o.prototype.destroy.call(this), this._source = null, this.canvas = null, this.context = null, this.imageData = null, this.data = null, this.pixels = null, this.buffer = null; },\n    }); t.exports = a;\n  }, function (t, e, i) {\n    const n = i(26); const s = i(0); const o = i(120); const a = i(234); const r = new s({\n      initialize(t, e, i, n, s) { void 0 === s && (s = !1); const r = t.manager.game; this.renderer = r.renderer, this.texture = t, this.source = e, this.image = e, this.compressionAlgorithm = null, this.resolution = 1, this.width = i || e.naturalWidth || e.videoWidth || e.width || 0, this.height = n || e.naturalHeight || e.videoHeight || e.height || 0, this.scaleMode = a.DEFAULT, this.isCanvas = e instanceof HTMLCanvasElement, this.isVideo = window.hasOwnProperty('HTMLVideoElement') && e instanceof HTMLVideoElement, this.isRenderTexture = e.type === 'RenderTexture', this.isGLTexture = window.hasOwnProperty('WebGLTexture') && e instanceof WebGLTexture, this.isPowerOf2 = o(this.width, this.height), this.glTexture = null, this.flipY = s, this.init(r); }, init(t) { this.renderer && (this.renderer.gl ? this.isCanvas ? this.glTexture = this.renderer.createCanvasTexture(this.image, !1, this.flipY) : this.isVideo ? this.glTexture = this.renderer.createVideoTexture(this.image, !1, this.flipY) : this.isRenderTexture ? (this.image = this.source.canvas, this.glTexture = this.renderer.createTextureFromSource(null, this.width, this.height, this.scaleMode)) : this.isGLTexture ? this.glTexture = this.source : this.glTexture = this.renderer.createTextureFromSource(this.image, this.width, this.height, this.scaleMode) : this.isRenderTexture && (this.image = this.source.canvas)), t.config.antialias || this.setFilter(1); }, setFilter(t) { this.renderer.gl && this.renderer.setTextureFilter(this.glTexture, t), this.scaleMode = t; }, setFlipY(t) { return void 0 === t && (t = !0), this.flipY = t, this; }, update() { const t = this.renderer.gl; t && this.isCanvas ? this.glTexture = this.renderer.updateCanvasTexture(this.image, this.glTexture, this.flipY) : t && this.isVideo && (this.glTexture = this.renderer.updateVideoTexture(this.image, this.glTexture, this.flipY)); }, destroy() { this.glTexture && this.renderer.deleteTexture(this.glTexture), this.isCanvas && n.remove(this.image), this.renderer = null, this.texture = null, this.source = null, this.image = null, this.glTexture = null; },\n    }); t.exports = r;\n  }, function (t, e, i) {\n    t.exports = {\n      AtlasXML: i(883), Canvas: i(884), Image: i(885), JSONArray: i(886), JSONHash: i(887), SpriteSheet: i(888), SpriteSheetFromAtlas: i(889), UnityYAML: i(890),\n    };\n  }, function (t, e, i) { const n = i(381); const s = i(385); const r = i(387); const o = { create(t) { const e = t.config.audio; const i = t.device.audio; return new (e && e.noAudio || !i.webAudio && !i.audioData ? s : !i.webAudio || e && e.disableWebAudio ? n : r)(t); } }; t.exports = o; }, function (t, e, i) {\n    const n = i(127); const s = i(0); const o = i(59); const r = i(384); const a = new s({\n      Extends: n, initialize(t) { this.override = !0, this.audioPlayDelay = 0.1, this.loopEndOffset = 0.05, this.onBlurPausedSounds = [], this.locked = 'ontouchstart' in window, this.lockedActionsQueue = this.locked ? [] : null, this._mute = !1, this._volume = 1, n.call(this, t); }, add(t, e) { const i = new r(this, t, e); return this.sounds.push(i), i; }, unlock() { this.locked = !1; let e; let i; let n; const r = this; this.game.cache.audio.entries.each((t, e) => { for (let i = 0; i < e.length; i++) if (e[i].dataset.locked === 'true') return !(r.locked = !0); return !0; }), this.locked && (e = !1, i = function () { e = !0; }, n = function () { let s; let t; e ? e = !1 : (document.body.removeEventListener('touchmove', i), document.body.removeEventListener('touchend', n), s = [], r.game.cache.audio.entries.each((t, e) => { for (let i = 0; i < e.length; i++) { const n = e[i]; n.dataset.locked === 'true' && s.push(n); } return !0; }), s.length !== 0 && ((t = s[s.length - 1]).oncanplaythrough = function () { t.oncanplaythrough = null, s.forEach((t) => { t.dataset.locked = 'false'; }), r.unlocked = !0; }, s.forEach((t) => { t.load(); }))); }, this.once(o.UNLOCKED, function () { for (this.forEachActiveSound((t) => { t.currentMarker === null && t.duration === 0 && (t.duration = t.tags[0].duration), t.totalDuration = t.tags[0].duration; }); this.lockedActionsQueue.length;) { const t = this.lockedActionsQueue.shift(); t.sound[t.prop].apply ? t.sound[t.prop].apply(t.sound, t.value || []) : t.sound[t.prop] = t.value; } }, this), document.body.addEventListener('touchmove', i, !1), document.body.addEventListener('touchend', n, !1)); }, onBlur() { this.forEachActiveSound(function (t) { t.isPlaying && (this.onBlurPausedSounds.push(t), t.onBlur()); }); }, onFocus() { this.onBlurPausedSounds.forEach((t) => { t.onFocus(); }), this.onBlurPausedSounds.length = 0; }, destroy() { n.prototype.destroy.call(this), this.onBlurPausedSounds.length = 0, this.onBlurPausedSounds = null; }, isLocked(t, e, i) { return t.tags[0].dataset.locked === 'true' && (this.lockedActionsQueue.push({ sound: t, prop: e, value: i }), !0); }, setMute(t) { return this.mute = t, this; }, mute: { get() { return this._mute; }, set(t) { this._mute = t, this.forEachActiveSound((t) => { t.updateMute(); }), this.emit(o.GLOBAL_MUTE, this, t); } }, setVolume(t) { return this.volume = t, this; }, volume: { get() { return this._volume; }, set(t) { this._volume = t, this.forEachActiveSound((t) => { t.updateVolume(); }), this.emit(o.GLOBAL_VOLUME, this, t); } },\n    }); t.exports = a;\n  }, function (t, e, i) { const h = i(68); t.exports = function (t, e, i, n, s) { void 0 === n && (n = 0), void 0 === s && (s = t.length); const r = []; if (h(t, n, s)) for (let o = n; o < s; o++) { const a = t[o]; (!e || e && void 0 === i && a.hasOwnProperty(e) || e && void 0 !== i && a[e] === i) && r.push(a); } return r; }; }, function (t, e, i) { const a = i(68); t.exports = function (t, e, i, n, s) { if (void 0 === n && (n = 0), void 0 === s && (s = t.length), a(t, n, s)) for (let r = n; r < s; r++) { const o = t[r]; if (!e || e && void 0 === i && o.hasOwnProperty(e) || e && void 0 !== i && o[e] === i) return o; } return null; }; }, function (t, e, i) {\n    const n = i(128); const s = i(0); const r = i(59); const o = i(19); const a = new s({\n      Extends: n, initialize(t, e, i) { if (void 0 === i && (i = {}), this.tags = t.game.cache.audio.get(e), !this.tags) throw new Error(`There is no audio asset with key \"${e}\" in the audio cache`); this.audio = null, this.startTime = 0, this.previousTime = 0, this.duration = this.tags[0].duration, this.totalDuration = this.tags[0].duration, n.call(this, t, e, i); }, play(t, e) { return !this.manager.isLocked(this, 'play', [t, e]) && (!!n.prototype.play.call(this, t, e) && (!!this.pickAndPlayAudioTag() && (this.emit(r.PLAY, this), !0))); }, pause() { return !this.manager.isLocked(this, 'pause') && (!(this.startTime > 0) && (!!n.prototype.pause.call(this) && (this.currentConfig.seek = this.audio.currentTime - (this.currentMarker ? this.currentMarker.start : 0), this.stopAndReleaseAudioTag(), this.emit(r.PAUSE, this), !0))); }, resume() { return !this.manager.isLocked(this, 'resume') && (!(this.startTime > 0) && (!!n.prototype.resume.call(this) && (!!this.pickAndPlayAudioTag() && (this.emit(r.RESUME, this), !0)))); }, stop() { return !this.manager.isLocked(this, 'stop') && (!!n.prototype.stop.call(this) && (this.stopAndReleaseAudioTag(), this.emit(r.STOP, this), !0)); }, pickAndPlayAudioTag() { if (!this.pickAudioTag()) return this.reset(), !1; const t = this.currentConfig.seek; const e = this.currentConfig.delay; const i = (this.currentMarker ? this.currentMarker.start : 0) + t; return this.previousTime = i, this.audio.currentTime = i, this.applyConfig(), e === 0 ? (this.startTime = 0, this.audio.paused && this.playCatchPromise()) : (this.startTime = window.performance.now() + 1e3 * e, this.audio.paused || this.audio.pause()), this.resetConfig(), !0; }, pickAudioTag() { if (this.audio) return !0; for (let t = 0; t < this.tags.length; t++) { const e = this.tags[t]; if (e.dataset.used === 'false') return e.dataset.used = 'true', this.audio = e, !0; } if (!this.manager.override) return !1; const i = []; this.manager.forEachActiveSound(function (t) { t.key === this.key && t.audio && i.push(t); }, this), i.sort((t, e) => (t.loop === e.loop ? e.seek / e.duration - t.seek / t.duration : t.loop ? 1 : -1)); const n = i[0]; return this.audio = n.audio, n.reset(), n.audio = null, n.startTime = 0, !(n.previousTime = 0); }, playCatchPromise() { const t = this.audio.play(); t && t.catch((t) => { console.warn(t); }); }, stopAndReleaseAudioTag() { this.startTime = 0, this.previousTime = 0, this.audio && (this.audio.pause(), this.audio.dataset.used = 'false', this.audio = null); }, reset() { n.prototype.stop.call(this); }, onBlur() { this.isPlaying = !1, this.isPaused = !0, this.currentConfig.seek = this.audio.currentTime - (this.currentMarker ? this.currentMarker.start : 0), this.currentConfig.delay = Math.max(0, (this.startTime - window.performance.now()) / 1e3), this.stopAndReleaseAudioTag(); }, onFocus() { this.isPlaying = !0, this.isPaused = !1, this.pickAndPlayAudioTag(); }, update(t, e) { if (this.isPlaying) if (this.startTime > 0) this.startTime < t - this.manager.audioPlayDelay && (this.audio.currentTime += Math.max(0, t - this.startTime) / 1e3, this.startTime = 0, this.previousTime = this.audio.currentTime, this.playCatchPromise()); else { const i = this.currentMarker ? this.currentMarker.start : 0; const n = i + this.duration; let s = this.audio.currentTime; if (this.currentConfig.loop)s >= n - this.manager.loopEndOffset ? (this.audio.currentTime = i + Math.max(0, s - n), s = this.audio.currentTime) : s < i && (this.audio.currentTime += i, s = this.audio.currentTime), s < this.previousTime && this.emit(r.LOOPED, this); else if (n <= s) return this.reset(), this.stopAndReleaseAudioTag(), void this.emit(r.COMPLETE, this); this.previousTime = s; } }, destroy() { n.prototype.destroy.call(this), this.tags = null, this.audio && this.stopAndReleaseAudioTag(); }, updateMute() { this.audio && (this.audio.muted = this.currentConfig.mute || this.manager.mute); }, updateVolume() { this.audio && (this.audio.volume = o(this.currentConfig.volume * this.manager.volume, 0, 1)); }, calculateRate() { n.prototype.calculateRate.call(this), this.audio && (this.audio.playbackRate = this.totalRate); }, mute: { get() { return this.currentConfig.mute; }, set(t) { this.currentConfig.mute = t, this.manager.isLocked(this, 'mute', t) || (this.updateMute(), this.emit(r.MUTE, this, t)); } }, setMute(t) { return this.mute = t, this; }, volume: { get() { return this.currentConfig.volume; }, set(t) { this.currentConfig.volume = t, this.manager.isLocked(this, 'volume', t) || (this.updateVolume(), this.emit(r.VOLUME, this, t)); } }, setVolume(t) { return this.volume = t, this; }, rate: { get() { return this.currentConfig.rate; }, set(t) { this.currentConfig.rate = t, this.manager.isLocked(this, r.RATE, t) || (this.calculateRate(), this.emit(r.RATE, this, t)); } }, setRate(t) { return this.rate = t, this; }, detune: { get() { return this.currentConfig.detune; }, set(t) { this.currentConfig.detune = t, this.manager.isLocked(this, r.DETUNE, t) || (this.calculateRate(), this.emit(r.DETUNE, this, t)); } }, setDetune(t) { return this.detune = t, this; }, seek: { get() { return this.isPlaying ? this.audio.currentTime - (this.currentMarker ? this.currentMarker.start : 0) : this.isPaused ? this.currentConfig.seek : 0; }, set(t) { this.manager.isLocked(this, 'seek', t) || this.startTime > 0 || (this.isPlaying || this.isPaused) && (t = Math.min(Math.max(0, t), this.duration), this.isPlaying ? (this.previousTime = t, this.audio.currentTime = t) : this.isPaused && (this.currentConfig.seek = t), this.emit(r.SEEK, this, t)); } }, setSeek(t) { return this.seek = t, this; }, loop: { get() { return this.currentConfig.loop; }, set(t) { this.currentConfig.loop = t, this.manager.isLocked(this, 'loop', t) || (this.audio && (this.audio.loop = t), this.emit(r.LOOP, this, t)); } }, setLoop(t) { return this.loop = t, this; },\n    }); t.exports = a;\n  }, function (t, e, i) {\n    const n = i(127); const s = i(0); const r = i(10); const o = i(386); const a = i(1); const h = new s({\n      Extends: r, initialize(t) { r.call(this), this.game = t, this.sounds = [], this.mute = !1, this.volume = 1, this.rate = 1, this.detune = 0, this.pauseOnBlur = !0, this.locked = !1; }, add(t, e) { const i = new o(this, t, e); return this.sounds.push(i), i; }, addAudioSprite(t, e) { const i = this.add(t, e); return i.spritemap = {}, i; }, play(t, e) { return !1; }, playAudioSprite(t, e, i) { return !1; }, remove(t) { return n.prototype.remove.call(this, t); }, removeByKey(t) { return n.prototype.removeByKey.call(this, t); }, pauseAll: a, resumeAll: a, stopAll: a, update: a, setRate: a, setDetune: a, setMute: a, setVolume: a, forEachActiveSound(t, e) { n.prototype.forEachActiveSound.call(this, t, e); }, destroy() { n.prototype.destroy.call(this); },\n    }); t.exports = h;\n  }, function (t, e, i) {\n    function n() { return !1; } function s() { return this; } const r = i(128); const o = i(0); const a = i(10); const h = i(18); const l = new o({\n      Extends: a,\n      initialize(t, e, i) {\n        void 0 === i && (i = {}), a.call(this), this.manager = t, this.key = e, this.isPlaying = !1, this.isPaused = !1, this.totalRate = 1, this.duration = 0, this.totalDuration = 0, this.config = h({\n          mute: !1, volume: 1, rate: 1, detune: 0, seek: 0, loop: !1, delay: 0,\n        }, i), this.currentConfig = this.config, this.mute = !1, this.volume = 1, this.rate = 1, this.detune = 0, this.seek = 0, this.loop = !1, this.markers = {}, this.currentMarker = null, this.pendingRemove = !1;\n      },\n      addMarker: n,\n      updateMarker: n,\n      removeMarker() { return null; },\n      play: n,\n      pause: n,\n      resume: n,\n      stop: n,\n      destroy() { r.prototype.destroy.call(this); },\n      setMute: s,\n      setVolume: s,\n      setRate: s,\n      setDetune: s,\n      setSeek: s,\n      setLoop: s,\n    }); t.exports = l;\n  }, function (t, e, i) {\n    const c = i(388); const n = i(127); const s = i(0); const d = i(59); const r = i(389); const o = new s({\n      Extends: n, initialize(t) { this.context = this.createAudioContext(t), this.masterMuteNode = this.context.createGain(), this.masterVolumeNode = this.context.createGain(), this.masterMuteNode.connect(this.masterVolumeNode), this.masterVolumeNode.connect(this.context.destination), this.destination = this.masterMuteNode, this.locked = this.context.state === 'suspended' && ('ontouchstart' in window || 'onclick' in window), n.call(this, t), this.locked && this.unlock(); }, createAudioContext(t) { const e = t.config.audio; return e && e.context ? (e.context.resume(), e.context) : new AudioContext(); }, setAudioContext(t) { return this.context && this.context.close(), this.masterMuteNode && this.masterMuteNode.disconnect(), this.masterVolumeNode && this.masterVolumeNode.disconnect(), this.context = t, this.masterMuteNode = t.createGain(), this.masterVolumeNode = t.createGain(), this.masterMuteNode.connect(this.masterVolumeNode), this.masterVolumeNode.connect(t.destination), this.destination = this.masterMuteNode, this; }, add(t, e) { const i = new r(this, t, e); return this.sounds.push(i), i; }, decodeAudio(t, e) { for (var i = Array.isArray(t) ? t : [{ key: t, data: e }], n = this.game.cache.audio, s = i.length, r = 0; r < i.length; r++) { const o = i[r]; const a = o.key; let h = o.data; typeof h === 'string' && (h = c(h)); const l = function (t, e) { n.add(t, e), this.emit(d.DECODED, t), --s === 0 && this.emit(d.DECODED_ALL); }.bind(this, a); const u = function (t, e) { console.error(`Error decoding audio: ${t} - `, e ? e.message : ''), --s === 0 && this.emit(d.DECODED_ALL); }.bind(this, a); this.context.decodeAudioData(h, l, u); } }, unlock() { function t() { e.context && e.context.resume().then(() => { i.removeEventListener('touchstart', t), i.removeEventListener('touchend', t), i.removeEventListener('click', t), i.removeEventListener('keydown', t), e.unlocked = !0; }, () => { i.removeEventListener('touchstart', t), i.removeEventListener('touchend', t), i.removeEventListener('click', t), i.removeEventListener('keydown', t); }); } var e = this; var i = document.body; i && (i.addEventListener('touchstart', t, !1), i.addEventListener('touchend', t, !1), i.addEventListener('click', t, !1), i.addEventListener('keydown', t, !1)); }, onBlur() { this.locked || this.context.suspend(); }, onFocus() { this.locked || this.context.resume(); }, destroy() { let t; this.destination = null, this.masterVolumeNode.disconnect(), this.masterVolumeNode = null, this.masterMuteNode.disconnect(), this.masterMuteNode = null, this.game.config.audio && this.game.config.audio.context ? this.context.suspend() : (t = this).context.close().then(() => { t.context = null; }), n.prototype.destroy.call(this); }, setMute(t) { return this.mute = t, this; }, mute: { get() { return this.masterMuteNode.gain.value === 0; }, set(t) { this.masterMuteNode.gain.setValueAtTime(t ? 0 : 1, 0), this.emit(d.GLOBAL_MUTE, this, t); } }, setVolume(t) { return this.volume = t, this; }, volume: { get() { return this.masterVolumeNode.gain.value; }, set(t) { this.masterVolumeNode.gain.setValueAtTime(t, 0), this.emit(d.GLOBAL_VOLUME, this, t); } },\n    }); t.exports = o;\n  }, function (t, e) { for (var i = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/', c = new Uint8Array(256), n = 0; n < i.length; n++)c[i.charCodeAt(n)] = n; t.exports = function (t) { let e; let i; let n; let s; const r = (t = t.substr(t.indexOf(',') + 1)).length; let o = 0.75 * r; let a = 0; t[r - 1] === '=' && (o--, t[r - 2] === '=' && o--); for (var h = new ArrayBuffer(o), l = new Uint8Array(h), u = 0; u < r; u += 4)e = c[t.charCodeAt(u)], i = c[t.charCodeAt(u + 1)], n = c[t.charCodeAt(u + 2)], s = c[t.charCodeAt(u + 3)], l[a++] = e << 2 | i >> 4, l[a++] = (15 & i) << 4 | n >> 2, l[a++] = (3 & n) << 6 | 63 & s; return h; }; }, function (t, e, i) {\n    const n = i(128); const s = i(0); const r = i(59); const o = new s({\n      Extends: n, initialize(t, e, i) { if (void 0 === i && (i = {}), this.audioBuffer = t.game.cache.audio.get(e), !this.audioBuffer) throw new Error(`There is no audio asset with key \"${e}\" in the audio cache`); this.source = null, this.loopSource = null, this.muteNode = t.context.createGain(), this.volumeNode = t.context.createGain(), this.playTime = 0, this.startTime = 0, this.loopTime = 0, this.rateUpdates = [], this.hasEnded = !1, this.hasLooped = !1, this.muteNode.connect(this.volumeNode), this.volumeNode.connect(t.destination), this.duration = this.audioBuffer.duration, this.totalDuration = this.audioBuffer.duration, n.call(this, t, e, i); }, play(t, e) { return !!n.prototype.play.call(this, t, e) && (this.stopAndRemoveBufferSource(), this.createAndStartBufferSource(), this.emit(r.PLAY, this), !0); }, pause() { return !(this.manager.context.currentTime < this.startTime) && (!!n.prototype.pause.call(this) && (this.currentConfig.seek = this.getCurrentTime(), this.stopAndRemoveBufferSource(), this.emit(r.PAUSE, this), !0)); }, resume() { return !(this.manager.context.currentTime < this.startTime) && (!!n.prototype.resume.call(this) && (this.createAndStartBufferSource(), this.emit(r.RESUME, this), !0)); }, stop() { return !!n.prototype.stop.call(this) && (this.stopAndRemoveBufferSource(), this.emit(r.STOP, this), !0); }, createAndStartBufferSource() { const t = this.currentConfig.seek; const e = this.currentConfig.delay; const i = this.manager.context.currentTime + e; const n = (this.currentMarker ? this.currentMarker.start : 0) + t; const s = this.duration - t; this.playTime = i - t, this.startTime = i, this.source = this.createBufferSource(), this.applyConfig(), this.source.start(Math.max(0, i), Math.max(0, n), Math.max(0, s)), this.resetConfig(); }, createAndStartLoopBufferSource() { const t = this.getLoopTime(); const e = this.currentMarker ? this.currentMarker.start : 0; const i = this.duration; this.loopTime = t, this.loopSource = this.createBufferSource(), this.loopSource.playbackRate.setValueAtTime(this.totalRate, 0), this.loopSource.start(Math.max(0, t), Math.max(0, e), Math.max(0, i)); }, createBufferSource() { const e = this; const t = this.manager.context.createBufferSource(); return t.buffer = this.audioBuffer, t.connect(this.muteNode), t.onended = function (t) { t.target === e.source && (e.currentConfig.loop ? e.hasLooped = !0 : e.hasEnded = !0); }, t; }, stopAndRemoveBufferSource() { this.source && (this.source.stop(), this.source.disconnect(), this.source = null), this.playTime = 0, this.startTime = 0, this.stopAndRemoveLoopBufferSource(); }, stopAndRemoveLoopBufferSource() { this.loopSource && (this.loopSource.stop(), this.loopSource.disconnect(), this.loopSource = null), this.loopTime = 0; }, applyConfig() { this.rateUpdates.length = 0, this.rateUpdates.push({ time: 0, rate: 1 }), n.prototype.applyConfig.call(this); }, update(t, e) { this.hasEnded ? (this.hasEnded = !1, n.prototype.stop.call(this), this.stopAndRemoveBufferSource(), this.emit(r.COMPLETE, this)) : this.hasLooped && (this.hasLooped = !1, this.source = this.loopSource, this.loopSource = null, this.playTime = this.startTime = this.loopTime, this.rateUpdates.length = 0, this.rateUpdates.push({ time: 0, rate: this.totalRate }), this.createAndStartLoopBufferSource(), this.emit(r.LOOPED, this)); }, destroy() { n.prototype.destroy.call(this), this.audioBuffer = null, this.stopAndRemoveBufferSource(), this.muteNode.disconnect(), this.muteNode = null, this.volumeNode.disconnect(), this.volumeNode = null, this.rateUpdates.length = 0, this.rateUpdates = null; }, calculateRate() { n.prototype.calculateRate.call(this); const t = this.manager.context.currentTime; this.source && typeof this.totalRate === 'number' && this.source.playbackRate.setValueAtTime(this.totalRate, t), this.isPlaying && (this.rateUpdates.push({ time: Math.max(this.startTime, t) - this.playTime, rate: this.totalRate }), this.loopSource && (this.stopAndRemoveLoopBufferSource(), this.createAndStartLoopBufferSource())); }, getCurrentTime() { for (var t = 0, e = 0; e < this.rateUpdates.length; e++) { t += ((e < this.rateUpdates.length - 1 ? this.rateUpdates[e + 1].time : this.manager.context.currentTime - this.playTime) - this.rateUpdates[e].time) * this.rateUpdates[e].rate; } return t; }, getLoopTime() { for (var t = 0, e = 0; e < this.rateUpdates.length - 1; e++)t += (this.rateUpdates[e + 1].time - this.rateUpdates[e].time) * this.rateUpdates[e].rate; const i = this.rateUpdates[this.rateUpdates.length - 1]; return this.playTime + i.time + (this.duration - t) / i.rate; }, rate: { get() { return this.currentConfig.rate; }, set(t) { this.currentConfig.rate = t, this.calculateRate(), this.emit(r.RATE, this, t); } }, setRate(t) { return this.rate = t, this; }, detune: { get() { return this.currentConfig.detune; }, set(t) { this.currentConfig.detune = t, this.calculateRate(), this.emit(r.DETUNE, this, t); } }, setDetune(t) { return this.detune = t, this; }, mute: { get() { return this.muteNode.gain.value === 0; }, set(t) { this.currentConfig.mute = t, this.muteNode.gain.setValueAtTime(t ? 0 : 1, 0), this.emit(r.MUTE, this, t); } }, setMute(t) { return this.mute = t, this; }, volume: { get() { return this.volumeNode.gain.value; }, set(t) { this.currentConfig.volume = t, this.volumeNode.gain.setValueAtTime(t, 0), this.emit(r.VOLUME, this, t); } }, setVolume(t) { return this.volume = t, this; }, seek: { get() { return this.isPlaying ? this.manager.context.currentTime < this.startTime ? this.startTime - this.playTime : this.getCurrentTime() : this.isPaused ? this.currentConfig.seek : 0; }, set(t) { this.manager.context.currentTime < this.startTime || (this.isPlaying || this.isPaused) && (t = Math.min(Math.max(0, t), this.duration), this.currentConfig.seek = t, this.isPlaying && (this.stopAndRemoveBufferSource(), this.createAndStartBufferSource()), this.emit(r.SEEK, this, t)); } }, setSeek(t) { return this.seek = t, this; }, loop: { get() { return this.currentConfig.loop; }, set(t) { this.currentConfig.loop = t, this.isPlaying && (this.stopAndRemoveLoopBufferSource(), t && this.createAndStartLoopBufferSource()), this.emit(r.LOOP, this, t); } }, setLoop(t) { return this.loop = t, this; },\n    }); t.exports = o;\n  }, function (t, e) { t.exports = function (t) { for (var e = t.length, i = t[0].length, n = new Array(i), s = 0; s < i; s++) { n[s] = new Array(e); for (let r = e - 1; r > -1; r--)n[s][r] = t[r][s]; } return n; }; }, function (t, e) { function g(t, e, i) { const n = t[e]; t[e] = t[i], t[i] = n; } function v(t, e) { return t < e ? -1 : e < t ? 1 : 0; } var m = function (t, e, i, n, s) { for (void 0 === i && (i = 0), void 0 === n && (n = t.length - 1), void 0 === s && (s = v); i < n;) { var r; var o; var a; var h; var l; var u; var c; n - i > 600 && (r = n - i + 1, o = e - i + 1, a = Math.log(r), h = 0.5 * Math.exp(2 * a / 3), l = 0.5 * Math.sqrt(a * h * (r - h) / r) * (o - r / 2 < 0 ? -1 : 1), u = Math.max(i, Math.floor(e - o * h / r + l)), c = Math.min(n, Math.floor(e + (r - o) * h / r + l)), m(t, e, u, c, s)); const d = t[e]; let f = i; let p = n; for (g(t, i, e), s(t[n], d) > 0 && g(t, i, n); f < p;) { for (g(t, f, p), f++, p--; s(t[f], d) < 0;)f++; for (;s(t[p], d) > 0;)p--; }s(t[i], d) === 0 ? g(t, i, p) : g(t, ++p, n), p <= e && (i = p + 1), e <= p && (n = p - 1); } }; t.exports = m; }, function (t, e, i) { const f = i(6); const p = i(114); t.exports = function (t, e, i) { let n; const s = f(i, 'max', 0); const r = f(i, 'qty', 1); const o = f(i, 'random', !1); const a = f(i, 'randomB', !1); let h = f(i, 'repeat', 0); const l = f(i, 'yoyo', !1); let u = []; a && p(e), h === -1 && (h = s === 0 ? 0 : (n = t.length * e.length * r, l && (n *= 2), Math.ceil(s / n))); for (let c = 0; c <= h; c++) { const d = (function (t, e, i) { for (var n = [], s = 0; s < t.length; s++) for (let r = 0; r < e.length; r++) for (let o = 0; o < i; o++)n.push({ a: t[s], b: e[r] }); return n; }(t, e, r)); o && p(d), u = u.concat(d), l && (d.reverse(), u = u.concat(d)); } return s && u.splice(s), u; }; }, function (t, e, i) { const d = i(15); t.exports = function (t, e) { let i; let n; let s; let r; let o; let a; let h; let l; let u; const c = d(e, 'anims', null); return c === null || (typeof c === 'string' ? t.anims.play(c) : typeof c === 'object' && (i = t.anims, n = d(c, 'key', void 0), s = d(c, 'startFrame', void 0), r = d(c, 'delay', 0), o = d(c, 'repeat', 0), a = d(c, 'repeatDelay', 0), h = d(c, 'yoyo', !1), l = d(c, 'play', !1), u = d(c, 'delayedPlay', 0), i.setDelay(r), i.setRepeat(o), i.setRepeatDelay(a), i.setYoyo(h), l ? i.play(n, s) : u > 0 ? i.delayedPlay(u, n, s) : i.load(n))), t; }; }, function (t, e, i) { const a = i(11); t.exports = function (t, e, i) { void 0 === i && (i = new a()); const n = Math.min(t.x, e.x); const s = Math.min(t.y, e.y); const r = Math.max(t.right, e.right) - n; const o = Math.max(t.bottom, e.bottom) - s; return i.setTo(n, s, r, o); }; }, function (t, e, i) {\n    const n = i(0); const s = i(12); const r = i(957); const o = i(14); const a = i(7); const h = i(178); const l = i(22); const u = i(334); const c = new n({\n      Extends: o, Mixins: [s.AlphaSingle, s.BlendMode, s.Depth, s.Origin, s.ScrollFactor, s.Transform, s.Visible, r], initialize(t, e, i, n, s, r) { o.call(this, t, 'DOMElement'), this.parent = t.sys.game.domContainer, this.cache = t.sys.cache.html, this.node, this.transformOnly = !1, this.skewX = 0, this.skewY = 0, this.rotate3d = new u(), this.rotate3dAngle = 'deg', this.width = 0, this.height = 0, this.displayWidth = 0, this.displayHeight = 0, this.handler = this.dispatchNativeEvent.bind(this), this.setPosition(e, i), typeof n === 'string' ? n[0] === '#' ? this.setElement(n.substr(1), s, r) : this.createElement(n, s, r) : n && this.setElement(n, s, r), t.sys.events.on(l.SLEEP, this.handleSceneEvent, this), t.sys.events.on(l.WAKE, this.handleSceneEvent, this); }, handleSceneEvent(t) { const e = this.node; const i = e.style; e && (i.display = t.settings.visible ? 'block' : 'none'); }, setSkew(t, e) { return void 0 === t && (t = 0), void 0 === e && (e = t), this.skewX = t, this.skewY = e, this; }, setPerspective(t) { return this.parent.style.perspective = `${t}px`, this; }, perspective: { get() { return parseFloat(this.parent.style.perspective); }, set(t) { this.parent.style.perspective = `${t}px`; } }, addListener(t) { if (this.node) { t = t.split(' '); for (let e = 0; e < t.length; e++) this.node.addEventListener(t[e], this.handler, !1); } return this; }, removeListener(t) { if (this.node) { t = t.split(' '); for (let e = 0; e < t.length; e++) this.node.removeEventListener(t[e], this.handler); } return this; }, dispatchNativeEvent(t) { this.emit(t.type, t); }, createElement(t, e, i) { return this.setElement(document.createElement(t), e, i); }, setElement(t, e, i) { let n; if (this.removeElement(), typeof t === 'string' ? (t[0] === '#' && (t = t.substr(1)), n = document.getElementById(t)) : typeof t === 'object' && t.nodeType === 1 && (n = t), !n) return this; if (this.node = n, e && a(e)) for (const s in e)n.style[s] = e[s]; else typeof e === 'string' && (n.style = e); return n.style.zIndex = '0', n.style.display = 'inline', n.style.position = 'absolute', (n.phaser = this).parent && this.parent.appendChild(n), i && (n.innerText = i), this.updateSize(); }, createFromCache(t, e) { const i = this.cache.get(t); return i && this.createFromHTML(i, e), this; }, createFromHTML(t, e) { void 0 === e && (e = 'div'), this.removeElement(); const i = document.createElement(e); return (this.node = i).style.zIndex = '0', i.style.display = 'inline', i.style.position = 'absolute', (i.phaser = this).parent && this.parent.appendChild(i), i.innerHTML = t, this.updateSize(); }, removeElement() { return this.node && (h(this.node), this.node = null), this; }, updateSize() { const t = this.node; const e = t.getBoundingClientRect(); return this.width = t.clientWidth, this.height = t.clientHeight, this.displayWidth = e.width || 0, this.displayHeight = e.height || 0, this; }, getChildByProperty(t, e) { if (this.node) for (let i = this.node.querySelectorAll('*'), n = 0; n < i.length; n++) if (i[n][t] === e) return i[n]; return null; }, getChildByID(t) { return this.getChildByProperty('id', t); }, getChildByName(t) { return this.getChildByProperty('name', t); }, setClassName(t) { return this.node && (this.node.className = t, this.updateSize()), this; }, setText(t) { return this.node && (this.node.innerText = t, this.updateSize()), this; }, setHTML(t) { return this.node && (this.node.innerHTML = t, this.updateSize()), this; }, preUpdate() { const t = this.parentContainer; const e = this.node; e && t && !t.willRender() && (e.style.display = 'none'); }, willRender() { return !0; }, preDestroy() { this.removeElement(), this.scene.sys.events.off(l.SLEEP, this.handleSceneEvent, this), this.scene.sys.events.off(l.WAKE, this.handleSceneEvent, this); },\n    }); t.exports = c;\n  }, function (t, e, i) { const m = i(958); const y = i(14); t.exports = function (t, e, i, n, s) { let r; let o; let a; let h; let l; let u; let c; let d; let f; const p = e.node; const g = p.style; const v = e.scene.sys.settings; !(p && g && v.visible && y.RENDER_MASK === e.renderFlags) || e.cameraFilter !== 0 && e.cameraFilter & n.id || e.parentContainer && !e.parentContainer.willRender() ? p && (g.display = 'none') : (r = e.parentContainer, o = n.alpha * e.alpha, r && (o *= r.alpha), a = t._tempMatrix1, h = t._tempMatrix2, l = t._tempMatrix3, c = u = 0, f = d = '0%', s ? (u = e.width * e.scaleX * e.originX, c = e.height * e.scaleY * e.originY, h.applyITRS(e.x - u, e.y - c, e.rotation, e.scaleX, e.scaleY), a.copyFrom(n.matrix), a.multiplyWithOffset(s, -n.scrollX * e.scrollFactorX, -n.scrollY * e.scrollFactorY), h.e = e.x - u, h.f = e.y - c) : (u = e.width * e.originX, c = e.height * e.originY, h.applyITRS(e.x - u, e.y - c, e.rotation, e.scaleX, e.scaleY), a.copyFrom(n.matrix), d = `${100 * e.originX}%`, f = `${100 * e.originY}%`, h.e -= n.scrollX * e.scrollFactorX, h.f -= n.scrollY * e.scrollFactorY), a.multiply(h, l), e.transformOnly || (g.display = 'block', g.opacity = o, g.zIndex = e._depth, g.pointerEvents = 'auto', g.mixBlendMode = m[e._blendMode]), g.transform = `${l.getCSSMatrix()} skew(${e.skewX}rad, ${e.skewY}rad) rotate3d(${e.rotate3d.x},${e.rotate3d.y},${e.rotate3d.z},${e.rotate3d.w}${e.rotate3dAngle})`, g.transformOrigin = `${d} ${f}`); }; }, function (t, e, i) {\n    const n = i(0); const s = i(12); const r = i(14); const o = i(962); const a = new n({\n      Extends: r, Mixins: [s.Alpha, s.BlendMode, s.Depth, s.Flip, s.Origin, s.ScrollFactor, s.Size, s.Texture, s.Tint, s.Transform, s.Visible, o], initialize(t) { r.call(this, t, 'Extern'); }, preUpdate() {}, render() {},\n    }); t.exports = a;\n  }, function (t, e, i) { const s = i(193); const r = i(87); const o = i(13); const a = i(4); t.exports = function (t, e, i) { void 0 === i && (i = new a()); const n = r(e, 0, o.PI2); return s(t, n, i); }; }, function (t, e, i) { const o = i(400); const a = i(193); const h = i(87); const l = i(13); t.exports = function (t, e, i, n) { void 0 === n && (n = []), !e && i > 0 && (e = o(t) / i); for (let s = 0; s < e; s++) { const r = h(s / e, 0, l.PI2); n.push(a(t, r)); } return n; }; }, function (t, e) { t.exports = function (t) { const e = t.width / 2; const i = t.height / 2; const n = Math.pow(e - i, 2) / Math.pow(e + i, 2); return Math.PI * (e + i) * (1 + 3 * n / (10 + Math.sqrt(4 - 3 * n))); }; }, function (t, e, i) { const x = i(192); const T = i(28); t.exports = function (t, e, i, n, s, r, o) { const a = e.commandBuffer; const h = a.length; const l = r || t.currentContext; if (h !== 0 && T(t, l, e, n, s)) { let u; let c; let d; let f; let p; let g = 0; let v = 0; let m = 0; l.beginPath(); for (let y = 0; y < h; ++y) { switch (a[y]) { case x.ARC: l.arc(a[y + 1], a[y + 2], a[y + 3], a[y + 4], a[y + 5], a[y + 6]), y += 7; break; case x.LINE_STYLE: p = a[y + 1], d = a[y + 2], u = a[y + 3], g = (16711680 & d) >>> 16, v = (65280 & d) >>> 8, m = 255 & d, l.strokeStyle = `rgba(${g},${v},${m},${u})`, l.lineWidth = p, y += 3; break; case x.FILL_STYLE: f = a[y + 1], c = a[y + 2], g = (16711680 & f) >>> 16, v = (65280 & f) >>> 8, m = 255 & f, l.fillStyle = `rgba(${g},${v},${m},${c})`, y += 2; break; case x.BEGIN_PATH: l.beginPath(); break; case x.CLOSE_PATH: l.closePath(); break; case x.FILL_PATH: o || l.fill(); break; case x.STROKE_PATH: o || l.stroke(); break; case x.FILL_RECT: o ? l.rect(a[y + 1], a[y + 2], a[y + 3], a[y + 4]) : l.fillRect(a[y + 1], a[y + 2], a[y + 3], a[y + 4]), y += 4; break; case x.FILL_TRIANGLE: l.beginPath(), l.moveTo(a[y + 1], a[y + 2]), l.lineTo(a[y + 3], a[y + 4]), l.lineTo(a[y + 5], a[y + 6]), l.closePath(), o || l.fill(), y += 6; break; case x.STROKE_TRIANGLE: l.beginPath(), l.moveTo(a[y + 1], a[y + 2]), l.lineTo(a[y + 3], a[y + 4]), l.lineTo(a[y + 5], a[y + 6]), l.closePath(), o || l.stroke(), y += 6; break; case x.LINE_TO: l.lineTo(a[y + 1], a[y + 2]), y += 2; break; case x.MOVE_TO: l.moveTo(a[y + 1], a[y + 2]), y += 2; break; case x.LINE_FX_TO: l.lineTo(a[y + 1], a[y + 2]), y += 5; break; case x.MOVE_FX_TO: l.moveTo(a[y + 1], a[y + 2]), y += 5; break; case x.SAVE: l.save(); break; case x.RESTORE: l.restore(); break; case x.TRANSLATE: l.translate(a[y + 1], a[y + 2]), y += 2; break; case x.SCALE: l.scale(a[y + 1], a[y + 2]), y += 2; break; case x.ROTATE: l.rotate(a[y + 1]), y += 1; break; case x.GRADIENT_FILL_STYLE: y += 5; break; case x.GRADIENT_LINE_STYLE: y += 6; break; case x.SET_TEXTURE: y += 2; } }l.restore(); } }; }, function (t, e, i) {\n    const n = i(0); const o = i(2); const s = new n({\n      initialize(t, e, i, n, s) { let r; typeof t === 'object' ? (t = o(r = t, 'x', 0), e = o(r, 'y', 0), i = o(r, 'power', 0), n = o(r, 'epsilon', 100), s = o(r, 'gravity', 50)) : (void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === n && (n = 100), void 0 === s && (s = 50)), this.x = t, this.y = e, this.active = !0, this._gravity = s, this._power = 0, this._epsilon = 0, this.power = i, this.epsilon = n; }, update(t, e) { let i; let n; const s = this.x - t.x; const r = this.y - t.y; let o = s * s + r * r; o !== 0 && (i = Math.sqrt(o), o < this._epsilon && (o = this._epsilon), n = this._power * e / (o * i) * 100, t.velocityX += s * n, t.velocityY += r * n); }, epsilon: { get() { return Math.sqrt(this._epsilon); }, set(t) { this._epsilon = t * t; } }, power: { get() { return this._power / this._gravity; }, set(t) { this._power = t * this._gravity; } }, gravity: { get() { return this._gravity; }, set(t) { const e = this.power; this._gravity = t, this.power = e; } },\n    }); t.exports = s;\n  }, function (t, e, i) {\n    const n = i(0); const u = i(39); const c = i(53); const s = new n({\n      initialize(t) {\n        this.emitter = t, this.frame = null, this.x = 0, this.y = 0, this.velocityX = 0, this.velocityY = 0, this.accelerationX = 0, this.accelerationY = 0, this.maxVelocityX = 1e4, this.maxVelocityY = 1e4, this.bounce = 0, this.scaleX = 1, this.scaleY = 1, this.alpha = 1, this.angle = 0, this.rotation = 0, this.tint = 16777215, this.life = 1e3, this.lifeCurrent = 1e3, this.delayCurrent = 0, this.lifeT = 0, this.data = {\n          tint: { min: 16777215, max: 16777215, current: 16777215 }, alpha: { min: 1, max: 1 }, rotate: { min: 0, max: 0 }, scaleX: { min: 1, max: 1 }, scaleY: { min: 1, max: 1 },\n        };\n      },\n      isAlive() { return this.lifeCurrent > 0; },\n      resetPosition() { this.x = 0, this.y = 0; },\n      fire(t, e) { const i = this.emitter; this.frame = i.getFrame(), i.emitZone && i.emitZone.getPoint(this), void 0 === t ? (i.follow && (this.x += i.follow.x + i.followOffset.x), this.x += i.x.onEmit(this, 'x')) : this.x += t, void 0 === e ? (i.follow && (this.y += i.follow.y + i.followOffset.y), this.y += i.y.onEmit(this, 'y')) : this.y += e, this.life = i.lifespan.onEmit(this, 'lifespan'), this.lifeCurrent = this.life, this.lifeT = 0; let n; let s; let r; let o; let a; const h = i.speedX.onEmit(this, 'speedX'); const l = i.speedY ? i.speedY.onEmit(this, 'speedY') : h; i.radial ? (n = u(i.angle.onEmit(this, 'angle')), this.velocityX = Math.cos(n) * Math.abs(h), this.velocityY = Math.sin(n) * Math.abs(l)) : i.moveTo ? (s = i.moveToX.onEmit(this, 'moveToX'), r = i.moveToY ? i.moveToY.onEmit(this, 'moveToY') : s, o = Math.atan2(r - this.y, s - this.x), a = c(this.x, this.y, s, r) / (this.life / 1e3), this.velocityX = Math.cos(o) * a, this.velocityY = Math.sin(o) * a) : (this.velocityX = h, this.velocityY = l), i.acceleration && (this.accelerationX = i.accelerationX.onEmit(this, 'accelerationX'), this.accelerationY = i.accelerationY.onEmit(this, 'accelerationY')), this.maxVelocityX = i.maxVelocityX.onEmit(this, 'maxVelocityX'), this.maxVelocityY = i.maxVelocityY.onEmit(this, 'maxVelocityY'), this.delayCurrent = i.delay.onEmit(this, 'delay'), this.scaleX = i.scaleX.onEmit(this, 'scaleX'), this.scaleY = i.scaleY ? i.scaleY.onEmit(this, 'scaleY') : this.scaleX, this.angle = i.rotate.onEmit(this, 'rotate'), this.rotation = u(this.angle), this.bounce = i.bounce.onEmit(this, 'bounce'), this.alpha = i.alpha.onEmit(this, 'alpha'), this.tint = i.tint.onEmit(this, 'tint'); },\n      computeVelocity(t, e, i, n) { let s = this.velocityX; let r = this.velocityY; const o = this.accelerationX; const a = this.accelerationY; const h = this.maxVelocityX; const l = this.maxVelocityY; s += t.gravityX * i, r += t.gravityY * i, o && (s += o * i), a && (r += a * i), h < s ? s = h : s < -h && (s = -h), l < r ? r = l : r < -l && (r = -l), this.velocityX = s, this.velocityY = r; for (let u = 0; u < n.length; u++)n[u].update(this, e, i); },\n      checkBounds(t) { const e = t.bounds; const i = -this.bounce; this.x < e.x && t.collideLeft ? (this.x = e.x, this.velocityX *= i) : this.x > e.right && t.collideRight && (this.x = e.right, this.velocityX *= i), this.y < e.y && t.collideTop ? (this.y = e.y, this.velocityY *= i) : this.y > e.bottom && t.collideBottom && (this.y = e.bottom, this.velocityY *= i); },\n      update(t, e, i) { if (this.delayCurrent > 0) return this.delayCurrent -= t, !1; const n = this.emitter; const s = 1 - this.lifeCurrent / this.life; return this.lifeT = s, this.computeVelocity(n, t, e, i), this.x += this.velocityX * e, this.y += this.velocityY * e, n.bounds && this.checkBounds(n), n.deathZone && n.deathZone.willKill(this) ? !(this.lifeCurrent = 0) : (this.scaleX = n.scaleX.onUpdate(this, 'scaleX', s, this.scaleX), n.scaleY ? this.scaleY = n.scaleY.onUpdate(this, 'scaleY', s, this.scaleY) : this.scaleY = this.scaleX, this.angle = n.rotate.onUpdate(this, 'rotate', s, this.angle), this.rotation = u(this.angle), this.alpha = n.alpha.onUpdate(this, 'alpha', s, this.alpha), this.tint = n.tint.onUpdate(this, 'tint', s, this.tint), this.lifeCurrent -= t, this.lifeCurrent <= 0); },\n    }); t.exports = s;\n  }, function (t, e, i) {\n    const n = i(52); const s = i(0); const r = i(12); const o = i(405); const a = i(406); const h = i(974); const l = i(2); const u = i(185); const c = i(407); const d = i(108); const f = i(403); const p = i(408); const g = i(11); const v = i(131); const m = i(3); const y = i(58); const x = new s({\n      Mixins: [r.BlendMode, r.Mask, r.ScrollFactor, r.Visible], initialize(t, e) { this.manager = t, this.texture = t.texture, this.frames = [t.defaultFrame], this.defaultFrame = t.defaultFrame, this.configFastMap = ['active', 'blendMode', 'collideBottom', 'collideLeft', 'collideRight', 'collideTop', 'deathCallback', 'deathCallbackScope', 'emitCallback', 'emitCallbackScope', 'follow', 'frequency', 'gravityX', 'gravityY', 'maxParticles', 'name', 'on', 'particleBringToTop', 'particleClass', 'radial', 'timeScale', 'trackVisible', 'visible'], this.configOpMap = ['accelerationX', 'accelerationY', 'angle', 'alpha', 'bounce', 'delay', 'lifespan', 'maxVelocityX', 'maxVelocityY', 'moveToX', 'moveToY', 'quantity', 'rotate', 'scaleX', 'scaleY', 'speedX', 'speedY', 'tint', 'x', 'y'], this.name = '', this.particleClass = f, this.x = new h(e, 'x', 0, !0), this.y = new h(e, 'y', 0, !0), this.radial = !0, this.gravityX = 0, this.gravityY = 0, this.acceleration = !1, this.accelerationX = new h(e, 'accelerationX', 0, !0), this.accelerationY = new h(e, 'accelerationY', 0, !0), this.maxVelocityX = new h(e, 'maxVelocityX', 1e4, !0), this.maxVelocityY = new h(e, 'maxVelocityY', 1e4, !0), this.speedX = new h(e, 'speedX', 0, !0), this.speedY = new h(e, 'speedY', 0, !0), this.moveTo = !1, this.moveToX = new h(e, 'moveToX', 0, !0), this.moveToY = new h(e, 'moveToY', 0, !0), this.bounce = new h(e, 'bounce', 0, !0), this.scaleX = new h(e, 'scaleX', 1), this.scaleY = new h(e, 'scaleY', 1), this.tint = new h(e, 'tint', 4294967295), this.alpha = new h(e, 'alpha', 1), this.lifespan = new h(e, 'lifespan', 1e3, !0), this.angle = new h(e, 'angle', { min: 0, max: 360 }, !0), this.rotate = new h(e, 'rotate', 0), this.emitCallback = null, this.emitCallbackScope = null, this.deathCallback = null, this.deathCallbackScope = null, this.maxParticles = 0, this.quantity = new h(e, 'quantity', 1, !0), this.delay = new h(e, 'delay', 0, !0), this.frequency = 0, this.on = !0, this.particleBringToTop = !0, this.timeScale = 1, this.emitZone = null, this.deathZone = null, this.bounds = null, this.collideLeft = !0, this.collideRight = !0, this.collideTop = !0, this.collideBottom = !0, this.active = !0, this.visible = !0, this.blendMode = n.NORMAL, this.follow = null, this.followOffset = new m(), this.trackVisible = !1, this.currentFrame = 0, this.randomFrame = !0, this.frameQuantity = 1, this.dead = [], this.alive = [], this._counter = 0, this._frameCounter = 0, e && this.fromJSON(e); }, fromJSON(t) { if (!t) return this; for (var e, i = 0, n = '', i = 0; i < this.configFastMap.length; i++)n = this.configFastMap[i], d(t, n) && (this[n] = l(t, n)); for (i = 0; i < this.configOpMap.length; i++)n = this.configOpMap[i], d(t, n) && this[n].loadConfig(t); return this.acceleration = this.accelerationX.propertyValue !== 0 || this.accelerationY.propertyValue !== 0, this.moveTo = this.moveToX.propertyValue !== 0 || this.moveToY.propertyValue !== 0, d(t, 'speed') && (this.speedX.loadConfig(t, 'speed'), this.speedY = null), (c(t, ['speedX', 'speedY']) || this.moveTo) && (this.radial = !1), d(t, 'scale') && (this.scaleX.loadConfig(t, 'scale'), this.scaleY = null), d(t, 'callbackScope') && (e = l(t, 'callbackScope', null), this.emitCallbackScope = e, this.deathCallbackScope = e), d(t, 'emitZone') && this.setEmitZone(t.emitZone), d(t, 'deathZone') && this.setDeathZone(t.deathZone), d(t, 'bounds') && this.setBounds(t.bounds), d(t, 'followOffset') && this.followOffset.setFromObject(l(t, 'followOffset', 0)), d(t, 'frame') && this.setFrame(t.frame), this; }, toJSON(t) { void 0 === t && (t = {}); for (var e = 0, i = '', e = 0; e < this.configFastMap.length; e++)t[i = this.configFastMap[e]] = this[i]; for (e = 0; e < this.configOpMap.length; e++) this[i = this.configOpMap[e]] && (t[i] = this[i].toJSON()); return this.speedY || (delete t.speedX, t.speed = this.speedX.toJSON()), this.scaleY || (delete t.scaleX, t.scale = this.scaleX.toJSON()), t; }, startFollow(t, e, i, n) { return void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === n && (n = !1), this.follow = t, this.followOffset.set(e, i), this.trackVisible = n, this; }, stopFollow() { return this.follow = null, this.followOffset.set(0, 0), this.trackVisible = !1, this; }, getFrame() { if (this.frames.length === 1) return this.defaultFrame; if (this.randomFrame) return u(this.frames); const t = this.frames[this.currentFrame]; return this._frameCounter++, this._frameCounter === this.frameQuantity && (this._frameCounter = 0, this.currentFrame = y(this.currentFrame + 1, 0, this._frameLength)), t; }, setFrame(t, e, i) { void 0 === e && (e = !0), void 0 === i && (i = 1), this.randomFrame = e, this.frameQuantity = i, this.currentFrame = 0, this._frameCounter = 0; let n; let s; const r = typeof t; return Array.isArray(t) || r == 'string' || r == 'number' ? this.manager.setEmitterFrames(t, this) : r == 'object' && ((t = l(n = t, 'frames', null)) && this.manager.setEmitterFrames(t, this), s = l(n, 'cycle', !1), this.randomFrame = !s, this.frameQuantity = l(n, 'quantity', i)), this._frameLength = this.frames.length, this._frameLength === 1 && (this.frameQuantity = 1, this.randomFrame = !1), this; }, setRadial(t) { return void 0 === t && (t = !0), this.radial = t, this; }, setPosition(t, e) { return this.x.onChange(t), this.y.onChange(e), this; }, setBounds(t, e, i, n) { let s; return typeof t === 'object' && (t = (s = t).x, e = s.y, i = d(s, 'w') ? s.w : s.width, n = d(s, 'h') ? s.h : s.height), this.bounds ? this.bounds.setTo(t, e, i, n) : this.bounds = new g(t, e, i, n), this; }, setSpeedX(t) { return this.speedX.onChange(t), this.radial = !1, this; }, setSpeedY(t) { return this.speedY && (this.speedY.onChange(t), this.radial = !1), this; }, setSpeed(t) { return this.speedX.onChange(t), this.speedY = null, this.radial = !0, this; }, setScaleX(t) { return this.scaleX.onChange(t), this; }, setScaleY(t) { return this.scaleY.onChange(t), this; }, setScale(t) { return this.scaleX.onChange(t), this.scaleY = null, this; }, setGravityX(t) { return this.gravityX = t, this; }, setGravityY(t) { return this.gravityY = t, this; }, setGravity(t, e) { return this.gravityX = t, this.gravityY = e, this; }, setAlpha(t) { return this.alpha.onChange(t), this; }, setTint(t) { return this.tint.onChange(t), this; }, setEmitterAngle(t) { return this.angle.onChange(t), this; }, setAngle(t) { return this.angle.onChange(t), this; }, setLifespan(t) { return this.lifespan.onChange(t), this; }, setQuantity(t) { return this.quantity.onChange(t), this; }, setFrequency(t, e) { return this.frequency = t, this._counter = 0, e && this.quantity.onChange(e), this; }, setEmitZone(t) { if (void 0 === t) this.emitZone = null; else { const e = l(t, 'type', 'random'); const i = l(t, 'source', null); switch (e) { case 'random': this.emitZone = new p(i); break; case 'edge': var n = l(t, 'quantity', 1); var s = l(t, 'stepRate', 0); var r = l(t, 'yoyo', !1); var o = l(t, 'seamless', !0); this.emitZone = new a(i, n, s, r, o); } } return this; }, setDeathZone(t) { let e; let i; let n; return void 0 === t ? this.deathZone = null : (e = l(t, 'type', 'onEnter'), (i = l(t, 'source', null)) && typeof i.contains === 'function' && (n = e === 'onEnter', this.deathZone = new o(i, n))), this; }, reserve(t) { for (let e = this.dead, i = 0; i < t; i++)e.push(new this.particleClass(this)); return this; }, getAliveParticleCount() { return this.alive.length; }, getDeadParticleCount() { return this.dead.length; }, getParticleCount() { return this.getAliveParticleCount() + this.getDeadParticleCount(); }, atLimit() { return this.maxParticles > 0 && this.getParticleCount() === this.maxParticles; }, onParticleEmit(t, e) { return void 0 === t ? (this.emitCallback = null, this.emitCallbackScope = null) : typeof t === 'function' && (this.emitCallback = t, e && (this.emitCallbackScope = e)), this; }, onParticleDeath(t, e) { return void 0 === t ? (this.deathCallback = null, this.deathCallbackScope = null) : typeof t === 'function' && (this.deathCallback = t, e && (this.deathCallbackScope = e)), this; }, killAll() { for (let t = this.dead, e = this.alive; e.length > 0;)t.push(e.pop()); return this; }, forEachAlive(t, e) { for (let i = this.alive, n = i.length, s = 0; s < n; ++s)t.call(e, i[s], this); return this; }, forEachDead(t, e) { for (let i = this.dead, n = i.length, s = 0; s < n; ++s)t.call(e, i[s], this); return this; }, start() { return this.on = !0, this._counter = 0, this; }, stop() { return this.on = !1, this; }, pause() { return this.active = !1, this; }, resume() { return this.active = !0, this; }, remove() { return this.manager.removeEmitter(this), this; }, depthSort() { return v.inplace(this.alive, this.depthSortCallback), this; }, flow(t, e) { return void 0 === e && (e = 1), this.frequency = t, this.quantity.onChange(e), this.start(); }, explode(t, e, i) { return this.frequency = -1, this.emitParticle(t, e, i); }, emitParticleAt(t, e, i) { return this.emitParticle(i, t, e); }, emitParticle(t, e, i) { if (!this.atLimit()) { void 0 === t && (t = this.quantity.onEmit()); for (let n = this.dead, s = 0; s < t; s++) { var r = n.pop(); if ((r = r || new this.particleClass(this)).fire(e, i), this.particleBringToTop ? this.alive.push(r) : this.alive.unshift(r), this.emitCallback && this.emitCallback.call(this.emitCallbackScope, r, this), this.atLimit()) break; } return r; } }, preUpdate(t, e) { const i = (e *= this.timeScale) / 1e3; this.trackVisible && (this.visible = this.follow.visible); const n = this.manager.getProcessors(); const s = this.alive; const r = this.dead; var o = 0; const a = []; let h = s.length; for (o = 0; o < h; o++) { const l = s[o]; l.update(e, i, n) && a.push({ index: o, particle: l }); } if ((h = a.length) > 0) for (var u = this.deathCallback, c = this.deathCallbackScope, o = h - 1; o >= 0; o--) { const d = a[o]; s.splice(d.index, 1), r.push(d.particle), u && u.call(c, d.particle), d.particle.resetPosition(); } this.on && (this.frequency === 0 ? this.emitParticle() : this.frequency > 0 && (this._counter -= e, this._counter <= 0 && (this.emitParticle(), this._counter = this.frequency - Math.abs(this._counter)))); }, depthSortCallback(t, e) { return t.y - e.y; },\n    }); t.exports = x;\n  }, function (t, e, i) { const n = new (i(0))({ initialize(t, e) { this.source = t, this.killOnEnter = e; }, willKill(t) { const e = this.source.contains(t.x, t.y); return e && this.killOnEnter || !e && !this.killOnEnter; } }); t.exports = n; }, function (t, e, i) {\n    const n = new (i(0))({\n      initialize(t, e, i, n, s) { void 0 === n && (n = !1), void 0 === s && (s = !0), this.source = t, this.points = [], this.quantity = e, this.stepRate = i, this.yoyo = n, this.counter = -1, this.seamless = s, this._length = 0, this._direction = 0, this.updateSource(); }, updateSource() { let t; let e; this.points = this.source.getPoints(this.quantity, this.stepRate), this.seamless && (t = this.points[0], e = this.points[this.points.length - 1], t.x === e.x && t.y === e.y && this.points.pop()); const i = this._length; return this._length = this.points.length, this._length < i && this.counter > this._length && (this.counter = this._length - 1), this; }, changeSource(t) { return this.source = t, this.updateSource(); }, getPoint(t) { this._direction === 0 ? (this.counter++, this.counter >= this._length && (this.yoyo ? (this._direction = 1, this.counter = this._length - 1) : this.counter = 0)) : (this.counter--, this.counter === -1 && (this.yoyo ? (this._direction = 0, this.counter = 0) : this.counter = this._length - 1)); const e = this.points[this.counter]; e && (t.x = e.x, t.y = e.y); },\n    }); t.exports = n;\n  }, function (t, e) { t.exports = function (t, e) { for (let i = 0; i < e.length; i++) if (t.hasOwnProperty(e[i])) return !0; return !1; }; }, function (t, e, i) { const n = i(0); const s = i(3); const r = new n({ initialize(t) { this.source = t, this._tempVec = new s(); }, getPoint(t) { const e = this._tempVec; this.source.getRandomPoint(e), t.x = e.x, t.y = e.y; } }); t.exports = r; }, function (t, e, i) {\n    const n = i(0); const s = i(12); const o = i(75); const r = new n({\n      Extends: o, Mixins: [s.PathFollower], initialize(t, e, i, n, s, r) { o.call(this, t, i, n, s, r), this.path = e; }, preUpdate(t, e) { this.anims.update(t, e), this.pathUpdate(t); },\n    }); t.exports = r;\n  }, function (t, e, i) {\n    const n = i(1e3); const s = i(0); const l = i(39); const u = i(66); const c = i(65); const d = i(13); const f = i(30); const r = new s({\n      Extends: f, Mixins: [n], initialize(t, e, i, n, s, r, o, a, h) { void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === n && (n = 128), void 0 === s && (s = 0), void 0 === r && (r = 360), void 0 === o && (o = !1), f.call(this, t, 'Arc', new c(0, 0, n)), this._startAngle = s, this._endAngle = r, this._anticlockwise = o, this._iterations = 0.01, this.setPosition(e, i); const l = 2 * this.geom.radius; this.setSize(l, l), void 0 !== a && this.setFillStyle(a, h), this.updateDisplayOrigin(), this.updateData(); }, iterations: { get() { return this._iterations; }, set(t) { this._iterations = t, this.updateData(); } }, radius: { get() { return this.geom.radius; }, set(t) { const e = 2 * (this.geom.radius = t); this.setSize(e, e), this.updateDisplayOrigin(), this.updateData(); } }, startAngle: { get() { return this._startAngle; }, set(t) { this._startAngle = t, this.updateData(); } }, endAngle: { get() { return this._endAngle; }, set(t) { this._endAngle = t, this.updateData(); } }, anticlockwise: { get() { return this._anticlockwise; }, set(t) { this._anticlockwise = t, this.updateData(); } }, setRadius(t) { return this.radius = t, this; }, setIterations(t) { return void 0 === t && (t = 0.01), this.iterations = t, this; }, setStartAngle(t, e) { return this._startAngle = t, void 0 !== e && (this._anticlockwise = e), this.updateData(); }, setEndAngle(t, e) { return this._endAngle = t, void 0 !== e && (this._anticlockwise = e), this.updateData(); }, updateData() { const t = this._iterations; let e = t; const i = this.geom.radius; const n = l(this._startAngle); let s = l(this._endAngle); const r = i; const o = i; s -= n, this._anticlockwise ? s < -d.PI2 ? s = -d.PI2 : s > 0 && (s = -d.PI2 + s % d.PI2) : s > d.PI2 ? s = d.PI2 : s < 0 && (s = d.PI2 + s % d.PI2); for (var a, h = [r + Math.cos(n) * i, o + Math.sin(n) * i]; e < 1;)a = s * e + n, h.push(r + Math.cos(a) * i, o + Math.sin(a) * i), e += t; return a = s + n, h.push(r + Math.cos(a) * i, o + Math.sin(a) * i), h.push(r + Math.cos(n) * i, o + Math.sin(n) * i), this.pathIndexes = u(h), this.pathData = h, this; },\n    }); t.exports = r;\n  }, function (t, e, i) {\n    const n = i(0); const s = i(1003); const r = i(66); const o = i(11); const a = i(30); const h = new n({\n      Extends: a, Mixins: [s], initialize(t, e, i, n, s, r) { void 0 === e && (e = 0), void 0 === i && (i = 0), a.call(this, t, 'Curve', n), this._smoothness = 32, this._curveBounds = new o(), this.closePath = !1, this.setPosition(e, i), void 0 !== s && this.setFillStyle(s, r), this.updateData(); }, smoothness: { get() { return this._smoothness; }, set(t) { this._smoothness = t, this.updateData(); } }, setSmoothness(t) { return this._smoothness = t, this.updateData(); }, updateData() { const t = this._curveBounds; const e = this._smoothness; this.geom.getBounds(t, e), this.setSize(t.width, t.height), this.updateDisplayOrigin(); for (var i = [], n = this.geom.getPoints(e), s = 0; s < n.length; s++)i.push(n[s].x, n[s].y); return i.push(n[0].x, n[0].y), this.pathIndexes = r(i), this.pathData = i, this; },\n    }); t.exports = h;\n  }, function (t, e, i) {\n    const n = i(0); const s = i(66); const r = i(1006); const a = i(95); const h = i(30); const o = new n({\n      Extends: h, Mixins: [r], initialize(t, e, i, n, s, r, o) { void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === n && (n = 128), void 0 === s && (s = 128), h.call(this, t, 'Ellipse', new a(n / 2, s / 2, n, s)), this._smoothness = 64, this.setPosition(e, i), this.width = n, this.height = s, void 0 !== r && this.setFillStyle(r, o), this.updateDisplayOrigin(), this.updateData(); }, smoothness: { get() { return this._smoothness; }, set(t) { this._smoothness = t, this.updateData(); } }, setSize(t, e) { return this.geom.setSize(t, e), this.updateData(); }, setSmoothness(t) { return this._smoothness = t, this.updateData(); }, updateData() { for (var t = [], e = this.geom.getPoints(this._smoothness), i = 0; i < e.length; i++)t.push(e[i].x, e[i].y); return t.push(e[0].x, e[0].y), this.pathIndexes = s(t), this.pathData = t, this; },\n    }); t.exports = o;\n  }, function (t, e, i) {\n    const n = i(0); const c = i(30); const s = i(1009); const r = new n({\n      Extends: c, Mixins: [s], initialize(t, e, i, n, s, r, o, a, h, l, u) { void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === n && (n = 128), void 0 === s && (s = 128), void 0 === r && (r = 32), void 0 === o && (o = 32), c.call(this, t, 'Grid', null), this.cellWidth = r, this.cellHeight = o, this.showCells = !0, this.outlineFillColor = 0, this.outlineFillAlpha = 0, this.showOutline = !0, this.showAltCells = !1, this.altFillColor, this.altFillAlpha, this.setPosition(e, i), this.setSize(n, s), void 0 !== a && this.setFillStyle(a, h), void 0 !== l && this.setOutlineStyle(l, u), this.updateDisplayOrigin(); }, setFillStyle(t, e) { return void 0 === e && (e = 1), void 0 === t ? this.showCells = !1 : (this.fillColor = t, this.fillAlpha = e, this.showCells = !0), this; }, setAltFillStyle(t, e) { return void 0 === e && (e = 1), void 0 === t ? this.showAltCells = !1 : (this.altFillColor = t, this.altFillAlpha = e, this.showAltCells = !0), this; }, setOutlineStyle(t, e) { return void 0 === e && (e = 1), void 0 === t ? this.showOutline = !1 : (this.outlineFillColor = t, this.outlineFillAlpha = e, this.showOutline = !0), this; },\n    }); t.exports = r;\n  }, function (t, e, i) {\n    const n = i(1012); const s = i(0); const h = i(30); const r = new s({\n      Extends: h, Mixins: [n], initialize(t, e, i, n, s, r, o, a) { void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === n && (n = 48), void 0 === s && (s = 32), void 0 === r && (r = 15658734), void 0 === o && (o = 10066329), void 0 === a && (a = 13421772), h.call(this, t, 'IsoBox', null), this.projection = 4, this.fillTop = r, this.fillLeft = o, this.fillRight = a, this.showTop = !0, this.showLeft = !0, this.showRight = !0, this.isFilled = !0, this.setPosition(e, i), this.setSize(n, s), this.updateDisplayOrigin(); }, setProjection(t) { return this.projection = t, this; }, setFaces(t, e, i) { return void 0 === t && (t = !0), void 0 === e && (e = !0), void 0 === i && (i = !0), this.showTop = t, this.showLeft = e, this.showRight = i, this; }, setFillStyle(t, e, i) { return this.fillTop = t, this.fillLeft = e, this.fillRight = i, this.isFilled = !0, this; },\n    }); t.exports = r;\n  }, function (t, e, i) {\n    const n = i(0); const s = i(1015); const l = i(30); const r = new n({\n      Extends: l, Mixins: [s], initialize(t, e, i, n, s, r, o, a, h) { void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === n && (n = 48), void 0 === s && (s = 32), void 0 === r && (r = !1), void 0 === o && (o = 15658734), void 0 === a && (a = 10066329), void 0 === h && (h = 13421772), l.call(this, t, 'IsoTriangle', null), this.projection = 4, this.fillTop = o, this.fillLeft = a, this.fillRight = h, this.showTop = !0, this.showLeft = !0, this.showRight = !0, this.isReversed = r, this.isFilled = !0, this.setPosition(e, i), this.setSize(n, s), this.updateDisplayOrigin(); }, setProjection(t) { return this.projection = t, this; }, setReversed(t) { return this.isReversed = t, this; }, setFaces(t, e, i) { return void 0 === t && (t = !0), void 0 === e && (e = !0), void 0 === i && (i = !0), this.showTop = t, this.showLeft = e, this.showRight = i, this; }, setFillStyle(t, e, i) { return this.fillTop = t, this.fillLeft = e, this.fillRight = i, this.isFilled = !0, this; },\n    }); t.exports = r;\n  }, function (t, e, i) {\n    const n = i(0); const c = i(30); const d = i(56); const s = i(1018); const r = new n({\n      Extends: c, Mixins: [s], initialize(t, e, i, n, s, r, o, a, h) { void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === n && (n = 0), void 0 === s && (s = 0), void 0 === r && (r = 128), void 0 === o && (o = 0), c.call(this, t, 'Line', new d(n, s, r, o)); const l = this.geom.right - this.geom.left; const u = this.geom.bottom - this.geom.top; this.lineWidth = 1, this._startWidth = 1, this._endWidth = 1, this.setPosition(e, i), this.setSize(l, u), void 0 !== a && this.setStrokeStyle(1, a, h), this.updateDisplayOrigin(); }, setLineWidth(t, e) { return void 0 === e && (e = t), this._startWidth = t, this._endWidth = e, this.lineWidth = t, this; }, setTo(t, e, i, n) { return this.geom.setTo(t, e, i, n), this; },\n    }); t.exports = r;\n  }, function (t, e, i) {\n    const n = i(1021); const s = i(0); const r = i(66); const a = i(418); const h = i(201); const l = i(30); const o = i(421); const u = new s({\n      Extends: l, Mixins: [n], initialize(t, e, i, n, s, r) { void 0 === e && (e = 0), void 0 === i && (i = 0), l.call(this, t, 'Polygon', new h(n)); const o = a(this.geom); this.setPosition(e, i), this.setSize(o.width, o.height), void 0 !== s && this.setFillStyle(s, r), this.updateDisplayOrigin(), this.updateData(); }, smooth(t) { void 0 === t && (t = 1); for (let e = 0; e < t; e++)o(this.geom); return this.updateData(); }, updateData() { for (var t = [], e = this.geom.points, i = 0; i < e.length; i++)t.push(e[i].x, e[i].y); return t.push(e[0].x, e[0].y), this.pathIndexes = r(t), this.pathData = t, this; },\n    }); t.exports = u;\n  }, function (t, e, i) { const h = i(11); t.exports = function (t, e) { void 0 === e && (e = new h()); for (var i, n = 1 / 0, s = 1 / 0, r = -n, o = -s, a = 0; a < t.points.length; a++)i = t.points[a], n = Math.min(n, i.x), s = Math.min(s, i.y), r = Math.max(r, i.x), o = Math.max(o, i.y); return e.x = n, e.y = s, e.width = r - n, e.height = o - s, e; }; }, function (t, e, i) { const g = i(57); const v = i(56); const m = i(420); t.exports = function (t, e, i, n) { void 0 === n && (n = []); const s = t.points; const r = m(t); !e && i > 0 && (e = r / i); for (let o = 0; o < e; o++) for (let a = r * (o / e), h = 0, l = 0; l < s.length; l++) { const u = s[l]; const c = s[(l + 1) % s.length]; const d = new v(u.x, u.y, c.x, c.y); const f = g(d); if (!(a < h || h + f < a)) { const p = d.getPoint((a - h) / f); n.push(p); break; }h += f; } return n; }; }, function (t, e, i) { const a = i(57); const h = i(56); t.exports = function (t) { for (var e = t.points, i = 0, n = 0; n < e.length; n++) { const s = e[n]; const r = e[(n + 1) % e.length]; const o = new h(s.x, s.y, r.x, r.y); i += a(o); } return i; }; }, function (t, e) { function c(t, e) { return t[0] = e[0], t[1] = e[1], t; }t.exports = function (t) { for (var e = [], i = t.points, n = 0; n < i.length; n++)e.push([i[n].x, i[n].y]); const s = []; for (e.length > 0 && s.push(c([0, 0], e[0])), n = 0; n < e.length - 1; n++) { const r = e[n]; const o = e[n + 1]; const a = r[0]; const h = r[1]; const l = o[0]; const u = o[1]; s.push([0.85 * a + 0.15 * l, 0.85 * h + 0.15 * u]), s.push([0.15 * a + 0.85 * l, 0.15 * h + 0.85 * u]); } return e.length > 1 && s.push(c([0, 0], e[e.length - 1])), t.setTo(s); }; }, function (t, e, i) {\n    const n = i(0); const a = i(11); const h = i(30); const s = i(1024); const r = new n({\n      Extends: h, Mixins: [s], initialize(t, e, i, n, s, r, o) { void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === n && (n = 128), void 0 === s && (s = 128), h.call(this, t, 'Rectangle', new a(0, 0, n, s)), this.setPosition(e, i), this.setSize(n, s), void 0 !== r && this.setFillStyle(r, o), this.updateDisplayOrigin(), this.updateData(); }, updateData() { const t = []; const e = this.geom; const i = this._tempLine; return e.getLineA(i), t.push(i.x1, i.y1, i.x2, i.y2), e.getLineB(i), t.push(i.x2, i.y2), e.getLineC(i), t.push(i.x2, i.y2), e.getLineD(i), t.push(i.x2, i.y2), this.pathData = t, this; },\n    }); t.exports = r;\n  }, function (t, e, i) {\n    const n = i(1027); const s = i(0); const l = i(66); const h = i(30); const r = new s({\n      Extends: h, Mixins: [n], initialize(t, e, i, n, s, r, o, a) { void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === n && (n = 5), void 0 === s && (s = 32), void 0 === r && (r = 64), h.call(this, t, 'Star', null), this._points = n, this._innerRadius = s, this._outerRadius = r, this.setPosition(e, i), this.setSize(2 * r, 2 * r), void 0 !== o && this.setFillStyle(o, a), this.updateDisplayOrigin(), this.updateData(); }, setPoints(t) { return this._points = t, this.updateData(); }, setInnerRadius(t) { return this._innerRadius = t, this.updateData(); }, setOuterRadius(t) { return this._outerRadius = t, this.updateData(); }, points: { get() { return this._points; }, set(t) { this._points = t, this.updateData(); } }, innerRadius: { get() { return this._innerRadius; }, set(t) { this._innerRadius = t, this.updateData(); } }, outerRadius: { get() { return this._outerRadius; }, set(t) { this._outerRadius = t, this.updateData(); } }, updateData() { const t = []; const e = this._points; const i = this._innerRadius; const n = this._outerRadius; let s = Math.PI / 2 * 3; const r = Math.PI / e; const o = n; const a = n; t.push(o, a + -n); for (let h = 0; h < e; h++)t.push(o + Math.cos(s) * n, a + Math.sin(s) * n), s += r, t.push(o + Math.cos(s) * i, a + Math.sin(s) * i), s += r; return t.push(o, a + -n), this.pathIndexes = l(t), this.pathData = t, this; },\n    }); t.exports = r;\n  }, function (t, e, i) {\n    const n = i(0); const f = i(30); const p = i(71); const s = i(1030); const r = new n({\n      Extends: f, Mixins: [s], initialize(t, e, i, n, s, r, o, a, h, l, u) { void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === n && (n = 0), void 0 === s && (s = 128), void 0 === r && (r = 64), void 0 === o && (o = 0), void 0 === a && (a = 128), void 0 === h && (h = 128), f.call(this, t, 'Triangle', new p(n, s, r, o, a, h)); const c = this.geom.right - this.geom.left; const d = this.geom.bottom - this.geom.top; this.setPosition(e, i), this.setSize(c, d), void 0 !== l && this.setFillStyle(l, u), this.updateDisplayOrigin(), this.updateData(); }, setTo(t, e, i, n, s, r) { return this.geom.setTo(t, e, i, n, s, r), this.updateData(); }, updateData() { const t = []; const e = this.geom; const i = this._tempLine; return e.getLineA(i), t.push(i.x1, i.y1, i.x2, i.y2), e.getLineB(i), t.push(i.x2, i.y2), e.getLineC(i), t.push(i.x2, i.y2), this.pathData = t, this; },\n    }); t.exports = r;\n  }, function (t, e, i) { const c = i(4); const d = i(57); t.exports = function (t, e, i) { void 0 === i && (i = new c()); const n = t.getLineA(); const s = t.getLineB(); const r = t.getLineC(); if (e <= 0 || e >= 1) return i.x = n.x1, i.y = n.y1, i; const o = d(n); const a = d(s); const h = d(r); let l = (o + a + h) * e; let u = 0; return l < o ? (u = l / o, i.x = n.x1 + (n.x2 - n.x1) * u, i.y = n.y1 + (n.y2 - n.y1) * u) : o + a < l ? (u = (l -= o + a) / h, i.x = r.x1 + (r.x2 - r.x1) * u, i.y = r.y1 + (r.y2 - r.y1) * u) : (u = (l -= o) / a, i.x = s.x1 + (s.x2 - s.x1) * u, i.y = s.y1 + (s.y2 - s.y1) * u), i; }; }, function (t, e, i) { const g = i(57); const v = i(4); t.exports = function (t, e, i, n) { void 0 === n && (n = []); const s = t.getLineA(); const r = t.getLineB(); const o = t.getLineC(); const a = g(s); const h = g(r); const l = g(o); const u = a + h + l; !e && i > 0 && (e = u / i); for (let c = 0; c < e; c++) { let d = u * (c / e); let f = 0; const p = new v(); d < a ? (f = d / a, p.x = s.x1 + (s.x2 - s.x1) * f, p.y = s.y1 + (s.y2 - s.y1) * f) : a + h < d ? (f = (d -= a + h) / l, p.x = o.x1 + (o.x2 - o.x1) * f, p.y = o.y1 + (o.y2 - o.y1) * f) : (f = (d -= a) / h, p.x = r.x1 + (r.x2 - r.x1) * f, p.y = r.y1 + (r.y2 - r.y1) * f), n.push(p); } return n; }; }, function (t, e) { t.exports = function (t, e, i) { if (!t || typeof t === 'number') return !1; if (t.hasOwnProperty(e)) return t[e] = i, !0; if (e.indexOf('.') === -1) return !1; for (var n = e.split('.'), s = t, r = t, o = 0; o < n.length; o++) { if (!s.hasOwnProperty(n[o])) return !1; s = (r = s)[n[o]]; } return r[n[n.length - 1]] = i, !0; }; }, function (t, e, i) {\n    const n = i(0); const s = i(9); const r = new n({\n      initialize(t, e, i, n, s, r, o) { this.x = t, this.y = e, this.radius = i, this.r = n, this.g = s, this.b = r, this.intensity = o, this.scrollFactorX = 1, this.scrollFactorY = 1; }, set(t, e, i, n, s, r, o) { return this.x = t, this.y = e, this.radius = i, this.r = n, this.g = s, this.b = r, this.intensity = o, this.scrollFactorX = 1, this.scrollFactorY = 1, this; }, setScrollFactor(t, e) { return void 0 === t && (t = 1), void 0 === e && (e = t), this.scrollFactorX = t, this.scrollFactorY = e, this; }, setColor(t) { const e = s.getFloatsFromUintRGB(t); return this.r = e[0], this.g = e[1], this.b = e[2], this; }, setIntensity(t) { return this.intensity = t, this; }, setPosition(t, e) { return this.x = t, this.y = e, this; }, setRadius(t) { return this.radius = t, this; },\n    }); t.exports = r;\n  }, function (t, e, i) {\n    const n = i(0); const a = i(428); const h = i(9); const s = new n({\n      initialize() { this.lightPool = [], this.lights = [], this.culledLights = [], this.ambientColor = { r: 0.1, g: 0.1, b: 0.1 }, this.active = !1, this.maxLights = -1; }, enable() { return this.maxLights === -1 && (this.maxLights = this.scene.sys.game.renderer.config.maxLights), this.active = !0, this; }, disable() { return this.active = !1, this; }, cull(t) { for (var e = this.lights, i = this.culledLights, n = e.length, s = t.x + t.width / 2, r = t.y + t.height / 2, o = (t.width + t.height) / 2, a = { x: 0, y: 0 }, h = t.matrix, l = this.systems.game.config.height, u = i.length = 0; u < n && i.length < this.maxLights; u++) { const c = e[u]; h.transformPoint(c.x, c.y, a); const d = s - (a.x - t.scrollX * c.scrollFactorX * t.zoom); const f = r - (l - (a.y - t.scrollY * c.scrollFactorY * t.zoom)); Math.sqrt(d * d + f * f) < c.radius + o && i.push(e[u]); } return i; }, forEachLight(t) { if (t) { for (let e = this.lights, i = e.length, n = 0; n < i; ++n)t(e[n]); return this; } }, setAmbientColor(t) { const e = h.getFloatsFromUintRGB(t); return this.ambientColor.r = e[0], this.ambientColor.g = e[1], this.ambientColor.b = e[2], this; }, getMaxVisibleLights() { return 10; }, getLightCount() { return this.lights.length; }, addLight(t, e, i, n, s) { let r; let o = null; return t = void 0 === t ? 0 : t, e = void 0 === e ? 0 : e, n = void 0 === n ? 16777215 : n, i = void 0 === i ? 100 : i, s = void 0 === s ? 1 : s, r = h.getFloatsFromUintRGB(n), o = null, this.lightPool.length > 0 ? (o = this.lightPool.pop()).set(t, e, i, r[0], r[1], r[2], s) : o = new a(t, e, i, r[0], r[1], r[2], s), this.lights.push(o), o; }, removeLight(t) { const e = this.lights.indexOf(t); return e >= 0 && (this.lightPool.push(t), this.lights.splice(e, 1)), this; }, shutdown() { for (;this.lights.length > 0;) this.lightPool.push(this.lights.pop()); this.ambientColor = { r: 0.1, g: 0.1, b: 0.1 }, this.culledLights.length = 0, this.lights.length = 0; }, destroy() { this.shutdown(); },\n    }); t.exports = s;\n  }, function (t, e, i) {\n    const n = i(47); var s = i(18)(!1, s = {\n      Circle: i(1090), Ellipse: i(1100), Intersects: i(431), Line: i(1119), Point: i(1141), Polygon: i(1155), Rectangle: i(444), Triangle: i(1186),\n    }, n); t.exports = s;\n  }, function (t, e, i) {\n    t.exports = {\n      CircleToCircle: i(205), CircleToRectangle: i(206), GetCircleToCircle: i(1110), GetCircleToRectangle: i(1111), GetLineToCircle: i(207), GetLineToRectangle: i(209), GetRectangleIntersection: i(1112), GetRectangleToRectangle: i(1113), GetRectangleToTriangle: i(1114), GetTriangleToCircle: i(1115), GetTriangleToLine: i(436), GetTriangleToTriangle: i(1116), LineToCircle: i(208), LineToLine: i(84), LineToRectangle: i(432), PointToLine: i(440), PointToLineSegment: i(1117), RectangleToRectangle: i(135), RectangleToTriangle: i(433), RectangleToValues: i(1118), TriangleToCircle: i(435), TriangleToLine: i(437), TriangleToTriangle: i(438),\n    };\n  }, function (t, e) { t.exports = function (t, e) { const i = t.x1; const n = t.y1; const s = t.x2; const r = t.y2; const o = e.x; const a = e.y; const h = e.right; const l = e.bottom; let u = 0; if (o <= i && i <= h && a <= n && n <= l || o <= s && s <= h && a <= r && r <= l) return !0; if (i < o && o <= s) { if (a < (u = n + (r - n) * (o - i) / (s - i)) && u <= l) return !0; } else if (h < i && s <= h && a <= (u = n + (r - n) * (h - i) / (s - i)) && u <= l) return !0; if (n < a && a <= r) { if (o <= (u = i + (s - i) * (a - n) / (r - n)) && u <= h) return !0; } else if (l < n && r <= l && o <= (u = i + (s - i) * (l - n) / (r - n)) && u <= h) return !0; return !1; }; }, function (t, e, i) { const u = i(84); const c = i(48); const d = i(210); const f = i(434); t.exports = function (t, e) { if (e.left > t.right || e.right < t.left || e.top > t.bottom || e.bottom < t.top) return !1; const i = e.getLineA(); const n = e.getLineB(); const s = e.getLineC(); if (c(t, i.x1, i.y1) || c(t, i.x2, i.y2)) return !0; if (c(t, n.x1, n.y1) || c(t, n.x2, n.y2)) return !0; if (c(t, s.x1, s.y1) || c(t, s.x2, s.y2)) return !0; const r = t.getLineA(); const o = t.getLineB(); const a = t.getLineC(); const h = t.getLineD(); if (u(i, r) || u(i, o) || u(i, a) || u(i, h)) return !0; if (u(n, r) || u(n, o) || u(n, a) || u(n, h)) return !0; if (u(s, r) || u(s, o) || u(s, a) || u(s, h)) return !0; const l = f(t); return d(e, l, !0).length > 0; }; }, function (t, e) { t.exports = function (t, e) { return void 0 === e && (e = []), e.push({ x: t.x, y: t.y }), e.push({ x: t.right, y: t.y }), e.push({ x: t.right, y: t.bottom }), e.push({ x: t.x, y: t.bottom }), e; }; }, function (t, e, i) { const n = i(208); const s = i(83); t.exports = function (t, e) { return !(t.left > e.right || t.right < e.left || t.top > e.bottom || t.bottom < e.top) && (!!s(t, e.x, e.y) || (!!n(t.getLineA(), e) || (!!n(t.getLineB(), e) || !!n(t.getLineC(), e)))); }; }, function (t, e, i) { const l = i(4); const u = i(437); const c = i(84); t.exports = function (t, e, i) { if (void 0 === i && (i = []), u(t, e)) for (let n = t.getLineA(), s = t.getLineB(), r = t.getLineC(), o = [new l(), new l(), new l()], a = [c(n, e, o[0]), c(s, e, o[1]), c(r, e, o[2])], h = 0; h < 3; h++)a[h] && i.push(o[h]); return i; }; }, function (t, e, i) { const n = i(83); const s = i(84); t.exports = function (t, e) { return !(!n(t, e.getPointA()) && !n(t, e.getPointB())) || (!!s(t.getLineA(), e) || (!!s(t.getLineB(), e) || !!s(t.getLineC(), e))); }; }, function (t, e, i) { const u = i(210); const c = i(439); const d = i(84); t.exports = function (t, e) { if (t.left > e.right || t.right < e.left || t.top > e.bottom || t.bottom < e.top) return !1; const i = t.getLineA(); const n = t.getLineB(); const s = t.getLineC(); const r = e.getLineA(); const o = e.getLineB(); const a = e.getLineC(); if (d(i, r) || d(i, o) || d(i, a)) return !0; if (d(n, r) || d(n, o) || d(n, a)) return !0; if (d(s, r) || d(s, o) || d(s, a)) return !0; let h = c(t); const l = u(e, h, !0); return l.length > 0 || (h = c(e), u(t, h, !0).length > 0); }; }, function (t, e) { t.exports = function (t, e) { return void 0 === e && (e = []), e.push({ x: t.x1, y: t.y1 }), e.push({ x: t.x2, y: t.y2 }), e.push({ x: t.x3, y: t.y3 }), e; }; }, function (t, e) { t.exports = function (t, e, i) { void 0 === i && (i = 1); const n = e.x1; const s = e.y1; const r = e.x2; const o = e.y2; const a = t.x; const h = t.y; const l = (r - n) * (r - n) + (o - s) * (o - s); if (l == 0) return !1; const u = ((a - n) * (r - n) + (h - s) * (o - s)) / l; if (u < 0) return Math.sqrt((n - a) * (n - a) + (s - h) * (s - h)) <= i; if (u >= 0 && u <= 1) { const c = ((s - h) * (r - n) - (n - a) * (o - s)) / l; return Math.abs(c) * Math.sqrt(l) <= i; } return Math.sqrt((r - a) * (r - a) + (o - h) * (o - h)) <= i; }; }, function (t, e, i) { const n = i(13); const s = i(58); const r = i(85); t.exports = function (t) { const e = r(t) - n.TAU; return s(e, -Math.PI, Math.PI); }; }, function (t, e) { t.exports = function (t) { return Math.sqrt(t.x * t.x + t.y * t.y); }; }, function (t, e) { t.exports = function (t) { return t.x * t.x + t.y * t.y; }; }, function (t, e, i) { const n = i(11); n.Area = i(1160), n.Ceil = i(1161), n.CeilAll = i(1162), n.CenterOn = i(168), n.Clone = i(1163), n.Contains = i(48), n.ContainsPoint = i(1164), n.ContainsRect = i(445), n.CopyFrom = i(1165), n.Decompose = i(434), n.Equals = i(1166), n.FitInside = i(1167), n.FitOutside = i(1168), n.Floor = i(1169), n.FloorAll = i(1170), n.FromPoints = i(176), n.FromXY = i(1171), n.GetAspectRatio = i(212), n.GetCenter = i(1172), n.GetPoint = i(152), n.GetPoints = i(274), n.GetSize = i(1173), n.Inflate = i(1174), n.Intersection = i(1175), n.MarchingAnts = i(285), n.MergePoints = i(1176), n.MergeRect = i(1177), n.MergeXY = i(1178), n.Offset = i(1179), n.OffsetPoint = i(1180), n.Overlaps = i(1181), n.Perimeter = i(112), n.PerimeterPoint = i(1182), n.Random = i(155), n.RandomOutside = i(1183), n.SameDimensions = i(1184), n.Scale = i(1185), n.Union = i(394), t.exports = n; }, function (t, e) { t.exports = function (t, e) { return !(e.width * e.height > t.width * t.height) && (e.x > t.x && e.x < t.right && e.right > t.x && e.right < t.right && e.y > t.y && e.y < t.bottom && e.bottom > t.y && e.bottom < t.bottom); }; }, function (t, e, i) { const n = i(4); t.exports = function (t, e) { return void 0 === e && (e = new n()), e.x = (t.x1 + t.x2 + t.x3) / 3, e.y = (t.y1 + t.y2 + t.y3) / 3, e; }; }, function (t, e) { t.exports = function (t, e, i) { return t.x1 += e, t.y1 += i, t.x2 += e, t.y2 += i, t.x3 += e, t.y3 += i, t; }; }, function (t, e, i) { const d = i(4); function f(t, e, i, n) { const s = t - i; const r = e - n; const o = s * s + r * r; return Math.sqrt(o); }t.exports = function (t, e) { void 0 === e && (e = new d()); const i = t.x1; const n = t.y1; const s = t.x2; const r = t.y2; const o = t.x3; const a = t.y3; const h = f(o, a, s, r); const l = f(i, n, o, a); const u = f(s, r, i, n); const c = h + l + u; return e.x = (i * h + s * l + o * u) / c, e.y = (n * h + r * l + a * u) / c, e; }; }, function (t, e) {\n    t.exports = function (t, e, i) {\n      return {\n        gameObject: t, enabled: !0, alwaysEnabled: !1, draggable: !1, dropZone: !1, cursor: !1, target: null, camera: null, hitArea: e, hitAreaCallback: i, hitAreaDebug: null, customHitArea: !1, localX: 0, localY: 0, dragState: 0, dragStartX: 0, dragStartY: 0, dragStartXGlobal: 0, dragStartYGlobal: 0, dragX: 0, dragY: 0,\n      };\n    };\n  }, function (t, e, i) {\n    const n = new (i(0))({\n      initialize(t, e) { this.pad = t, this.events = t.events, this.index = e, this.value = 0, this.threshold = 0.1; }, update(t) { this.value = t; }, getValue() { return Math.abs(this.value) < this.threshold ? 0 : this.value; }, destroy() { this.pad = null, this.events = null; },\n    }); t.exports = n;\n  }, function (t, e, i) { const n = i(0); const s = i(214); const r = new n({ initialize(t, e) { this.pad = t, this.events = t.manager, this.index = e, this.value = 0, this.threshold = 1, this.pressed = !1; }, update(t) { this.value = t; const e = this.pad; const i = this.index; t >= this.threshold ? this.pressed || (this.pressed = !0, this.events.emit(s.BUTTON_DOWN, e, this, t), this.pad.emit(s.GAMEPAD_BUTTON_DOWN, i, t, this)) : this.pressed && (this.pressed = !1, this.events.emit(s.BUTTON_UP, e, this, t), this.pad.emit(s.GAMEPAD_BUTTON_UP, i, t, this)); }, destroy() { this.pad = null, this.events = null; } }); t.exports = r; }, function (t, e, i) {\n    const a = i(450); const h = i(451); const n = i(0); const l = i(10); const u = i(3); const s = new n({\n      Extends: l, initialize(t, e) { l.call(this), this.manager = t, this.pad = e, this.id = e.id, this.index = e.index; for (var i = [], n = 0; n < e.buttons.length; n++)i.push(new h(this, n)); this.buttons = i; for (var s = [], n = 0; n < e.axes.length; n++)s.push(new a(this, n)); this.axes = s, this.vibration = e.vibrationActuator; const r = { value: 0, pressed: !1 }; this._LCLeft = i[14] ? i[14] : r, this._LCRight = i[15] ? i[15] : r, this._LCTop = i[12] ? i[12] : r, this._LCBottom = i[13] ? i[13] : r, this._RCLeft = i[2] ? i[2] : r, this._RCRight = i[1] ? i[1] : r, this._RCTop = i[3] ? i[3] : r, this._RCBottom = i[0] ? i[0] : r, this._FBLeftTop = i[4] ? i[4] : r, this._FBLeftBottom = i[6] ? i[6] : r, this._FBRightTop = i[5] ? i[5] : r, this._FBRightBottom = i[7] ? i[7] : r; const o = { value: 0 }; this._HAxisLeft = s[0] ? s[0] : o, this._VAxisLeft = s[1] ? s[1] : o, this._HAxisRight = s[2] ? s[2] : o, this._VAxisRight = s[3] ? s[3] : o, this.leftStick = new u(), this.rightStick = new u(); }, getAxisTotal() { return this.axes.length; }, getAxisValue(t) { return this.axes[t].getValue(); }, setAxisThreshold(t) { for (let e = 0; e < this.axes.length; e++) this.axes[e].threshold = t; }, getButtonTotal() { return this.buttons.length; }, getButtonValue(t) { return this.buttons[t].value; }, isButtonDown(t) { return this.buttons[t].pressed; }, update(t) { for (var e = this.buttons, i = t.buttons, n = e.length, s = 0; s < n; s++)e[s].update(i[s].value); const r = this.axes; const o = t.axes; var n = r.length; for (s = 0; s < n; s++)r[s].update(o[s]); n >= 2 && (this.leftStick.set(r[0].getValue(), r[1].getValue()), n >= 4 && this.rightStick.set(r[2].getValue(), r[3].getValue())); }, destroy() { let t; for (this.removeAllListeners(), this.manager = null, this.pad = null, t = 0; t < this.buttons.length; t++) this.buttons[t].destroy(); for (t = 0; t < this.axes.length; t++) this.axes[t].destroy(); this.buttons = [], this.axes = []; }, connected: { get() { return this.pad.connected; } }, timestamp: { get() { return this.pad.timestamp; } }, left: { get() { return this._LCLeft.pressed; } }, right: { get() { return this._LCRight.pressed; } }, up: { get() { return this._LCTop.pressed; } }, down: { get() { return this._LCBottom.pressed; } }, A: { get() { return this._RCBottom.pressed; } }, Y: { get() { return this._RCTop.pressed; } }, X: { get() { return this._RCLeft.pressed; } }, B: { get() { return this._RCRight.pressed; } }, L1: { get() { return this._FBLeftTop.value; } }, L2: { get() { return this._FBLeftBottom.value; } }, R1: { get() { return this._FBRightTop.value; } }, R2: { get() { return this._FBRightBottom.value; } },\n    }); t.exports = s;\n  }, function (t, e, i) {\n    const n = i(0); const s = i(10); const r = i(137); const o = new n({\n      Extends: s, initialize(t, e) { s.call(this), this.plugin = t, this.keyCode = e, this.originalEvent = void 0, this.enabled = !0, this.isDown = !1, this.isUp = !0, this.altKey = !1, this.ctrlKey = !1, this.shiftKey = !1, this.metaKey = !1, this.location = 0, this.timeDown = 0, this.duration = 0, this.timeUp = 0, this.emitOnRepeat = !1, this.repeats = 0, this._justDown = !1, this._justUp = !1, this._tick = -1; }, setEmitOnRepeat(t) { return this.emitOnRepeat = t, this; }, onDown(t) { this.originalEvent = t, this.enabled && (this.altKey = t.altKey, this.ctrlKey = t.ctrlKey, this.shiftKey = t.shiftKey, this.metaKey = t.metaKey, this.location = t.location, this.repeats++, this.isDown ? this.emitOnRepeat && this.emit(r.DOWN, this, t) : (this.isDown = !0, this.isUp = !1, this.timeDown = t.timeStamp, this.duration = 0, this._justDown = !0, this._justUp = !1, this.emit(r.DOWN, this, t))); }, onUp(t) { this.originalEvent = t, this.enabled && (this.isDown = !1, this.isUp = !0, this.timeUp = t.timeStamp, this.duration = this.timeUp - this.timeDown, this.repeats = 0, this._justDown = !1, this._justUp = !0, this._tick = -1, this.emit(r.UP, this, t)); }, reset() { return this.preventDefault = !0, this.enabled = !0, this.isDown = !1, this.isUp = !0, this.altKey = !1, this.ctrlKey = !1, this.shiftKey = !1, this.metaKey = !1, this.timeDown = 0, this.duration = 0, this.timeUp = 0, this.repeats = 0, this._justDown = !1, this._justUp = !1, this._tick = -1, this; }, getDuration() { return this.isDown ? this.plugin.game.loop.time - this.timeDown : 0; }, destroy() { this.removeAllListeners(), this.originalEvent = null, this.plugin = null; },\n    }); t.exports = o;\n  }, function (t, e, i) { const n = i(0); const o = i(137); const a = i(2); const h = i(1225); const l = i(1227); const s = new n({ initialize(t, e, i) { if (void 0 === i && (i = {}), e.length < 2) return !1; this.manager = t, this.enabled = !0, this.keyCodes = []; for (let n = 0; n < e.length; n++) { const s = e[n]; typeof s === 'string' ? this.keyCodes.push(s.toUpperCase().charCodeAt(0)) : typeof s === 'number' ? this.keyCodes.push(s) : s.hasOwnProperty('keyCode') && this.keyCodes.push(s.keyCode); } this.current = this.keyCodes[0], this.index = 0, this.size = this.keyCodes.length, this.timeLastMatched = 0, this.matched = !1, this.timeMatched = 0, this.resetOnWrongKey = a(i, 'resetOnWrongKey', !0), this.maxKeyDelay = a(i, 'maxKeyDelay', 0), this.resetOnMatch = a(i, 'resetOnMatch', !1), this.deleteOnMatch = a(i, 'deleteOnMatch', !1); const r = this; this.onKeyDown = function (t) { !r.matched && r.enabled && h(t, r) && (r.manager.emit(o.COMBO_MATCH, r, t), r.resetOnMatch ? l(r) : r.deleteOnMatch && r.destroy()); }, this.manager.on(o.ANY_KEY_DOWN, this.onKeyDown); }, progress: { get() { return this.index / this.size; } }, destroy() { this.enabled = !1, this.keyCodes = [], this.manager.off(o.ANY_KEY_DOWN, this.onKeyDown), this.manager = null; } }); t.exports = s; }, function (t, e, i) { const r = i(215); t.exports = function (t, e) { const i = r(e, t.xhrSettings); const n = new XMLHttpRequest(); if (n.open('GET', t.src, i.async, i.user, i.password), n.responseType = t.xhrSettings.responseType, n.timeout = i.timeout, i.headers) for (const s in i.headers)n.setRequestHeader(s, i.headers[s]); return i.header && i.headerValue && n.setRequestHeader(i.header, i.headerValue), i.requestedWith && n.setRequestHeader('X-Requested-With', i.requestedWith), i.overrideMimeType && n.overrideMimeType(i.overrideMimeType), i.withCredentials && (n.withCredentials = !0), n.onload = t.onLoad.bind(t, n), n.onerror = t.onError.bind(t, n), n.onprogress = t.onProgress.bind(t), n.send(), n; }; }, function (t, e, i) {\n    const n = i(0); const s = i(17); const a = i(21); const r = i(8); const l = i(2); const u = i(457); const c = i(7); const d = new n({\n      Extends: a,\n      initialize(t, e, i, n, s) {\n        let r; c(e) && (e = l(r = e, 'key'), n = l(r, 'xhrSettings'), s = l(r, 'context', s)); const o = {\n          type: 'audio', cache: t.cacheManager.audio, extension: i.type, responseType: 'arraybuffer', key: e, url: i.url, xhrSettings: n, config: { context: s },\n        }; a.call(this, t, o);\n      },\n      onProcess() { this.state = s.FILE_PROCESSING; const e = this; this.config.context.decodeAudioData(this.xhrLoader.response, (t) => { e.data = t, e.onProcessComplete(); }, (t) => { console.error(`Error decoding audio: ${e.key} - `, t ? t.message : null), e.onProcessError(); }), this.config.context = null; },\n    }); d.create = function (t, e, i, n, s) { const r = t.systems.game; const o = r.config.audio; const a = r.device.audio; c(e) && (i = l(e, 'url', []), n = l(e, 'config', {})); const h = d.getAudioURL(r, i); return h ? !a.webAudio || o && o.disableWebAudio ? new u(t, e, h, n) : new d(t, e, h, s, r.sound.context) : null; }, d.getAudioURL = function (t, e) { Array.isArray(e) || (e = [e]); for (let i = 0; i < e.length; i++) { const n = l(e[i], 'url', e[i]); if (n.indexOf('blob:') === 0 || n.indexOf('data:') === 0) return { url: n, type: '' }; var s = n.match(/\\.([a-zA-Z0-9]+)($|\\?)/); var s = l(e[i], 'type', s ? s[1] : '').toLowerCase(); if (t.device.audio[s]) return { url: n, type: s }; } return null; }, r.register('audio', function (t, e, i, n) { let s; const r = this.systems.game; const o = r.config.audio; const a = r.device.audio; if (o && o.noAudio || !a.webAudio && !a.audioData) return this; if (Array.isArray(t)) for (let h = 0; h < t.length; h++)(s = d.create(this, t[h])) && this.addFile(s); else (s = d.create(this, t, e, i, n)) && this.addFile(s); return this; }), t.exports = d;\n  }, function (t, e, i) {\n    const n = i(0); const s = i(82); const o = i(21); const a = i(2); const r = i(138); const h = i(7); const l = new n({\n      Extends: o,\n      initialize(t, e, i, n) {\n        let s; h(e) && (e = a(s = e, 'key'), n = a(s, 'config', n)); const r = {\n          type: 'audio', cache: t.cacheManager.audio, extension: i.type, key: e, url: i.url, config: n,\n        }; o.call(this, t, r), this.locked = 'ontouchstart' in window, this.loaded = !1, this.filesLoaded = 0, this.filesTotal = 0;\n      },\n      onLoad() { this.loaded || (this.loaded = !0, this.loader.nextFile(this, !0)); },\n      onError() { for (let t = 0; t < this.data.length; t++) { const e = this.data[t]; e.oncanplaythrough = null, e.onerror = null; } this.loader.nextFile(this, !1); },\n      onProgress(t) { const e = t.target; e.oncanplaythrough = null, e.onerror = null, this.filesLoaded++, this.percentComplete = Math.min(this.filesLoaded / this.filesTotal, 1), this.loader.emit(s.FILE_PROGRESS, this, this.percentComplete), this.filesLoaded === this.filesTotal && this.onLoad(); },\n      load() { this.data = []; const t = this.config && this.config.instances || 1; this.filesTotal = t, this.filesLoaded = 0; for (var e = this.percentComplete = 0; e < t; e++) { var i = new Audio(); i.dataset || (i.dataset = {}), i.dataset.name = this.key + (`0${e}`).slice(-2), i.dataset.used = 'false', this.locked ? i.dataset.locked = 'true' : (i.dataset.locked = 'false', i.preload = 'auto', i.oncanplaythrough = this.onProgress.bind(this), i.onerror = this.onError.bind(this)), this.data.push(i); } for (e = 0; e < this.data.length; e++)(i = this.data[e]).src = r(this, this.loader.baseURL), this.locked || i.load(); this.locked && setTimeout(this.onLoad.bind(this)); },\n    }); t.exports = l;\n  }, function (t, e, i) {\n    const n = i(0); const s = i(17); const a = i(21); const r = i(8); const h = i(2); const l = i(7); const o = new n({\n      Extends: a,\n      initialize(t, e, i, n) {\n        let s; let r = 'js'; l(e) && (e = h(s = e, 'key'), i = h(s, 'url'), n = h(s, 'xhrSettings'), r = h(s, 'extension', r)); const o = {\n          type: 'script', cache: !1, extension: r, responseType: 'text', key: e, url: i, xhrSettings: n,\n        }; a.call(this, t, o);\n      },\n      onProcess() { this.state = s.FILE_PROCESSING, this.data = document.createElement('script'), this.data.language = 'javascript', this.data.type = 'text/javascript', this.data.defer = !1, this.data.text = this.xhrLoader.responseText, document.head.appendChild(this.data), this.onProcessComplete(); },\n    }); r.register('script', function (t, e, i) { if (Array.isArray(t)) for (let n = 0; n < t.length; n++) this.addFile(new o(this, t[n])); else this.addFile(new o(this, t, e, i)); return this; }), t.exports = o;\n  }, function (t, e, i) {\n    const n = i(0); const s = i(17); const a = i(21); const r = i(8); const h = i(2); const l = i(7); const o = new n({\n      Extends: a,\n      initialize(t, e, i, n) {\n        let s; let r = 'txt'; l(e) && (e = h(s = e, 'key'), i = h(s, 'url'), n = h(s, 'xhrSettings'), r = h(s, 'extension', r)); const o = {\n          type: 'text', cache: t.cacheManager.text, extension: r, responseType: 'text', key: e, url: i, xhrSettings: n,\n        }; a.call(this, t, o);\n      },\n      onProcess() { this.state = s.FILE_PROCESSING, this.data = this.xhrLoader.responseText, this.onProcessComplete(); },\n    }); r.register('text', function (t, e, i) { if (Array.isArray(t)) for (let n = 0; n < t.length; n++) this.addFile(new o(this, t[n])); else this.addFile(new o(this, t, e, i)); return this; }), t.exports = o;\n  }, function (t, e, i) {\n    const r = i(461); const o = i(140); const n = i(0); const a = i(50); const s = i(462); const h = i(463); const l = new n({\n      initialize(t) { this.world = t, this.scene = t.scene, this.sys = t.scene.sys; }, collider(t, e, i, n, s) { return this.world.addCollider(t, e, i, n, s); }, overlap(t, e, i, n, s) { return this.world.addOverlap(t, e, i, n, s); }, existing(t, e) { const i = e ? a.STATIC_BODY : a.DYNAMIC_BODY; return this.world.enableBody(t, i), t; }, staticImage(t, e, i, n) { const s = new r(this.scene, t, e, i, n); return this.sys.displayList.add(s), this.world.enableBody(s, a.STATIC_BODY), s; }, image(t, e, i, n) { const s = new r(this.scene, t, e, i, n); return this.sys.displayList.add(s), this.world.enableBody(s, a.DYNAMIC_BODY), s; }, staticSprite(t, e, i, n) { const s = new o(this.scene, t, e, i, n); return this.sys.displayList.add(s), this.sys.updateList.add(s), this.world.enableBody(s, a.STATIC_BODY), s; }, sprite(t, e, i, n) { const s = new o(this.scene, t, e, i, n); return this.sys.displayList.add(s), this.sys.updateList.add(s), this.world.enableBody(s, a.DYNAMIC_BODY), s; }, staticGroup(t, e) { return this.sys.updateList.add(new h(this.world, this.world.scene, t, e)); }, group(t, e) { return this.sys.updateList.add(new s(this.world, this.world.scene, t, e)); }, destroy() { this.world = null, this.scene = null, this.sys = null; },\n    }); t.exports = l;\n  }, function (t, e, i) { const n = i(0); const s = i(217); const r = i(107); const o = new n({ Extends: r, Mixins: [s.Acceleration, s.Angular, s.Bounce, s.Debug, s.Drag, s.Enable, s.Friction, s.Gravity, s.Immovable, s.Mass, s.Size, s.Velocity], initialize(t, e, i, n, s) { r.call(this, t, e, i, n, s), this.body = null; } }); t.exports = o; }, function (t, e, i) {\n    const r = i(140); const n = i(0); const o = i(50); const a = i(2); const h = i(97); const l = i(7); const s = new n({\n      Extends: h,\n      initialize(t, e, i, n) {\n        let s; i || n ? l(i) ? (n = i, i = null, n.internalCreateCallback = this.createCallbackHandler, n.internalRemoveCallback = this.removeCallbackHandler) : Array.isArray(i) && l(i[0]) ? (n = i[0], s = this, i.forEach((t) => { t.internalCreateCallback = s.createCallbackHandler, t.internalRemoveCallback = s.removeCallbackHandler; }), i = null) : n = { internalCreateCallback: this.createCallbackHandler, internalRemoveCallback: this.removeCallbackHandler } : n = { internalCreateCallback: this.createCallbackHandler, internalRemoveCallback: this.removeCallbackHandler }, this.world = t, n.classType = a(n, 'classType', r), this.physicsType = o.DYNAMIC_BODY, this.defaults = {\n          setCollideWorldBounds: a(n, 'collideWorldBounds', !1), setBoundsRectangle: a(n, 'customBoundsRectangle', null), setAccelerationX: a(n, 'accelerationX', 0), setAccelerationY: a(n, 'accelerationY', 0), setAllowDrag: a(n, 'allowDrag', !0), setAllowGravity: a(n, 'allowGravity', !0), setAllowRotation: a(n, 'allowRotation', !0), setBounceX: a(n, 'bounceX', 0), setBounceY: a(n, 'bounceY', 0), setDragX: a(n, 'dragX', 0), setDragY: a(n, 'dragY', 0), setEnable: a(n, 'enable', !0), setGravityX: a(n, 'gravityX', 0), setGravityY: a(n, 'gravityY', 0), setFrictionX: a(n, 'frictionX', 0), setFrictionY: a(n, 'frictionY', 0), setVelocityX: a(n, 'velocityX', 0), setVelocityY: a(n, 'velocityY', 0), setAngularVelocity: a(n, 'angularVelocity', 0), setAngularAcceleration: a(n, 'angularAcceleration', 0), setAngularDrag: a(n, 'angularDrag', 0), setMass: a(n, 'mass', 1), setImmovable: a(n, 'immovable', !1),\n        }, h.call(this, e, i, n), this.type = 'PhysicsGroup';\n      },\n      createCallbackHandler(t) { t.body || this.world.enableBody(t, o.DYNAMIC_BODY); const e = t.body; for (const i in this.defaults)e[i](this.defaults[i]); },\n      removeCallbackHandler(t) { t.body && this.world.disableBody(t); },\n      setVelocity(t, e, i) { void 0 === i && (i = 0); for (let n = this.getChildren(), s = 0; s < n.length; s++)n[s].body.velocity.set(t + s * i, e + s * i); return this; },\n      setVelocityX(t, e) { void 0 === e && (e = 0); for (let i = this.getChildren(), n = 0; n < i.length; n++)i[n].body.velocity.x = t + n * e; return this; },\n      setVelocityY(t, e) { void 0 === e && (e = 0); for (let i = this.getChildren(), n = 0; n < i.length; n++)i[n].body.velocity.y = t + n * e; return this; },\n    }); t.exports = s;\n  }, function (t, e, i) {\n    const s = i(140); const n = i(0); const r = i(50); const o = i(2); const a = i(97); const h = i(7); const l = new n({\n      Extends: a,\n      initialize(t, e, i, n) {\n        i || n ? h(i) ? (n = i, i = null, n.internalCreateCallback = this.createCallbackHandler, n.internalRemoveCallback = this.removeCallbackHandler, n.createMultipleCallback = this.createMultipleCallbackHandler, n.classType = o(n, 'classType', s)) : Array.isArray(i) && h(i[0]) ? (n = i, i = null, n.forEach(function (t) { t.internalCreateCallback = this.createCallbackHandler, t.internalRemoveCallback = this.removeCallbackHandler, t.createMultipleCallback = this.createMultipleCallbackHandler, t.classType = o(t, 'classType', s); })) : n = { internalCreateCallback: this.createCallbackHandler, internalRemoveCallback: this.removeCallbackHandler } : n = {\n          internalCreateCallback: this.createCallbackHandler, internalRemoveCallback: this.removeCallbackHandler, createMultipleCallback: this.createMultipleCallbackHandler, classType: s,\n        }, this.world = t, this.physicsType = r.STATIC_BODY, a.call(this, e, i, n), this.type = 'StaticPhysicsGroup';\n      },\n      createCallbackHandler(t) { t.body || this.world.enableBody(t, r.STATIC_BODY); },\n      removeCallbackHandler(t) { t.body && this.world.disableBody(t); },\n      createMultipleCallbackHandler() { this.refresh(); },\n      refresh() { for (let t = this.children.entries, e = 0; e < t.length; e++)t[e].body.reset(); return this; },\n    }); t.exports = l;\n  }, function (t, e) {\n    t.exports = function (t, e, i, n, s, r, o) {\n      void 0 === r && (r = !0), void 0 === o && (o = !1); let a; let h; let l; let u = []; let c = []; const d = t.treeMinMax; return d.minX = e, d.minY = i, d.maxX = e + n, d.maxY = i + s, o && (c = t.staticTree.search(d)), r && t.useTree ? u = t.tree.search(d) : r && (a = t.bodies, h = {\n        position: { x: e, y: i }, left: e, top: i, right: e + n, bottom: i + s, isCircle: !1,\n      }, l = t.intersects, a.iterate((t) => { l(t, h) && u.push(t); })), c.concat(u);\n    };\n  }, function (t, e, i) {\n    const v = i(318); const n = i(466); const p = i(19); const s = i(0); const o = i(467); const g = i(50); const m = i(53); const r = i(10); const y = i(218); const x = i(106); const T = i(322); const w = i(323); const b = i(468); const E = i(469); const a = i(6); const S = i(13); const h = i(186); const f = i(1284); const l = i(11); const u = i(470); const _ = i(1285); const A = i(1290); const C = i(1291); const c = i(133); const d = i(472); const M = i(471); const P = i(29); const O = i(3); const R = i(58); const L = new s({\n      Extends: r,\n      initialize(t, e) {\n        r.call(this), this.scene = t, this.bodies = new c(), this.staticBodies = new c(), this.pendingDestroy = new c(), this.colliders = new h(), this.gravity = new O(a(e, 'gravity.x', 0), a(e, 'gravity.y', 0)), this.bounds = new l(a(e, 'x', 0), a(e, 'y', 0), a(e, 'width', t.sys.scale.width), a(e, 'height', t.sys.scale.height)), this.checkCollision = {\n          up: a(e, 'checkCollision.up', !0), down: a(e, 'checkCollision.down', !0), left: a(e, 'checkCollision.left', !0), right: a(e, 'checkCollision.right', !0),\n        }, this.fps = a(e, 'fps', 60), this.fixedStep = !0, this._elapsed = 0, this._frameTime = 1 / this.fps, this._frameTimeMS = 1e3 * this._frameTime, this.stepsLastFrame = 0, this.timeScale = a(e, 'timeScale', 1), this.OVERLAP_BIAS = a(e, 'overlapBias', 4), this.TILE_BIAS = a(e, 'tileBias', 16), this.forceX = a(e, 'forceX', !1), this.isPaused = a(e, 'isPaused', !1), this._total = 0, this.drawDebug = a(e, 'debug', !1), this.debugGraphic, this.defaults = {\n          debugShowBody: a(e, 'debugShowBody', !0), debugShowStaticBody: a(e, 'debugShowStaticBody', !0), debugShowVelocity: a(e, 'debugShowVelocity', !0), bodyDebugColor: a(e, 'debugBodyColor', 16711935), staticBodyDebugColor: a(e, 'debugStaticBodyColor', 255), velocityDebugColor: a(e, 'debugVelocityColor', 65280),\n        }, this.maxEntries = a(e, 'maxEntries', 16), this.useTree = a(e, 'useTree', !0), this.tree = new u(this.maxEntries), this.staticTree = new u(this.maxEntries), this.treeMinMax = {\n          minX: 0, minY: 0, maxX: 0, maxY: 0,\n        }, this._tempMatrix = new P(), this._tempMatrix2 = new P(), this.drawDebug && this.createDebugGraphic();\n      },\n      enable(t, e) { void 0 === e && (e = g.DYNAMIC_BODY), Array.isArray(t) || (t = [t]); for (let i = 0; i < t.length; i++) { const n = t[i]; if (n.isParent) for (let s = n.getChildren(), r = 0; r < s.length; r++) { const o = s[r]; o.isParent ? this.enable(o, e) : this.enableBody(o, e); } else this.enableBody(n, e); } },\n      enableBody(t, e) { return void 0 === e && (e = g.DYNAMIC_BODY), t.body || (e === g.DYNAMIC_BODY ? t.body = new n(this, t) : e === g.STATIC_BODY && (t.body = new d(this, t))), this.add(t.body), t; },\n      add(t) { return t.physicsType === g.DYNAMIC_BODY ? this.bodies.set(t) : t.physicsType === g.STATIC_BODY && (this.staticBodies.set(t), this.staticTree.insert(t)), t.enable = !0, t; },\n      disable(t) { Array.isArray(t) || (t = [t]); for (let e = 0; e < t.length; e++) { const i = t[e]; if (i.isParent) for (let n = i.getChildren(), s = 0; s < n.length; s++) { const r = n[s]; r.isParent ? this.disable(r) : this.disableBody(r.body); } else this.disableBody(i.body); } },\n      disableBody(t) { this.remove(t), t.enable = !1; },\n      remove(t) { t.physicsType === g.DYNAMIC_BODY ? (this.tree.remove(t), this.bodies.delete(t)) : t.physicsType === g.STATIC_BODY && (this.staticBodies.delete(t), this.staticTree.remove(t)); },\n      createDebugGraphic() { const t = this.scene.sys.add.graphics({ x: 0, y: 0 }); return t.setDepth(Number.MAX_VALUE), this.debugGraphic = t, this.drawDebug = !0, t; },\n      setBounds(t, e, i, n, s, r, o, a) { return this.bounds.setTo(t, e, i, n), void 0 !== s && this.setBoundsCollision(s, r, o, a), this; },\n      setBoundsCollision(t, e, i, n) { return void 0 === t && (t = !0), void 0 === e && (e = !0), void 0 === i && (i = !0), void 0 === n && (n = !0), this.checkCollision.left = t, this.checkCollision.right = e, this.checkCollision.up = i, this.checkCollision.down = n, this; },\n      pause() { return this.isPaused = !0, this.emit(y.PAUSE), this; },\n      resume() { return this.isPaused = !1, this.emit(y.RESUME), this; },\n      addCollider(t, e, i, n, s) { void 0 === i && (i = null), void 0 === n && (n = null), void 0 === s && (s = i); const r = new o(this, !1, t, e, i, n, s); return this.colliders.add(r), r; },\n      addOverlap(t, e, i, n, s) { void 0 === i && (i = null), void 0 === n && (n = null), void 0 === s && (s = i); const r = new o(this, !0, t, e, i, n, s); return this.colliders.add(r), r; },\n      removeCollider(t) { return this.colliders.remove(t), this; },\n      setFPS(t) { return this.fps = t, this._frameTime = 1 / this.fps, this._frameTimeMS = 1e3 * this._frameTime, this; },\n      update(t, e) { if (!this.isPaused && this.bodies.size !== 0) { let i; let n = this._frameTime; const s = this._frameTimeMS * this.timeScale; this._elapsed += e; const r = this.bodies.entries; let o = this._elapsed >= s; for (this.fixedStep || (n = 0.001 * e, o = !0, this._elapsed = 0), h = 0; h < r.length; h++)(i = r[h]).enable && i.preUpdate(o, n); if (o) { this._elapsed -= s, this.stepsLastFrame = 1, this.useTree && (this.tree.clear(), this.tree.load(r)); for (var a = this.colliders.update(), h = 0; h < a.length; h++) { const l = a[h]; l.active && l.update(); } this.emit(y.WORLD_STEP); } for (;this._elapsed >= s;) this._elapsed -= s, this.step(n); } },\n      step(t) { for (var e, i = this.bodies.entries, n = i.length, s = 0; s < n; s++)(e = i[s]).enable && e.update(t); this.useTree && (this.tree.clear(), this.tree.load(i)); const r = this.colliders.update(); for (s = 0; s < r.length; s++) { const o = r[s]; o.active && o.update(); } this.emit(y.WORLD_STEP), this.stepsLastFrame++; },\n      postUpdate() { let t; var e = (o = this.bodies.entries).length; const i = this.bodies; const n = this.staticBodies; if (this.stepsLastFrame) for (l = this.stepsLastFrame = 0; l < e; l++)(t = o[l]).enable && t.postUpdate(); if (this.drawDebug) { const s = this.debugGraphic; for (s.clear(), l = 0; l < e; l++)(t = o[l]).willDrawDebug() && t.drawDebug(s); for (e = (o = n.entries).length, l = 0; l < e; l++)(t = o[l]).willDrawDebug() && t.drawDebug(s); } const r = this.pendingDestroy; if (r.size > 0) { for (var o, a = this.tree, h = this.staticTree, e = (o = r.entries).length, l = 0; l < e; l++)(t = o[l]).physicsType === g.DYNAMIC_BODY ? (a.remove(t), i.delete(t)) : t.physicsType === g.STATIC_BODY && (h.remove(t), n.delete(t)), t.world = void 0, t.gameObject = void 0; r.clear(); } },\n      updateMotion(t, e) { t.allowRotation && this.computeAngularVelocity(t, e), this.computeVelocity(t, e); },\n      computeAngularVelocity(t, e) { let i = t.angularVelocity; const n = t.angularAcceleration; let s = t.angularDrag; const r = t.maxAngular; n ? i += n * e : t.allowDrag && s && (T(i - (s *= e), 0, 0.1) ? i -= s : w(i + s, 0, 0.1) ? i += s : i = 0); const o = (i = p(i, -r, r)) - t.angularVelocity; t.angularVelocity += o, t.rotation += t.angularVelocity * e; },\n      computeVelocity(t, e) { let i = t.velocity.x; const n = t.acceleration.x; let s = t.drag.x; const r = t.maxVelocity.x; let o = t.velocity.y; const a = t.acceleration.y; let h = t.drag.y; const l = t.maxVelocity.y; let u = t.speed; const c = t.maxSpeed; const d = t.allowDrag; const f = t.useDamping; t.allowGravity && (i += (this.gravity.x + t.gravity.x) * e, o += (this.gravity.y + t.gravity.y) * e), n ? i += n * e : d && s && (f ? (i *= s, u = Math.sqrt(i * i + o * o), x(u, 0, 0.001) && (i = 0)) : T(i - (s *= e), 0, 0.01) ? i -= s : w(i + s, 0, 0.01) ? i += s : i = 0), a ? o += a * e : d && h && (f ? (o *= h, u = Math.sqrt(i * i + o * o), x(u, 0, 0.001) && (o = 0)) : T(o - (h *= e), 0, 0.01) ? o -= h : w(o + h, 0, 0.01) ? o += h : o = 0), i = p(i, -r, r), o = p(o, -l, l), t.velocity.set(i, o), c > -1 && c < u && (t.velocity.normalize().scale(c), u = c), t.speed = u; },\n      separate(t, e, i, n, s, r) { if (!r && !t.enable || !e.enable || t.checkCollision.none || e.checkCollision.none || !this.intersects(t, e)) return !1; if (i && !1 === i.call(n, t.gameObject, e.gameObject)) return !1; if (t.isCircle && e.isCircle) return this.separateCircle(t, e, s); if (t.isCircle !== e.isCircle) { const o = t.isCircle ? e : t; const a = t.isCircle ? t : e; const h = o.x; const l = o.y; const u = o.right; const c = o.bottom; const d = a.center; if ((d.y < l || d.y > c) && (d.x < h || d.x > u)) return this.separateCircle(t, e, s); } let f = !1; let p = !1; s ? (f = A(t, e, s, this.OVERLAP_BIAS), p = C(t, e, s, this.OVERLAP_BIAS)) : this.forceX || Math.abs(this.gravity.y + t.gravity.y) < Math.abs(this.gravity.x + t.gravity.x) ? (f = A(t, e, s, this.OVERLAP_BIAS), this.intersects(t, e) && (p = C(t, e, s, this.OVERLAP_BIAS))) : (p = C(t, e, s, this.OVERLAP_BIAS), this.intersects(t, e) && (f = A(t, e, s, this.OVERLAP_BIAS))); const g = f || p; return g && (s ? (t.onOverlap || e.onOverlap) && this.emit(y.OVERLAP, t.gameObject, e.gameObject, t, e) : (t.onCollide || e.onCollide) && this.emit(y.COLLIDE, t.gameObject, e.gameObject, t, e)), g; },\n      separateCircle(t, e, i, n) {\n        t.updateCenter(), e.updateCenter(), b(t, e, !1, n), E(t, e, !1, n); let s; let r; let o = 0; if (t.isCircle !== e.isCircle ? (s = {\n          x: e.isCircle ? t.position.x : e.position.x, y: e.isCircle ? t.position.y : e.position.y, right: e.isCircle ? t.right : e.right, bottom: e.isCircle ? t.bottom : e.bottom,\n        }, (r = { x: t.isCircle ? t.center.x : e.center.x, y: t.isCircle ? t.center.y : e.center.y, radius: t.isCircle ? t.halfWidth : e.halfWidth }).y < s.y ? r.x < s.x ? o = m(r.x, r.y, s.x, s.y) - r.radius : s.right < r.x && (o = m(r.x, r.y, s.right, s.y) - r.radius) : s.bottom < r.y && (r.x < s.x ? o = m(r.x, r.y, s.x, s.bottom) - r.radius : s.right < r.x && (o = m(r.x, r.y, s.right, s.bottom) - r.radius)), o *= -1) : o = t.halfWidth + e.halfWidth - m(t.center.x, t.center.y, e.center.x, e.center.y), i || o === 0 || t.immovable && e.immovable || t.customSeparateX || e.customSeparateX) return o !== 0 && (t.onOverlap || e.onOverlap) && this.emit(y.OVERLAP, t.gameObject, e.gameObject, t, e), o !== 0; const a = t.center.x - e.center.x; const h = t.center.y - e.center.y; const l = Math.sqrt(Math.pow(a, 2) + Math.pow(h, 2)); const u = (e.center.x - t.center.x) / l || 0; const c = (e.center.y - t.center.y) / l || 0; let d = 2 * (t.velocity.x * u + t.velocity.y * c - e.velocity.x * u - e.velocity.y * c) / (t.mass + e.mass); (t.immovable || e.immovable) && (d *= 2), t.immovable || (t.velocity.x = t.velocity.x - d / t.mass * u, t.velocity.y = t.velocity.y - d / t.mass * c), e.immovable || (e.velocity.x = e.velocity.x + d / e.mass * u, e.velocity.y = e.velocity.y + d / e.mass * c), t.immovable || e.immovable || (o /= 2); const f = v(t.center, e.center); const p = (o + S.EPSILON) * Math.cos(f); const g = (o + S.EPSILON) * Math.sin(f); return t.immovable || (t.x -= p, t.y -= g, t.updateCenter()), e.immovable || (e.x += p, e.y += g, e.updateCenter()), t.velocity.x *= t.bounce.x, t.velocity.y *= t.bounce.y, e.velocity.x *= e.bounce.x, e.velocity.y *= e.bounce.y, (t.onCollide || e.onCollide) && this.emit(y.COLLIDE, t.gameObject, e.gameObject, t, e), !0;\n      },\n      intersects(t, e) { return t !== e && (t.isCircle || e.isCircle ? t.isCircle ? e.isCircle ? m(t.center.x, t.center.y, e.center.x, e.center.y) <= t.halfWidth + e.halfWidth : this.circleBodyIntersects(t, e) : this.circleBodyIntersects(e, t) : !(t.right <= e.position.x || t.bottom <= e.position.y || t.position.x >= e.right || t.position.y >= e.bottom)); },\n      circleBodyIntersects(t, e) { const i = p(t.center.x, e.left, e.right); const n = p(t.center.y, e.top, e.bottom); return (t.center.x - i) * (t.center.x - i) + (t.center.y - n) * (t.center.y - n) <= t.halfWidth * t.halfWidth; },\n      overlap(t, e, i, n, s) { return void 0 === i && (i = null), void 0 === n && (n = null), void 0 === s && (s = i), this.collideObjects(t, e, i, n, s, !0); },\n      collide(t, e, i, n, s) { return void 0 === i && (i = null), void 0 === n && (n = null), void 0 === s && (s = i), this.collideObjects(t, e, i, n, s, !1); },\n      collideObjects(t, e, i, n, s, r) { let o; t.isParent && void 0 === t.physicsType && (t = t.children.entries), e && e.isParent && void 0 === e.physicsType && (e = e.children.entries); const a = Array.isArray(t); const h = Array.isArray(e); if (this._total = 0, a || h) if (!a && h) for (o = 0; o < e.length; o++) this.collideHandler(t, e[o], i, n, s, r); else if (a && !h) if (e) for (o = 0; o < t.length; o++) this.collideHandler(t[o], e, i, n, s, r); else for (o = 0; o < t.length; o++) for (var l = t[o], u = o + 1; u < t.length; u++)o !== u && this.collideHandler(l, t[u], i, n, s, r); else for (o = 0; o < t.length; o++) for (u = 0; u < e.length; u++) this.collideHandler(t[o], e[u], i, n, s, r); else this.collideHandler(t, e, i, n, s, r); return this._total > 0; },\n      collideHandler(t, e, i, n, s, r) { if (void 0 === e && t.isParent) return this.collideGroupVsGroup(t, t, i, n, s, r); if (!t || !e) return !1; if (t.body) { if (e.body) return this.collideSpriteVsSprite(t, e, i, n, s, r); if (e.isParent) return this.collideSpriteVsGroup(t, e, i, n, s, r); if (e.isTilemap) return this.collideSpriteVsTilemapLayer(t, e, i, n, s, r); } else if (t.isParent) { if (e.body) return this.collideSpriteVsGroup(e, t, i, n, s, r); if (e.isParent) return this.collideGroupVsGroup(t, e, i, n, s, r); if (e.isTilemap) return this.collideGroupVsTilemapLayer(t, e, i, n, s, r); } else if (t.isTilemap) { if (e.body) return this.collideSpriteVsTilemapLayer(e, t, i, n, s, r); if (e.isParent) return this.collideGroupVsTilemapLayer(e, t, i, n, s, r); } },\n      collideSpriteVsSprite(t, e, i, n, s, r) { return !(!t.body || !e.body) && (this.separate(t.body, e.body, n, s, r) && (i && i.call(s, t, e), this._total++), !0); },\n      collideSpriteVsGroup(t, e, i, n, s, r) { let o; const a = t.body; if (e.length !== 0 && a && a.enable && !a.checkCollision.none) if (this.useTree || e.physicsType === g.STATIC_BODY) { const h = this.treeMinMax; h.minX = a.left, h.minY = a.top, h.maxX = a.right, h.maxY = a.bottom; for (var l = e.physicsType === g.DYNAMIC_BODY ? this.tree.search(h) : this.staticTree.search(h), u = l.length, c = 0; c < u; c++)a !== (o = l[c]) && o.enable && !o.checkCollision.none && e.contains(o.gameObject) && this.separate(a, o, n, s, r, !0) && (i && i.call(s, a.gameObject, o.gameObject), this._total++); } else { const d = e.getChildren(); const f = e.children.entries.indexOf(t); for (u = d.length, c = 0; c < u; c++)(o = d[c].body) && c !== f && o.enable && this.separate(a, o, n, s, r) && (i && i.call(s, a.gameObject, o.gameObject), this._total++); } },\n      collideGroupVsTilemapLayer(t, e, i, n, s, r) { const o = t.getChildren(); if (o.length === 0) return !1; for (var a = !1, h = 0; h < o.length; h++)o[h].body && this.collideSpriteVsTilemapLayer(o[h], e, i, n, s, r) && (a = !0); return a; },\n      collideTiles(t, e, i, n, s) { return !(!t.body.enable || e.length === 0) && this.collideSpriteVsTilesHandler(t, e, i, n, s, !1, !1); },\n      overlapTiles(t, e, i, n, s) { return !(!t.body.enable || e.length === 0) && this.collideSpriteVsTilesHandler(t, e, i, n, s, !0, !1); },\n      collideSpriteVsTilemapLayer(t, e, i, n, s, r) { const o = t.body; if (!o.enable || o.checkCollision.none) return !1; let a; let h = o.position.x; const l = o.position.y; let u = o.width; let c = o.height; const d = e.layer; d.tileWidth > d.baseTileWidth && (h -= a = (d.tileWidth - d.baseTileWidth) * e.scaleX, u += a), d.tileHeight > d.baseTileHeight && (c += (d.tileHeight - d.baseTileHeight) * e.scaleY); const f = e.getTilesWithinWorldXY(h, l, u, c); return f.length !== 0 && this.collideSpriteVsTilesHandler(t, f, i, n, s, r, !0); },\n      collideSpriteVsTilesHandler(t, e, i, n, s, r, o) {\n        for (var a, h, l = t.body, u = {\n            left: 0, right: 0, top: 0, bottom: 0,\n          }, c = !1, d = 0; d < e.length; d++)h = (a = e[d]).tilemapLayer, u.left = h.tileToWorldX(a.x), u.top = h.tileToWorldY(a.y), a.baseHeight !== a.height && (u.top -= (a.height - a.baseHeight) * h.scaleY), u.right = u.left + a.width * h.scaleX, u.bottom = u.top + a.height * h.scaleY, M(u, l) && (!n || n.call(s, t, a)) && f(a, t) && (r || _(d, l, a, u, h, this.TILE_BIAS, o)) && (this._total++, c = !0, i && i.call(s, t, a), r && l.onOverlap ? this.emit(y.TILE_OVERLAP, t, a, l) : l.onCollide && this.emit(y.TILE_COLLIDE, t, a, l)); return c;\n      },\n      collideGroupVsGroup(t, e, i, n, s, r) { if (t.length !== 0 && e.length !== 0) for (let o = t.getChildren(), a = 0; a < o.length; a++) this.collideSpriteVsGroup(o[a], e, i, n, s, r); },\n      wrap(t, e) { t.body ? this.wrapObject(t, e) : t.getChildren ? this.wrapArray(t.getChildren(), e) : Array.isArray(t) ? this.wrapArray(t, e) : this.wrapObject(t, e); },\n      wrapArray(t, e) { for (let i = 0; i < t.length; i++) this.wrapObject(t[i], e); },\n      wrapObject(t, e) { void 0 === e && (e = 0), t.x = R(t.x, this.bounds.left - e, this.bounds.right + e), t.y = R(t.y, this.bounds.top - e, this.bounds.bottom + e); },\n      shutdown() { this.tree.clear(), this.staticTree.clear(), this.bodies.clear(), this.staticBodies.clear(), this.colliders.destroy(), this.removeAllListeners(); },\n      destroy() { this.shutdown(), this.scene = null; },\n    }); t.exports = L;\n  }, function (t, e, i) {\n    const n = i(0); const s = i(50); const r = i(218); const a = i(173); const o = i(11); const h = i(48); const l = i(3); const u = new n({\n      initialize(t, e) {\n        const i = e.displayWidth ? e.displayWidth : 64; const n = e.displayHeight ? e.displayHeight : 64; this.world = t, this.gameObject = e, this.transform = {\n          x: e.x, y: e.y, rotation: e.angle, scaleX: e.scaleX, scaleY: e.scaleY, displayOriginX: e.displayOriginX, displayOriginY: e.displayOriginY,\n        }, this.debugShowBody = t.defaults.debugShowBody, this.debugShowVelocity = t.defaults.debugShowVelocity, this.debugBodyColor = t.defaults.bodyDebugColor, this.enable = !0, this.isCircle = !1, this.radius = 0, this.offset = new l(), this.position = new l(e.x - e.scaleX * e.displayOriginX, e.y - e.scaleY * e.displayOriginY), this.prev = this.position.clone(), this.prevFrame = this.position.clone(), this.allowRotation = !0, this.rotation = e.angle, this.preRotation = e.angle, this.width = i, this.height = n, this.sourceWidth = i, this.sourceHeight = n, e.frame && (this.sourceWidth = e.frame.realWidth, this.sourceHeight = e.frame.realHeight), this.halfWidth = Math.abs(i / 2), this.halfHeight = Math.abs(n / 2), this.center = new l(this.position.x + this.halfWidth, this.position.y + this.halfHeight), this.velocity = new l(), this.newVelocity = new l(), this.deltaMax = new l(), this.acceleration = new l(), this.allowDrag = !0, this.drag = new l(), this.allowGravity = !0, this.gravity = new l(), this.bounce = new l(), this.worldBounce = null, this.customBoundsRectangle = t.bounds, this.onWorldBounds = !1, this.onCollide = !1, this.onOverlap = !1, this.maxVelocity = new l(1e4, 1e4), this.maxSpeed = -1, this.friction = new l(1, 0), this.useDamping = !1, this.angularVelocity = 0, this.angularAcceleration = 0, this.angularDrag = 0, this.maxAngular = 1e3, this.mass = 1, this.angle = 0, this.speed = 0, this.facing = s.FACING_NONE, this.immovable = !1, this.moves = !0, this.customSeparateX = !1, this.customSeparateY = !1, this.overlapX = 0, this.overlapY = 0, this.overlapR = 0, this.embedded = !1, this.collideWorldBounds = !1, this.checkCollision = {\n          none: !1, up: !0, down: !0, left: !0, right: !0,\n        }, this.touching = {\n          none: !0, up: !1, down: !1, left: !1, right: !1,\n        }, this.wasTouching = {\n          none: !0, up: !1, down: !1, left: !1, right: !1,\n        }, this.blocked = {\n          none: !0, up: !1, down: !1, left: !1, right: !1,\n        }, this.syncBounds = !1, this.physicsType = s.DYNAMIC_BODY, this._sx = e.scaleX, this._sy = e.scaleY, this._dx = 0, this._dy = 0, this._tx = 0, this._ty = 0, this._bounds = new o();\n      },\n      updateBounds() { let t; const e = this.gameObject; const i = this.transform; e.parentContainer ? (t = e.getWorldTransformMatrix(this.world._tempMatrix, this.world._tempMatrix2), i.x = t.tx, i.y = t.ty, i.rotation = a(t.rotation), i.scaleX = t.scaleX, i.scaleY = t.scaleY) : (i.x = e.x, i.y = e.y, i.rotation = e.angle, i.scaleX = e.scaleX, i.scaleY = e.scaleY), i.displayOriginX = e.displayOriginX, i.displayOriginY = e.displayOriginY; let n; let s; let r; let o = !1; this.syncBounds ? (n = e.getBounds(this._bounds), this.width = n.width, this.height = n.height, o = !0) : (s = Math.abs(i.scaleX), r = Math.abs(i.scaleY), this._sx === s && this._sy === r || (this.width = this.sourceWidth * s, this.height = this.sourceHeight * r, this._sx = s, this._sy = r, o = !0)), o && (this.halfWidth = Math.floor(this.width / 2), this.halfHeight = Math.floor(this.height / 2), this.updateCenter()); },\n      updateCenter() { this.center.set(this.position.x + this.halfWidth, this.position.y + this.halfHeight); },\n      updateFromGameObject() { this.updateBounds(); const t = this.transform; this.position.x = t.x + t.scaleX * (this.offset.x - t.displayOriginX), this.position.y = t.y + t.scaleY * (this.offset.y - t.displayOriginY), this.updateCenter(); },\n      resetFlags() { const t = this.wasTouching; const e = this.touching; const i = this.blocked; t.none = e.none, t.up = e.up, t.down = e.down, t.left = e.left, t.right = e.right, e.none = !0, e.up = !1, e.down = !1, e.left = !1, e.right = !1, i.none = !0, i.up = !1, i.down = !1, i.left = !1, i.right = !1, this.overlapR = 0, this.overlapX = 0, this.overlapY = 0, this.embedded = !1; },\n      preUpdate(t, e) { t && this.resetFlags(), this.updateFromGameObject(), this.rotation = this.transform.rotation, this.preRotation = this.rotation, this.moves && (this.prev.x = this.position.x, this.prev.y = this.position.y, this.prevFrame.x = this.position.x, this.prevFrame.y = this.position.y), t && this.update(e); },\n      update(t) { let e; let i; this.prev.x = this.position.x, this.prev.y = this.position.y, this.moves && (this.world.updateMotion(this, t), e = this.velocity.x, i = this.velocity.y, this.newVelocity.set(e * t, i * t), this.position.add(this.newVelocity), this.updateCenter(), this.angle = Math.atan2(i, e), this.speed = Math.sqrt(e * e + i * i), this.collideWorldBounds && this.checkWorldBounds() && this.onWorldBounds && this.world.emit(r.WORLD_BOUNDS, this, this.blocked.up, this.blocked.down, this.blocked.left, this.blocked.right)), this._dx = this.position.x - this.prev.x, this._dy = this.position.y - this.prev.y; },\n      postUpdate() { let t; let e; let i = this.position.x - this.prevFrame.x; let n = this.position.y - this.prevFrame.y; this.moves && ((t = this.deltaMax.x) !== 0 && i !== 0 && (i < 0 && i < -t ? i = -t : i > 0 && t < i && (i = t)), (e = this.deltaMax.y) !== 0 && n !== 0 && (n < 0 && n < -e ? n = -e : n > 0 && e < n && (n = e)), this.gameObject.x += i, this.gameObject.y += n), i < 0 ? this.facing = s.FACING_LEFT : i > 0 && (this.facing = s.FACING_RIGHT), n < 0 ? this.facing = s.FACING_UP : n > 0 && (this.facing = s.FACING_DOWN), this.allowRotation && (this.gameObject.angle += this.deltaZ()), this._tx = i, this._ty = n; },\n      setBoundsRectangle(t) { return this.customBoundsRectangle = t || this.world.bounds, this; },\n      checkWorldBounds() { const t = this.position; const e = this.customBoundsRectangle; const i = this.world.checkCollision; const n = this.worldBounce ? -this.worldBounce.x : -this.bounce.x; const s = this.worldBounce ? -this.worldBounce.y : -this.bounce.y; let r = !1; return t.x < e.x && i.left ? (t.x = e.x, this.velocity.x *= n, r = this.blocked.left = !0) : this.right > e.right && i.right && (t.x = e.right - this.width, this.velocity.x *= n, r = this.blocked.right = !0), t.y < e.y && i.up ? (t.y = e.y, this.velocity.y *= s, r = this.blocked.up = !0) : this.bottom > e.bottom && i.down && (t.y = e.bottom - this.height, this.velocity.y *= s, r = this.blocked.down = !0), r && (this.blocked.none = !1), r; },\n      setOffset(t, e) { return void 0 === e && (e = t), this.offset.set(t, e), this.updateCenter(), this; },\n      setSize(t, e, i) { void 0 === i && (i = !0); let n; let s; const r = this.gameObject; return !t && r.frame && (t = r.frame.realWidth), !e && r.frame && (e = r.frame.realHeight), this.sourceWidth = t, this.sourceHeight = e, this.width = this.sourceWidth * this._sx, this.height = this.sourceHeight * this._sy, this.halfWidth = Math.floor(this.width / 2), this.halfHeight = Math.floor(this.height / 2), this.updateCenter(), i && r.getCenter && (n = (r.width - t) / 2, s = (r.height - e) / 2, this.offset.set(n, s)), this.isCircle = !1, this.radius = 0, this; },\n      setCircle(t, e, i) { return void 0 === e && (e = this.offset.x), void 0 === i && (i = this.offset.y), t > 0 ? (this.isCircle = !0, this.radius = t, this.sourceWidth = 2 * t, this.sourceHeight = 2 * t, this.width = this.sourceWidth * this._sx, this.height = this.sourceHeight * this._sy, this.halfWidth = Math.floor(this.width / 2), this.halfHeight = Math.floor(this.height / 2), this.offset.set(e, i), this.updateCenter()) : this.isCircle = !1, this; },\n      reset(t, e) { this.stop(); const i = this.gameObject; i.setPosition(t, e), i.getTopLeft ? i.getTopLeft(this.position) : this.position.set(t, e), this.prev.copy(this.position), this.prevFrame.copy(this.position), this.rotation = i.angle, this.preRotation = i.angle, this.updateBounds(), this.updateCenter(); },\n      stop() { return this.velocity.set(0), this.acceleration.set(0), this.speed = 0, this.angularVelocity = 0, this.angularAcceleration = 0, this; },\n      getBounds(t) { return t.x = this.x, t.y = this.y, t.right = this.right, t.bottom = this.bottom, t; },\n      hitTest(t, e) { return this.isCircle ? this.radius > 0 && t >= this.left && t <= this.right && e >= this.top && e <= this.bottom && (this.center.x - t) * (this.center.x - t) + (this.center.y - e) * (this.center.y - e) <= this.radius * this.radius : h(this, t, e); },\n      onFloor() { return this.blocked.down; },\n      onCeiling() { return this.blocked.up; },\n      onWall() { return this.blocked.left || this.blocked.right; },\n      deltaAbsX() { return this._dx > 0 ? this._dx : -this._dx; },\n      deltaAbsY() { return this._dy > 0 ? this._dy : -this._dy; },\n      deltaX() { return this._dx; },\n      deltaY() { return this._dy; },\n      deltaXFinal() { return this._tx; },\n      deltaYFinal() { return this._ty; },\n      deltaZ() { return this.rotation - this.preRotation; },\n      destroy() { this.enable = !1, this.world && this.world.pendingDestroy.set(this); },\n      drawDebug(t) { const e = this.position; const i = e.x + this.halfWidth; const n = e.y + this.halfHeight; this.debugShowBody && (t.lineStyle(t.defaultStrokeWidth, this.debugBodyColor), this.isCircle ? t.strokeCircle(i, n, this.width / 2) : (this.checkCollision.up && t.lineBetween(e.x, e.y, e.x + this.width, e.y), this.checkCollision.right && t.lineBetween(e.x + this.width, e.y, e.x + this.width, e.y + this.height), this.checkCollision.down && t.lineBetween(e.x, e.y + this.height, e.x + this.width, e.y + this.height), this.checkCollision.left && t.lineBetween(e.x, e.y, e.x, e.y + this.height))), this.debugShowVelocity && (t.lineStyle(t.defaultStrokeWidth, this.world.defaults.velocityDebugColor, 1), t.lineBetween(i, n, i + this.velocity.x / 2, n + this.velocity.y / 2)); },\n      willDrawDebug() { return this.debugShowBody || this.debugShowVelocity; },\n      setCollideWorldBounds(t, e, i) { void 0 === t && (t = !0), this.collideWorldBounds = t; const n = void 0 !== e; const s = void 0 !== i; return (n || s) && (this.worldBounce || (this.worldBounce = new l()), n && (this.worldBounce.x = e), s && (this.worldBounce.y = i)), this; },\n      setVelocity(t, e) { return this.velocity.set(t, e), t = this.velocity.x, e = this.velocity.y, this.speed = Math.sqrt(t * t + e * e), this; },\n      setVelocityX(t) { this.velocity.x = t; const e = this.velocity.y; return this.speed = Math.sqrt(t * t + e * e), this; },\n      setVelocityY(t) { this.velocity.y = t; const e = this.velocity.x; return this.speed = Math.sqrt(e * e + t * t), this; },\n      setMaxVelocity(t, e) { return this.maxVelocity.set(t, e), this; },\n      setMaxSpeed(t) { return this.maxSpeed = t, this; },\n      setBounce(t, e) { return this.bounce.set(t, e), this; },\n      setBounceX(t) { return this.bounce.x = t, this; },\n      setBounceY(t) { return this.bounce.y = t, this; },\n      setAcceleration(t, e) { return this.acceleration.set(t, e), this; },\n      setAccelerationX(t) { return this.acceleration.x = t, this; },\n      setAccelerationY(t) { return this.acceleration.y = t, this; },\n      setAllowDrag(t) { return void 0 === t && (t = !0), this.allowDrag = t, this; },\n      setAllowGravity(t) { return void 0 === t && (t = !0), this.allowGravity = t, this; },\n      setAllowRotation(t) { return void 0 === t && (t = !0), this.allowRotation = t, this; },\n      setDrag(t, e) { return this.drag.set(t, e), this; },\n      setDragX(t) { return this.drag.x = t, this; },\n      setDragY(t) { return this.drag.y = t, this; },\n      setGravity(t, e) { return this.gravity.set(t, e), this; },\n      setGravityX(t) { return this.gravity.x = t, this; },\n      setGravityY(t) { return this.gravity.y = t, this; },\n      setFriction(t, e) { return this.friction.set(t, e), this; },\n      setFrictionX(t) { return this.friction.x = t, this; },\n      setFrictionY(t) { return this.friction.y = t, this; },\n      setAngularVelocity(t) { return this.angularVelocity = t, this; },\n      setAngularAcceleration(t) { return this.angularAcceleration = t, this; },\n      setAngularDrag(t) { return this.angularDrag = t, this; },\n      setMass(t) { return this.mass = t, this; },\n      setImmovable(t) { return void 0 === t && (t = !0), this.immovable = t, this; },\n      setEnable(t) { return void 0 === t && (t = !0), this.enable = t, this; },\n      x: { get() { return this.position.x; }, set(t) { this.position.x = t; } },\n      y: { get() { return this.position.y; }, set(t) { this.position.y = t; } },\n      left: { get() { return this.position.x; } },\n      right: { get() { return this.position.x + this.width; } },\n      top: { get() { return this.position.y; } },\n      bottom: { get() { return this.position.y + this.height; } },\n    }); t.exports = u;\n  }, function (t, e, i) {\n    const n = new (i(0))({\n      initialize(t, e, i, n, s, r, o) { this.world = t, this.name = '', this.active = !0, this.overlapOnly = e, this.object1 = i, this.object2 = n, this.collideCallback = s, this.processCallback = r, this.callbackContext = o; }, setName(t) { return this.name = t, this; }, update() { this.world.collideObjects(this.object1, this.object2, this.collideCallback, this.processCallback, this.callbackContext, this.overlapOnly); }, destroy() { this.world.removeCollider(this), this.active = !1, this.world = null, this.object1 = null, this.object2 = null, this.collideCallback = null, this.processCallback = null, this.callbackContext = null; },\n    }); t.exports = n;\n  }, function (t, e, i) { const o = i(50); t.exports = function (t, e, i, n) { let s = 0; const r = t.deltaAbsX() + e.deltaAbsX() + n; return t._dx === 0 && e._dx === 0 ? (t.embedded = !0, e.embedded = !0) : t._dx > e._dx ? r < (s = t.right - e.x) && !i || !1 === t.checkCollision.right || !1 === e.checkCollision.left ? s = 0 : (t.touching.none = !1, t.touching.right = !0, e.touching.none = !1, e.touching.left = !0, e.physicsType === o.STATIC_BODY && (t.blocked.none = !1, t.blocked.right = !0), t.physicsType === o.STATIC_BODY && (e.blocked.none = !1, e.blocked.left = !0)) : t._dx < e._dx && (r < -(s = t.x - e.width - e.x) && !i || !1 === t.checkCollision.left || !1 === e.checkCollision.right ? s = 0 : (t.touching.none = !1, t.touching.left = !0, e.touching.none = !1, e.touching.right = !0, e.physicsType === o.STATIC_BODY && (t.blocked.none = !1, t.blocked.left = !0), t.physicsType === o.STATIC_BODY && (e.blocked.none = !1, e.blocked.right = !0))), t.overlapX = s, e.overlapX = s; }; }, function (t, e, i) { const o = i(50); t.exports = function (t, e, i, n) { let s = 0; const r = t.deltaAbsY() + e.deltaAbsY() + n; return t._dy === 0 && e._dy === 0 ? (t.embedded = !0, e.embedded = !0) : t._dy > e._dy ? r < (s = t.bottom - e.y) && !i || !1 === t.checkCollision.down || !1 === e.checkCollision.up ? s = 0 : (t.touching.none = !1, t.touching.down = !0, e.touching.none = !1, e.touching.up = !0, e.physicsType === o.STATIC_BODY && (t.blocked.none = !1, t.blocked.down = !0), t.physicsType === o.STATIC_BODY && (e.blocked.none = !1, e.blocked.up = !0)) : t._dy < e._dy && (r < -(s = t.y - e.bottom) && !i || !1 === t.checkCollision.up || !1 === e.checkCollision.down ? s = 0 : (t.touching.none = !1, t.touching.up = !0, e.touching.none = !1, e.touching.down = !0, e.physicsType === o.STATIC_BODY && (t.blocked.none = !1, t.blocked.up = !0), t.physicsType === o.STATIC_BODY && (e.blocked.none = !1, e.blocked.down = !0))), t.overlapY = s, e.overlapY = s; }; }, function (t, e, i) {\n    const a = i(391); function n(t) { if (!(this instanceof n)) return new n(t); this._maxEntries = Math.max(4, t || 9), this._minEntries = Math.max(2, Math.ceil(0.4 * this._maxEntries)), this.clear(); } function f(t, e) { m(t, 0, t.children.length, e, t); } function m(t, e, i, n, s) { (s = s || p(null)).minX = 1 / 0, s.minY = 1 / 0, s.maxX = -1 / 0, s.maxY = -1 / 0; for (var r, o = e; o < i; o++)r = t.children[o], u(s, t.leaf ? n(r) : r); return s; } function u(t, e) { return t.minX = Math.min(t.minX, e.minX), t.minY = Math.min(t.minY, e.minY), t.maxX = Math.max(t.maxX, e.maxX), t.maxY = Math.max(t.maxY, e.maxY), t; } function r(t, e) { return t.minX - e.minX; } function o(t, e) { return t.minY - e.minY; } function y(t) { return (t.maxX - t.minX) * (t.maxY - t.minY); } function c(t) { return t.maxX - t.minX + (t.maxY - t.minY); } function d(t, e) { return t.minX <= e.minX && t.minY <= e.minY && e.maxX <= t.maxX && e.maxY <= t.maxY; } function l(t, e) { return e.minX <= t.maxX && e.minY <= t.maxY && e.maxX >= t.minX && e.maxY >= t.minY; } function p(t) {\n      return {\n        children: t, height: 1, leaf: !0, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0,\n      };\n    } function g(t, e, i, n, s) { for (var r, o = [e, i]; o.length;)(i = o.pop()) - (e = o.pop()) <= n || (r = e + Math.ceil((i - e) / n / 2) * n, a(t, r, e, i, s), o.push(e, r, r, i)); }n.prototype = {\n      all() { return this._all(this.data, []); },\n      search(t) { let e = this.data; const i = []; const n = this.toBBox; if (!l(t, e)) return i; for (var s, r, o, a, h = []; e;) { for (s = 0, r = e.children.length; s < r; s++)o = e.children[s], l(t, a = e.leaf ? n(o) : o) && (e.leaf ? i.push(o) : d(t, a) ? this._all(o, i) : h.push(o)); e = h.pop(); } return i; },\n      collides(t) { let e = this.data; const i = this.toBBox; if (!l(t, e)) return !1; for (var n, s, r, o, a = []; e;) { for (n = 0, s = e.children.length; n < s; n++) if (r = e.children[n], l(t, o = e.leaf ? i(r) : r)) { if (e.leaf || d(t, o)) return !0; a.push(r); }e = a.pop(); } return !1; },\n      load(t) { if (!t || !t.length) return this; if (t.length < this._minEntries) { for (let e = 0, i = t.length; e < i; e++) this.insert(t[e]); return this; } let n; let s = this._build(t.slice(), 0, t.length - 1, 0); return this.data.children.length ? this.data.height === s.height ? this._splitRoot(this.data, s) : (this.data.height < s.height && (n = this.data, this.data = s, s = n), this._insert(s, this.data.height - s.height - 1, !0)) : this.data = s, this; },\n      insert(t) { return t && this._insert(t, this.data.height - 1), this; },\n      clear() { return this.data = p([]), this; },\n      remove(t, e) { if (!t) return this; for (var i, n, s, r, o = this.data, a = this.toBBox(t), h = [], l = []; o || h.length;) { if (o || (o = h.pop(), n = h[h.length - 1], i = l.pop(), r = !0), o.leaf && (s = (function (t, e, i) { if (!i) return e.indexOf(t); for (let n = 0; n < e.length; n++) if (i(t, e[n])) return n; return -1; }(t, o.children, e))) !== -1) return o.children.splice(s, 1), h.push(o), this._condense(h), this; r || o.leaf || !d(o, a) ? n ? (i++, o = n.children[i], r = !1) : o = null : (h.push(o), l.push(i), i = 0, o = (n = o).children[0]); } return this; },\n      toBBox(t) {\n        return {\n          minX: t.left, minY: t.top, maxX: t.right, maxY: t.bottom,\n        };\n      },\n      compareMinX(t, e) { return t.left - e.left; },\n      compareMinY(t, e) { return t.top - e.top; },\n      toJSON() { return this.data; },\n      fromJSON(t) { return this.data = t, this; },\n      _all(t, e) { for (let i = []; t;)t.leaf ? e.push.apply(e, t.children) : i.push.apply(i, t.children), t = i.pop(); return e; },\n      _build(t, e, i, n) { let s; const r = i - e + 1; let o = this._maxEntries; if (r <= o) return f(s = p(t.slice(e, i + 1)), this.toBBox), s; n || (n = Math.ceil(Math.log(r) / Math.log(o)), o = Math.ceil(r / Math.pow(o, n - 1))), (s = p([])).leaf = !1, s.height = n; let a; let h; let l; let u; const c = Math.ceil(r / o); const d = c * Math.ceil(Math.sqrt(o)); for (g(t, e, i, d, this.compareMinX), a = e; a <= i; a += d) for (g(t, a, l = Math.min(a + d - 1, i), c, this.compareMinY), h = a; h <= l; h += c)u = Math.min(h + c - 1, l), s.children.push(this._build(t, h, u, n - 1)); return f(s, this.toBBox), s; },\n      _chooseSubtree(t, e, i, n) { for (var s, r, o, a, h, l, u, c, d, f; n.push(e), !e.leaf && n.length - 1 !== i;) { for (u = c = 1 / 0, s = 0, r = e.children.length; s < r; s++)h = y(o = e.children[s]), d = t, f = o, (l = (Math.max(f.maxX, d.maxX) - Math.min(f.minX, d.minX)) * (Math.max(f.maxY, d.maxY) - Math.min(f.minY, d.minY)) - h) < c ? (c = l, u = h < u ? h : u, a = o) : l === c && h < u && (u = h, a = o); e = a || e.children[0]; } return e; },\n      _insert(t, e, i) { const n = this.toBBox; const s = i ? t : n(t); const r = []; const o = this._chooseSubtree(s, this.data, e, r); for (o.children.push(t), u(o, s); e >= 0 && r[e].children.length > this._maxEntries;) this._split(r, e), e--; this._adjustParentBBoxes(s, r, e); },\n      _split(t, e) { const i = t[e]; const n = i.children.length; const s = this._minEntries; this._chooseSplitAxis(i, s, n); const r = this._chooseSplitIndex(i, s, n); const o = p(i.children.splice(r, i.children.length - r)); o.height = i.height, o.leaf = i.leaf, f(i, this.toBBox), f(o, this.toBBox), e ? t[e - 1].children.push(o) : this._splitRoot(i, o); },\n      _splitRoot(t, e) { this.data = p([t, e]), this.data.height = t.height + 1, this.data.leaf = !1, f(this.data, this.toBBox); },\n      _chooseSplitIndex(t, e, i) { for (var n, s, r, o, a, h, l, u, c, d, f, p, g = a = 1 / 0, v = e; v <= i - e; v++)n = m(t, 0, v, this.toBBox), s = m(t, v, i, this.toBBox), l = n, u = s, p = f = d = c = void 0, c = Math.max(l.minX, u.minX), d = Math.max(l.minY, u.minY), f = Math.min(l.maxX, u.maxX), p = Math.min(l.maxY, u.maxY), r = Math.max(0, f - c) * Math.max(0, p - d), o = y(n) + y(s), r < g ? (g = r, h = v, a = o < a ? o : a) : r === g && o < a && (a = o, h = v); return h; },\n      _chooseSplitAxis(t, e, i) { const n = t.leaf ? this.compareMinX : r; const s = t.leaf ? this.compareMinY : o; this._allDistMargin(t, e, i, n) < this._allDistMargin(t, e, i, s) && t.children.sort(n); },\n      _allDistMargin(t, e, i, n) { t.children.sort(n); for (var s, r = this.toBBox, o = m(t, 0, e, r), a = m(t, i - e, i, r), h = c(o) + c(a), l = e; l < i - e; l++)s = t.children[l], u(o, t.leaf ? r(s) : s), h += c(o); for (l = i - e - 1; e <= l; l--)s = t.children[l], u(a, t.leaf ? r(s) : s), h += c(a); return h; },\n      _adjustParentBBoxes(t, e, i) { for (let n = i; n >= 0; n--)u(e[n], t); },\n      _condense(t) { for (var e, i = t.length - 1; i >= 0; i--)t[i].children.length === 0 ? i > 0 ? (e = t[i - 1].children).splice(e.indexOf(t[i]), 1) : this.clear() : f(t[i], this.toBBox); },\n    }, t.exports = n;\n  }, function (t, e) { t.exports = function (t, e) { return !(e.right <= t.left || e.bottom <= t.top || e.position.x >= t.right || e.position.y >= t.bottom); }; }, function (t, e, i) {\n    const n = i(55); const s = i(0); const r = i(50); const o = i(48); const a = i(3); const h = new s({\n      initialize(t, e) {\n        const i = e.displayWidth ? e.displayWidth : 64; const n = e.displayHeight ? e.displayHeight : 64; this.world = t, this.gameObject = e, this.debugShowBody = t.defaults.debugShowStaticBody, this.debugBodyColor = t.defaults.staticBodyDebugColor, this.enable = !0, this.isCircle = !1, this.radius = 0, this.offset = new a(), this.position = new a(e.x - i * e.originX, e.y - n * e.originY), this.width = i, this.height = n, this.halfWidth = Math.abs(this.width / 2), this.halfHeight = Math.abs(this.height / 2), this.center = new a(this.position.x + this.halfWidth, this.position.y + this.halfHeight), this.velocity = a.ZERO, this.allowGravity = !1, this.gravity = a.ZERO, this.bounce = a.ZERO, this.onWorldBounds = !1, this.onCollide = !1, this.onOverlap = !1, this.mass = 1, this.immovable = !0, this.customSeparateX = !1, this.customSeparateY = !1, this.overlapX = 0, this.overlapY = 0, this.overlapR = 0, this.embedded = !1, this.collideWorldBounds = !1, this.checkCollision = {\n          none: !1, up: !0, down: !0, left: !0, right: !0,\n        }, this.touching = {\n          none: !0, up: !1, down: !1, left: !1, right: !1,\n        }, this.wasTouching = {\n          none: !0, up: !1, down: !1, left: !1, right: !1,\n        }, this.blocked = {\n          none: !0, up: !1, down: !1, left: !1, right: !1,\n        }, this.physicsType = r.STATIC_BODY, this._dx = 0, this._dy = 0;\n      },\n      setGameObject(t, e) { return t && t !== this.gameObject && (this.gameObject.body = null, (t.body = this).gameObject = t), e && this.updateFromGameObject(), this; },\n      updateFromGameObject() { this.world.staticTree.remove(this); const t = this.gameObject; return t.getTopLeft(this.position), this.width = t.displayWidth, this.height = t.displayHeight, this.halfWidth = Math.abs(this.width / 2), this.halfHeight = Math.abs(this.height / 2), this.center.set(this.position.x + this.halfWidth, this.position.y + this.halfHeight), this.world.staticTree.insert(this), this; },\n      setOffset(t, e) { return void 0 === e && (e = t), this.world.staticTree.remove(this), this.position.x -= this.offset.x, this.position.y -= this.offset.y, this.offset.set(t, e), this.position.x += this.offset.x, this.position.y += this.offset.y, this.updateCenter(), this.world.staticTree.insert(this), this; },\n      setSize(t, e, i) { void 0 === i && (i = !0); let n; let s; const r = this.gameObject; return !t && r.frame && (t = r.frame.realWidth), !e && r.frame && (e = r.frame.realHeight), this.world.staticTree.remove(this), this.width = t, this.height = e, this.halfWidth = Math.floor(t / 2), this.halfHeight = Math.floor(e / 2), i && r.getCenter && (n = r.displayWidth / 2, s = r.displayHeight / 2, this.position.x -= this.offset.x, this.position.y -= this.offset.y, this.offset.set(n - this.halfWidth, s - this.halfHeight), this.position.x += this.offset.x, this.position.y += this.offset.y), this.updateCenter(), this.isCircle = !1, this.radius = 0, this.world.staticTree.insert(this), this; },\n      setCircle(t, e, i) { return void 0 === e && (e = this.offset.x), void 0 === i && (i = this.offset.y), t > 0 ? (this.world.staticTree.remove(this), this.isCircle = !0, this.radius = t, this.width = 2 * t, this.height = 2 * t, this.halfWidth = Math.floor(this.width / 2), this.halfHeight = Math.floor(this.height / 2), this.offset.set(e, i), this.updateCenter(), this.world.staticTree.insert(this)) : this.isCircle = !1, this; },\n      updateCenter() { this.center.set(this.position.x + this.halfWidth, this.position.y + this.halfHeight); },\n      reset(t, e) { const i = this.gameObject; void 0 === t && (t = i.x), void 0 === e && (e = i.y), this.world.staticTree.remove(this), i.setPosition(t, e), i.getTopLeft(this.position), this.updateCenter(), this.world.staticTree.insert(this); },\n      stop() { return this; },\n      getBounds(t) { return t.x = this.x, t.y = this.y, t.right = this.right, t.bottom = this.bottom, t; },\n      hitTest(t, e) { return (this.isCircle ? n : o)(this, t, e); },\n      postUpdate() {},\n      deltaAbsX() { return 0; },\n      deltaAbsY() { return 0; },\n      deltaX() { return 0; },\n      deltaY() { return 0; },\n      deltaZ() { return 0; },\n      destroy() { this.enable = !1, this.world.pendingDestroy.set(this); },\n      drawDebug(t) { const e = this.position; const i = e.x + this.halfWidth; const n = e.y + this.halfHeight; this.debugShowBody && (t.lineStyle(t.defaultStrokeWidth, this.debugBodyColor, 1), this.isCircle ? t.strokeCircle(i, n, this.width / 2) : t.strokeRect(e.x, e.y, this.width, this.height)); },\n      willDrawDebug() { return this.debugShowBody; },\n      setMass(t) { return t <= 0 && (t = 0.1), this.mass = t, this; },\n      x: { get() { return this.position.x; }, set(t) { this.world.staticTree.remove(this), this.position.x = t, this.world.staticTree.insert(this); } },\n      y: { get() { return this.position.y; }, set(t) { this.world.staticTree.remove(this), this.position.y = t, this.world.staticTree.insert(this); } },\n      left: { get() { return this.position.x; } },\n      right: { get() { return this.position.x + this.width; } },\n      top: { get() { return this.position.y; } },\n      bottom: { get() { return this.position.y + this.height; } },\n    }); t.exports = h;\n  }, function (t, e) {\n    const l = {}; (t.exports = l).create = function (t, e) {\n      const i = t.bodyA; const n = t.bodyB; const s = {\n        id: l.id(i, n), bodyA: i, bodyB: n, activeContacts: [], separation: 0, isActive: !0, confirmedActive: !0, isSensor: i.isSensor || n.isSensor, timeCreated: e, timeUpdated: e, collision: null, inverseMass: 0, friction: 0, frictionStatic: 0, restitution: 0, slop: 0,\n      }; return l.update(s, t, e), s;\n    }, l.update = function (t, e, i) { if ((t.collision = e).collided) { const n = e.supports; const s = t.activeContacts; const r = e.parentA; const o = e.parentB; t.inverseMass = r.inverseMass + o.inverseMass, t.friction = Math.min(r.friction, o.friction), t.frictionStatic = Math.max(r.frictionStatic, o.frictionStatic), t.restitution = Math.max(r.restitution, o.restitution), t.slop = Math.max(r.slop, o.slop); for (let a = 0; a < n.length; a++)s[a] = n[a].contact; const h = n.length; h < s.length && (s.length = h), t.separation = e.depth, l.setActive(t, !0, i); } else !0 === t.isActive && l.setActive(t, !1, i); }, l.setActive = function (t, e, i) { e ? (t.isActive = !0, t.timeUpdated = i) : (t.isActive = !1, t.activeContacts.length = 0); }, l.id = function (t, e) { return t.id < e.id ? `A${t.id}B${e.id}` : `A${e.id}B${t.id}`; };\n  }, function (t, e, i) {\n    const n = new (i(0))({\n      initialize(t) { this.pluginManager = t, this.game = t.game; }, init() {}, start() {}, stop() {}, destroy() { this.pluginManager = null, this.game = null, this.scene = null, this.systems = null; },\n    }); t.exports = n;\n  }, function (t, e, i) { const l = i(24); t.exports = function (t, e, i, n, s, r, o) { for (let a = l(i, n, s, r, null, o), h = 0; h < a.length; h++)a[h] && a[h].index === t && (a[h].index = e); }; }, function (t, e, i) { const s = i(101); t.exports = function (t, e, i) { if (s(t, e, i)) { const n = i.data[e][t]; return n !== null && n.index > -1; } return !1; }; }, function (t, e, i) { const o = i(74); const a = i(101); const h = i(220); t.exports = function (t, e, i, n, s) { if (void 0 === i && (i = !1), void 0 === n && (n = !0), !a(t, e, s)) return null; const r = s.data[e][t]; return r ? (s.data[e][t] = i ? null : new o(s, -1, t, e, r.width, r.height), n && r && r.collides && h(t, e, s), r) : null; }; }, function (t, e, i) { const a = i(32); const h = i(223); const l = i(479); const u = i(480); const c = i(491); t.exports = function (t, e, i, n, s, r) { let o; switch (e) { case a.ARRAY_2D: o = h(t, i, n, s, r); break; case a.CSV: o = l(t, i, n, s, r); break; case a.TILED_JSON: o = u(t, i, r); break; case a.WELTMEISTER: o = c(t, i, r); break; default: console.warn(`Unrecognized tilemap data format: ${e}`), o = null; } return o; }; }, function (t, e, i) { const a = i(32); const h = i(223); t.exports = function (t, e, i, n, s) { const r = e.trim().split('\\n').map((t) => t.split(',')); const o = h(t, r, i, n, s); return o.format = a.CSV, o; }; }, function (t, e, i) {\n    const r = i(32); const o = i(103); const a = i(481); const h = i(483); const l = i(484); const u = i(487); const c = i(489); const d = i(490); t.exports = function (t, e, i) {\n      if (e.orientation !== 'orthogonal') return console.warn('Only orthogonal map types are supported in this version of Phaser'), null; const n = new o({\n        width: e.width, height: e.height, name: t, tileWidth: e.tilewidth, tileHeight: e.tileheight, orientation: e.orientation, format: r.TILED_JSON, version: e.version, properties: e.properties, renderOrder: e.renderorder, infinite: e.infinite,\n      }); n.layers = a(e, i), n.images = h(e); const s = l(e); return n.tilesets = s.tilesets, n.imageCollections = s.imageCollections, n.objects = u(e), n.tiles = c(n), d(n), n;\n    };\n  }, function (t, e, i) {\n    const O = i(482); const R = i(2); const L = i(102); const k = i(224); const D = i(74); const F = i(225); t.exports = function (t, e) {\n      for (var i = R(t, 'infinite', !1), n = [], s = [], r = F(t); r.i < r.layers.length || s.length > 0;) {\n        if (r.i >= r.layers.length) { if (s.length < 1) { console.warn('TilemapParser.parseTiledJSON - Invalid layer group hierarchy'); break; }r = s.pop(); } else {\n          var o; const a = r.layers[r.i]; if (r.i++, a.type === 'tilelayer') {\n            if (a.compression)console.warn(`TilemapParser.parseTiledJSON - Layer compression is unsupported, skipping layer '${a.name}'`); else {\n              if (a.encoding && a.encoding === 'base64') { if (a.chunks) for (let h = 0; h < a.chunks.length; h++)a.chunks[h].data = O(a.chunks[h].data); a.data && (a.data = O(a.data)), delete a.encoding; } var l; var u; const c = []; let d = 0; if (i) {\n                for (var f = R(a, 'startx', 0) + a.x, p = R(a, 'starty', 0) + a.y, g = new L({\n                    name: r.name + a.name, x: r.x + R(a, 'offsetx', 0) + f * t.tilewidth, y: r.y + R(a, 'offsety', 0) + p * t.tileheight, width: a.width, height: a.height, tileWidth: t.tilewidth, tileHeight: t.tileheight, alpha: r.opacity * a.opacity, visible: r.visible && a.visible, properties: R(a, 'properties', []),\n                  }), v = 0; v < a.height; v++) { c.push([null]); for (let m = 0; m < a.width; m++)c[v][m] = null; } for (v = 0, P = a.chunks.length; v < P; v++) for (let y = a.chunks[v], x = y.x - f, T = y.y - p, w = 0, b = 0, E = y.data.length; b < E; b++) { var S; const _ = d + x; const A = w + T; (S = k(y.data[b])).gid > 0 ? ((l = new D(g, S.gid, _, A, t.tilewidth, t.tileheight)).rotation = S.rotation, l.flipX = S.flipped, c[A][_] = l) : (u = e ? null : new D(g, -1, _, A, t.tilewidth, t.tileheight), c[A][_] = u), ++d === y.width && (w++, d = 0); }\n              } else {\n                g = new L({\n                  name: r.name + a.name, x: r.x + R(a, 'offsetx', 0) + a.x, y: r.y + R(a, 'offsety', 0) + a.y, width: a.width, height: a.height, tileWidth: t.tilewidth, tileHeight: t.tileheight, alpha: r.opacity * a.opacity, visible: r.visible && a.visible, properties: R(a, 'properties', []),\n                }); for (var C = [], M = 0, P = a.data.length; M < P; M++)(S = k(a.data[M])).gid > 0 ? ((l = new D(g, S.gid, d, c.length, t.tilewidth, t.tileheight)).rotation = S.rotation, l.flipX = S.flipped, C.push(l)) : (u = e ? null : new D(g, -1, d, c.length, t.tilewidth, t.tileheight), C.push(u)), ++d === a.width && (c.push(C), d = 0, C = []);\n              }g.data = c, n.push(g);\n            }\n          } else a.type === 'group' && (o = F(t, a, r), s.push(r), r = o);\n        }\n      } return n;\n    };\n  }, function (t, e) { t.exports = function (t) { for (var e = window.atob(t), i = e.length, n = new Array(i / 4), s = 0; s < i; s += 4)n[s / 4] = (e.charCodeAt(s) | e.charCodeAt(s + 1) << 8 | e.charCodeAt(s + 2) << 16 | e.charCodeAt(s + 3) << 24) >>> 0; return n; }; }, function (t, e, i) {\n    const h = i(2); const l = i(225); t.exports = function (t) {\n      for (var e = [], i = [], n = l(t); n.i < n.layers.length || i.length > 0;) {\n        if (n.i >= n.layers.length) { if (i.length < 1) { console.warn('TilemapParser.parseTiledJSON - Invalid layer group hierarchy'); break; }n = i.pop(); } else {\n          var s; var r; var o; const a = n.layers[n.i]; n.i++, a.type === 'imagelayer' ? (s = h(a, 'offsetx', 0) + h(a, 'startx', 0), r = h(a, 'offsety', 0) + h(a, 'starty', 0), e.push({\n            name: n.name + a.name, image: a.image, x: n.x + s + a.x, y: n.y + r + a.y, alpha: n.opacity * a.opacity, visible: n.visible && a.visible, properties: h(a, 'properties', {}),\n          })) : a.type === 'group' && (o = l(t, a, n), i.push(n), n = o);\n        }\n      } return e;\n    };\n  }, function (t, e, i) { const x = i(104); const T = i(485); const w = i(226); t.exports = function (t) { for (var e, i = [], n = [], s = null, r = 0; r < t.tilesets.length; r++) { const o = t.tilesets[r]; if (o.source)console.warn(\"Phaser can't load external tilesets. Use the Embed Tileset button and then export the map again.\"); else if (o.image) { const a = new x(o.name, o.firstgid, o.tilewidth, o.tileheight, o.margin, o.spacing); if (t.version > 1) { if (Array.isArray(o.tiles)) { for (var h = {}, l = {}, u = 0; u < o.tiles.length; u++) { var c; var d; const f = o.tiles[u]; f.properties && (c = {}, f.properties.forEach((t) => { c[t.name] = t.value; }), l[f.id] = c), f.objectgroup && (h[f.id] = { objectgroup: f.objectgroup }, f.objectgroup.objects && (d = f.objectgroup.objects.map((t) => w(t)), h[f.id].objectgroup.objects = d)), f.animation && (h.hasOwnProperty(f.id) ? h[f.id].animation = f.animation : h[f.id] = { animation: f.animation }); }a.tileData = h, a.tileProperties = l; } } else if (o.tileproperties && (a.tileProperties = o.tileproperties), o.tiles) for (e in a.tileData = o.tiles, a.tileData) { var p; const g = a.tileData[e].objectgroup; g && g.objects && (p = g.objects.map((t) => w(t)), a.tileData[e].objectgroup.objects = p); }a.updateTileData(o.imagewidth, o.imageheight), i.push(a); } else { const v = new T(o.name, o.firstgid, o.tilewidth, o.tileheight, o.margin, o.spacing, o.properties); for (e in o.tiles) { const m = o.tiles[e].image; const y = o.firstgid + parseInt(e, 10); v.addImage(y, m); }n.push(v); }s && (s.lastgid = o.firstgid - 1), s = o; } return { tilesets: i, imageCollections: n }; }; }, function (t, e, i) { const n = new (i(0))({ initialize(t, e, i, n, s, r, o) { (void 0 === i || i <= 0) && (i = 32), (void 0 === n || n <= 0) && (n = 32), void 0 === s && (s = 0), void 0 === r && (r = 0), this.name = t, this.firstgid = 0 | e, this.imageWidth = 0 | i, this.imageHeight = 0 | n, this.imageMargin = 0 | s, this.imageSpacing = 0 | r, this.properties = o || {}, this.images = [], this.total = 0; }, containsImageIndex(t) { return t >= this.firstgid && t < this.firstgid + this.total; }, addImage(t, e) { return this.images.push({ gid: t, image: e }), this.total++, this; } }); t.exports = n; }, function (t, e, i) { const r = i(108); t.exports = function (t, e) { for (var i = {}, n = 0; n < e.length; n++) { const s = e[n]; r(t, s) && (i[s] = t[s]); } return i; }; }, function (t, e, i) { const d = i(2); const f = i(226); const p = i(488); const g = i(225); t.exports = function (t) { for (var e = [], i = [], n = g(t); n.i < n.layers.length || i.length > 0;) if (n.i >= n.layers.length) { if (i.length < 1) { console.warn('TilemapParser.parseTiledJSON - Invalid layer group hierarchy'); break; }n = i.pop(); } else { var s; const r = n.layers[n.i]; if (n.i++, r.opacity *= n.opacity, r.visible = n.visible && r.visible, r.type === 'objectgroup') { r.name = n.name + r.name; for (var o = n.x + d(r, 'startx', 0) + d(r, 'offsetx', 0), a = n.y + d(r, 'starty', 0) + d(r, 'offsety', 0), h = [], l = 0; l < r.objects.length; l++) { const u = f(r.objects[l], o, a); h.push(u); } const c = new p(r); c.objects = h, e.push(c); } else { r.type === 'group' && (s = g(t, r, n), i.push(n), n = s); } } return e; }; }, function (t, e, i) { const n = i(0); const s = i(2); const r = new n({ initialize(t) { void 0 === t && (t = {}), this.name = s(t, 'name', 'object layer'), this.opacity = s(t, 'opacity', 1), this.properties = s(t, 'properties', {}), this.propertyTypes = s(t, 'propertytypes', {}), this.type = s(t, 'type', 'objectgroup'), this.visible = s(t, 'visible', !0), this.objects = s(t, 'objects', []); } }); t.exports = r; }, function (t, e, i) { const p = i(104); t.exports = function (t) { for (var e = [], i = 0; i < t.imageCollections.length; i++) for (let n = t.imageCollections[i], s = n.images, r = 0; r < s.length; r++) { var o; const a = s[r]; (o = new p(a.image, a.gid, n.imageWidth, n.imageHeight, 0, 0)).updateTileData(n.imageWidth, n.imageHeight), t.tilesets.push(o); } for (i = 0; i < t.tilesets.length; i++) for (let h = (o = t.tilesets[i]).tileMargin, l = o.tileMargin, u = 0, c = 0, d = 0, f = o.firstgid; f < o.firstgid + o.total && (e[f] = [h, l, i], h += o.tileWidth + o.tileSpacing, ++u !== o.total) && (++c !== o.columns || (h = o.tileMargin, l += o.tileHeight + o.tileSpacing, c = 0, ++d !== o.rows)); f++);return e; }; }, function (t, e, i) { const l = i(18); t.exports = function (t) { for (var e, i, n, s, r, o = 0; o < t.layers.length; o++) { e = t.layers[o], 0; for (let a = 0; a < e.data.length; a++) { r = e.data[a]; for (let h = 0; h < r.length; h++)(i = r[h]) === null || i.index < 0 || (n = t.tiles[i.index][2], s = t.tilesets[n], i.width = s.tileWidth, i.height = s.tileHeight, s.tileProperties && s.tileProperties[i.index - s.firstgid] && (i.properties = l(i.properties, s.tileProperties[i.index - s.firstgid]))); } } }; }, function (t, e, i) {\n    const a = i(32); const h = i(103); const l = i(492); const u = i(493); t.exports = function (t, e, i) {\n      if (e.layer.length === 0) return console.warn(`No layers found in the Weltmeister map: ${t}`), null; for (var n = 0, s = 0, r = 0; r < e.layer.length; r++)e.layer[r].width > n && (n = e.layer[r].width), e.layer[r].height > s && (s = e.layer[r].height); const o = new h({\n        width: n, height: s, name: t, tileWidth: e.layer[0].tilesize, tileHeight: e.layer[0].tilesize, format: a.WELTMEISTER,\n      }); return o.layers = l(e, i), o.tilesets = u(e), o;\n    };\n  }, function (t, e, i) {\n    const d = i(102); const f = i(74); t.exports = function (t, e) {\n      for (var i = [], n = 0; n < t.layer.length; n++) {\n        for (var s = t.layer[n], r = new d({\n            name: s.name, width: s.width, height: s.height, tileWidth: s.tilesize, tileHeight: s.tilesize, visible: s.visible === 1,\n          }), o = [], a = [], h = 0; h < s.data.length; h++) { for (let l = 0; l < s.data[h].length; l++) { const u = s.data[h][l] - 1; const c = u > -1 ? new f(r, u, l, h, s.tilesize, s.tilesize) : e ? null : new f(r, -1, l, h, s.tilesize, s.tilesize); o.push(c); }a.push(o), o = []; }r.data = a, i.push(r);\n      } return i;\n    };\n  }, function (t, e, i) { const o = i(104); t.exports = function (t) { for (var e = [], i = [], n = 0; n < t.layer.length; n++) { const s = t.layer[n]; const r = s.tilesetName; r !== '' && i.indexOf(r) === -1 && (i.push(r), e.push(new o(r, 0, s.tilesize, s.tilesize, 0, 0))); } return e; }; }, function (t, e, i) {\n    const n = i(0); const g = i(39); const f = i(495); const v = i(18); const u = i(32); const p = i(102); const m = i(331); const s = i(80); const o = i(496); const y = i(74); const h = i(141); const c = i(104); const r = new n({\n      initialize(t, e) { this.scene = t, this.tileWidth = e.tileWidth, this.tileHeight = e.tileHeight, this.width = e.width, this.height = e.height, this.orientation = e.orientation, this.renderOrder = e.renderOrder, this.format = e.format, this.version = e.version, this.properties = e.properties, this.widthInPixels = e.widthInPixels, this.heightInPixels = e.heightInPixels, this.imageCollections = e.imageCollections, this.images = e.images, this.layers = e.layers, this.tilesets = e.tilesets, this.objects = e.objects, this.currentLayerIndex = 0; },\n      setRenderOrder(t) { const e = ['right-down', 'left-down', 'right-up', 'left-up']; return typeof t === 'number' && (t = e[t]), e.indexOf(t) > -1 && (this.renderOrder = t), this; },\n      addTilesetImage(t, e, i, n, s, r, o) { if (void 0 === t) return null; if (e == null && (e = t), !this.scene.sys.textures.exists(e)) return console.warn(`Invalid Tileset Image: ${e}`), null; const a = this.scene.sys.textures.get(e); const h = this.getTilesetIndex(t); if (h === null && this.format === u.TILED_JSON) return console.warn(`No data found for Tileset: ${t}`), null; let l = this.tilesets[h]; return l ? (l.setTileSize(i, n), l.setSpacing(s, r), l.setImage(a)) : (void 0 === i && (i = this.tileWidth), void 0 === n && (n = this.tileHeight), void 0 === s && (s = 0), void 0 === r && (r = 0), void 0 === o && (o = 0), (l = new c(t, o, i, n, s, r)).setImage(a), this.tilesets.push(l)), l; },\n      convertLayerToStatic(t) { if ((t = this.getLayer(t)) === null) return null; const e = t.tilemapLayer; if (!(e && e instanceof f)) return null; const i = new o(e.scene, e.tilemap, e.layerIndex, e.tileset, e.x, e.y); return this.scene.sys.displayList.add(i), e.destroy(), i; },\n      copy(t, e, i, n, s, r, o, a) { return a = this.getLayer(a), this._isStaticCall(a, 'copy') ? this : a !== null ? (h.Copy(t, e, i, n, s, r, o, a), this) : null; },\n      createBlankDynamicLayer(t, e, i, n, s, r, o, a) {\n        if (void 0 === i && (i = 0), void 0 === n && (n = 0), void 0 === s && (s = this.width), void 0 === r && (r = this.height), void 0 === o && (o = this.tileWidth), void 0 === a && (a = this.tileHeight), this.getLayerIndex(t) !== null) return console.warn(`Invalid Tilemap Layer ID: ${t}`), null; for (var h, l = new p({\n            name: t, tileWidth: o, tileHeight: a, width: s, height: r,\n          }), u = 0; u < r; u++) { h = []; for (let c = 0; c < s; c++)h.push(new y(l, -1, c, u, o, a, this.tileWidth, this.tileHeight)); l.data.push(h); } this.layers.push(l), this.currentLayerIndex = this.layers.length - 1; const d = new f(this.scene, this, this.currentLayerIndex, e, i, n); return d.setRenderOrder(this.renderOrder), this.scene.sys.displayList.add(d), d;\n      },\n      createDynamicLayer(t, e, i, n) { const s = this.getLayerIndex(t); if (s === null) return console.warn(`Invalid Tilemap Layer ID: ${t}`), typeof t === 'string' && console.warn(`Valid tilelayer names:\\n\\t${this.getTileLayerNames().join(',\\n\\t')}`), null; const r = this.layers[s]; if (r.tilemapLayer) return console.warn(`Tilemap Layer ID already exists:${t}`), null; this.currentLayerIndex = s, void 0 === i && (i = r.x), void 0 === n && (n = r.y); const o = new f(this.scene, this, s, e, i, n); return o.setRenderOrder(this.renderOrder), this.scene.sys.displayList.add(o), o; },\n      createFromObjects(t, e, i, n) { void 0 === i && (i = {}), void 0 === n && (n = this.scene); const s = this.getObjectLayer(t); if (!s) return console.warn(`Cannot create from object. Invalid objectgroup name given: ${t}`), typeof layerID === 'string' && console.warn(`Valid objectgroup names:\\n\\t${this.getObjectLayerNames().join(',\\n\\t')}`), null; for (var r = s.objects, o = [], a = 0; a < r.length; a++) { let h = !1; const l = r[a]; if ((void 0 !== l.gid && typeof e === 'number' && l.gid === e || void 0 !== l.id && typeof e === 'number' && l.id === e || void 0 !== l.name && typeof e === 'string' && l.name === e) && (h = !0), h) { const u = v({}, i, l.properties); u.x = l.x, u.y = l.y; const c = n.make.sprite(u); c.name = l.name, l.width && (c.displayWidth = l.width), l.height && (c.displayHeight = l.height); var d; const f = { x: c.originX * l.width, y: (c.originY - 1) * l.height }; for (const p in l.rotation && (d = g(l.rotation), m(f, d), c.rotation = d), c.x += f.x, c.y += f.y, void 0 === l.flippedHorizontal && void 0 === l.flippedVertical || c.setFlip(l.flippedHorizontal, l.flippedVertical), l.visible || (c.visible = !1), l.properties)c.hasOwnProperty(p) || c.setData(p, l.properties[p]); o.push(c); } } return o; },\n      createFromTiles(t, e, i, n, s, r) { return (r = this.getLayer(r)) === null ? null : h.CreateFromTiles(t, e, i, n, s, r); },\n      createStaticLayer(t, e, i, n) { const s = this.getLayerIndex(t); if (s === null) return console.warn(`Invalid Tilemap Layer ID: ${t}`), typeof t === 'string' && console.warn(`Valid tilelayer names:\\n\\t${this.getTileLayerNames().join(',\\n\\t')}`), null; if (this.layers[s].tilemapLayer) return console.warn(`Tilemap Layer ID already exists:${t}`), null; this.currentLayerIndex = s, void 0 === i && this.layers[s].x && (i = this.layers[s].x), void 0 === n && this.layers[s].y && (n = this.layers[s].y); const r = new o(this.scene, this, s, e, i, n); return r.setRenderOrder(this.renderOrder), this.scene.sys.displayList.add(r), r; },\n      destroy() { this.removeAllLayers(), this.tilesets.length = 0, this.objects.length = 0, this.scene = void 0; },\n      fill(t, e, i, n, s, r, o) { return (o = this.getLayer(o)) === null ? null : (this._isStaticCall(o, 'fill') || h.Fill(t, e, i, n, s, r, o), this); },\n      filterObjects(t, e, i) { if (typeof t === 'string') { const n = t; if (!(t = this.getObjectLayer(t))) return console.warn(`No object layer found with the name: ${n}`), null; } return t.objects.filter(e, i); },\n      filterTiles(t, e, i, n, s, r, o, a) { return (a = this.getLayer(a)) === null ? null : h.FilterTiles(t, e, i, n, s, r, o, a); },\n      findByIndex(t, e, i, n) { return (n = this.getLayer(n)) === null ? null : h.FindByIndex(t, e, i, n); },\n      findObject(t, e, i) { if (typeof t === 'string') { const n = t; if (!(t = this.getObjectLayer(t))) return console.warn(`No object layer found with the name: ${n}`), null; } return t.objects.find(e, i) || null; },\n      findTile(t, e, i, n, s, r, o, a) { return (a = this.getLayer(a)) === null ? null : h.FindTile(t, e, i, n, s, r, o, a); },\n      forEachTile(t, e, i, n, s, r, o, a) { return (a = this.getLayer(a)) === null ? null : (h.ForEachTile(t, e, i, n, s, r, o, a), this); },\n      getImageIndex(t) { return this.getIndex(this.images, t); },\n      getImageLayerNames() { return this.images && Array.isArray(this.images) ? this.images.map((t) => t.name) : []; },\n      getIndex(t, e) { for (let i = 0; i < t.length; i++) if (t[i].name === e) return i; return null; },\n      getLayer(t) { const e = this.getLayerIndex(t); return e !== null ? this.layers[e] : null; },\n      getObjectLayer(t) { const e = this.getIndex(this.objects, t); return e !== null ? this.objects[e] : null; },\n      getObjectLayerNames() { return this.objects && Array.isArray(this.objects) ? this.objects.map((t) => t.name) : []; },\n      getLayerIndex(t) { return void 0 === t ? this.currentLayerIndex : typeof t === 'string' ? this.getLayerIndexByName(t) : typeof t === 'number' && t < this.layers.length ? t : t instanceof o || t instanceof f ? t.layerIndex : null; },\n      getLayerIndexByName(t) { return this.getIndex(this.layers, t); },\n      getTileAt(t, e, i, n) { return (n = this.getLayer(n)) === null ? null : h.GetTileAt(t, e, i, n); },\n      getTileAtWorldXY(t, e, i, n, s) { return (s = this.getLayer(s)) === null ? null : h.GetTileAtWorldXY(t, e, i, n, s); },\n      getTileLayerNames() { return this.layers && Array.isArray(this.layers) ? this.layers.map((t) => t.name) : []; },\n      getTilesWithin(t, e, i, n, s, r) { return (r = this.getLayer(r)) === null ? null : h.GetTilesWithin(t, e, i, n, s, r); },\n      getTilesWithinShape(t, e, i, n) { return (n = this.getLayer(n)) === null ? null : h.GetTilesWithinShape(t, e, i, n); },\n      getTilesWithinWorldXY(t, e, i, n, s, r, o) { return (o = this.getLayer(o)) === null ? null : h.GetTilesWithinWorldXY(t, e, i, n, s, r, o); },\n      getTileset(t) { const e = this.getIndex(this.tilesets, t); return e !== null ? this.tilesets[e] : null; },\n      getTilesetIndex(t) { return this.getIndex(this.tilesets, t); },\n      hasTileAt(t, e, i) { return (i = this.getLayer(i)) === null ? null : h.HasTileAt(t, e, i); },\n      hasTileAtWorldXY(t, e, i, n) { return (n = this.getLayer(n)) === null ? null : h.HasTileAtWorldXY(t, e, i, n); },\n      layer: { get() { return this.layers[this.currentLayerIndex]; }, set(t) { this.setLayer(t); } },\n      putTileAt(t, e, i, n, s) { return s = this.getLayer(s), this._isStaticCall(s, 'putTileAt') || s === null ? null : h.PutTileAt(t, e, i, n, s); },\n      putTileAtWorldXY(t, e, i, n, s, r) { return r = this.getLayer(r), this._isStaticCall(r, 'putTileAtWorldXY') || r === null ? null : h.PutTileAtWorldXY(t, e, i, n, s, r); },\n      putTilesAt(t, e, i, n, s) { return s = this.getLayer(s), this._isStaticCall(s, 'putTilesAt') ? this : s === null ? null : (h.PutTilesAt(t, e, i, n, s), this); },\n      randomize(t, e, i, n, s, r) { return r = this.getLayer(r), this._isStaticCall(r, 'randomize') ? this : r === null ? null : (h.Randomize(t, e, i, n, s, r), this); },\n      calculateFacesAt(t, e, i) { return (i = this.getLayer(i)) === null ? null : (h.CalculateFacesAt(t, e, i), this); },\n      calculateFacesWithin(t, e, i, n, s) { return (s = this.getLayer(s)) === null ? null : (h.CalculateFacesWithin(t, e, i, n, s), this); },\n      removeLayer(t) { const e = this.getLayerIndex(t); if (e === null) return null; s(this.layers, e); for (let i = e; i < this.layers.length; i++) this.layers[i].tilemapLayer && this.layers[i].tilemapLayer.layerIndex--; return this.currentLayerIndex === e && (this.currentLayerIndex = 0), this; },\n      destroyLayer(t) { const e = this.getLayerIndex(t); return e !== null ? ((t = this.layers[e]).destroy(), s(this.layers, e), this.currentLayerIndex === e && (this.currentLayerIndex = 0), this) : null; },\n      removeAllLayers() { for (var t = this.layers, e = 0; e < t.length; e++)t[e].tilemapLayer && t[e].tilemapLayer.destroy(!1); return t.length = 0, this.currentLayerIndex = 0, this; },\n      removeTile(t, e, i) { void 0 === e && (e = -1), void 0 === i && (i = !0); const n = []; Array.isArray(t) || (t = [t]); for (let s = 0; s < t.length; s++) { const r = t[s]; n.push(this.removeTileAt(r.x, r.y, !0, i, r.tilemapLayer)), e > -1 && this.putTileAt(e, r.x, r.y, i, r.tilemapLayer); } return n; },\n      removeTileAt(t, e, i, n, s) { return s = this.getLayer(s), this._isStaticCall(s, 'removeTileAt') || s === null ? null : h.RemoveTileAt(t, e, i, n, s); },\n      removeTileAtWorldXY(t, e, i, n, s, r) { return r = this.getLayer(r), this._isStaticCall(r, 'removeTileAtWorldXY') || r === null ? null : h.RemoveTileAtWorldXY(t, e, i, n, s, r); },\n      renderDebug(t, e, i) { return (i = this.getLayer(i)) === null ? null : (h.RenderDebug(t, e, i), this); },\n      renderDebugFull(t, e) { for (let i = this.layers, n = 0; n < i.length; n++)h.RenderDebug(t, e, i[n]); return this; },\n      replaceByIndex(t, e, i, n, s, r, o) { return o = this.getLayer(o), this._isStaticCall(o, 'replaceByIndex') ? this : o === null ? null : (h.ReplaceByIndex(t, e, i, n, s, r, o), this); },\n      setCollision(t, e, i, n, s) { return (n = this.getLayer(n)) === null ? null : (h.SetCollision(t, e, i, n, s), this); },\n      setCollisionBetween(t, e, i, n, s) { return (s = this.getLayer(s)) === null ? null : (h.SetCollisionBetween(t, e, i, n, s), this); },\n      setCollisionByProperty(t, e, i, n) { return (n = this.getLayer(n)) === null ? null : (h.SetCollisionByProperty(t, e, i, n), this); },\n      setCollisionByExclusion(t, e, i, n) { return (n = this.getLayer(n)) === null ? null : (h.SetCollisionByExclusion(t, e, i, n), this); },\n      setCollisionFromCollisionGroup(t, e, i) { return (i = this.getLayer(i)) === null ? null : (h.SetCollisionFromCollisionGroup(t, e, i), this); },\n      setTileIndexCallback(t, e, i, n) { return (n = this.getLayer(n)) === null ? null : (h.SetTileIndexCallback(t, e, i, n), this); },\n      setTileLocationCallback(t, e, i, n, s, r, o) { return (o = this.getLayer(o)) === null ? null : (h.SetTileLocationCallback(t, e, i, n, s, r, o), this); },\n      setLayer(t) { const e = this.getLayerIndex(t); return e !== null && (this.currentLayerIndex = e), this; },\n      setBaseTileSize(t, e) { this.tileWidth = t, this.tileHeight = e, this.widthInPixels = this.width * t, this.heightInPixels = this.height * e; for (let i = 0; i < this.layers.length; i++) { this.layers[i].baseTileWidth = t, this.layers[i].baseTileHeight = e; for (let n = this.layers[i].data, s = this.layers[i].width, r = this.layers[i].height, o = 0; o < r; o++) for (let a = 0; a < s; a++) { const h = n[o][a]; h !== null && h.setSize(void 0, void 0, t, e); } } return this; },\n      setLayerTileSize(t, e, i) { if ((i = this.getLayer(i)) === null) return this; i.tileWidth = t, i.tileHeight = e; for (let n = i.data, s = i.width, r = i.height, o = 0; o < r; o++) for (let a = 0; a < s; a++) { const h = n[o][a]; h !== null && h.setSize(t, e); } return this; },\n      shuffle(t, e, i, n, s) { return s = this.getLayer(s), this._isStaticCall(s, 'shuffle') ? this : s === null ? null : (h.Shuffle(t, e, i, n, s), this); },\n      swapByIndex(t, e, i, n, s, r, o) { return o = this.getLayer(o), this._isStaticCall(o, 'swapByIndex') ? this : o === null ? null : (h.SwapByIndex(t, e, i, n, s, r, o), this); },\n      tileToWorldX(t, e, i) { return (i = this.getLayer(i)) === null ? null : h.TileToWorldX(t, e, i); },\n      tileToWorldY(t, e, i) { return (i = this.getLayer(i)) === null ? null : h.TileToWorldY(t, e, i); },\n      tileToWorldXY(t, e, i, n, s) { return (s = this.getLayer(s)) === null ? null : h.TileToWorldXY(t, e, i, n, s); },\n      weightedRandomize(t, e, i, n, s, r) { return r = this.getLayer(r), this._isStaticCall(r, 'weightedRandomize') ? this : r === null ? null : (h.WeightedRandomize(t, e, i, n, s, r), this); },\n      worldToTileX(t, e, i, n) { return (n = this.getLayer(n)) === null ? null : h.WorldToTileX(t, e, i, n); },\n      worldToTileY(t, e, i, n) { return (n = this.getLayer(n)) === null ? null : h.WorldToTileY(t, e, i, n); },\n      worldToTileXY(t, e, i, n, s, r) { return (r = this.getLayer(r)) === null ? null : h.WorldToTileXY(t, e, i, n, s, r); },\n      _isStaticCall(t, e) { return t.tilemapLayer instanceof o && (console.warn(`${e}: You cannot change the tiles in a static tilemap layer`), !0); },\n    }); t.exports = r;\n  }, function (t, e, i) {\n    const n = i(0); const s = i(12); const r = i(1345); const o = i(14); const a = i(141); const h = new n({\n      Extends: o, Mixins: [s.Alpha, s.BlendMode, s.ComputedSize, s.Depth, s.Flip, s.GetBounds, s.Origin, s.Pipeline, s.Transform, s.Visible, s.ScrollFactor, r], initialize(t, e, i, n, s, r) { o.call(this, t, 'DynamicTilemapLayer'), this.isTilemap = !0, this.tilemap = e, this.layerIndex = i, this.layer = e.layers[i], (this.layer.tilemapLayer = this).tileset = [], this.culledTiles = [], this.skipCull = !1, this.tilesDrawn = 0, this.tilesTotal = this.layer.width * this.layer.height, this.cullPaddingX = 1, this.cullPaddingY = 1, this.cullCallback = a.CullTiles, this._renderOrder = 0, this.gidMap = [], this.setTilesets(n), this.setAlpha(this.layer.alpha), this.setPosition(s, r), this.setOrigin(), this.setSize(e.tileWidth * this.layer.width, e.tileHeight * this.layer.height), this.initPipeline('TextureTintPipeline'); }, setTilesets(t) { const e = []; const i = []; const n = this.tilemap; Array.isArray(t) || (t = [t]); for (let s = 0; s < t.length; s++) { let r = t[s]; if (typeof r === 'string' && (r = n.getTileset(r)), r) { i.push(r); for (let o = r.firstgid, a = 0; a < r.total; a++)e[o + a] = r; } } this.gidMap = e, this.tileset = i; }, setRenderOrder(t) { return typeof t === 'string' && (t = ['right-down', 'left-down', 'right-up', 'left-up'].indexOf(t)), t >= 0 && t < 4 && (this._renderOrder = t), this; }, calculateFacesAt(t, e) { return a.CalculateFacesAt(t, e, this.layer), this; }, calculateFacesWithin(t, e, i, n) { return a.CalculateFacesWithin(t, e, i, n, this.layer), this; }, createFromTiles(t, e, i, n, s) { return a.CreateFromTiles(t, e, i, n, s, this.layer); }, cull(t) { return this.cullCallback(this.layer, t, this.culledTiles, this._renderOrder); }, copy(t, e, i, n, s, r, o) { return a.Copy(t, e, i, n, s, r, o, this.layer), this; }, destroy(t) { void 0 === t && (t = !0), this.tilemap && (this.layer.tilemapLayer === this && (this.layer.tilemapLayer = void 0), t && this.tilemap.removeLayer(this), this.tilemap = void 0, this.layer = void 0, this.culledTiles.length = 0, this.cullCallback = null, this.gidMap = [], this.tileset = [], o.prototype.destroy.call(this)); }, fill(t, e, i, n, s, r) { return a.Fill(t, e, i, n, s, r, this.layer), this; }, filterTiles(t, e, i, n, s, r, o) { return a.FilterTiles(t, e, i, n, s, r, o, this.layer); }, findByIndex(t, e, i) { return a.FindByIndex(t, e, i, this.layer); }, findTile(t, e, i, n, s, r, o) { return a.FindTile(t, e, i, n, s, r, o, this.layer); }, forEachTile(t, e, i, n, s, r, o) { return a.ForEachTile(t, e, i, n, s, r, o, this.layer), this; }, getTileAt(t, e, i) { return a.GetTileAt(t, e, i, this.layer); }, getTileAtWorldXY(t, e, i, n) { return a.GetTileAtWorldXY(t, e, i, n, this.layer); }, getTilesWithin(t, e, i, n, s) { return a.GetTilesWithin(t, e, i, n, s, this.layer); }, getTilesWithinShape(t, e, i) { return a.GetTilesWithinShape(t, e, i, this.layer); }, getTilesWithinWorldXY(t, e, i, n, s, r) { return a.GetTilesWithinWorldXY(t, e, i, n, s, r, this.layer); }, hasTileAt(t, e) { return a.HasTileAt(t, e, this.layer); }, hasTileAtWorldXY(t, e, i) { return a.HasTileAtWorldXY(t, e, i, this.layer); }, putTileAt(t, e, i, n) { return a.PutTileAt(t, e, i, n, this.layer); }, putTileAtWorldXY(t, e, i, n, s) { return a.PutTileAtWorldXY(t, e, i, n, s, this.layer); }, putTilesAt(t, e, i, n) { return a.PutTilesAt(t, e, i, n, this.layer), this; }, randomize(t, e, i, n, s) { return a.Randomize(t, e, i, n, s, this.layer), this; }, removeTileAt(t, e, i, n) { return a.RemoveTileAt(t, e, i, n, this.layer); }, removeTileAtWorldXY(t, e, i, n, s) { return a.RemoveTileAtWorldXY(t, e, i, n, s, this.layer); }, renderDebug(t, e) { return a.RenderDebug(t, e, this.layer), this; }, replaceByIndex(t, e, i, n, s, r) { return a.ReplaceByIndex(t, e, i, n, s, r, this.layer), this; }, setSkipCull(t) { return void 0 === t && (t = !0), this.skipCull = t, this; }, setCullPadding(t, e) { return void 0 === t && (t = 1), void 0 === e && (e = 1), this.cullPaddingX = t, this.cullPaddingY = e, this; }, setCollision(t, e, i, n) { return a.SetCollision(t, e, i, this.layer, n), this; }, setCollisionBetween(t, e, i, n) { return a.SetCollisionBetween(t, e, i, n, this.layer), this; }, setCollisionByProperty(t, e, i) { return a.SetCollisionByProperty(t, e, i, this.layer), this; }, setCollisionByExclusion(t, e, i) { return a.SetCollisionByExclusion(t, e, i, this.layer), this; }, setCollisionFromCollisionGroup(t, e) { return a.SetCollisionFromCollisionGroup(t, e, this.layer), this; }, setTileIndexCallback(t, e, i) { return a.SetTileIndexCallback(t, e, i, this.layer), this; }, setTileLocationCallback(t, e, i, n, s, r) { return a.SetTileLocationCallback(t, e, i, n, s, r, this.layer), this; }, shuffle(t, e, i, n) { return a.Shuffle(t, e, i, n, this.layer), this; }, swapByIndex(t, e, i, n, s, r) { return a.SwapByIndex(t, e, i, n, s, r, this.layer), this; }, tileToWorldX(t, e) { return a.TileToWorldX(t, e, this.layer); }, tileToWorldY(t, e) { return a.TileToWorldY(t, e, this.layer); }, tileToWorldXY(t, e, i, n) { return a.TileToWorldXY(t, e, i, n, this.layer); }, weightedRandomize(t, e, i, n, s) { return a.WeightedRandomize(t, e, i, n, s, this.layer), this; }, worldToTileX(t, e, i) { return a.WorldToTileX(t, e, i, this.layer); }, worldToTileY(t, e, i) { return a.WorldToTileY(t, e, i, this.layer); }, worldToTileXY(t, e, i, n, s) { return a.WorldToTileXY(t, e, i, n, s, this.layer); },\n    }); t.exports = h;\n  }, function (t, e, i) {\n    const n = i(0); const s = i(12); const o = i(20); const a = i(14); const r = i(1348); const h = i(141); const l = i(29); const L = i(9); const u = new n({\n      Extends: a, Mixins: [s.Alpha, s.BlendMode, s.ComputedSize, s.Depth, s.Flip, s.GetBounds, s.Origin, s.Pipeline, s.Transform, s.Visible, s.ScrollFactor, r], initialize(t, e, i, n, s, r) { a.call(this, t, 'StaticTilemapLayer'), this.isTilemap = !0, this.tilemap = e, this.layerIndex = i, this.layer = e.layers[i], (this.layer.tilemapLayer = this).tileset = [], this.culledTiles = [], this.skipCull = !1, this.tilesDrawn = 0, this.tilesTotal = this.layer.width * this.layer.height, this.cullPaddingX = 1, this.cullPaddingY = 1, this.cullCallback = h.CullTiles, this.renderer = t.sys.game.renderer, this.vertexBuffer = [], this.bufferData = [], this.vertexViewF32 = [], this.vertexViewU32 = [], this.dirty = [], this.vertexCount = [], this._renderOrder = 0, this._tempMatrix = new l(), this.gidMap = [], this.setTilesets(n), this.setAlpha(this.layer.alpha), this.setPosition(s, r), this.setOrigin(), this.setSize(e.tileWidth * this.layer.width, e.tileHeight * this.layer.height), this.updateVBOData(), this.initPipeline('TextureTintPipeline'), t.sys.game.events.on(o.CONTEXT_RESTORED, function () { this.updateVBOData(); }, this); }, setTilesets(t) { const e = []; const i = []; const n = this.tilemap; Array.isArray(t) || (t = [t]); for (let s = 0; s < t.length; s++) { let r = t[s]; if (typeof r === 'string' && (r = n.getTileset(r)), r) { i.push(r); for (let o = r.firstgid, a = 0; a < r.total; a++)e[o + a] = r; } } this.gidMap = e, this.tileset = i; }, updateVBOData() { for (let t = 0; t < this.tileset.length; t++) this.dirty[t] = !0, this.vertexCount[t] = 0, this.vertexBuffer[t] = null, this.bufferData[t] = null, this.vertexViewF32[t] = null, this.vertexViewU32[t] = null; return this; }, upload(t, e) { const i = this.renderer; const n = i.gl; const s = i.pipelines.TextureTintPipeline; if (this.dirty[e]) { let r; let o; let a; const h = this.tileset[e]; const l = this.layer.width; const u = this.layer.height; const c = h.image.source[0].width; const d = h.image.source[0].height; const f = this.layer.data; const p = this._renderOrder; const g = h.firstgid; const v = h.firstgid + h.total; let m = this.vertexBuffer[e]; let y = this.bufferData[e]; let x = -1; const T = l * u * s.vertexSize * 6; if (this.vertexCount[e] = 0, y === null && (y = new ArrayBuffer(T), this.bufferData[e] = y, this.vertexViewF32[e] = new Float32Array(y), this.vertexViewU32[e] = new Uint32Array(y)), p === 0) for (o = 0; o < u; o++) for (a = 0; a < l; a++)!(r = f[o][a]) || r.index < g || r.index > v || !r.visible || (x = this.batchTile(x, r, h, c, d, t, e)); else if (p === 1) for (o = 0; o < u; o++) for (a = l - 1; a >= 0; a--)!(r = f[o][a]) || r.index < g || r.index > v || !r.visible || (x = this.batchTile(x, r, h, c, d, t, e)); else if (p === 2) for (o = u - 1; o >= 0; o--) for (a = 0; a < l; a++)!(r = f[o][a]) || r.index < g || r.index > v || !r.visible || (x = this.batchTile(x, r, h, c, d, t, e)); else if (p === 3) for (o = u - 1; o >= 0; o--) for (a = l - 1; a >= 0; a--)!(r = f[o][a]) || r.index < g || r.index > v || !r.visible || (x = this.batchTile(x, r, h, c, d, t, e)); this.dirty[e] = !1, m === null ? (m = i.createVertexBuffer(y, n.STATIC_DRAW), this.vertexBuffer[e] = m) : (i.setVertexBuffer(m), n.bufferSubData(n.ARRAY_BUFFER, 0, y)); } return this; }, batchTile(t, e, i, n, s, r, o) { const a = i.getTileTextureCoordinates(e.index); if (!a) return t; let h = i.tileWidth; let l = i.tileHeight; const u = h / 2; const c = l / 2; const d = a.x / n; const f = a.y / s; const p = (a.x + h) / n; const g = (a.y + l) / s; const v = this._tempMatrix; let m = -u; let y = -c; e.flipX && (h *= -1, m += i.tileWidth), e.flipY && (l *= -1, y += i.tileHeight); const x = m + h; const T = y + l; v.applyITRS(u + e.pixelX, c + e.pixelY, e.rotation, 1, 1); const w = L.getTintAppendFloatAlpha(16777215, r.alpha * this.alpha * e.alpha); let b = v.getX(m, y); let E = v.getY(m, y); let S = v.getX(m, T); let _ = v.getY(m, T); let A = v.getX(x, T); let C = v.getY(x, T); let M = v.getX(x, y); let P = v.getY(x, y); r.roundPixels && (b = Math.round(b), E = Math.round(E), S = Math.round(S), _ = Math.round(_), A = Math.round(A), C = Math.round(C), M = Math.round(M), P = Math.round(P)); const O = this.vertexViewF32[o]; const R = this.vertexViewU32[o]; return O[++t] = b, O[++t] = E, O[++t] = d, O[++t] = f, O[++t] = 0, R[++t] = w, O[++t] = S, O[++t] = _, O[++t] = d, O[++t] = g, O[++t] = 0, R[++t] = w, O[++t] = A, O[++t] = C, O[++t] = p, O[++t] = g, O[++t] = 0, R[++t] = w, O[++t] = b, O[++t] = E, O[++t] = d, O[++t] = f, O[++t] = 0, R[++t] = w, O[++t] = A, O[++t] = C, O[++t] = p, O[++t] = g, O[++t] = 0, R[++t] = w, O[++t] = M, O[++t] = P, O[++t] = p, O[++t] = f, O[++t] = 0, R[++t] = w, this.vertexCount[o] += 6, t; }, setRenderOrder(t) { if (typeof t === 'string' && (t = ['right-down', 'left-down', 'right-up', 'left-up'].indexOf(t)), t >= 0 && t < 4) { this._renderOrder = t; for (let e = 0; e < this.tileset.length; e++) this.dirty[e] = !0; } return this; }, calculateFacesAt(t, e) { return h.CalculateFacesAt(t, e, this.layer), this; }, calculateFacesWithin(t, e, i, n) { return h.CalculateFacesWithin(t, e, i, n, this.layer), this; }, createFromTiles(t, e, i, n, s) { return h.CreateFromTiles(t, e, i, n, s, this.layer); }, cull(t) { return this.cullCallback(this.layer, t, this.culledTiles); }, setSkipCull(t) { return void 0 === t && (t = !0), this.skipCull = t, this; }, setCullPadding(t, e) { return void 0 === t && (t = 1), void 0 === e && (e = 1), this.cullPaddingX = t, this.cullPaddingY = e, this; }, findByIndex(t, e, i) { return h.FindByIndex(t, e, i, this.layer); }, findTile(t, e, i, n, s, r, o) { return h.FindTile(t, e, i, n, s, r, o, this.layer); }, filterTiles(t, e, i, n, s, r, o) { return h.FilterTiles(t, e, i, n, s, r, o, this.layer); }, forEachTile(t, e, i, n, s, r, o) { return h.ForEachTile(t, e, i, n, s, r, o, this.layer), this; }, getTileAt(t, e, i) { return h.GetTileAt(t, e, i, this.layer); }, getTileAtWorldXY(t, e, i, n) { return h.GetTileAtWorldXY(t, e, i, n, this.layer); }, getTilesWithin(t, e, i, n, s) { return h.GetTilesWithin(t, e, i, n, s, this.layer); }, getTilesWithinWorldXY(t, e, i, n, s, r) { return h.GetTilesWithinWorldXY(t, e, i, n, s, r, this.layer); }, getTilesWithinShape(t, e, i) { return h.GetTilesWithinShape(t, e, i, this.layer); }, hasTileAt(t, e) { return h.HasTileAt(t, e, this.layer); }, hasTileAtWorldXY(t, e, i) { return h.HasTileAtWorldXY(t, e, i, this.layer); }, renderDebug(t, e) { return h.RenderDebug(t, e, this.layer), this; }, setCollision(t, e, i, n) { return h.SetCollision(t, e, i, this.layer, n), this; }, setCollisionBetween(t, e, i, n) { return h.SetCollisionBetween(t, e, i, n, this.layer), this; }, setCollisionByProperty(t, e, i) { return h.SetCollisionByProperty(t, e, i, this.layer), this; }, setCollisionByExclusion(t, e, i) { return h.SetCollisionByExclusion(t, e, i, this.layer), this; }, setTileIndexCallback(t, e, i) { return h.SetTileIndexCallback(t, e, i, this.layer), this; }, setCollisionFromCollisionGroup(t, e) { return h.SetCollisionFromCollisionGroup(t, e, this.layer), this; }, setTileLocationCallback(t, e, i, n, s, r) { return h.SetTileLocationCallback(t, e, i, n, s, r, this.layer), this; }, tileToWorldX(t, e) { return h.TileToWorldX(t, e, this.layer); }, tileToWorldY(t, e) { return h.TileToWorldY(t, e, this.layer); }, tileToWorldXY(t, e, i, n) { return h.TileToWorldXY(t, e, i, n, this.layer); }, worldToTileX(t, e, i) { return h.WorldToTileX(t, e, i, this.layer); }, worldToTileY(t, e, i) { return h.WorldToTileY(t, e, i, this.layer); }, worldToTileXY(t, e, i, n, s) { return h.WorldToTileXY(t, e, i, n, s, this.layer); }, destroy(t) { if (void 0 === t && (t = !0), this.tilemap) { this.layer.tilemapLayer === this && (this.layer.tilemapLayer = void 0), t && this.tilemap.removeLayer(this), this.tilemap = void 0, this.layer = void 0, this.culledTiles.length = 0, this.cullCallback = null; for (let e = 0; e < this.tileset.length; e++) this.dirty[e] = !0, this.vertexCount[e] = 0, this.vertexBuffer[e] = null, this.bufferData[e] = null, this.vertexViewF32[e] = null, this.vertexViewU32[e] = null; this.gidMap = [], this.tileset = [], a.prototype.destroy.call(this); } },\n    }); t.exports = u;\n  }, function (t, e, i) {\n    const n = i(0); const s = i(2); const r = new n({\n      initialize(t) { this.delay = 0, this.repeat = 0, this.repeatCount = 0, this.loop = !1, this.callback, this.callbackScope, this.args, this.timeScale = 1, this.startAt = 0, this.elapsed = 0, this.paused = !1, this.hasDispatched = !1, this.reset(t); }, reset(t) { return this.delay = s(t, 'delay', 0), this.repeat = s(t, 'repeat', 0), this.loop = s(t, 'loop', !1), this.callback = s(t, 'callback', void 0), this.callbackScope = s(t, 'callbackScope', this.callback), this.args = s(t, 'args', []), this.timeScale = s(t, 'timeScale', 1), this.startAt = s(t, 'startAt', 0), this.paused = s(t, 'paused', !1), this.elapsed = this.startAt, this.hasDispatched = !1, this.repeatCount = this.repeat === -1 || this.loop ? 999999999999 : this.repeat, this; }, getProgress() { return this.elapsed / this.delay; }, getOverallProgress() { if (this.repeat > 0) { const t = this.delay + this.delay * this.repeat; return (this.elapsed + this.delay * (this.repeat - this.repeatCount)) / t; } return this.getProgress(); }, getRepeatCount() { return this.repeatCount; }, getElapsed() { return this.elapsed; }, getElapsedSeconds() { return 0.001 * this.elapsed; }, remove(t) { void 0 === t && (t = !1), this.elapsed = this.delay, this.hasDispatched = !t, this.repeatCount = 0; }, destroy() { this.callback = void 0, this.callbackScope = void 0, this.args = []; },\n    }); t.exports = r;\n  }, function (t, e, i) { const n = i(1357); t.exports = function (t) { let e; const i = []; if (t.hasOwnProperty('props')) for (e in t.props)e.substr(0, 1) !== '_' && i.push({ key: e, value: t.props[e] }); else for (e in t)n.indexOf(e) === -1 && e.substr(0, 1) !== '_' && i.push({ key: e, value: t[e] }); return i; }; }, function (t, e, i) { const n = i(6); t.exports = function (t) { let e = n(t, 'tweens', null); return e === null ? [] : (typeof e === 'function' && (e = e.call()), Array.isArray(e) || (e = [e]), e); }; }, function (t, e, i) { const A = i(230); const C = i(15); const M = i(88); const P = i(69); const O = i(145); const R = i(6); const L = i(229); const k = i(231); const D = i(233); t.exports = function (t, e, i) { void 0 === i && (i = A); const n = R(e, 'from', 0); const s = R(e, 'to', 1); const r = [{ value: n }]; const o = O(e, 'delay', i.delay); const a = O(e, 'duration', i.duration); const h = R(e, 'easeParams', i.easeParams); const l = P(R(e, 'ease', i.ease), h); const u = O(e, 'hold', i.hold); const c = O(e, 'repeat', i.repeat); const d = O(e, 'repeatDelay', i.repeatDelay); const f = M(e, 'yoyo', i.yoyo); const p = []; const g = L('value', s); const v = D(r[0], 0, 'value', g.getEnd, g.getStart, g.getActive, l, o, a, f, u, c, d, !1, !1); v.start = n, v.current = n, v.to = s, p.push(v); const m = new k(t, p, r); m.offset = C(e, 'offset', null), m.completeDelay = C(e, 'completeDelay', 0), m.loop = Math.round(C(e, 'loop', 0)), m.loopDelay = Math.round(C(e, 'loopDelay', 0)), m.paused = M(e, 'paused', !1), m.useFrames = M(e, 'useFrames', !1); for (let y = R(e, 'callbackScope', m), x = [m, null], T = k.TYPES, w = 0; w < T.length; w++) { var b; var E; const S = T[w]; const _ = R(e, S, !1); _ && (b = R(e, `${S}Scope`, y), E = R(e, `${S}Params`, []), m.setCallback(S, _, x.concat(E), b)); } return m; }; }, function (t, e, i) { const A = i(69); const C = i(6); const M = i(13); t.exports = function (t, e) { void 0 === e && (e = {}); let h = C(e, 'start', 0); const i = C(e, 'ease', null); const n = C(e, 'grid', null); const a = C(e, 'from', 0); const l = a === 'first'; const u = a === 'center'; const c = a === 'last'; const d = typeof a === 'number'; const f = Array.isArray(t); const p = f ? parseFloat(t[0]) : parseFloat(t); const g = f ? parseFloat(t[1]) : 0; const v = Math.max(p, g); if (f && (h += p), n) { let s; let r; var m = n[0]; var y = n[1]; let o = 0; let x = 0; var T = []; c ? (o = m - 1, x = y - 1) : d ? (o = a % m, x = Math.floor(a / m)) : u && (o = (m - 1) / 2, x = (y - 1) / 2); for (var w = M.MIN_SAFE_INTEGER, b = 0; b < y; b++) { T[b] = []; for (let E = 0; E < m; E++) { s = o - E, r = x - b; const S = Math.sqrt(s * s + r * r); w < S && (w = S), T[b][E] = S; } } } const _ = i ? A(i) : null; return n ? function (t, e, i, n) { let s; let r = 0; const o = n % m; const a = Math.floor(n / m); return o >= 0 && o < m && a >= 0 && a < y && (r = T[a][o]), (f ? (s = g - p, _ ? r / w * s * _(r / w) : r / w * s) : _ ? r * p * _(r / w) : r * p) + h; } : function (t, e, i, n, s) { let r; let o; return s--, l ? r = n : u ? r = Math.abs(s / 2 - n) : c ? r = s - n : d && (r = Math.abs(a - n)), (f ? (o = u ? (g - p) / s * (2 * r) : (g - p) / s * r, _ ? o * _(r / s) : o) : _ ? s * v * _(r / s) : r * p) + h; }; }; }, function (t, e, i) { const S = i(67); const _ = i(230); const A = i(15); const C = i(88); const M = i(69); const P = i(145); const O = i(228); const R = i(499); const L = i(6); const k = i(503); const D = i(146); t.exports = function (t, e) { const i = new k(t); i.completeDelay = A(e, 'completeDelay', 0), i.loop = Math.round(A(e, 'loop', 0)), i.loopDelay = Math.round(A(e, 'loopDelay', 0)), i.paused = C(e, 'paused', !1), i.useFrames = C(e, 'useFrames', !1); let n; let s; const r = L(e, 'callbackScope', i); const o = [i]; const a = L(e, 'onStart', !1); a && (n = L(e, 'onStartScope', r), s = L(e, 'onStartParams', []), i.setCallback('onStart', a, o.concat(s), n)); let h; let l; const u = L(e, 'onUpdate', !1); u && (h = L(e, 'onUpdateScope', r), l = L(e, 'onUpdateParams', []), i.setCallback('onUpdate', u, o.concat(l), h)); let c; let d; const f = L(e, 'onLoop', !1); f && (c = L(e, 'onLoopScope', r), d = L(e, 'onLoopParams', []), i.setCallback('onLoop', f, o.concat(d), c)); let p; let g; const v = L(e, 'onYoyo', !1); v && (p = L(e, 'onYoyoScope', r), g = L(e, 'onYoyoParams', []), i.setCallback('onYoyo', v, o.concat(null, g), p)); let m; let y; const x = L(e, 'onComplete', !1); x && (m = L(e, 'onCompleteScope', r), y = L(e, 'onCompleteParams', []), i.setCallback('onComplete', x, o.concat(y), m)); const T = R(e); if (T.length === 0) return i.paused = !0, i; const w = S(_); w.targets = O(e); const b = A(e, 'totalDuration', 0); w.duration = b > 0 ? Math.floor(b / T.length) : P(e, 'duration', w.duration), w.delay = P(e, 'delay', w.delay), w.easeParams = L(e, 'easeParams', w.easeParams), w.ease = M(L(e, 'ease', w.ease), w.easeParams), w.hold = P(e, 'hold', w.hold), w.repeat = P(e, 'repeat', w.repeat), w.repeatDelay = P(e, 'repeatDelay', w.repeatDelay), w.yoyo = C(e, 'yoyo', w.yoyo), w.flipX = C(e, 'flipX', w.flipX), w.flipY = C(e, 'flipY', w.flipY); for (let E = 0; E < T.length; E++)i.queue(D(i, T[E], w)); return i; }; }, function (t, e, i) {\n    const n = i(0); const s = i(10); const r = i(232); const o = i(146); const a = i(89); var h = new n({\n      Extends: s,\n      initialize(t) {\n        s.call(this), this.manager = t, this.isTimeline = !0, this.data = [], this.totalData = 0, this.useFrames = !1, this.timeScale = 1, this.loop = 0, this.loopDelay = 0, this.loopCounter = 0, this.completeDelay = 0, this.countdown = 0, this.state = a.PENDING_ADD, this._pausedState = a.PENDING_ADD, this.paused = !1, this.elapsed = 0, this.totalElapsed = 0, this.duration = 0, this.progress = 0, this.totalDuration = 0, this.totalProgress = 0, this.callbacks = {\n          onComplete: null, onLoop: null, onStart: null, onUpdate: null, onYoyo: null,\n        }, this.callbackScope;\n      },\n      dispatchTimelineEvent(t, e) { this.emit(t, this), e && e.func.apply(e.scope, e.params); },\n      setTimeScale(t) { return this.timeScale = t, this; },\n      getTimeScale() { return this.timeScale; },\n      isPlaying() { return this.state === a.ACTIVE; },\n      add(t) { return this.queue(o(this, t)); },\n      queue(t) { return this.isPlaying() || (t.parent = this, t.parentIsTimeline = !0, this.data.push(t), this.totalData = this.data.length), this; },\n      hasOffset(t) { return t.offset !== null; },\n      isOffsetAbsolute(t) { return typeof t === 'number'; },\n      isOffsetRelative(t) { if (typeof t === 'string') { const e = t[0]; if (e === '-' || e === '+') return !0; } return !1; },\n      getRelativeOffset(t, e) { const i = t[0]; const n = parseFloat(t.substr(2)); let s = e; switch (i) { case '+': s += n; break; case '-': s -= n; } return Math.max(0, s); },\n      calcDuration() { for (var t = 0, e = 0, i = 0, n = 0; n < this.totalData; n++) { const s = this.data[n]; s.init(), this.hasOffset(s) ? this.isOffsetAbsolute(s.offset) ? (s.calculatedOffset = s.offset, s.offset === 0 && (i = 0)) : this.isOffsetRelative(s.offset) && (s.calculatedOffset = this.getRelativeOffset(s.offset, t)) : s.calculatedOffset = i, t = s.totalDuration + s.calculatedOffset, e += s.totalDuration, i += s.totalDuration; } this.duration = e, this.loopCounter = this.loop === -1 ? 999999999999 : this.loop, this.loopCounter > 0 ? this.totalDuration = this.duration + this.completeDelay + (this.duration + this.loopDelay) * this.loopCounter : this.totalDuration = this.duration + this.completeDelay; },\n      init() { return this.calcDuration(), this.progress = 0, this.totalProgress = 0, !this.paused || (this.state = a.PAUSED, !1); },\n      resetTweens(t) { for (let e = 0; e < this.totalData; e++) { this.data[e].play(t); } },\n      setCallback(t, e, i, n) { return h.TYPES.indexOf(t) !== -1 && (this.callbacks[t] = { func: e, scope: n, params: i }), this; },\n      makeActive(t) { return this.manager.makeActive(t); },\n      play() { if (this.state !== a.ACTIVE) { if (this.paused) return this.paused = !1, void this.manager.makeActive(this); this.resetTweens(!1), this.state = a.ACTIVE, this.dispatchTimelineEvent(r.TIMELINE_START, this.callbacks.onStart); } },\n      nextState() { this.loopCounter > 0 ? (this.elapsed = 0, this.progress = 0, this.loopCounter--, this.resetTweens(!0), this.loopDelay > 0 ? (this.countdown = this.loopDelay, this.state = a.LOOP_DELAY) : (this.state = a.ACTIVE, this.dispatchTimelineEvent(r.TIMELINE_LOOP, this.callbacks.onLoop))) : this.completeDelay > 0 ? (this.state = a.COMPLETE_DELAY, this.countdown = this.completeDelay) : (this.state = a.PENDING_REMOVE, this.dispatchTimelineEvent(r.TIMELINE_COMPLETE, this.callbacks.onComplete)); },\n      update(t, e) { if (this.state !== a.PAUSED) { switch (this.useFrames && (e = +this.manager.timeScale), e *= this.timeScale, this.elapsed += e, this.progress = Math.min(this.elapsed / this.duration, 1), this.totalElapsed += e, this.totalProgress = Math.min(this.totalElapsed / this.totalDuration, 1), this.state) { case a.ACTIVE: for (var i = this.totalData, n = 0; n < this.totalData; n++) { this.data[n].update(t, e) && i--; } this.dispatchTimelineEvent(r.TIMELINE_UPDATE, this.callbacks.onUpdate), i === 0 && this.nextState(); break; case a.LOOP_DELAY: this.countdown -= e, this.countdown <= 0 && (this.state = a.ACTIVE, this.dispatchTimelineEvent(r.TIMELINE_LOOP, this.callbacks.onLoop)); break; case a.COMPLETE_DELAY: this.countdown -= e, this.countdown <= 0 && (this.state = a.PENDING_REMOVE, this.dispatchTimelineEvent(r.TIMELINE_COMPLETE, this.callbacks.onComplete)); } return this.state === a.PENDING_REMOVE; } },\n      stop() { this.state = a.PENDING_REMOVE; },\n      pause() { if (this.state !== a.PAUSED) return this.paused = !0, this._pausedState = this.state, this.state = a.PAUSED, this.emit(r.TIMELINE_PAUSE, this), this; },\n      resume() { return this.state === a.PAUSED && (this.paused = !1, this.state = this._pausedState, this.emit(r.TIMELINE_RESUME, this)), this; },\n      hasTarget(t) { for (let e = 0; e < this.data.length; e++) if (this.data[e].hasTarget(t)) return !0; return !1; },\n      destroy() { for (let t = 0; t < this.data.length; t++) this.data[t].stop(); },\n    }); h.TYPES = ['onStart', 'onUpdate', 'onLoop', 'onComplete', 'onYoyo'], t.exports = h;\n  }, function (t, e, i) {\n    const n = i(151); const s = i(0); const r = i(111); const o = new s({\n      initialize(t) { this.parent = t, this.animationManager = t.scene.sys.anims, this.animationManager.once(r.REMOVE_ANIMATION, this.remove, this), this.isPlaying = !1, this.currentAnim = null, this.currentFrame = null, this.nextAnim = null, this.nextAnimsQueue = [], this._timeScale = 1, this.frameRate = 0, this.duration = 0, this.msPerFrame = 0, this.skipMissedFrames = !0, this._delay = 0, this._repeat = 0, this._repeatDelay = 0, this._yoyo = !1, this.forward = !0, this._reverse = !1, this.accumulator = 0, this.nextTick = 0, this.repeatCounter = 0, this.pendingRepeat = !1, this._paused = !1, this._wasPlaying = !1, this._pendingStop = 0, this._pendingStopValue; }, chain(t) { return t instanceof n && (t = t.key), this.nextAnim === null ? this.nextAnim = t : this.nextAnimsQueue.push(t), this.parent; }, setDelay(t) { return void 0 === t && (t = 0), this._delay = t, this.parent; }, getDelay() { return this._delay; }, delayedPlay(t, e, i) { return this.play(e, !0, i), this.nextTick += t, this.parent; }, getCurrentKey() { if (this.currentAnim) return this.currentAnim.key; }, load(t, e) { return void 0 === e && (e = 0), this.isPlaying && this.stop(), this.animationManager.load(this, t, e), this.parent; }, pause(t) { return this._paused || (this._paused = !0, this._wasPlaying = this.isPlaying, this.isPlaying = !1), void 0 !== t && this.updateFrame(t), this.parent; }, resume(t) { return this._paused && (this._paused = !1, this.isPlaying = this._wasPlaying), void 0 !== t && this.updateFrame(t), this.parent; }, isPaused: { get() { return this._paused; } }, play(t, e, i) { return void 0 === e && (e = !1), void 0 === i && (i = 0), t instanceof n && (t = t.key), e && this.isPlaying && this.currentAnim.key === t ? this.parent : (this.forward = !0, this._reverse = !1, this._paused = !1, this._wasPlaying = !0, this._startAnimation(t, i)); }, playReverse(t, e, i) { return void 0 === e && (e = !1), void 0 === i && (i = 0), t instanceof n && (t = t.key), e && this.isPlaying && this.currentAnim.key === t ? this.parent : (this.forward = !1, this._reverse = !0, this._startAnimation(t, i)); }, _startAnimation(t, e) { this.load(t, e); const i = this.currentAnim; const n = this.parent; if (!i) return n; this.repeatCounter = this._repeat === -1 ? Number.MAX_VALUE : this._repeat, i.getFirstTick(this), this.isPlaying = !0, this.pendingRepeat = !1, i.showOnStart && (n.visible = !0); const s = this.currentFrame; return i.emit(r.ANIMATION_START, i, s, n), n.emit(r.SPRITE_ANIMATION_KEY_START + t, i, s, n), n.emit(r.SPRITE_ANIMATION_START, i, s, n), n; }, reverse() { return this.isPlaying && (this._reverse = !this._reverse, this.forward = !this.forward), this.parent; }, getProgress() { let t = this.currentFrame.progress; return this.forward || (t = 1 - t), t; }, setProgress(t) { return this.forward || (t = 1 - t), this.setCurrentFrame(this.currentAnim.getFrameByProgress(t)), this.parent; }, remove(t, e) { void 0 === e && (e = this.currentAnim), this.isPlaying && e.key === this.currentAnim.key && (this.stop(), this.setCurrentFrame(this.currentAnim.frames[0])); }, getRepeat() { return this._repeat; }, setRepeat(t) { return this._repeat = t, this.repeatCounter = t === -1 ? Number.MAX_VALUE : t, this.parent; }, getRepeatDelay() { return this._repeatDelay; }, setRepeatDelay(t) { return this._repeatDelay = t, this.parent; }, restart(t) { void 0 === t && (t = !1); const e = this.currentAnim; e.getFirstTick(this, t), this.forward = !0, this.isPlaying = !0, this.pendingRepeat = !1, this._paused = !1, this.updateFrame(e.frames[0]); const i = this.parent; const n = this.currentFrame; return e.emit(r.ANIMATION_RESTART, e, n, i), i.emit(r.SPRITE_ANIMATION_KEY_RESTART + e.key, e, n, i), i.emit(r.SPRITE_ANIMATION_RESTART, e, n, i), this.parent; }, stop() { this._pendingStop = 0, this.isPlaying = !1; let t; const e = this.parent; const i = this.currentAnim; const n = this.currentFrame; return i && (i.emit(r.ANIMATION_COMPLETE, i, n, e), e.emit(r.SPRITE_ANIMATION_KEY_COMPLETE + i.key, i, n, e), e.emit(r.SPRITE_ANIMATION_COMPLETE, i, n, e)), this.nextAnim && (t = this.nextAnim, this.nextAnim = this.nextAnimsQueue.length > 0 ? this.nextAnimsQueue.shift() : null, this.play(t)), e; }, stopAfterDelay(t) { return this._pendingStop = 1, this._pendingStopValue = t, this.parent; }, stopOnRepeat() { return this._pendingStop = 2, this.parent; }, stopOnFrame(t) { return this._pendingStop = 3, this._pendingStopValue = t, this.parent; }, setTimeScale(t) { return void 0 === t && (t = 1), this._timeScale = t, this.parent; }, getTimeScale() { return this._timeScale; }, getTotalFrames() { return this.currentAnim.frames.length; }, update(t, e) { if (this.currentAnim && this.isPlaying && !this.currentAnim.paused) { if (this.accumulator += e * this._timeScale, this._pendingStop === 1 && (this._pendingStopValue -= e, this._pendingStopValue <= 0)) return this.currentAnim.completeAnimation(this); this.accumulator >= this.nextTick && this.currentAnim.setFrame(this); } }, setCurrentFrame(t) { const e = this.parent; return this.currentFrame = t, e.texture = t.frame.texture, e.frame = t.frame, e.isCropped && e.frame.updateCropUVs(e._crop, e.flipX, e.flipY), e.setSizeToFrame(), e._originComponent && (t.frame.customPivot ? e.setOrigin(t.frame.pivotX, t.frame.pivotY) : e.updateDisplayOrigin()), e; }, updateFrame(t) { let e; const i = this.setCurrentFrame(t); this.isPlaying && (t.setAlpha && (i.alpha = t.alpha), e = this.currentAnim, i.emit(r.SPRITE_ANIMATION_KEY_UPDATE + e.key, e, t, i), i.emit(r.SPRITE_ANIMATION_UPDATE, e, t, i), this._pendingStop === 3 && this._pendingStopValue === t && this.currentAnim.completeAnimation(this)); }, nextFrame() { return this.currentAnim && this.currentAnim.nextFrame(this), this.parent; }, previousFrame() { return this.currentAnim && this.currentAnim.previousFrame(this), this.parent; }, setYoyo(t) { return void 0 === t && (t = !1), this._yoyo = t, this.parent; }, getYoyo() { return this._yoyo; }, destroy() { this.animationManager.off(r.REMOVE_ANIMATION, this.remove, this), this.animationManager = null, this.parent = null, this.nextAnimsQueue.length = 0, this.currentAnim = null, this.currentFrame = null; },\n    }); t.exports = o;\n  }, function (t, e, i) {\n    const u = i(506); const p = i(40); const n = i(0); const s = i(33); const r = i(507); const o = i(92); const a = i(29); const h = new n({\n      initialize(t) {\n        this.game = t, this.type = s.CANVAS, this.drawCount = 0, this.width = 0, this.height = 0, this.config = {\n          clearBeforeRender: t.config.clearBeforeRender, backgroundColor: t.config.backgroundColor, resolution: t.config.resolution, antialias: t.config.antialias, roundPixels: t.config.roundPixels,\n        }, this.gameCanvas = t.canvas; const e = { alpha: t.config.transparent, desynchronized: t.config.desynchronized }; this.gameContext = this.game.config.context ? this.game.config.context : this.gameCanvas.getContext('2d', e), this.currentContext = this.gameContext, this.antialias = t.config.antialias, this.blendModes = r(), this.snapshotState = {\n          x: 0, y: 0, width: 1, height: 1, getPixel: !1, callback: null, type: 'image/png', encoder: 0.92,\n        }, this._tempMatrix1 = new a(), this._tempMatrix2 = new a(), this._tempMatrix3 = new a(), this._tempMatrix4 = new a(), this.init();\n      },\n      init() { this.game.scale.on(o.RESIZE, this.onResize, this); const t = this.game.scale.baseSize; this.resize(t.width, t.height); },\n      onResize(t, e) { e.width === this.width && e.height === this.height || this.resize(e.width, e.height); },\n      resize(t, e) { this.width = t, this.height = e; },\n      resetTransform() { this.currentContext.setTransform(1, 0, 0, 1, 0, 0); },\n      setBlendMode(t) { return this.currentContext.globalCompositeOperation = t, this; },\n      setContext(t) { return this.currentContext = t || this.gameContext, this; },\n      setAlpha(t) { return this.currentContext.globalAlpha = t, this; },\n      preRender() { const t = this.gameContext; const e = this.config; const i = this.width; const n = this.height; t.globalAlpha = 1, t.globalCompositeOperation = 'source-over', t.setTransform(1, 0, 0, 1, 0, 0), e.clearBeforeRender && t.clearRect(0, 0, i, n), e.transparent || (t.fillStyle = e.backgroundColor.rgba, t.fillRect(0, 0, i, n)), t.save(), this.drawCount = 0; },\n      render(t, e, i, n) { const s = e.list; const r = s.length; const o = n._cx; const a = n._cy; const h = n._cw; const l = n._ch; const u = n.renderToTexture ? n.context : t.sys.context; u.save(), this.game.scene.customViewports && (u.beginPath(), u.rect(o, a, h, l), u.clip()), this.currentContext = u; const c = n.mask; c && c.preRenderCanvas(this, null, n._maskCamera), n.transparent || (u.fillStyle = n.backgroundColor.rgba, u.fillRect(o, a, h, l)), u.globalAlpha = n.alpha, u.globalCompositeOperation = 'source-over', this.drawCount += s.length, n.renderToTexture && n.emit(p.PRE_RENDER, n), n.matrix.copyToContext(u); for (let d = 0; d < r; d++) { const f = s[d]; f.willRender(n) && (f.mask && f.mask.preRenderCanvas(this, f, n), f.renderCanvas(this, f, i, n), f.mask && f.mask.postRenderCanvas(this, f, n)); }u.setTransform(1, 0, 0, 1, 0, 0), u.globalCompositeOperation = 'source-over', u.globalAlpha = 1, n.flashEffect.postRenderCanvas(u), n.fadeEffect.postRenderCanvas(u), n.dirty = !1, c && c.postRenderCanvas(this), u.restore(), n.renderToTexture && (n.emit(p.POST_RENDER, n), n.renderToGame && t.sys.context.drawImage(n.canvas, o, a)); },\n      postRender() { this.gameContext.restore(); const t = this.snapshotState; t.callback && (u(this.gameCanvas, t), t.callback = null); },\n      snapshotCanvas(t, e, i, n, s, r, o, a, h) { void 0 === i && (i = !1), this.snapshotArea(n, s, r, o, e, a, h); const l = this.snapshotState; return l.getPixel = i, u(this.canvas, l), l.callback = null, this; },\n      snapshot(t, e, i) { return this.snapshotArea(0, 0, this.gameCanvas.width, this.gameCanvas.height, t, e, i); },\n      snapshotArea(t, e, i, n, s, r, o) { const a = this.snapshotState; return a.callback = s, a.type = r, a.encoder = o, a.getPixel = !1, a.x = t, a.y = e, a.width = Math.min(i, this.gameCanvas.width), a.height = Math.min(n, this.gameCanvas.height), this; },\n      snapshotPixel(t, e, i) { return this.snapshotArea(t, e, 1, 1, i), this.snapshotState.getPixel = !0, this; },\n      batchSprite(t, e, i, n) { let s; let r; let o; let a; let h; let l; let u; let c; let d; let f; let p; let g; let v; let m; let y; let x; let T; let w; const b = i.alpha * t.alpha; b != 0 && (s = this.currentContext, r = this._tempMatrix1, o = this._tempMatrix2, a = this._tempMatrix3, l = (h = e.canvasData).x, u = h.y, c = e.cutWidth, d = e.cutHeight, f = e.customPivot, p = e.source.resolution, g = t.displayOriginX, v = t.displayOriginY, m = -g + e.x, y = -v + e.y, t.isCropped && ((x = t._crop).flipX === t.flipX && x.flipY === t.flipY || e.updateCropUVs(x, t.flipX, t.flipY), c = x.cw, d = x.ch, l = x.cx, u = x.cy, m = -g + x.x, y = -v + x.y, t.flipX && (m >= 0 ? m = -(m + c) : m < 0 && (m = Math.abs(m) - c)), t.flipY && (y >= 0 ? y = -(y + d) : y < 0 && (y = Math.abs(y) - d))), w = T = 1, t.flipX && (f || (m += -e.realWidth + 2 * g), T = -1), t.flipY && (f || (y += -e.realHeight + 2 * v), w = -1), o.applyITRS(t.x, t.y, t.rotation, t.scaleX * T, t.scaleY * w), r.copyFrom(i.matrix), n ? (r.multiplyWithOffset(n, -i.scrollX * t.scrollFactorX, -i.scrollY * t.scrollFactorY), o.e = t.x, o.f = t.y) : (o.e -= i.scrollX * t.scrollFactorX, o.f -= i.scrollY * t.scrollFactorY), r.multiply(o, a), s.save(), a.setToContext(s), s.globalCompositeOperation = this.blendModes[t.blendMode], s.globalAlpha = b, s.imageSmoothingEnabled = !(!this.antialias || e.source.scaleMode), t.mask && t.mask.preRenderCanvas(this, t, i), s.drawImage(e.source.image, l, u, c, d, m, y, c / p, d / p), t.mask && t.mask.postRenderCanvas(this, t, i), s.restore()); },\n      destroy() { this.gameCanvas = null, this.gameContext = null, this.game = null; },\n    }); t.exports = h;\n  }, function (t, e, i) { const f = i(26); const p = i(31); const g = i(2); t.exports = function (t, e) { let i; let n; let s; let r; const o = g(e, 'callback'); const a = g(e, 'type', 'image/png'); const h = g(e, 'encoder', 0.92); const l = Math.abs(Math.round(g(e, 'x', 0))); const u = Math.abs(Math.round(g(e, 'y', 0))); const c = g(e, 'width', t.width); const d = g(e, 'height', t.height); g(e, 'getPixel', !1) ? (i = t.getContext('2d').getImageData(l, u, 1, 1).data, o.call(null, new p(i[0], i[1], i[2], i[3] / 255))) : l !== 0 || u !== 0 || c !== t.width || d !== t.height ? ((n = f.createWebGL(this, c, d)).getContext('2d').drawImage(t, l, u, c, d, 0, 0, c, d), (s = new Image()).onerror = function () { o.call(null), f.remove(n); }, s.onload = function () { o.call(null, s), f.remove(n); }, s.src = n.toDataURL(a, h)) : ((r = new Image()).onerror = function () { o.call(null); }, r.onload = function () { o.call(null, r); }, r.src = t.toDataURL(a, h)); }; }, function (t, e, i) { const n = i(52); const s = i(316); t.exports = function () { const t = []; const e = s.supportNewBlendModes; const i = 'source-over'; return t[n.NORMAL] = i, t[n.ADD] = 'lighter', t[n.MULTIPLY] = e ? 'multiply' : i, t[n.SCREEN] = e ? 'screen' : i, t[n.OVERLAY] = e ? 'overlay' : i, t[n.DARKEN] = e ? 'darken' : i, t[n.LIGHTEN] = e ? 'lighten' : i, t[n.COLOR_DODGE] = e ? 'color-dodge' : i, t[n.COLOR_BURN] = e ? 'color-burn' : i, t[n.HARD_LIGHT] = e ? 'hard-light' : i, t[n.SOFT_LIGHT] = e ? 'soft-light' : i, t[n.DIFFERENCE] = e ? 'difference' : i, t[n.EXCLUSION] = e ? 'exclusion' : i, t[n.HUE] = e ? 'hue' : i, t[n.SATURATION] = e ? 'saturation' : i, t[n.COLOR] = e ? 'color' : i, t[n.LUMINOSITY] = e ? 'luminosity' : i, t[n.ERASE] = 'destination-out', t[n.SOURCE_IN] = 'source-in', t[n.SOURCE_OUT] = 'source-out', t[n.SOURCE_ATOP] = 'source-atop', t[n.DESTINATION_OVER] = 'destination-over', t[n.DESTINATION_IN] = 'destination-in', t[n.DESTINATION_OUT] = 'destination-out', t[n.DESTINATION_ATOP] = 'destination-atop', t[n.LIGHTER] = 'lighter', t[n.COPY] = 'copy', t[n.XOR] = 'xor', t; }; }, function (t, e, i) {\n    const n = i(91); const h = i(40); const s = i(0); const f = i(33); const c = i(20); const p = i(120); const r = i(1); const o = i(92); const a = i(80); const d = i(121); const l = i(29); const u = i(9); const g = i(509); const v = i(510); const m = i(511); const y = i(237); const x = i(512); const T = new s({\n      initialize(t) {\n        const e = t.config; const i = {\n          alpha: e.transparent, desynchronized: e.desynchronized, depth: !1, antialias: e.antialiasGL, premultipliedAlpha: e.premultipliedAlpha, stencil: !0, failIfMajorPerformanceCaveat: e.failIfMajorPerformanceCaveat, powerPreference: e.powerPreference,\n        }; this.config = {\n          clearBeforeRender: e.clearBeforeRender, antialias: e.antialias, backgroundColor: e.backgroundColor, contextCreation: i, resolution: e.resolution, roundPixels: e.roundPixels, maxTextures: e.maxTextures, maxTextureSize: e.maxTextureSize, batchSize: e.batchSize, maxLights: e.maxLights, mipmapFilter: e.mipmapFilter,\n        }, this.game = t, this.type = f.WEBGL, this.width = 0, this.height = 0, this.canvas = t.canvas, this.blendModes = [], this.nativeTextures = [], this.contextLost = !1, this.pipelines = null, this.snapshotState = {\n          x: 0, y: 0, width: 1, height: 1, getPixel: !1, callback: null, type: 'image/png', encoder: 0.92, isFramebuffer: !1, bufferWidth: 0, bufferHeight: 0,\n        }, this.currentActiveTextureUnit = 0, this.currentTextures = new Array(16), this.currentFramebuffer = null, this.currentPipeline = null, this.currentProgram = null, this.currentVertexBuffer = null, this.currentIndexBuffer = null, this.currentBlendMode = 1 / 0, this.currentScissorEnabled = !1, this.currentScissor = null, this.scissorStack = [], this.contextLostHandler = r, this.contextRestoredHandler = r, this.gl = null, this.supportedExtensions = null, this.extensions = {}, this.glFormats = [], this.compression = { ETC1: !1, PVRTC: !1, S3TC: !1 }, this.drawingBufferHeight = 0, this.blankTexture = null, this.defaultCamera = new n(0, 0, 0, 0), this._tempMatrix1 = new l(), this._tempMatrix2 = new l(), this._tempMatrix3 = new l(), this._tempMatrix4 = new l(), this.maskCount = 0, this.maskStack = [], this.currentMask = { mask: null, camera: null }, this.currentCameraMask = { mask: null, camera: null }, this.glFuncMap = null, this.currentType = '', this.newType = !1, this.nextTypeMatch = !1, this.mipmapFilter = null, this.init(this.config);\n      },\n      init(t) {\n        const e = this.game; const i = this.canvas; const n = t.backgroundColor; const s = e.config.context ? e.config.context : i.getContext('webgl', t.contextCreation) || i.getContext('experimental-webgl', t.contextCreation); if (!s || s.isContextLost()) throw this.contextLost = !0, new Error('WebGL unsupported'); this.gl = s; const r = this; this.contextLostHandler = function (t) { r.contextLost = !0, r.game.events.emit(c.CONTEXT_LOST, r), t.preventDefault(); }, this.contextRestoredHandler = function () { r.contextLost = !1, r.init(r.config), r.game.events.emit(c.CONTEXT_RESTORED, r); }, i.addEventListener('webglcontextlost', this.contextLostHandler, !1), i.addEventListener('webglcontextrestored', this.contextRestoredHandler, !1), e.context = s; for (let o = 0; o <= 27; o++) this.blendModes.push({ func: [s.ONE, s.ONE_MINUS_SRC_ALPHA], equation: s.FUNC_ADD }); this.blendModes[1].func = [s.ONE, s.DST_ALPHA], this.blendModes[2].func = [s.DST_COLOR, s.ONE_MINUS_SRC_ALPHA], this.blendModes[3].func = [s.ONE, s.ONE_MINUS_SRC_COLOR], this.blendModes[17] = { func: [s.ZERO, s.ONE_MINUS_SRC_ALPHA], equation: s.FUNC_REVERSE_SUBTRACT }, this.glFormats[0] = s.BYTE, this.glFormats[1] = s.SHORT, this.glFormats[2] = s.UNSIGNED_BYTE, this.glFormats[3] = s.UNSIGNED_SHORT, this.glFormats[4] = s.FLOAT, this.glFuncMap = {\n          mat2: { func: s.uniformMatrix2fv, length: 1, matrix: !0 }, mat3: { func: s.uniformMatrix3fv, length: 1, matrix: !0 }, mat4: { func: s.uniformMatrix4fv, length: 1, matrix: !0 }, '1f': { func: s.uniform1f, length: 1 }, '1fv': { func: s.uniform1fv, length: 1 }, '1i': { func: s.uniform1i, length: 1 }, '1iv': { func: s.uniform1iv, length: 1 }, '2f': { func: s.uniform2f, length: 2 }, '2fv': { func: s.uniform2fv, length: 1 }, '2i': { func: s.uniform2i, length: 2 }, '2iv': { func: s.uniform2iv, length: 1 }, '3f': { func: s.uniform3f, length: 3 }, '3fv': { func: s.uniform3fv, length: 1 }, '3i': { func: s.uniform3i, length: 3 }, '3iv': { func: s.uniform3iv, length: 1 }, '4f': { func: s.uniform4f, length: 4 }, '4fv': { func: s.uniform4fv, length: 1 }, '4i': { func: s.uniform4i, length: 4 }, '4iv': { func: s.uniform4iv, length: 1 },\n        }; const a = s.getSupportedExtensions(); t.maxTextures || (t.maxTextures = s.getParameter(s.MAX_TEXTURE_IMAGE_UNITS)), t.maxTextureSize || (t.maxTextureSize = s.getParameter(s.MAX_TEXTURE_SIZE)); const h = 'WEBGL_compressed_texture_'; const l = `WEBKIT_${h}`; this.compression.ETC1 = s.getExtension(`${h}etc1`) || s.getExtension(`${l}etc1`), this.compression.PVRTC = s.getExtension(`${h}pvrtc`) || s.getExtension(`${l}pvrtc`), this.compression.S3TC = s.getExtension(`${h}s3tc`) || s.getExtension(`${l}s3tc`), this.supportedExtensions = a, s.disable(s.DEPTH_TEST), s.disable(s.CULL_FACE), s.enable(s.BLEND), s.clearColor(n.redGL, n.greenGL, n.blueGL, n.alphaGL), this.mipmapFilter = s[t.mipmapFilter]; for (let u = 0; u < this.currentTextures.length; ++u) this.currentTextures[u] = null; return this.pipelines = {}, this.addPipeline('TextureTintPipeline', new y({ game: e, renderer: this })), this.addPipeline('TextureTintStripPipeline', new x({ game: e, renderer: this })), this.addPipeline('BitmapMaskPipeline', new v({ game: e, renderer: this })), this.addPipeline('Light2D', new m({ game: e, renderer: this, maxLights: t.maxLights })), this.setBlendMode(f.BlendModes.NORMAL), e.textures.once(d.READY, this.boot, this), this;\n      },\n      boot() { for (const t in this.pipelines) this.pipelines[t].boot(); const e = this.game.textures.getFrame('__DEFAULT'); this.pipelines.TextureTintPipeline.currentFrame = e, this.blankTexture = e; const i = this.gl; i.bindFramebuffer(i.FRAMEBUFFER, null), i.enable(i.SCISSOR_TEST), this.setPipeline(this.pipelines.TextureTintPipeline), this.game.scale.on(o.RESIZE, this.onResize, this); const n = this.game.scale.baseSize; this.resize(n.width, n.height, this.game.scale.resolution); },\n      onResize(t, e, i, n) { e.width === this.width && e.height === this.height && n === this.resolution || this.resize(e.width, e.height, n); },\n      resize(t, e, i) { const n = this.gl; const s = this.pipelines; for (const r in this.width = t, this.height = e, this.resolution = i, n.viewport(0, 0, t, e), s)s[r].resize(t, e, i); return this.drawingBufferHeight = n.drawingBufferHeight, n.scissor(0, n.drawingBufferHeight - e, t, e), this.defaultCamera.setSize(t, e), this; },\n      hasExtension(t) { return !!this.supportedExtensions && this.supportedExtensions.indexOf(t); },\n      getExtension(t) { return this.hasExtension(t) ? (t in this.extensions || (this.extensions[t] = this.gl.getExtension(t)), this.extensions[t]) : null; },\n      flush() { this.currentPipeline && this.currentPipeline.flush(); },\n      hasPipeline(t) { return t in this.pipelines; },\n      getPipeline(t) { return this.hasPipeline(t) ? this.pipelines[t] : null; },\n      removePipeline(t) { return delete this.pipelines[t], this; },\n      addPipeline(t, e) { return this.hasPipeline(t) ? console.warn(`Pipeline exists: ${t}`) : this.pipelines[t] = e, e.name = t, this.pipelines[t].resize(this.width, this.height, this.config.resolution), e; },\n      pushScissor(t, e, i, n, s) { void 0 === s && (s = this.drawingBufferHeight); const r = [t, e, i, n]; return this.scissorStack.push(r), this.setScissor(t, e, i, n, s), this.currentScissor = r; },\n      setScissor(t, e, i, n, s) { void 0 === s && (s = this.drawingBufferHeight); let r; let o; let a; let h; const l = this.gl; const u = this.currentScissor; let c = i > 0 && n > 0; u && c && (r = u[0], o = u[1], a = u[2], h = u[3], c = r !== t || o !== e || a !== i || h !== n), c && (this.flush(), l.scissor(t, s - e - n, i, n)); },\n      popScissor() { const t = this.scissorStack; t.pop(); const e = t[t.length - 1]; e && this.setScissor(e[0], e[1], e[2], e[3]), this.currentScissor = e; },\n      setPipeline(t, e) { return this.currentPipeline === t && this.currentPipeline.vertexBuffer === this.currentVertexBuffer && this.currentPipeline.program === this.currentProgram || (this.flush(), this.currentPipeline = t, this.currentPipeline.bind()), this.currentPipeline.onBind(e), this.currentPipeline; },\n      hasActiveStencilMask() { const t = this.currentMask.mask; const e = this.currentCameraMask.mask; return t && t.isStencil || e && e.isStencil; },\n      rebindPipeline(t) { const e = this.gl; e.disable(e.DEPTH_TEST), e.disable(e.CULL_FACE), this.hasActiveStencilMask() ? e.clear(e.DEPTH_BUFFER_BIT) : (e.disable(e.STENCIL_TEST), e.clear(e.DEPTH_BUFFER_BIT | e.STENCIL_BUFFER_BIT)), e.viewport(0, 0, this.width, this.height), this.setBlendMode(0, !0), e.activeTexture(e.TEXTURE0), e.bindTexture(e.TEXTURE_2D, this.blankTexture.glTexture), this.currentActiveTextureUnit = 0, this.currentTextures[0] = this.blankTexture.glTexture, this.currentPipeline = t, this.currentPipeline.bind(), this.currentPipeline.onBind(); },\n      clearPipeline() { this.flush(), this.currentPipeline = null, this.currentProgram = null, this.currentVertexBuffer = null, this.currentIndexBuffer = null, this.setBlendMode(0, !0); },\n      setBlendMode(t, e) { void 0 === e && (e = !1); const i = this.gl; const n = this.blendModes[t]; return !!(e || t !== f.BlendModes.SKIP_CHECK && this.currentBlendMode !== t) && (this.flush(), i.enable(i.BLEND), i.blendEquation(n.equation), n.func.length > 2 ? i.blendFuncSeparate(n.func[0], n.func[1], n.func[2], n.func[3]) : i.blendFunc(n.func[0], n.func[1]), this.currentBlendMode = t, !0); },\n      addBlendMode(t, e) { return this.blendModes.push({ func: t, equation: e }) - 1; },\n      updateBlendMode(t, e, i) { return this.blendModes[t] && (this.blendModes[t].func = e, i && (this.blendModes[t].equation = i)), this; },\n      removeBlendMode(t) { return t > 17 && this.blendModes[t] && this.blendModes.splice(t, 1), this; },\n      setBlankTexture(t) { void 0 === t && (t = !1), !t && this.currentActiveTextureUnit === 0 && this.currentTextures[0] || this.setTexture2D(this.blankTexture.glTexture, 0); },\n      setTexture2D(t, e, i) { void 0 === i && (i = !0); const n = this.gl; return t !== this.currentTextures[e] && (i && this.flush(), this.currentActiveTextureUnit !== e && (n.activeTexture(n.TEXTURE0 + e), this.currentActiveTextureUnit = e), n.bindTexture(n.TEXTURE_2D, t), this.currentTextures[e] = t), this; },\n      setFramebuffer(t, e) { void 0 === e && (e = !1); const i = this.gl; let n = this.width; let s = this.height; return t !== this.currentFramebuffer && (t && t.renderTexture ? (n = t.renderTexture.width, s = t.renderTexture.height) : this.flush(), i.bindFramebuffer(i.FRAMEBUFFER, t), i.viewport(0, 0, n, s), e && (t ? (this.drawingBufferHeight = s, this.pushScissor(0, 0, n, s)) : (this.drawingBufferHeight = this.height, this.popScissor())), this.currentFramebuffer = t), this; },\n      setProgram(t) { const e = this.gl; return t !== this.currentProgram && (this.flush(), e.useProgram(t), this.currentProgram = t), this; },\n      setVertexBuffer(t) { const e = this.gl; return t !== this.currentVertexBuffer && (this.flush(), e.bindBuffer(e.ARRAY_BUFFER, t), this.currentVertexBuffer = t), this; },\n      setIndexBuffer(t) { const e = this.gl; return t !== this.currentIndexBuffer && (this.flush(), e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, t), this.currentIndexBuffer = t), this; },\n      createTextureFromSource(t, e, i, n) { const s = this.gl; let r = s.NEAREST; let o = s.NEAREST; let a = s.CLAMP_TO_EDGE; e = t ? t.width : e, i = t ? t.height : i; const h = p(e, i); return h && (a = s.REPEAT), n === f.ScaleModes.LINEAR && this.config.antialias && (r = h ? this.mipmapFilter : s.LINEAR, o = s.LINEAR), t || typeof e !== 'number' || typeof i !== 'number' ? this.createTexture2D(0, r, o, a, a, s.RGBA, t) : this.createTexture2D(0, r, o, a, a, s.RGBA, null, e, i); },\n      createTexture2D(t, e, i, n, s, r, o, a, h, l, u, c) { l = l == null || l, void 0 === u && (u = !1), void 0 === c && (c = !1); const d = this.gl; const f = d.createTexture(); return this.setTexture2D(f, 0), d.texParameteri(d.TEXTURE_2D, d.TEXTURE_MIN_FILTER, e), d.texParameteri(d.TEXTURE_2D, d.TEXTURE_MAG_FILTER, i), d.texParameteri(d.TEXTURE_2D, d.TEXTURE_WRAP_S, s), d.texParameteri(d.TEXTURE_2D, d.TEXTURE_WRAP_T, n), d.pixelStorei(d.UNPACK_PREMULTIPLY_ALPHA_WEBGL, l), d.pixelStorei(d.UNPACK_FLIP_Y_WEBGL, c), o == null ? d.texImage2D(d.TEXTURE_2D, t, r, a, h, 0, r, d.UNSIGNED_BYTE, null) : (u || (a = o.width, h = o.height), d.texImage2D(d.TEXTURE_2D, t, r, r, d.UNSIGNED_BYTE, o)), p(a, h) && d.generateMipmap(d.TEXTURE_2D), this.setTexture2D(null, 0), f.isAlphaPremultiplied = l, f.isRenderTexture = !1, f.width = a, f.height = h, this.nativeTextures.push(f), f; },\n      createFramebuffer(t, e, i, n) {\n        let s; let r; const o = this.gl; const a = o.createFramebuffer(); if (this.setFramebuffer(a), n && (r = o.createRenderbuffer(), o.bindRenderbuffer(o.RENDERBUFFER, r), o.renderbufferStorage(o.RENDERBUFFER, o.DEPTH_STENCIL, t, e), o.framebufferRenderbuffer(o.FRAMEBUFFER, o.DEPTH_STENCIL_ATTACHMENT, o.RENDERBUFFER, r)), i.isRenderTexture = !0, i.isAlphaPremultiplied = !1, o.framebufferTexture2D(o.FRAMEBUFFER, o.COLOR_ATTACHMENT0, o.TEXTURE_2D, i, 0), (s = o.checkFramebufferStatus(o.FRAMEBUFFER)) === o.FRAMEBUFFER_COMPLETE) return a.renderTexture = i, this.setFramebuffer(null), a; throw new Error(`Framebuffer incomplete. Framebuffer status: ${{\n          36054: 'Incomplete Attachment', 36055: 'Missing Attachment', 36057: 'Incomplete Dimensions', 36061: 'Framebuffer Unsupported',\n        }[s]}`);\n      },\n      createProgram(t, e) { const i = this.gl; const n = i.createProgram(); const s = i.createShader(i.VERTEX_SHADER); const r = i.createShader(i.FRAGMENT_SHADER); if (i.shaderSource(s, t), i.shaderSource(r, e), i.compileShader(s), i.compileShader(r), !i.getShaderParameter(s, i.COMPILE_STATUS)) throw new Error(`Failed to compile Vertex Shader:\\n${i.getShaderInfoLog(s)}`); if (!i.getShaderParameter(r, i.COMPILE_STATUS)) throw new Error(`Failed to compile Fragment Shader:\\n${i.getShaderInfoLog(r)}`); if (i.attachShader(n, s), i.attachShader(n, r), i.linkProgram(n), !i.getProgramParameter(n, i.LINK_STATUS)) throw new Error(`Failed to link program:\\n${i.getProgramInfoLog(n)}`); return n; },\n      createVertexBuffer(t, e) { const i = this.gl; const n = i.createBuffer(); return this.setVertexBuffer(n), i.bufferData(i.ARRAY_BUFFER, t, e), this.setVertexBuffer(null), n; },\n      createIndexBuffer(t, e) { const i = this.gl; const n = i.createBuffer(); return this.setIndexBuffer(n), i.bufferData(i.ELEMENT_ARRAY_BUFFER, t, e), this.setIndexBuffer(null), n; },\n      deleteTexture(t) { const e = this.nativeTextures.indexOf(t); return e !== -1 && a(this.nativeTextures, e), this.gl.deleteTexture(t), this.currentTextures[0] !== t || this.game.pendingDestroy || this.setBlankTexture(!0), this; },\n      deleteFramebuffer(t) { return this.gl.deleteFramebuffer(t), this; },\n      deleteProgram(t) { return this.gl.deleteProgram(t), this; },\n      deleteBuffer(t) { return this.gl.deleteBuffer(t), this; },\n      preRenderCamera(t) { let e; const i = t._cx; const n = t._cy; const s = t._cw; const r = t._ch; const o = this.pipelines.TextureTintPipeline; const a = t.backgroundColor; t.renderToTexture ? (this.flush(), this.pushScissor(i, n, s, -r), this.setFramebuffer(t.framebuffer), (e = this.gl).clearColor(0, 0, 0, 0), e.clear(e.COLOR_BUFFER_BIT), o.projOrtho(i, s + i, n, r + n, -1e3, 1e3), t.mask && (this.currentCameraMask.mask = t.mask, this.currentCameraMask.camera = t._maskCamera, t.mask.preRenderWebGL(this, t, t._maskCamera)), a.alphaGL > 0 && o.drawFillRect(i, n, s + i, r + n, u.getTintFromFloats(a.redGL, a.greenGL, a.blueGL, 1), a.alphaGL), t.emit(h.PRE_RENDER, t)) : (this.pushScissor(i, n, s, r), t.mask && (this.currentCameraMask.mask = t.mask, this.currentCameraMask.camera = t._maskCamera, t.mask.preRenderWebGL(this, t, t._maskCamera)), a.alphaGL > 0 && o.drawFillRect(i, n, s, r, u.getTintFromFloats(a.redGL, a.greenGL, a.blueGL, 1), a.alphaGL)); },\n      getCurrentStencilMask() { let t = null; const e = this.maskStack; const i = this.currentCameraMask; return e.length > 0 ? t = e[e.length - 1] : i.mask && i.mask.isStencil && (t = i), t; },\n      postRenderCamera(t) { this.setPipeline(this.pipelines.TextureTintPipeline); let e; const i = this.pipelines.TextureTintPipeline; t.flashEffect.postRenderWebGL(i, u.getTintFromFloats), t.fadeEffect.postRenderWebGL(i, u.getTintFromFloats), t.dirty = !1, this.popScissor(), t.renderToTexture && (i.flush(), this.setFramebuffer(null), t.emit(h.POST_RENDER, t), t.renderToGame && (i.projOrtho(0, i.width, i.height, 0, -1e3, 1e3), e = u.getTintAppendFloatAlpha, (t.pipeline ? t.pipeline : i).batchTexture(t, t.glTexture, t.width, t.height, t.x, t.y, t.width, t.height, t.zoom, t.zoom, t.rotation, t.flipX, !t.flipY, 1, 1, 0, 0, 0, 0, t.width, t.height, e(t._tintTL, t._alphaTL), e(t._tintTR, t._alphaTR), e(t._tintBL, t._alphaBL), e(t._tintBR, t._alphaBR), t._isTinted && t.tintFill, 0, 0, this.defaultCamera, null)), this.setBlankTexture(!0)), t.mask && (this.currentCameraMask.mask = null, t.mask.postRenderWebGL(this, t._maskCamera)); },\n      preRender() { if (!this.contextLost) { let t; const e = this.gl; const i = this.pipelines; for (const n in e.bindFramebuffer(e.FRAMEBUFFER, null), this.config.clearBeforeRender && (t = this.config.backgroundColor, e.clearColor(t.redGL, t.greenGL, t.blueGL, t.alphaGL), e.clear(e.COLOR_BUFFER_BIT | e.DEPTH_BUFFER_BIT | e.STENCIL_BUFFER_BIT)), e.enable(e.SCISSOR_TEST), i)i[n].onPreRender(); this.currentScissor = [0, 0, this.width, this.height], this.scissorStack = [this.currentScissor], this.game.scene.customViewports && e.scissor(0, this.drawingBufferHeight - this.height, this.width, this.height), this.currentMask.mask = null, this.currentCameraMask.mask = null, this.maskStack.length = 0, this.setPipeline(this.pipelines.TextureTintPipeline); } },\n      render(t, e, i, n) { if (!this.contextLost) { const s = e.list; const r = s.length; const o = this.pipelines; for (const a in o)o[a].onRender(t, n); if (this.preRenderCamera(n), r === 0) return this.setBlendMode(f.BlendModes.NORMAL), void this.postRenderCamera(n); this.currentType = ''; for (var h = this.currentMask, l = 0; l < r; l++) { var u; var c; const d = s[l]; d.willRender(n) && (d.blendMode !== this.currentBlendMode && this.setBlendMode(d.blendMode), u = d.mask, (h = this.currentMask).mask && h.mask !== u && h.mask.postRenderWebGL(this, h.camera), u && h.mask !== u && u.preRenderWebGL(this, d, n), (c = d.type) !== this.currentType && (this.newType = !0, this.currentType = c), this.nextTypeMatch = l < r - 1 && s[l + 1].type === this.currentType, d.renderWebGL(this, d, i, n), this.newType = !1); }(h = this.currentMask).mask && h.mask.postRenderWebGL(this, h.camera), this.setBlendMode(f.BlendModes.NORMAL), this.postRenderCamera(n); } },\n      postRender() { if (!this.contextLost) { this.flush(); const t = this.snapshotState; t.callback && (g(this.canvas, t), t.callback = null); const e = this.pipelines; for (const i in e)e[i].onPostRender(); } },\n      snapshot(t, e, i) { return this.snapshotArea(0, 0, this.gl.drawingBufferWidth, this.gl.drawingBufferHeight, t, e, i); },\n      snapshotArea(t, e, i, n, s, r, o) { const a = this.snapshotState; return a.callback = s, a.type = r, a.encoder = o, a.getPixel = !1, a.x = t, a.y = e, a.width = Math.min(i, this.gl.drawingBufferWidth), a.height = Math.min(n, this.gl.drawingBufferHeight), this; },\n      snapshotPixel(t, e, i) { return this.snapshotArea(t, e, 1, 1, i), this.snapshotState.getPixel = !0, this; },\n      snapshotFramebuffer(t, e, i, n, s, r, o, a, h, l, u) { void 0 === s && (s = !1), void 0 === r && (r = 0), void 0 === o && (o = 0), void 0 === a && (a = e), void 0 === h && (h = i); const c = this.currentFramebuffer; this.snapshotArea(r, o, a, h, n, l, u); const d = this.snapshotState; return d.getPixel = s, d.isFramebuffer = !0, d.bufferWidth = e, d.bufferHeight = i, this.setFramebuffer(t), g(this.canvas, d), this.setFramebuffer(c), d.callback = null, d.isFramebuffer = !1, this; },\n      canvasToTexture(t, e, i, n) { return void 0 === i && (i = !1), void 0 === n && (n = !1), e ? this.updateCanvasTexture(t, e, n) : this.createCanvasTexture(t, i, n); },\n      createCanvasTexture(t, e, i) { void 0 === e && (e = !1), void 0 === i && (i = !1); const n = this.gl; let s = n.NEAREST; let r = n.NEAREST; const o = t.width; const a = t.height; let h = n.CLAMP_TO_EDGE; const l = p(o, a); return !e && l && (h = n.REPEAT), this.config.antialias && (s = l ? this.mipmapFilter : n.LINEAR, r = n.LINEAR), this.createTexture2D(0, s, r, h, h, n.RGBA, t, o, a, !0, !1, i); },\n      updateCanvasTexture(t, e, i) { void 0 === i && (i = !1); const n = this.gl; const s = t.width; const r = t.height; return s > 0 && r > 0 && (this.setTexture2D(e, 0), n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL, i), n.texImage2D(n.TEXTURE_2D, 0, n.RGBA, n.RGBA, n.UNSIGNED_BYTE, t), e.width = s, e.height = r, this.setTexture2D(null, 0)), e; },\n      createVideoTexture(t, e, i) { void 0 === e && (e = !1), void 0 === i && (i = !1); const n = this.gl; let s = n.NEAREST; let r = n.NEAREST; const o = t.videoWidth; const a = t.videoHeight; let h = n.CLAMP_TO_EDGE; const l = p(o, a); return !e && l && (h = n.REPEAT), this.config.antialias && (s = l ? this.mipmapFilter : n.LINEAR, r = n.LINEAR), this.createTexture2D(0, s, r, h, h, n.RGBA, t, o, a, !0, !0, i); },\n      updateVideoTexture(t, e, i) { void 0 === i && (i = !1); const n = this.gl; const s = t.videoWidth; const r = t.videoHeight; return s > 0 && r > 0 && (this.setTexture2D(e, 0), n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL, i), n.texImage2D(n.TEXTURE_2D, 0, n.RGBA, n.RGBA, n.UNSIGNED_BYTE, t), e.width = s, e.height = r, this.setTexture2D(null, 0)), e; },\n      setTextureFilter(t, e) { const i = this.gl; const n = [i.LINEAR, i.NEAREST][e]; return this.setTexture2D(t, 0), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MIN_FILTER, n), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MAG_FILTER, n), this.setTexture2D(null, 0), this; },\n      setFloat1(t, e, i) { return this.setProgram(t), this.gl.uniform1f(this.gl.getUniformLocation(t, e), i), this; },\n      setFloat2(t, e, i, n) { return this.setProgram(t), this.gl.uniform2f(this.gl.getUniformLocation(t, e), i, n), this; },\n      setFloat3(t, e, i, n, s) { return this.setProgram(t), this.gl.uniform3f(this.gl.getUniformLocation(t, e), i, n, s), this; },\n      setFloat4(t, e, i, n, s, r) { return this.setProgram(t), this.gl.uniform4f(this.gl.getUniformLocation(t, e), i, n, s, r), this; },\n      setFloat1v(t, e, i) { return this.setProgram(t), this.gl.uniform1fv(this.gl.getUniformLocation(t, e), i), this; },\n      setFloat2v(t, e, i) { return this.setProgram(t), this.gl.uniform2fv(this.gl.getUniformLocation(t, e), i), this; },\n      setFloat3v(t, e, i) { return this.setProgram(t), this.gl.uniform3fv(this.gl.getUniformLocation(t, e), i), this; },\n      setFloat4v(t, e, i) { return this.setProgram(t), this.gl.uniform4fv(this.gl.getUniformLocation(t, e), i), this; },\n      setInt1(t, e, i) { return this.setProgram(t), this.gl.uniform1i(this.gl.getUniformLocation(t, e), i), this; },\n      setInt2(t, e, i, n) { return this.setProgram(t), this.gl.uniform2i(this.gl.getUniformLocation(t, e), i, n), this; },\n      setInt3(t, e, i, n, s) { return this.setProgram(t), this.gl.uniform3i(this.gl.getUniformLocation(t, e), i, n, s), this; },\n      setInt4(t, e, i, n, s, r) { return this.setProgram(t), this.gl.uniform4i(this.gl.getUniformLocation(t, e), i, n, s, r), this; },\n      setMatrix2(t, e, i, n) { return this.setProgram(t), this.gl.uniformMatrix2fv(this.gl.getUniformLocation(t, e), i, n), this; },\n      setMatrix3(t, e, i, n) { return this.setProgram(t), this.gl.uniformMatrix3fv(this.gl.getUniformLocation(t, e), i, n), this; },\n      setMatrix4(t, e, i, n) { return this.setProgram(t), this.gl.uniformMatrix4fv(this.gl.getUniformLocation(t, e), i, n), this; },\n      getMaxTextures() { return this.config.maxTextures; },\n      getMaxTextureSize() { return this.config.maxTextureSize; },\n      destroy() { for (let t = 0; t < this.nativeTextures.length; t++) this.gl.deleteTexture(this.nativeTextures[t]); for (const e in this.nativeTextures = [], this.pipelines) this.pipelines[e].destroy(), delete this.pipelines[e]; this.defaultCamera.destroy(), this.currentMask = null, this.currentCameraMask = null, this.canvas.removeEventListener('webglcontextlost', this.contextLostHandler, !1), this.canvas.removeEventListener('webglcontextrestored', this.contextRestoredHandler, !1), this.game = null, this.gl = null, this.canvas = null, this.maskStack = [], this.contextLost = !0, this.extensions = {}; },\n    }); t.exports = T;\n  }, function (t, e, i) { const C = i(26); const M = i(31); const P = i(2); t.exports = function (t, e) { const i = t.getContext('experimental-webgl'); const n = P(e, 'callback'); const s = P(e, 'type', 'image/png'); const r = P(e, 'encoder', 0.92); const o = P(e, 'x', 0); const a = P(e, 'y', 0); const h = P(e, 'getPixel', !1); const l = P(e, 'isFramebuffer', !1); const u = l ? P(e, 'bufferWidth', 1) : i.drawingBufferWidth; const c = l ? P(e, 'bufferHeight', 1) : i.drawingBufferHeight; if (h) { const d = new Uint8Array(4); const f = l ? a : c - a; i.readPixels(o, f, 1, 1, i.RGBA, i.UNSIGNED_BYTE, d), n.call(null, new M(d[0], d[1], d[2], d[3] / 255)); } else { const p = P(e, 'width', u); const g = P(e, 'height', c); const v = p * g * 4; const m = new Uint8Array(v); i.readPixels(o, c - a - g, p, g, i.RGBA, i.UNSIGNED_BYTE, m); for (var y = C.createWebGL(this, p, g), x = y.getContext('2d'), T = x.getImageData(0, 0, p, g), w = T.data, b = 0; b < g; b++) for (let E = 0; E < p; E++) { const S = 4 * ((g - b) * p + E); const _ = l ? v - 4 * (b * p + (p - E)) : 4 * (b * p + E); w[0 + _] = m[0 + S], w[1 + _] = m[1 + S], w[2 + _] = m[2 + S], w[3 + _] = m[3 + S]; }x.putImageData(T, 0, 0); const A = new Image(); A.onerror = function () { n.call(null), C.remove(y); }, A.onload = function () { n.call(null, A), C.remove(y); }, A.src = y.toDataURL(s, r); } }; }, function (t, e, i) {\n    const n = i(0); const s = i(786); const r = i(787); const o = i(147); const a = new n({\n      Extends: o,\n      initialize(t) {\n        o.call(this, {\n          game: t.game,\n          renderer: t.renderer,\n          gl: t.renderer.gl,\n          topology: t.topology ? t.topology : t.renderer.gl.TRIANGLES,\n          vertShader: t.vertShader ? t.vertShader : r,\n          fragShader: t.fragShader ? t.fragShader : s,\n          vertexCapacity: t.vertexCapacity ? t.vertexCapacity : 3,\n          vertexSize: t.vertexSize ? t.vertexSize : 2 * Float32Array.BYTES_PER_ELEMENT,\n          vertices: new Float32Array([-1, 1, -1, -7, 7, 1]).buffer,\n          attributes: [{\n            name: 'inPosition', size: 2, type: t.renderer.gl.FLOAT, normalized: !1, offset: 0,\n          }],\n        }), this.vertexViewF32 = new Float32Array(this.vertexData), this.maxQuads = 1, this.resolutionDirty = !0;\n      },\n      onBind() { o.prototype.onBind.call(this); const t = this.renderer; const e = this.program; return this.resolutionDirty && (t.setFloat2(e, 'uResolution', this.width, this.height), t.setInt1(e, 'uMainSampler', 0), t.setInt1(e, 'uMaskSampler', 1), this.resolutionDirty = !1), this; },\n      resize(t, e, i) { return o.prototype.resize.call(this, t, e, i), this.resolutionDirty = !0, this; },\n      beginMask(t, e, i) { const n = this.renderer; const s = this.gl; t.bitmapMask && s && (n.flush(), t.prevFramebuffer = n.currentFramebuffer, n.setFramebuffer(t.mainFramebuffer), s.disable(s.STENCIL_TEST), s.clearColor(0, 0, 0, 0), s.clear(s.COLOR_BUFFER_BIT), n.currentCameraMask.mask !== t && (n.currentMask.mask = t, n.currentMask.camera = i)); },\n      endMask(t, e) { let i; const n = this.gl; const s = this.renderer; const r = t.bitmapMask; r && n && (s.flush(), s.setFramebuffer(t.maskFramebuffer), n.clearColor(0, 0, 0, 0), n.clear(n.COLOR_BUFFER_BIT), s.setBlendMode(0, !0), r.renderWebGL(s, r, 0, e), s.flush(), s.setFramebuffer(t.prevFramebuffer), (i = s.getCurrentStencilMask()) ? (n.enable(n.STENCIL_TEST), i.mask.applyStencil(s, i.camera, !0)) : s.currentMask.mask = null, s.setPipeline(this), n.activeTexture(n.TEXTURE1), n.bindTexture(n.TEXTURE_2D, t.maskTexture), n.activeTexture(n.TEXTURE0), n.bindTexture(n.TEXTURE_2D, t.mainTexture), n.uniform1i(n.getUniformLocation(this.program, 'uInvertMaskAlpha'), t.invertAlpha), n.drawArrays(this.topology, 0, 3)); },\n    }); t.exports = a;\n  }, function (t, e, i) {\n    const n = i(0); const s = i(788); const r = i(237); let f = 10; const o = new n({\n      Extends: r, initialize(t) { f = t.maxLights, t.fragShader = s.replace('%LIGHT_COUNT%', f.toString()), r.call(this, t), this.defaultNormalMap, this.inverseRotationMatrix = new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]); }, boot() { this.defaultNormalMap = this.game.textures.getFrame('__DEFAULT'); }, onBind(t) { r.prototype.onBind.call(this); const e = this.renderer; const i = this.program; return this.mvpUpdate(), e.setInt1(i, 'uNormSampler', 1), e.setFloat2(i, 'uResolution', this.width, this.height), t && this.setNormalMap(t), this; }, onRender(t, e) { this.active = !1; const i = t.sys.lights; if (!i || i.lights.length <= 0 || !i.active) return this; const n = i.cull(e); const s = Math.min(n.length, f); if (s === 0) return this; this.active = !0; for (var r = this.renderer, o = this.program, a = e.matrix, h = { x: 0, y: 0 }, l = r.height, u = 0; u < f; ++u)r.setFloat1(o, `uLights[${u}].radius`, 0); for (r.setFloat4(o, 'uCamera', e.x, e.y, e.rotation, e.zoom), r.setFloat3(o, 'uAmbientLightColor', i.ambientColor.r, i.ambientColor.g, i.ambientColor.b), u = 0; u < s; ++u) { const c = n[u]; const d = `uLights[${u}].`; a.transformPoint(c.x, c.y, h), r.setFloat2(o, `${d}position`, h.x - e.scrollX * c.scrollFactorX * e.zoom, l - (h.y - e.scrollY * c.scrollFactorY * e.zoom)), r.setFloat3(o, `${d}color`, c.r, c.g, c.b), r.setFloat1(o, `${d}intensity`, c.intensity), r.setFloat1(o, `${d}radius`, c.radius); } return this.currentNormalMapRotation = null, this; }, batchTexture(t, e, i, n, s, r, o, a, h, l, u, c, d, f, p, g, v, m, y, x, T, w, b, E, S, _, A, C, M, P) { let O; let R; let L; let k; let D; let F; let I; let B; let N; let Y; let X; let U; let z; let G; let W; let V; let H; let j; let q; let K; let J; let Z; let Q; let $; let tt; this.active && (this.renderer.setPipeline(this), t.displayTexture ? O = t.displayTexture.dataSource[t.displayFrame.sourceIndex] : t.texture ? O = t.texture.dataSource[t.frame.sourceIndex] : t.tileset && (O = Array.isArray(t.tileset) ? t.tileset[0].image.dataSource[0] : t.tileset.image.dataSource[0]), O ? (this.setTexture2D(O.glTexture, 1), this.setNormalMapRotation(u), R = this._tempMatrix1, L = this._tempMatrix2, k = this._tempMatrix3, D = m / i + A, F = y / n + C, I = (m + x) / i + A, B = (y + T) / n + C, U = o, z = a, N = -g, Y = -v, t.isCropped && (U = (X = t._crop).width, z = X.height, o = X.width, a = X.height, G = m = X.x, W = y = X.y, c && (G = x - X.x - X.width), d && !e.isRenderTexture && (W = T - X.y - X.height), D = G / i + A, F = W / n + C, I = (G + X.width) / i + A, B = (W + X.height) / n + C, N = -g + m, Y = -v + y), c && (U *= -1, N += o), (d ^= e.isRenderTexture ? 1 : 0) && (z *= -1, Y += a), V = N + U, H = Y + z, L.applyITRS(s, r, u, h, l), R.copyFrom(M.matrix), P ? (R.multiplyWithOffset(P, -M.scrollX * f, -M.scrollY * p), L.e = s, L.f = r) : (L.e -= M.scrollX * f, L.f -= M.scrollY * p), R.multiply(L, k), j = k.getX(N, Y), q = k.getY(N, Y), K = k.getX(N, H), J = k.getY(N, H), Z = k.getX(V, H), Q = k.getY(V, H), $ = k.getX(V, Y), tt = k.getY(V, Y), M.roundPixels && (j = Math.round(j), q = Math.round(q), K = Math.round(K), J = Math.round(J), Z = Math.round(Z), Q = Math.round(Q), $ = Math.round($), tt = Math.round(tt)), this.setTexture2D(e, 0), this.batchQuad(j, q, K, J, Z, Q, $, tt, D, F, I, B, w, b, E, S, _, e, 0)) : console.warn('Normal map missing or invalid')); }, setNormalMap(t) { let e; this.active && t && (t.texture && (e = t.texture.dataSource[t.frame.sourceIndex]), e = e || this.defaultNormalMap, this.setTexture2D(e.glTexture, 1), this.renderer.setPipeline(t.defaultPipeline)); }, setNormalMapRotation(t) { let e; let i; let n; let s; t === this.currentNormalMapRotation && this.batches.length !== 0 || (this.batches.length > 0 && this.flush(), e = this.inverseRotationMatrix, t ? (i = -t, n = Math.cos(i), s = Math.sin(i), e[1] = s, e[3] = -s, e[0] = e[4] = n) : (e[0] = e[4] = 1, e[1] = e[3] = 0), this.renderer.setMatrix3(this.program, 'uInverseRotationMatrix', !1, e), this.currentNormalMapRotation = t); }, batchSprite(t, e, i) { let n; !this.active || (n = t.texture.dataSource[t.frame.sourceIndex]) && (this.renderer.setPipeline(this), this.setTexture2D(n.glTexture, 1), this.setNormalMapRotation(t.rotation), r.prototype.batchSprite.call(this, t, e, i)); },\n    }); o.LIGHT_COUNT = f, t.exports = o;\n  }, function (t, e, i) {\n    const n = i(0); const s = i(2); const r = i(238); const o = i(340); const a = i(341); const h = i(29); const l = i(147); const u = new n({\n      Extends: l,\n      Mixins: [r],\n      initialize(t) {\n        const e = t.renderer.config; l.call(this, {\n          game: t.game,\n          renderer: t.renderer,\n          gl: t.renderer.gl,\n          topology: t.renderer.gl.TRIANGLE_STRIP,\n          vertShader: s(t, 'vertShader', a),\n          fragShader: s(t, 'fragShader', o),\n          vertexCapacity: s(t, 'vertexCapacity', 6 * e.batchSize),\n          vertexSize: s(t, 'vertexSize', 5 * Float32Array.BYTES_PER_ELEMENT + 4 * Uint8Array.BYTES_PER_ELEMENT),\n          attributes: [{\n            name: 'inPosition', size: 2, type: t.renderer.gl.FLOAT, normalized: !1, offset: 0,\n          }, {\n            name: 'inTexCoord', size: 2, type: t.renderer.gl.FLOAT, normalized: !1, offset: 2 * Float32Array.BYTES_PER_ELEMENT,\n          }, {\n            name: 'inTintEffect', size: 1, type: t.renderer.gl.FLOAT, normalized: !1, offset: 4 * Float32Array.BYTES_PER_ELEMENT,\n          }, {\n            name: 'inTint', size: 4, type: t.renderer.gl.UNSIGNED_BYTE, normalized: !0, offset: 5 * Float32Array.BYTES_PER_ELEMENT,\n          }],\n        }), this.vertexViewF32 = new Float32Array(this.vertexData), this.vertexViewU32 = new Uint32Array(this.vertexData), this.maxQuads = e.batchSize, this.batches = [], this._tempMatrix1 = new h(), this._tempMatrix2 = new h(), this._tempMatrix3 = new h(), this.mvpInit();\n      },\n      onBind() { return l.prototype.onBind.call(this), this.mvpUpdate(), this; },\n      resize(t, e, i) { return l.prototype.resize.call(this, t, e, i), this.projOrtho(0, this.width, this.height, 0, -1e3, 1e3), this; },\n      setTexture2D(t, e) { return void 0 === t && (t = this.renderer.blankTexture.glTexture), void 0 === e && (e = 0), this.requireTextureBatch(t, e) && this.pushBatch(t, e), this; },\n      requireTextureBatch(t, e) { const i = this.batches; const n = i.length; return !(n > 0) || !((e > 0 ? i[n - 1].textures[e - 1] : i[n - 1].texture) === t); },\n      pushBatch(t, e) { let i; e === 0 ? this.batches.push({ first: this.vertexCount, texture: t, textures: [] }) : ((i = [])[e - 1] = t, this.batches.push({ first: this.vertexCount, texture: null, textures: i })); },\n      flush() { if (this.flushLocked) return this; this.flushLocked = !0; let t; let e; let i; const n = this.gl; const s = this.vertexCount; const r = this.topology; const o = this.vertexSize; const a = this.renderer; const h = this.batches; const l = h.length; let u = 0; let c = null; if (l === 0 || s === 0) return this.flushLocked = !1, this; n.bufferSubData(n.ARRAY_BUFFER, 0, this.bytes.subarray(0, s * o)); for (let d = 0; d < l - 1; d++) { if (c = h[d], t = h[d + 1], c.textures.length > 0) { for (e = 0; e < c.textures.length; ++e)(i = c.textures[e]) && a.setTexture2D(i, 1 + e, !1); n.activeTexture(n.TEXTURE0); }u = t.first - c.first, c.texture === null || u <= 0 || (a.setTexture2D(c.texture, 0, !1), n.drawArrays(r, c.first, u)); } if ((c = h[l - 1]).textures.length > 0) { for (e = 0; e < c.textures.length; ++e)(i = c.textures[e]) && a.setTexture2D(i, 1 + e, !1); n.activeTexture(n.TEXTURE0); } return u = s - c.first, c.texture && u > 0 && (a.setTexture2D(c.texture, 0, !1), n.drawArrays(r, c.first, u)), this.vertexCount = 0, h.length = 0, this.flushLocked = !1, this; },\n    }); t.exports = u;\n  }, function (t, e, i) { const n = {}; t.exports = n; const r = i(99); const o = i(42); n.fromVertices = function (t) { for (var e = {}, i = 0; i < t.length; i++) { const n = (i + 1) % t.length; const s = r.normalise({ x: t[n].y - t[i].y, y: t[i].x - t[n].x }); e[(s.y === 0 ? 1 / 0 : s.x / s.y).toFixed(3).toString()] = s; } return o.values(e); }, n.rotate = function (t, e) { if (e !== 0) for (let i = Math.cos(e), n = Math.sin(e), s = 0; s < t.length; s++) { const r = t[s]; const o = r.x * i - r.y * n; r.y = r.x * n + r.y * i, r.x = o; } }; }, function (t, e, i) {\n    t.exports = {\n      Bounce: i(1397), Collision: i(1398), Force: i(1399), Friction: i(1400), Gravity: i(1401), Mass: i(1402), Static: i(1403), Sensor: i(1404), SetBody: i(1405), Sleep: i(1406), Transform: i(1423), Velocity: i(1424),\n    };\n  }, function (t, e, i) { const g = {}; t.exports = g; const v = i(516); const m = i(473); const y = i(100); g.collisions = function (t, e) { for (var i = [], n = e.pairs.table, s = e.metrics, r = 0; r < t.length; r++) { const o = t[r][0]; const a = t[r][1]; if ((!o.isStatic && !o.isSleeping || !a.isStatic && !a.isSleeping) && (g.canCollide(o.collisionFilter, a.collisionFilter) && (s.midphaseTests += 1, y.overlaps(o.bounds, a.bounds)))) for (let h = o.parts.length > 1 ? 1 : 0; h < o.parts.length; h++) for (let l = o.parts[h], u = a.parts.length > 1 ? 1 : 0; u < a.parts.length; u++) { var c; var d; var f; const p = a.parts[u]; (l === o && p === a || y.overlaps(l.bounds, p.bounds)) && (d = (c = n[m.id(l, p)]) && c.isActive ? c.collision : null, f = v.collides(l, p, d), s.narrowphaseTests += 1, f.reused && (s.narrowReuseCount += 1), f.collided && (i.push(f), s.narrowDetections += 1)); } } return i; }, g.canCollide = function (t, e) { return t.group === e.group && t.group !== 0 ? t.group > 0 : (t.mask & e.category) != 0 && (e.mask & t.category) != 0; }; }, function (t, e, i) { const m = {}; t.exports = m; const y = i(86); const x = i(99); m.collides = function (t, e, i) { let n; let s; let r; let o; let a; let h; let l = !1; if (h = i ? (r = t.parent, o = e.parent, a = r.speed * r.speed + r.angularSpeed * r.angularSpeed + o.speed * o.speed + o.angularSpeed * o.angularSpeed, l = i && i.collided && a < 0.2, i) : { collided: !1, bodyA: t, bodyB: e }, i && l) { const u = h.axisBody; const c = u === t ? e : t; const d = [u.axes[i.axisNumber]]; var f = m._overlapAxes(u.vertices, c.vertices, d); if (h.reused = !0, f.overlap <= 0) return h.collided = !1, h; } else { if ((n = m._overlapAxes(t.vertices, e.vertices, t.axes)).overlap <= 0) return h.collided = !1, h; if ((s = m._overlapAxes(e.vertices, t.vertices, e.axes)).overlap <= 0) return h.collided = !1, h; n.overlap < s.overlap ? (f = n, h.axisBody = t) : (f = s, h.axisBody = e), h.axisNumber = f.axisNumber; }h.bodyA = t.id < e.id ? t : e, h.bodyB = t.id < e.id ? e : t, h.collided = !0, h.depth = f.overlap, h.parentA = h.bodyA.parent, h.parentB = h.bodyB.parent, t = h.bodyA, e = h.bodyB, x.dot(f.axis, x.sub(e.position, t.position)) < 0 ? h.normal = { x: f.axis.x, y: f.axis.y } : h.normal = { x: -f.axis.x, y: -f.axis.y }, h.tangent = x.perp(h.normal), h.penetration = h.penetration || {}, h.penetration.x = h.normal.x * h.depth, h.penetration.y = h.normal.y * h.depth; let p; const g = m._findSupports(t, e, h.normal); let v = []; return y.contains(t.vertices, g[0]) && v.push(g[0]), y.contains(t.vertices, g[1]) && v.push(g[1]), v.length < 2 && (p = m._findSupports(e, t, x.neg(h.normal)), y.contains(e.vertices, p[0]) && v.push(p[0]), v.length < 2 && y.contains(e.vertices, p[1]) && v.push(p[1])), v.length < 1 && (v = [g[0]]), h.supports = v, h; }, m._overlapAxes = function (t, e, i) { for (var n, s, r = x._temp[0], o = x._temp[1], a = { overlap: Number.MAX_VALUE }, h = 0; h < i.length; h++) { if (s = i[h], m._projectToAxis(r, t, s), m._projectToAxis(o, e, s), (n = Math.min(r.max - o.min, o.max - r.min)) <= 0) return a.overlap = n, a; n < a.overlap && (a.overlap = n, a.axis = s, a.axisNumber = h); } return a; }, m._projectToAxis = function (t, e, i) { for (var n = x.dot(e[0], i), s = n, r = 1; r < e.length; r += 1) { const o = x.dot(e[r], i); s < o ? s = o : o < n && (n = o); }t.min = n, t.max = s; }, m._findSupports = function (t, e, i) { for (var n, s, r, o = Number.MAX_VALUE, a = x._temp[0], h = e.vertices, l = t.position, u = 0; u < h.length; u++)c = h[u], a.x = c.x - l.x, a.y = c.y - l.y, (n = -x.dot(i, a)) < o && (o = n, s = c); var c = h[s.index - 1 >= 0 ? s.index - 1 : h.length - 1]; return a.x = c.x - l.x, a.y = c.y - l.y, o = -x.dot(i, a), r = c, c = h[(s.index + 1) % h.length], a.x = c.x - l.x, a.y = c.y - l.y, (n = -x.dot(i, a)) < o && (r = c), [s, r]; }; }, function (t, e) { let i = (function () { return this; }()); try { i = i || new Function('return this')(); } catch (t) { typeof window === 'object' && (i = window); }t.exports = i; }, function (t, e, i) { i(519), i(520), i(521), i(522), i(523), i(524), i(525), i(526); }, function (t, e) {\n    Array.prototype.forEach || (Array.prototype.forEach = function (t) {\n      if (this == null) throw new TypeError(); const e = Object(this); const i = e.length >>> 0; if (typeof t !== 'function') throw new TypeError(); for (let n = arguments.length >= 2 ? arguments[1] : void 0, s = 0; s < i; s++)s in e && t.call(n, e[s], s, e);\n    });\n  }, function (t, e) { Array.isArray || (Array.isArray = function (t) { return Object.prototype.toString.call(t) === '[object Array]'; }); }, function (t, e) { function i(t) { t && (t.setTargetAtTime || (t.setTargetAtTime = t.setTargetValueAtTime)); }window.hasOwnProperty('webkitAudioContext') && !window.hasOwnProperty('AudioContext') && (window.AudioContext = webkitAudioContext, AudioContext.prototype.hasOwnProperty('createGain') || (AudioContext.prototype.createGain = AudioContext.prototype.createGainNode), AudioContext.prototype.hasOwnProperty('createDelay') || (AudioContext.prototype.createDelay = AudioContext.prototype.createDelayNode), AudioContext.prototype.hasOwnProperty('createScriptProcessor') || (AudioContext.prototype.createScriptProcessor = AudioContext.prototype.createJavaScriptNode), AudioContext.prototype.hasOwnProperty('createPeriodicWave') || (AudioContext.prototype.createPeriodicWave = AudioContext.prototype.createWaveTable), AudioContext.prototype.internal_createGain = AudioContext.prototype.createGain, AudioContext.prototype.createGain = function () { const t = this.internal_createGain(); return i(t.gain), t; }, AudioContext.prototype.internal_createDelay = AudioContext.prototype.createDelay, AudioContext.prototype.createDelay = function (t) { const e = t ? this.internal_createDelay(t) : this.internal_createDelay(); return i(e.delayTime), e; }, AudioContext.prototype.internal_createBufferSource = AudioContext.prototype.createBufferSource, AudioContext.prototype.createBufferSource = function () { const n = this.internal_createBufferSource(); return n.start ? (n.internal_start = n.start, n.start = function (t, e, i) { void 0 !== i ? n.internal_start(t || 0, e, i) : n.internal_start(t || 0, e || 0); }) : n.start = function (t, e, i) { e || i ? this.noteGrainOn(t || 0, e, i) : this.noteOn(t || 0); }, n.stop ? (n.internal_stop = n.stop, n.stop = function (t) { n.internal_stop(t || 0); }) : n.stop = function (t) { this.noteOff(t || 0); }, i(n.playbackRate), n; }, AudioContext.prototype.internal_createDynamicsCompressor = AudioContext.prototype.createDynamicsCompressor, AudioContext.prototype.createDynamicsCompressor = function () { const t = this.internal_createDynamicsCompressor(); return i(t.threshold), i(t.knee), i(t.ratio), i(t.reduction), i(t.attack), i(t.release), t; }, AudioContext.prototype.internal_createBiquadFilter = AudioContext.prototype.createBiquadFilter, AudioContext.prototype.createBiquadFilter = function () { const t = this.internal_createBiquadFilter(); return i(t.frequency), i(t.detune), i(t.Q), i(t.gain), t; }, AudioContext.prototype.hasOwnProperty('createOscillator') && (AudioContext.prototype.internal_createOscillator = AudioContext.prototype.createOscillator, AudioContext.prototype.createOscillator = function () { const e = this.internal_createOscillator(); return e.start ? (e.internal_start = e.start, e.start = function (t) { e.internal_start(t || 0); }) : e.start = function (t) { this.noteOn(t || 0); }, e.stop ? (e.internal_stop = e.stop, e.stop = function (t) { e.internal_stop(t || 0); }) : e.stop = function (t) { this.noteOff(t || 0); }, e.setPeriodicWave || (e.setPeriodicWave = e.setWaveTable), i(e.frequency), i(e.detune), e; })), window.hasOwnProperty('webkitOfflineAudioContext') && !window.hasOwnProperty('OfflineAudioContext') && (window.OfflineAudioContext = webkitOfflineAudioContext); }, function (t, e) { window.console || (window.console = {}, window.console.log = window.console.assert = function () {}, window.console.warn = window.console.assert = function () {}); }, function (t, e) { Math.trunc || (Math.trunc = function (t) { return t < 0 ? Math.ceil(t) : Math.floor(t); }); }, function (t, e) { let i; 'performance' in window == !1 && (window.performance = {}), Date.now = Date.now || function () { return (new Date()).getTime(); }, 'now' in window.performance == !1 && (i = Date.now(), performance.timing && performance.timing.navigationStart && (i = performance.timing.navigationStart), window.performance.now = function () { return Date.now() - i; }); }, function (t, e) { for (var n = Date.now(), i = ['ms', 'moz', 'webkit', 'o'], s = 0; s < i.length && !window.requestAnimationFrame; s++)window.requestAnimationFrame = window[`${i[s]}RequestAnimationFrame`], window.cancelAnimationFrame = window[`${i[s]}CancelAnimationFrame`] || window[`${i[s]}CancelRequestAnimationFrame`]; window.requestAnimationFrame || (window.requestAnimationFrame = function (t) { if (typeof t !== 'function') throw new TypeError(`${t}is not a function`); const e = Date.now(); let i = 16 + n - e; return i < 0 && (i = 0), n = e, setTimeout(() => { n = Date.now(), t(performance.now()); }, i); }), window.cancelAnimationFrame || (window.cancelAnimationFrame = function (t) { clearTimeout(t); }); }, function (t, e) { let i; typeof window.Uint32Array !== 'function' && typeof window.Uint32Array !== 'object' && ((i = function (t) { const e = new Array(); window[t] = function (t) { if (typeof t === 'number') { Array.call(this, t), this.length = t; for (var e = 0; e < this.length; e++) this[e] = 0; } else { Array.call(this, t.length), this.length = t.length; for (e = 0; e < this.length; e++) this[e] = t[e]; } }, window[t].prototype = e, window[t].constructor = window[t]; })('Float32Array'), i('Uint32Array'), i('Uint16Array'), i('Int16Array'), i('ArrayBuffer')); }, function (t, e, i) { const a = i(242); t.exports = function (t, e, i, n) { for (let s = t[0], r = 1; r < t.length; r++) { const o = t[r]; a(o, s, e, i, n), s = o; } return t; }; }, function (t, e, i) { const r = i(38); t.exports = function (t, e, i, n, s) { return r(t, 'angle', e, i, n, s); }; }, function (t, e) { t.exports = function (t, e, i) { for (let n = 0; n < t.length; n++) { const s = t[n]; e.call(i, s); } return t; }; }, function (t, e) { t.exports = function (t, e, i) { void 0 === i && (i = 0); for (let n = i; n < t.length; n++) { const s = t[n]; let r = !0; for (const o in e)s[o] !== e[o] && (r = !1); if (r) return s; } return null; }; }, function (t, e) { t.exports = function (t, e, i) { void 0 === i && (i = 0); for (let n = i; n < t.length; n++) { const s = t[n]; let r = !0; for (const o in e)s[o] !== e[o] && (r = !1); if (r) return s; } return null; }; }, function (t, e, i) { const v = i(255); const m = i(105); const y = i(2); const n = i(1); const x = new (i(110))({ sys: { queueDepthSort: n, events: { once: n } } }, 0, 0, 1, 1); t.exports = function (t, e) { void 0 === e && (e = {}); const i = e.hasOwnProperty('width'); const n = e.hasOwnProperty('height'); const s = y(e, 'width', -1); const r = y(e, 'height', -1); const o = y(e, 'cellWidth', 1); const a = y(e, 'cellHeight', o); const h = y(e, 'position', m.TOP_LEFT); const l = y(e, 'x', 0); const u = y(e, 'y', 0); let c = 0; let d = 0; const f = s * o; const p = r * a; x.setPosition(l, u), x.setSize(o, a); for (let g = 0; g < t.length; g++) if (v(t[g], x, h), i && s === -1)x.x += o; else if (n && r === -1)x.y += a; else if (c += o, x.x += o, c === f && (c = 0, d += a, x.x = l, x.y += a, d === p)) break; return t; }; }, function (t, e, i) {\n    const s = i(19); const n = {\n      _alpha: 1, _alphaTL: 1, _alphaTR: 1, _alphaBL: 1, _alphaBR: 1, clearAlpha() { return this.setAlpha(1); }, setAlpha(t, e, i, n) { return void 0 === t && (t = 1), void 0 === e ? this.alpha = t : (this._alphaTL = s(t, 0, 1), this._alphaTR = s(e, 0, 1), this._alphaBL = s(i, 0, 1), this._alphaBR = s(n, 0, 1)), this; }, alpha: { get() { return this._alpha; }, set(t) { const e = s(t, 0, 1); this._alpha = e, this._alphaTL = e, this._alphaTR = e, this._alphaBL = e, (this._alphaBR = e) === 0 ? this.renderFlags &= -3 : this.renderFlags |= 2; } }, alphaTopLeft: { get() { return this._alphaTL; }, set(t) { const e = s(t, 0, 1); (this._alphaTL = e) !== 0 && (this.renderFlags |= 2); } }, alphaTopRight: { get() { return this._alphaTR; }, set(t) { const e = s(t, 0, 1); (this._alphaTR = e) !== 0 && (this.renderFlags |= 2); } }, alphaBottomLeft: { get() { return this._alphaBL; }, set(t) { const e = s(t, 0, 1); (this._alphaBL = e) !== 0 && (this.renderFlags |= 2); } }, alphaBottomRight: { get() { return this._alphaBR; }, set(t) { const e = s(t, 0, 1); (this._alphaBR = e) !== 0 && (this.renderFlags |= 2); } },\n    }; t.exports = n;\n  }, function (t, e) { t.exports = 'add'; }, function (t, e) { t.exports = 'complete'; }, function (t, e) { t.exports = 'repeat'; }, function (t, e) { t.exports = 'restart'; }, function (t, e) { t.exports = 'start'; }, function (t, e) { t.exports = 'pauseall'; }, function (t, e) { t.exports = 'remove'; }, function (t, e) { t.exports = 'resumeall'; }, function (t, e) { t.exports = 'animationcomplete'; }, function (t, e) { t.exports = 'animationcomplete-'; }, function (t, e) { t.exports = 'animationrepeat-'; }, function (t, e) { t.exports = 'animationrestart-'; }, function (t, e) { t.exports = 'animationstart-'; }, function (t, e) { t.exports = 'animationupdate-'; }, function (t, e) { t.exports = 'animationrepeat'; }, function (t, e) { t.exports = 'animationrestart'; }, function (t, e) { t.exports = 'animationstart'; }, function (t, e) { t.exports = 'animationupdate'; }, function (t, e) {\n    t.exports = {\n      width: 0, height: 0, displayWidth: { get() { return this.scaleX * this.width; }, set(t) { this.scaleX = t / this.width; } }, displayHeight: { get() { return this.scaleY * this.height; }, set(t) { this.scaleY = t / this.height; } }, setSize(t, e) { return this.width = t, this.height = e, this; }, setDisplaySize(t, e) { return this.displayWidth = t, this.displayHeight = e, this; },\n    };\n  }, function (t, e) {\n    const i = {\n      texture: null,\n      frame: null,\n      isCropped: !1,\n      setCrop(t, e, i, n) { return void 0 === t ? this.isCropped = !1 : this.frame && (typeof t === 'number' ? this.frame.setCropUVs(this._crop, t, e, i, n, this.flipX, this.flipY) : this.frame.setCropUVs(this._crop, t.x, t.y, t.width, t.height, this.flipX, this.flipY), this.isCropped = !0), this; },\n      resetCropObject() {\n        return {\n          u0: 0, v0: 0, u1: 0, v1: 0, width: 0, height: 0, x: 0, y: 0, flipX: !1, flipY: !1, cx: 0, cy: 0, cw: 0, ch: 0,\n        };\n      },\n    }; t.exports = i;\n  }, function (t, e) {\n    t.exports = {\n      flipX: !1, flipY: !1, toggleFlipX() { return this.flipX = !this.flipX, this; }, toggleFlipY() { return this.flipY = !this.flipY, this; }, setFlipX(t) { return this.flipX = t, this; }, setFlipY(t) { return this.flipY = t, this; }, setFlip(t, e) { return this.flipX = t, this.flipY = e, this; }, resetFlip() { return this.flipX = !1, this.flipY = !1, this; },\n    };\n  }, function (t, e, i) {\n    const u = i(11); const n = i(276); const s = i(3); const r = {\n      prepareBoundsOutput(t, e) { return void 0 === e && (e = !1), this.rotation !== 0 && n(t, this.x, this.y, this.rotation), e && this.parentContainer && this.parentContainer.getBoundsTransformMatrix().transformPoint(t.x, t.y, t), t; }, getCenter(t) { return void 0 === t && (t = new s()), t.x = this.x - this.displayWidth * this.originX + this.displayWidth / 2, t.y = this.y - this.displayHeight * this.originY + this.displayHeight / 2, t; }, getTopLeft(t, e) { return (t = t || new s()).x = this.x - this.displayWidth * this.originX, t.y = this.y - this.displayHeight * this.originY, this.prepareBoundsOutput(t, e); }, getTopCenter(t, e) { return (t = t || new s()).x = this.x - this.displayWidth * this.originX + this.displayWidth / 2, t.y = this.y - this.displayHeight * this.originY, this.prepareBoundsOutput(t, e); }, getTopRight(t, e) { return (t = t || new s()).x = this.x - this.displayWidth * this.originX + this.displayWidth, t.y = this.y - this.displayHeight * this.originY, this.prepareBoundsOutput(t, e); }, getLeftCenter(t, e) { return (t = t || new s()).x = this.x - this.displayWidth * this.originX, t.y = this.y - this.displayHeight * this.originY + this.displayHeight / 2, this.prepareBoundsOutput(t, e); }, getRightCenter(t, e) { return (t = t || new s()).x = this.x - this.displayWidth * this.originX + this.displayWidth, t.y = this.y - this.displayHeight * this.originY + this.displayHeight / 2, this.prepareBoundsOutput(t, e); }, getBottomLeft(t, e) { return (t = t || new s()).x = this.x - this.displayWidth * this.originX, t.y = this.y - this.displayHeight * this.originY + this.displayHeight, this.prepareBoundsOutput(t, e); }, getBottomCenter(t, e) { return (t = t || new s()).x = this.x - this.displayWidth * this.originX + this.displayWidth / 2, t.y = this.y - this.displayHeight * this.originY + this.displayHeight, this.prepareBoundsOutput(t, e); }, getBottomRight(t, e) { return (t = t || new s()).x = this.x - this.displayWidth * this.originX + this.displayWidth, t.y = this.y - this.displayHeight * this.originY + this.displayHeight, this.prepareBoundsOutput(t, e); }, getBounds(t) { let e; let i; let n; let s; let r; let o; let a; let h; let l; return void 0 === t && (t = new u()), h = (a = (this.parentContainer ? (l = this.parentContainer.getBoundsTransformMatrix(), this.getTopLeft(t), l.transformPoint(t.x, t.y, t), e = t.x, i = t.y, this.getTopRight(t), l.transformPoint(t.x, t.y, t), n = t.x, s = t.y, this.getBottomLeft(t), l.transformPoint(t.x, t.y, t), r = t.x, o = t.y, this.getBottomRight(t), l.transformPoint(t.x, t.y, t)) : (this.getTopLeft(t), e = t.x, i = t.y, this.getTopRight(t), n = t.x, s = t.y, this.getBottomLeft(t), r = t.x, o = t.y, this.getBottomRight(t)), t.x), t.y), t.x = Math.min(e, n, r, a), t.y = Math.min(i, s, o, h), t.width = Math.max(e, n, r, a) - t.x, t.height = Math.max(i, s, o, h) - t.y, t; },\n    }; t.exports = r;\n  }, function (t, e) { t.exports = 'blur'; }, function (t, e) { t.exports = 'boot'; }, function (t, e) { t.exports = 'contextlost'; }, function (t, e) { t.exports = 'contextrestored'; }, function (t, e) { t.exports = 'destroy'; }, function (t, e) { t.exports = 'focus'; }, function (t, e) { t.exports = 'hidden'; }, function (t, e) { t.exports = 'pause'; }, function (t, e) { t.exports = 'postrender'; }, function (t, e) { t.exports = 'poststep'; }, function (t, e) { t.exports = 'prerender'; }, function (t, e) { t.exports = 'prestep'; }, function (t, e) { t.exports = 'ready'; }, function (t, e) { t.exports = 'resume'; }, function (t, e) { t.exports = 'step'; }, function (t, e) { t.exports = 'visible'; }, function (t, e) {\n    const i = {\n      _originComponent: !0, originX: 0.5, originY: 0.5, _displayOriginX: 0, _displayOriginY: 0, displayOriginX: { get() { return this._displayOriginX; }, set(t) { this._displayOriginX = t, this.originX = t / this.width; } }, displayOriginY: { get() { return this._displayOriginY; }, set(t) { this._displayOriginY = t, this.originY = t / this.height; } }, setOrigin(t, e) { return void 0 === t && (t = 0.5), void 0 === e && (e = t), this.originX = t, this.originY = e, this.updateDisplayOrigin(); }, setOriginFromFrame() { return this.frame && this.frame.customPivot ? (this.originX = this.frame.pivotX, this.originY = this.frame.pivotY, this.updateDisplayOrigin()) : this.setOrigin(); }, setDisplayOrigin(t, e) { return void 0 === t && (t = 0), void 0 === e && (e = t), this.displayOriginX = t, this.displayOriginY = e, this; }, updateDisplayOrigin() { return this._displayOriginX = this.originX * this.width, this._displayOriginY = this.originY * this.height, this; },\n    }; t.exports = i;\n  }, function (t, e, i) {\n    const h = i(39); const o = i(88); const a = i(6); const l = i(89); const u = i(3); const n = {\n      path: null, rotateToPath: !1, pathRotationOffset: 0, pathOffset: null, pathVector: null, pathDelta: null, pathTween: null, pathConfig: null, _prevDirection: l.PLAYING_FORWARD, setPath(t, e) { void 0 === e && (e = this.pathConfig); const i = this.pathTween; return i && i.isPlaying() && i.stop(), this.path = t, e && this.startFollow(e), this; }, setRotateToPath(t, e) { return void 0 === e && (e = 0), this.rotateToPath = t, this.pathRotationOffset = e, this; }, isFollowing() { const t = this.pathTween; return t && t.isPlaying(); }, startFollow(t, e) { void 0 === t && (t = {}), void 0 === e && (e = 0); const i = this.pathTween; i && i.isPlaying() && i.stop(), typeof t === 'number' && (t = { duration: t }), t.from = a(t, 'from', 0), t.to = a(t, 'to', 1); const n = o(t, 'positionOnPath', !1); this.rotateToPath = o(t, 'rotateToPath', !1), this.pathRotationOffset = a(t, 'rotationOffset', 0); let s; const r = a(t, 'startAt', e); return r && (t.onStart = function (t) { const e = t.data[0]; e.progress = r, e.elapsed = e.duration * r; const i = e.ease(e.progress); e.current = e.start + (e.end - e.start) * i, e.target[e.key] = e.current; }), this.pathOffset || (this.pathOffset = new u(this.x, this.y)), this.pathVector || (this.pathVector = new u()), this.pathDelta || (this.pathDelta = new u()), this.pathDelta.reset(), this.pathTween = this.scene.sys.tweens.addCounter(t), this.path.getStartPoint(this.pathOffset), n && (this.x = this.pathOffset.x, this.y = this.pathOffset.y), this.pathOffset.x = this.x - this.pathOffset.x, this.pathOffset.y = this.y - this.pathOffset.y, this._prevDirection = l.PLAYING_FORWARD, this.rotateToPath && (s = this.path.getPoint(0.1), this.rotation = Math.atan2(s.y - this.y, s.x - this.x) + h(this.pathRotationOffset)), this.pathConfig = t, this; }, pauseFollow() { const t = this.pathTween; return t && t.isPlaying() && t.pause(), this; }, resumeFollow() { const t = this.pathTween; return t && t.isPaused() && t.resume(), this; }, stopFollow() { const t = this.pathTween; return t && t.isPlaying() && t.stop(), this; }, pathUpdate() { const t = this.pathTween; if (t) { const e = t.data[0]; const i = this.pathDelta; const n = this.pathVector; if (i.copy(n).negate(), e.state === l.COMPLETE) return this.path.getPoint(1, n), i.add(n), n.add(this.pathOffset), void this.setPosition(n.x, n.y); if (e.state !== l.PLAYING_FORWARD && e.state !== l.PLAYING_BACKWARD) return; this.path.getPoint(t.getValue(), n), i.add(n), n.add(this.pathOffset); const s = this.x; const r = this.y; this.setPosition(n.x, n.y); const o = this.x - s; const a = this.y - r; if (o == 0 && a == 0) return; if (e.state !== this._prevDirection) return void (this._prevDirection = e.state); this.rotateToPath && (this.rotation = Math.atan2(a, o) + h(this.pathRotationOffset)); } },\n    }; t.exports = n;\n  }, function (t, e) {\n    const i = {\n      _sizeComponent: !0, width: 0, height: 0, displayWidth: { get() { return Math.abs(this.scaleX * this.frame.realWidth); }, set(t) { this.scaleX = t / this.frame.realWidth; } }, displayHeight: { get() { return Math.abs(this.scaleY * this.frame.realHeight); }, set(t) { this.scaleY = t / this.frame.realHeight; } }, setSizeToFrame(t) { return void 0 === t && (t = this.frame), this.width = t.realWidth, this.height = t.realHeight, this; }, setSize(t, e) { return this.width = t, this.height = e, this; }, setDisplaySize(t, e) { return this.displayWidth = t, this.displayHeight = e, this; },\n    }; t.exports = i;\n  }, function (t, e) {\n    const i = {\n      texture: null, frame: null, isCropped: !1, setTexture(t, e) { return this.texture = this.scene.sys.textures.get(t), this.setFrame(e); }, setFrame(t, e, i) { return void 0 === e && (e = !0), void 0 === i && (i = !0), this.frame = this.texture.get(t), this.frame.cutWidth && this.frame.cutHeight ? this.renderFlags |= 8 : this.renderFlags &= -9, this._sizeComponent && e && this.setSizeToFrame(), this._originComponent && i && (this.frame.customPivot ? this.setOrigin(this.frame.pivotX, this.frame.pivotY) : this.updateDisplayOrigin()), this; },\n    }; t.exports = i;\n  }, function (t, e) {\n    const i = {\n      texture: null,\n      frame: null,\n      isCropped: !1,\n      setCrop(t, e, i, n) { return void 0 === t ? this.isCropped = !1 : this.frame && (typeof t === 'number' ? this.frame.setCropUVs(this._crop, t, e, i, n, this.flipX, this.flipY) : this.frame.setCropUVs(this._crop, t.x, t.y, t.width, t.height, this.flipX, this.flipY), this.isCropped = !0), this; },\n      setTexture(t, e) { return this.texture = this.scene.sys.textures.get(t), this.setFrame(e); },\n      setFrame(t, e, i) { return void 0 === e && (e = !0), void 0 === i && (i = !0), this.frame = this.texture.get(t), this.frame.cutWidth && this.frame.cutHeight ? this.renderFlags |= 8 : this.renderFlags &= -9, this._sizeComponent && e && this.setSizeToFrame(), this._originComponent && i && (this.frame.customPivot ? this.setOrigin(this.frame.pivotX, this.frame.pivotY) : this.updateDisplayOrigin()), this.isCropped && this.frame.updateCropUVs(this._crop, this.flipX, this.flipY), this; },\n      resetCropObject() {\n        return {\n          u0: 0, v0: 0, u1: 0, v1: 0, width: 0, height: 0, x: 0, y: 0, flipX: !1, flipY: !1, cx: 0, cy: 0, cw: 0, ch: 0,\n        };\n      },\n    }; t.exports = i;\n  }, function (t, e) {\n    function s(t) { return (t >> 16) + (65280 & t) + ((255 & t) << 16); } const i = {\n      _tintTL: 16777215, _tintTR: 16777215, _tintBL: 16777215, _tintBR: 16777215, _isTinted: !1, tintFill: !1, clearTint() { return this.setTint(16777215), this._isTinted = !1, this; }, setTint(t, e, i, n) { return void 0 === t && (t = 16777215), void 0 === e && (n = i = e = t), this._tintTL = s(t), this._tintTR = s(e), this._tintBL = s(i), this._tintBR = s(n), this._isTinted = !0, this.tintFill = !1, this; }, setTintFill(t, e, i, n) { return this.setTint(t, e, i, n), this.tintFill = !0, this; }, tintTopLeft: { get() { return this._tintTL; }, set(t) { this._tintTL = s(t), this._isTinted = !0; } }, tintTopRight: { get() { return this._tintTR; }, set(t) { this._tintTR = s(t), this._isTinted = !0; } }, tintBottomLeft: { get() { return this._tintBL; }, set(t) { this._tintBL = s(t), this._isTinted = !0; } }, tintBottomRight: { get() { return this._tintBR; }, set(t) { this._tintBR = s(t), this._isTinted = !0; } }, tint: { set(t) { this.setTint(t, t, t, t); } }, isTinted: { get() { return this._isTinted; } },\n    }; t.exports = i;\n  }, function (t, e) { t.exports = 'changedata'; }, function (t, e) { t.exports = 'changedata-'; }, function (t, e) { t.exports = 'removedata'; }, function (t, e) { t.exports = 'setdata'; }, function (t, e) { t.exports = 'destroy'; }, function (t, e) { t.exports = 'complete'; }, function (t, e) { t.exports = 'created'; }, function (t, e) { t.exports = 'error'; }, function (t, e) { t.exports = 'loop'; }, function (t, e) { t.exports = 'play'; }, function (t, e) { t.exports = 'seeked'; }, function (t, e) { t.exports = 'seeking'; }, function (t, e) { t.exports = 'stop'; }, function (t, e) { t.exports = 'timeout'; }, function (t, e) { t.exports = 'unlocked'; }, function (t, e, i) { const r = i(38); t.exports = function (t, e, i, n, s) { return r(t, 'alpha', e, i, n, s); }; }, function (t, e, i) { const r = i(38); t.exports = function (t, e, i, n, s) { return r(t, 'x', e, i, n, s); }; }, function (t, e, i) { const a = i(38); t.exports = function (t, e, i, n, s, r, o) { return i == null && (i = e), a(t, 'x', e, n, r, o), a(t, 'y', i, s, r, o); }; }, function (t, e, i) { const r = i(38); t.exports = function (t, e, i, n, s) { return r(t, 'y', e, i, n, s); }; }, function (t, e) { t.exports = function (t, e, i, n) { void 0 === i && (i = 0), void 0 === n && (n = 6.28); for (let s = i, r = (n - i) / t.length, o = 0; o < t.length; o++)t[o].x = e.x + e.radius * Math.cos(s), t[o].y = e.y + e.radius * Math.sin(s), s += r; return t; }; }, function (t, e) { t.exports = function (t, e, i, n) { void 0 === i && (i = 0), void 0 === n && (n = 6.28); for (let s = i, r = (n - i) / t.length, o = e.width / 2, a = e.height / 2, h = 0; h < t.length; h++)t[h].x = e.x + o * Math.cos(s), t[h].y = e.y + a * Math.sin(s), s += r; return t; }; }, function (t, e, i) { const o = i(153); t.exports = function (t, e) { for (let i = o(e, t.length), n = 0; n < t.length; n++) { const s = t[n]; const r = i[n]; s.x = r.x, s.y = r.y; } return t; }; }, function (t, e, i) { const r = i(285); const o = i(286); const a = i(287); t.exports = function (t, e, i) { void 0 === i && (i = 0); const n = r(e, !1, t.length); i > 0 ? o(n, i) : i < 0 && a(n, Math.abs(i)); for (let s = 0; s < t.length; s++)t[s].x = n[s].x, t[s].y = n[s].y; return t; }; }, function (t, e, i) {\n    const c = i(288); t.exports = function (t, e, i) {\n      let n = c({\n        x1: e.x1, y1: e.y1, x2: e.x2, y2: e.y2,\n      }, i); const s = c({\n        x1: e.x2, y1: e.y2, x2: e.x3, y2: e.y3,\n      }, i); const r = c({\n        x1: e.x3, y1: e.y3, x2: e.x1, y2: e.y1,\n      }, i); n.pop(), s.pop(), r.pop(); for (let o = (n = n.concat(s, r)).length / t.length, a = 0, h = 0; h < t.length; h++) { const l = t[h]; const u = n[Math.floor(a)]; l.x = u.x, l.y = u.y, a += o; } return t;\n    };\n  }, function (t, e) { t.exports = function (t, e, i) { for (let n = 0; n < t.length; n++)t[n].anims.play(e, i); return t; }; }, function (t, e, i) { const n = i(150); t.exports = function (t, e) { for (let i = 0; i < t.length; i++)n(e, t[i]); return t; }; }, function (t, e, i) { const n = i(157); t.exports = function (t, e) { for (let i = 0; i < t.length; i++)n(e, t[i]); return t; }; }, function (t, e, i) { const n = i(154); t.exports = function (t, e) { for (let i = 0; i < t.length; i++)n(e, t[i]); return t; }; }, function (t, e, i) { const n = i(155); t.exports = function (t, e) { for (let i = 0; i < t.length; i++)n(e, t[i]); return t; }; }, function (t, e, i) { const n = i(158); t.exports = function (t, e) { for (let i = 0; i < t.length; i++)n(e, t[i]); return t; }; }, function (t, e, i) { const r = i(38); t.exports = function (t, e, i, n, s) { return r(t, 'rotation', e, i, n, s); }; }, function (t, e, i) { const a = i(159); const h = i(53); t.exports = function (t, e, i) { for (let n = e.x, s = e.y, r = 0; r < t.length; r++) { const o = t[r]; a(o, n, s, i, Math.max(1, h(o.x, o.y, n, s))); } return t; }; }, function (t, e, i) { const a = i(159); t.exports = function (t, e, i, n) { const s = e.x; const r = e.y; if (n === 0) return t; for (let o = 0; o < t.length; o++)a(t[o], s, r, i, n); return t; }; }, function (t, e, i) { const r = i(38); t.exports = function (t, e, i, n, s) { return r(t, 'scaleX', e, i, n, s); }; }, function (t, e, i) { const a = i(38); t.exports = function (t, e, i, n, s, r, o) { return i == null && (i = e), a(t, 'scaleX', e, n, r, o), a(t, 'scaleY', i, s, r, o); }; }, function (t, e, i) { const r = i(38); t.exports = function (t, e, i, n, s) { return r(t, 'scaleY', e, i, n, s); }; }, function (t, e, i) { const r = i(25); t.exports = function (t, e, i, n, s) { return r(t, 'alpha', e, i, n, s); }; }, function (t, e, i) { const s = i(25); t.exports = function (t, e, i, n) { return s(t, 'blendMode', e, 0, i, n); }; }, function (t, e, i) { const r = i(25); t.exports = function (t, e, i, n, s) { return r(t, 'depth', e, i, n, s); }; }, function (t, e) { t.exports = function (t, e, i) { for (let n = 0; n < t.length; n++)t[n].setInteractive(e, i); return t; }; }, function (t, e, i) { const a = i(25); t.exports = function (t, e, i, n, s, r, o) { return i == null && (i = e), a(t, 'originX', e, n, r, o), a(t, 'originY', i, s, r, o); }; }, function (t, e, i) { const r = i(25); t.exports = function (t, e, i, n, s) { return r(t, 'rotation', e, i, n, s); }; }, function (t, e, i) { const a = i(25); t.exports = function (t, e, i, n, s, r, o) { return i == null && (i = e), a(t, 'scaleX', e, n, r, o), a(t, 'scaleY', i, s, r, o); }; }, function (t, e, i) { const r = i(25); t.exports = function (t, e, i, n, s) { return r(t, 'scaleX', e, i, n, s); }; }, function (t, e, i) { const r = i(25); t.exports = function (t, e, i, n, s) { return r(t, 'scaleY', e, i, n, s); }; }, function (t, e, i) { const a = i(25); t.exports = function (t, e, i, n, s, r, o) { return i == null && (i = e), a(t, 'scrollFactorX', e, n, r, o), a(t, 'scrollFactorY', i, s, r, o); }; }, function (t, e, i) { const r = i(25); t.exports = function (t, e, i, n, s) { return r(t, 'scrollFactorX', e, i, n, s); }; }, function (t, e, i) { const r = i(25); t.exports = function (t, e, i, n, s) { return r(t, 'scrollFactorY', e, i, n, s); }; }, function (t, e) { t.exports = function (t, e, i, n, s) { for (let r = 0; r < t.length; r++)t[r].setTint(e, i, n, s); return t; }; }, function (t, e, i) { const s = i(25); t.exports = function (t, e, i, n) { return s(t, 'visible', e, 0, i, n); }; }, function (t, e, i) { const r = i(25); t.exports = function (t, e, i, n, s) { return r(t, 'x', e, i, n, s); }; }, function (t, e, i) { const a = i(25); t.exports = function (t, e, i, n, s, r, o) { return i == null && (i = e), a(t, 'x', e, n, r, o), a(t, 'y', i, s, r, o); }; }, function (t, e, i) { const r = i(25); t.exports = function (t, e, i, n, s) { return r(t, 'y', e, i, n, s); }; }, function (t, e, i) { const d = i(3); t.exports = function (t, e, i, n, s) { let r; let o; let a; if (void 0 === n && (n = 0), void 0 === s && (s = new d()), t.length > 1) if (n === 0) { for (var h = t.length - 1, l = t[h].x, u = t[h].y, c = h - 1; c >= 0; c--)r = (a = t[c]).x, o = a.y, a.x = l, a.y = u, l = r, u = o; t[h].x = e, t[h].y = i; } else { for (l = t[0].x, u = t[0].y, c = 1; c < t.length; c++)r = (a = t[c]).x, o = a.y, a.x = l, a.y = u, l = r, u = o; t[0].x = e, t[0].y = i; } else l = t[0].x, u = t[0].y, t[0].x = e, t[0].y = i; return s.x = l, s.y = u, s; }; }, function (t, e, i) { const n = i(114); t.exports = function (t) { return n(t); }; }, function (t, e, i) { const a = i(160); t.exports = function (t, e, i, n, s) { void 0 === s && (s = !1); let r; const o = Math.abs(n - i) / t.length; if (s) for (r = 0; r < t.length; r++)t[r][e] += a(r * o, i, n); else for (r = 0; r < t.length; r++)t[r][e] = a(r * o, i, n); return t; }; }, function (t, e, i) { const a = i(161); t.exports = function (t, e, i, n, s) { void 0 === s && (s = !1); let r; const o = Math.abs(n - i) / t.length; if (s) for (r = 0; r < t.length; r++)t[r][e] += a(r * o, i, n); else for (r = 0; r < t.length; r++)t[r][e] = a(r * o, i, n); return t; }; }, function (t, e) { t.exports = function (t, e, i, n, s) { void 0 === s && (s = !1); let r; const o = Math.abs(n - i) / t.length; if (s) for (r = 0; r < t.length; r++)t[r][e] += r * o + i; else for (r = 0; r < t.length; r++)t[r][e] = r * o + i; return t; }; }, function (t, e) { t.exports = function (t) { for (let e = 0; e < t.length; e++)t[e].visible = !t[e].visible; return t; }; }, function (t, e, i) { const r = i(58); t.exports = function (t, e, i) { void 0 === i && (i = 0); for (let n = 0; n < t.length; n++) { const s = t[n]; s.x = r(s.x, e.left - i, e.right + i), s.y = r(s.y, e.top - i, e.bottom + i); } return t; }; }, function (t, e, i) {\n    t.exports = {\n      Animation: i(151), AnimationFrame: i(271), AnimationManager: i(289), Events: i(111),\n    };\n  }, function (t, e, i) { t.exports = { BaseCache: i(290), CacheManager: i(292), Events: i(291) }; }, function (t, e) { t.exports = 'add'; }, function (t, e) { t.exports = 'remove'; }, function (t, e, i) { t.exports = { Controls: i(643), Scene2D: i(646) }; }, function (t, e, i) { t.exports = { FixedKeyControl: i(644), SmoothedKeyControl: i(645) }; }, function (t, e, i) {\n    const n = i(0); const s = i(6); const r = new n({\n      initialize(t) { this.camera = s(t, 'camera', null), this.left = s(t, 'left', null), this.right = s(t, 'right', null), this.up = s(t, 'up', null), this.down = s(t, 'down', null), this.zoomIn = s(t, 'zoomIn', null), this.zoomOut = s(t, 'zoomOut', null), this.zoomSpeed = s(t, 'zoomSpeed', 0.01), this.speedX = 0, this.speedY = 0; const e = s(t, 'speed', null); typeof e === 'number' ? (this.speedX = e, this.speedY = e) : (this.speedX = s(t, 'speed.x', 0), this.speedY = s(t, 'speed.y', 0)), this._zoom = 0, this.active = this.camera !== null; }, start() { return this.active = this.camera !== null, this; }, stop() { return this.active = !1, this; }, setCamera(t) { return this.camera = t, this; }, update(t) { let e; this.active && (void 0 === t && (t = 1), e = this.camera, this.up && this.up.isDown ? e.scrollY -= this.speedY * t | 0 : this.down && this.down.isDown && (e.scrollY += this.speedY * t | 0), this.left && this.left.isDown ? e.scrollX -= this.speedX * t | 0 : this.right && this.right.isDown && (e.scrollX += this.speedX * t | 0), this.zoomIn && this.zoomIn.isDown ? (e.zoom -= this.zoomSpeed, e.zoom < 0.1 && (e.zoom = 0.1)) : this.zoomOut && this.zoomOut.isDown && (e.zoom += this.zoomSpeed)); }, destroy() { this.camera = null, this.left = null, this.right = null, this.up = null, this.down = null, this.zoomIn = null, this.zoomOut = null; },\n    }); t.exports = r;\n  }, function (t, e, i) {\n    const n = i(0); const s = i(6); const r = new n({\n      initialize(t) { this.camera = s(t, 'camera', null), this.left = s(t, 'left', null), this.right = s(t, 'right', null), this.up = s(t, 'up', null), this.down = s(t, 'down', null), this.zoomIn = s(t, 'zoomIn', null), this.zoomOut = s(t, 'zoomOut', null), this.zoomSpeed = s(t, 'zoomSpeed', 0.01), this.accelX = 0, this.accelY = 0; const e = s(t, 'acceleration', null); typeof e === 'number' ? (this.accelX = e, this.accelY = e) : (this.accelX = s(t, 'acceleration.x', 0), this.accelY = s(t, 'acceleration.y', 0)), this.dragX = 0, this.dragY = 0; const i = s(t, 'drag', null); typeof i === 'number' ? (this.dragX = i, this.dragY = i) : (this.dragX = s(t, 'drag.x', 0), this.dragY = s(t, 'drag.y', 0)), this.maxSpeedX = 0, this.maxSpeedY = 0; const n = s(t, 'maxSpeed', null); typeof n === 'number' ? (this.maxSpeedX = n, this.maxSpeedY = n) : (this.maxSpeedX = s(t, 'maxSpeed.x', 0), this.maxSpeedY = s(t, 'maxSpeed.y', 0)), this._speedX = 0, this._speedY = 0, this._zoom = 0, this.active = this.camera !== null; }, start() { return this.active = this.camera !== null, this; }, stop() { return this.active = !1, this; }, setCamera(t) { return this.camera = t, this; }, update(t) { let e; this.active && (void 0 === t && (t = 1), e = this.camera, this._speedX > 0 ? (this._speedX -= this.dragX * t, this._speedX < 0 && (this._speedX = 0)) : this._speedX < 0 && (this._speedX += this.dragX * t, this._speedX > 0 && (this._speedX = 0)), this._speedY > 0 ? (this._speedY -= this.dragY * t, this._speedY < 0 && (this._speedY = 0)) : this._speedY < 0 && (this._speedY += this.dragY * t, this._speedY > 0 && (this._speedY = 0)), this.up && this.up.isDown ? (this._speedY += this.accelY, this._speedY > this.maxSpeedY && (this._speedY = this.maxSpeedY)) : this.down && this.down.isDown && (this._speedY -= this.accelY, this._speedY < -this.maxSpeedY && (this._speedY = -this.maxSpeedY)), this.left && this.left.isDown ? (this._speedX += this.accelX, this._speedX > this.maxSpeedX && (this._speedX = this.maxSpeedX)) : this.right && this.right.isDown && (this._speedX -= this.accelX, this._speedX < -this.maxSpeedX && (this._speedX = -this.maxSpeedX)), this.zoomIn && this.zoomIn.isDown ? this._zoom = -this.zoomSpeed : this.zoomOut && this.zoomOut.isDown ? this._zoom = this.zoomSpeed : this._zoom = 0, this._speedX !== 0 && (e.scrollX -= this._speedX * t | 0), this._speedY !== 0 && (e.scrollY -= this._speedY * t | 0), this._zoom !== 0 && (e.zoom += this._zoom, e.zoom < 0.001 && (e.zoom = 0.001))); }, destroy() { this.camera = null, this.left = null, this.right = null, this.up = null, this.down = null, this.zoomIn = null, this.zoomOut = null; },\n    }); t.exports = r;\n  }, function (t, e, i) {\n    t.exports = {\n      Camera: i(293), BaseCamera: i(91), CameraManager: i(702), Effects: i(301), Events: i(40),\n    };\n  }, function (t, e) { t.exports = 'cameradestroy'; }, function (t, e) { t.exports = 'camerafadeincomplete'; }, function (t, e) { t.exports = 'camerafadeinstart'; }, function (t, e) { t.exports = 'camerafadeoutcomplete'; }, function (t, e) { t.exports = 'camerafadeoutstart'; }, function (t, e) { t.exports = 'cameraflashcomplete'; }, function (t, e) { t.exports = 'cameraflashstart'; }, function (t, e) { t.exports = 'camerapancomplete'; }, function (t, e) { t.exports = 'camerapanstart'; }, function (t, e) { t.exports = 'postrender'; }, function (t, e) { t.exports = 'prerender'; }, function (t, e) { t.exports = 'camerarotatecomplete'; }, function (t, e) { t.exports = 'camerarotatestart'; }, function (t, e) { t.exports = 'camerashakecomplete'; }, function (t, e) { t.exports = 'camerashakestart'; }, function (t, e) { t.exports = 'camerazoomcomplete'; }, function (t, e) { t.exports = 'camerazoomstart'; }, function (t, e, i) {\n    const n = i(19); const s = i(0); const l = i(40); const r = new s({\n      initialize(t) { this.camera = t, this.isRunning = !1, this.isComplete = !1, this.direction = !0, this.duration = 0, this.red = 0, this.green = 0, this.blue = 0, this.alpha = 0, this.progress = 0, this._elapsed = 0, this._onUpdate, this._onUpdateScope; }, start(t, e, i, n, s, r, o, a) { if (void 0 === t && (t = !0), void 0 === e && (e = 1e3), void 0 === i && (i = 0), void 0 === n && (n = 0), void 0 === s && (s = 0), void 0 === r && (r = !1), void 0 === o && (o = null), void 0 === a && (a = this.camera.scene), !r && this.isRunning) return this.camera; this.isRunning = !0, this.isComplete = !1, this.duration = e, this.direction = t, this.progress = 0, this.red = i, this.green = n, this.blue = s, this.alpha = t ? Number.MIN_VALUE : 1, this._elapsed = 0, this._onUpdate = o, this._onUpdateScope = a; const h = t ? l.FADE_OUT_START : l.FADE_IN_START; return this.camera.emit(h, this.camera, this, e, i, n, s), this.camera; }, update(t, e) { this.isRunning && (this._elapsed += e, this.progress = n(this._elapsed / this.duration, 0, 1), this._onUpdate && this._onUpdate.call(this._onUpdateScope, this.camera, this.progress), this._elapsed < this.duration ? this.alpha = this.direction ? this.progress : 1 - this.progress : (this.alpha = this.direction ? 1 : 0, this.effectComplete())); }, postRenderCanvas(t) { if (!this.isRunning && !this.isComplete) return !1; const e = this.camera; return t.fillStyle = `rgba(${this.red},${this.green},${this.blue},${this.alpha})`, t.fillRect(e._cx, e._cy, e._cw, e._ch), !0; }, postRenderWebGL(t, e) { if (!this.isRunning && !this.isComplete) return !1; const i = this.camera; const n = this.red / 255; const s = this.blue / 255; const r = this.green / 255; return t.drawFillRect(i._cx, i._cy, i._cw, i._ch, e(n, r, s, 1), this.alpha), !0; }, effectComplete() { this._onUpdate = null, this._onUpdateScope = null, this.isRunning = !1, this.isComplete = !0; const t = this.direction ? l.FADE_OUT_COMPLETE : l.FADE_IN_COMPLETE; this.camera.emit(t, this.camera, this); }, reset() { this.isRunning = !1, this.isComplete = !1, this._onUpdate = null, this._onUpdateScope = null; }, destroy() { this.reset(), this.camera = null; },\n    }); t.exports = r;\n  }, function (t, e, i) {\n    const n = i(19); const s = i(0); const a = i(40); const r = new s({\n      initialize(t) { this.camera = t, this.isRunning = !1, this.duration = 0, this.red = 0, this.green = 0, this.blue = 0, this.alpha = 0, this.progress = 0, this._elapsed = 0, this._onUpdate, this._onUpdateScope; }, start(t, e, i, n, s, r, o) { return void 0 === t && (t = 250), void 0 === e && (e = 255), void 0 === i && (i = 255), void 0 === n && (n = 255), void 0 === s && (s = !1), void 0 === r && (r = null), void 0 === o && (o = this.camera.scene), !s && this.isRunning || (this.isRunning = !0, this.duration = t, this.progress = 0, this.red = e, this.green = i, this.blue = n, this.alpha = 1, this._elapsed = 0, this._onUpdate = r, this._onUpdateScope = o, this.camera.emit(a.FLASH_START, this.camera, this, t, e, i, n)), this.camera; }, update(t, e) { this.isRunning && (this._elapsed += e, this.progress = n(this._elapsed / this.duration, 0, 1), this._onUpdate && this._onUpdate.call(this._onUpdateScope, this.camera, this.progress), this._elapsed < this.duration ? this.alpha = 1 - this.progress : this.effectComplete()); }, postRenderCanvas(t) { if (!this.isRunning) return !1; const e = this.camera; return t.fillStyle = `rgba(${this.red},${this.green},${this.blue},${this.alpha})`, t.fillRect(e._cx, e._cy, e._cw, e._ch), !0; }, postRenderWebGL(t, e) { if (!this.isRunning) return !1; const i = this.camera; const n = this.red / 255; const s = this.blue / 255; const r = this.green / 255; return t.drawFillRect(i._cx, i._cy, i._cw, i._ch, e(n, r, s, 1), this.alpha), !0; }, effectComplete() { this._onUpdate = null, this._onUpdateScope = null, this.isRunning = !1, this.camera.emit(a.FLASH_COMPLETE, this.camera, this); }, reset() { this.isRunning = !1, this._onUpdate = null, this._onUpdateScope = null; }, destroy() { this.reset(), this.camera = null; },\n    }); t.exports = r;\n  }, function (t, e, i) {\n    const a = i(19); const n = i(0); const h = i(115); const l = i(40); const s = i(3); const r = new n({\n      initialize(t) { this.camera = t, this.isRunning = !1, this.duration = 0, this.source = new s(), this.current = new s(), this.destination = new s(), this.ease, this.progress = 0, this._elapsed = 0, this._onUpdate, this._onUpdateScope; }, start(t, e, i, n, s, r, o) { void 0 === i && (i = 1e3), void 0 === n && (n = h.Linear), void 0 === s && (s = !1), void 0 === r && (r = null), void 0 === o && (o = this.camera.scene); const a = this.camera; return !s && this.isRunning || (this.isRunning = !0, this.duration = i, this.progress = 0, this.source.set(a.scrollX, a.scrollY), this.destination.set(t, e), a.getScroll(t, e, this.current), typeof n === 'string' && h.hasOwnProperty(n) ? this.ease = h[n] : typeof n === 'function' && (this.ease = n), this._elapsed = 0, this._onUpdate = r, this._onUpdateScope = o, this.camera.emit(l.PAN_START, this.camera, this, i, t, e)), a; }, update(t, e) { let i; let n; let s; let r; let o; this.isRunning && (this._elapsed += e, i = a(this._elapsed / this.duration, 0, 1), this.progress = i, n = this.camera, this._elapsed < this.duration ? (s = this.ease(i), n.getScroll(this.destination.x, this.destination.y, this.current), r = this.source.x + (this.current.x - this.source.x) * s, o = this.source.y + (this.current.y - this.source.y) * s, n.setScroll(r, o), this._onUpdate && this._onUpdate.call(this._onUpdateScope, n, i, r, o)) : (n.centerOn(this.destination.x, this.destination.y), this._onUpdate && this._onUpdate.call(this._onUpdateScope, n, i, n.scrollX, n.scrollY), this.effectComplete())); }, effectComplete() { this._onUpdate = null, this._onUpdateScope = null, this.isRunning = !1, this.camera.emit(l.PAN_COMPLETE, this.camera, this); }, reset() { this.isRunning = !1, this._onUpdate = null, this._onUpdateScope = null; }, destroy() { this.reset(), this.camera = null, this.source = null, this.destination = null; },\n    }); t.exports = r;\n  }, function (t, e) { t.exports = function (t, e) { return void 0 === e && (e = 1.70158), t * t * ((e + 1) * t - e); }; }, function (t, e) { t.exports = function (t, e) { return void 0 === e && (e = 1.70158), --t * t * ((e + 1) * t + e) + 1; }; }, function (t, e) { t.exports = function (t, e) { void 0 === e && (e = 1.70158); const i = 1.525 * e; return (t *= 2) < 1 ? t * t * ((1 + i) * t - i) * 0.5 : 0.5 * ((t -= 2) * t * ((1 + i) * t + i) + 2); }; }, function (t, e) { t.exports = function (t) { return (t = 1 - t) < 1 / 2.75 ? 1 - 7.5625 * t * t : t < 2 / 2.75 ? 1 - (7.5625 * (t -= 1.5 / 2.75) * t + 0.75) : t < 2.5 / 2.75 ? 1 - (7.5625 * (t -= 2.25 / 2.75) * t + 0.9375) : 1 - (7.5625 * (t -= 2.625 / 2.75) * t + 0.984375); }; }, function (t, e) { t.exports = function (t) { return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + 0.75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + 0.9375 : 7.5625 * (t -= 2.625 / 2.75) * t + 0.984375; }; }, function (t, e) { t.exports = function (t) { let e = !1; return t < 0.5 ? (t = 1 - 2 * t, e = !0) : t = 2 * t - 1, t < 1 / 2.75 ? t *= 7.5625 * t : t = t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + 0.75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + 0.9375 : 7.5625 * (t -= 2.625 / 2.75) * t + 0.984375, e ? 0.5 * (1 - t) : 0.5 * t + 0.5; }; }, function (t, e) { t.exports = function (t) { return 1 - Math.sqrt(1 - t * t); }; }, function (t, e) { t.exports = function (t) { return Math.sqrt(1 - --t * t); }; }, function (t, e) { t.exports = function (t) { return (t *= 2) < 1 ? -0.5 * (Math.sqrt(1 - t * t) - 1) : 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1); }; }, function (t, e) { t.exports = function (t) { return t * t * t; }; }, function (t, e) { t.exports = function (t) { return --t * t * t + 1; }; }, function (t, e) { t.exports = function (t) { return (t *= 2) < 1 ? 0.5 * t * t * t : 0.5 * ((t -= 2) * t * t + 2); }; }, function (t, e) { t.exports = function (t, e, i) { if (void 0 === e && (e = 0.1), void 0 === i && (i = 0.1), t === 0) return 0; if (t === 1) return 1; let n = i / 4; return e < 1 ? e = 1 : n = i * Math.asin(1 / e) / (2 * Math.PI), -(e * Math.pow(2, 10 * --t) * Math.sin((t - n) * (2 * Math.PI) / i)); }; }, function (t, e) { t.exports = function (t, e, i) { if (void 0 === e && (e = 0.1), void 0 === i && (i = 0.1), t === 0) return 0; if (t === 1) return 1; let n = i / 4; return e < 1 ? e = 1 : n = i * Math.asin(1 / e) / (2 * Math.PI), e * Math.pow(2, -10 * t) * Math.sin((t - n) * (2 * Math.PI) / i) + 1; }; }, function (t, e) { t.exports = function (t, e, i) { if (void 0 === e && (e = 0.1), void 0 === i && (i = 0.1), t === 0) return 0; if (t === 1) return 1; let n = i / 4; return e < 1 ? e = 1 : n = i * Math.asin(1 / e) / (2 * Math.PI), (t *= 2) < 1 ? e * Math.pow(2, 10 * --t) * Math.sin((t - n) * (2 * Math.PI) / i) * -0.5 : e * Math.pow(2, -10 * --t) * Math.sin((t - n) * (2 * Math.PI) / i) * 0.5 + 1; }; }, function (t, e) { t.exports = function (t) { return Math.pow(2, 10 * (t - 1)) - 0.001; }; }, function (t, e) { t.exports = function (t) { return 1 - Math.pow(2, -10 * t); }; }, function (t, e) { t.exports = function (t) { return (t *= 2) < 1 ? 0.5 * Math.pow(2, 10 * (t - 1)) : 0.5 * (2 - Math.pow(2, -10 * (t - 1))); }; }, function (t, e) { t.exports = function (t) { return t; }; }, function (t, e) { t.exports = function (t) { return t * t; }; }, function (t, e) { t.exports = function (t) { return t * (2 - t); }; }, function (t, e) { t.exports = function (t) { return (t *= 2) < 1 ? 0.5 * t * t : -0.5 * (--t * (t - 2) - 1); }; }, function (t, e) { t.exports = function (t) { return t * t * t * t; }; }, function (t, e) { t.exports = function (t) { return 1 - --t * t * t * t; }; }, function (t, e) { t.exports = function (t) { return (t *= 2) < 1 ? 0.5 * t * t * t * t : -0.5 * ((t -= 2) * t * t * t - 2); }; }, function (t, e) { t.exports = function (t) { return t * t * t * t * t; }; }, function (t, e) { t.exports = function (t) { return --t * t * t * t * t + 1; }; }, function (t, e) { t.exports = function (t) { return (t *= 2) < 1 ? 0.5 * t * t * t * t * t : 0.5 * ((t -= 2) * t * t * t * t + 2); }; }, function (t, e) { t.exports = function (t) { return t === 0 ? 0 : t === 1 ? 1 : 1 - Math.cos(t * Math.PI / 2); }; }, function (t, e) { t.exports = function (t) { return t === 0 ? 0 : t === 1 ? 1 : Math.sin(t * Math.PI / 2); }; }, function (t, e) { t.exports = function (t) { return t === 0 ? 0 : t === 1 ? 1 : 0.5 * (1 - Math.cos(Math.PI * t)); }; }, function (t, e) { t.exports = function (t, e) { return void 0 === e && (e = 1), t <= 0 ? 0 : t >= 1 ? 1 : 1 / e * (1 + (e * t | 0)); }; }, function (t, e, i) {\n    const o = i(19); const n = i(0); const r = i(40); const s = i(3); const a = new n({\n      initialize(t) { this.camera = t, this.isRunning = !1, this.duration = 0, this.intensity = new s(), this.progress = 0, this._elapsed = 0, this._offsetX = 0, this._offsetY = 0, this._onUpdate, this._onUpdateScope; }, start(t, e, i, n, s) { return void 0 === t && (t = 100), void 0 === e && (e = 0.05), void 0 === i && (i = !1), void 0 === n && (n = null), void 0 === s && (s = this.camera.scene), !i && this.isRunning || (this.isRunning = !0, this.duration = t, this.progress = 0, typeof e === 'number' ? this.intensity.set(e) : this.intensity.set(e.x, e.y), this._elapsed = 0, this._offsetX = 0, this._offsetY = 0, this._onUpdate = n, this._onUpdateScope = s, this.camera.emit(r.SHAKE_START, this.camera, this, t, e)), this.camera; }, preRender() { this.isRunning && this.camera.matrix.translate(this._offsetX, this._offsetY); }, update(t, e) { let i; let n; let s; let r; this.isRunning && (this._elapsed += e, this.progress = o(this._elapsed / this.duration, 0, 1), this._onUpdate && this._onUpdate.call(this._onUpdateScope, this.camera, this.progress), this._elapsed < this.duration ? (i = this.intensity, n = this.camera._cw, s = this.camera._ch, r = this.camera.zoom, this._offsetX = (Math.random() * i.x * n * 2 - i.x * n) * r, this._offsetY = (Math.random() * i.y * s * 2 - i.y * s) * r, this.camera.roundPixels && (this._offsetX = Math.round(this._offsetX), this._offsetY = Math.round(this._offsetY))) : this.effectComplete()); }, effectComplete() { this._offsetX = 0, this._offsetY = 0, this._onUpdate = null, this._onUpdateScope = null, this.isRunning = !1, this.camera.emit(r.SHAKE_COMPLETE, this.camera, this); }, reset() { this.isRunning = !1, this._offsetX = 0, this._offsetY = 0, this._onUpdate = null, this._onUpdateScope = null; }, destroy() { this.reset(), this.camera = null, this.intensity = null; },\n    }); t.exports = a;\n  }, function (t, e, i) {\n    const u = i(19); const n = i(0); const d = i(40); const f = i(115); const s = new n({\n      initialize(t) { this.camera = t, this.isRunning = !1, this.duration = 0, this.source = 0, this.current = 0, this.destination = 0, this.ease, this.progress = 0, this._elapsed = 0, this._onUpdate, this._onUpdateScope, this.clockwise = !0, this.shortestPath = !1; }, start(t, e, i, n, s, r, o) { void 0 === i && (i = 1e3), void 0 === n && (n = f.Linear), void 0 === s && (s = !1), void 0 === r && (r = null), void 0 === o && (o = this.camera.scene), void 0 === e && (e = !1), this.shortestPath = e; let a = t; t < 0 ? (a = -1 * t, this.clockwise = !1) : this.clockwise = !0; const h = 360 * Math.PI / 180; a -= Math.floor(a / h) * h; let l; let u; const c = this.camera; return !s && this.isRunning || (this.isRunning = !0, this.duration = i, this.progress = 0, this.source = c.rotation, this.destination = a, typeof n === 'string' && f.hasOwnProperty(n) ? this.ease = f[n] : typeof n === 'function' && (this.ease = n), this._elapsed = 0, this._onUpdate = r, this._onUpdateScope = o, this.shortestPath && (u = l = 0, (l = this.destination > this.source ? Math.abs(this.destination - this.source) : Math.abs(this.destination + h) - this.source) < (u = this.source > this.destination ? Math.abs(this.source - this.destination) : Math.abs(this.source + h) - this.destination) ? this.clockwise = !0 : u < l && (this.clockwise = !1)), this.camera.emit(d.ROTATE_START, this.camera, this, i, a)), c; }, update(t, e) { let i; let n; let s; let r; let o; let a; let h; let l; this.isRunning && (this._elapsed += e, i = u(this._elapsed / this.duration, 0, 1), this.progress = i, n = this.camera, this._elapsed < this.duration ? (s = this.ease(i), this.current = n.rotation, r = 0, o = 360 * Math.PI / 180, a = this.destination, h = this.current, !1 === this.clockwise && (a = this.current, h = this.destination), r = h <= a ? Math.abs(a - h) : Math.abs(a + o) - h, l = 0, l = this.clockwise ? n.rotation + r * s : n.rotation - r * s, n.rotation = l, this._onUpdate && this._onUpdate.call(this._onUpdateScope, n, i, l)) : (n.rotation = this.destination, this._onUpdate && this._onUpdate.call(this._onUpdateScope, n, i, this.destination), this.effectComplete())); }, effectComplete() { this._onUpdate = null, this._onUpdateScope = null, this.isRunning = !1, this.camera.emit(d.ROTATE_COMPLETE, this.camera, this); }, reset() { this.isRunning = !1, this._onUpdate = null, this._onUpdateScope = null; }, destroy() { this.reset(), this.camera = null, this.source = null, this.destination = null; },\n    }); t.exports = s;\n  }, function (t, e, i) {\n    const n = i(19); const s = i(0); const a = i(115); const h = i(40); const r = new s({\n      initialize(t) { this.camera = t, this.isRunning = !1, this.duration = 0, this.source = 1, this.destination = 1, this.ease, this.progress = 0, this._elapsed = 0, this._onUpdate, this._onUpdateScope; }, start(t, e, i, n, s, r) { void 0 === e && (e = 1e3), void 0 === i && (i = a.Linear), void 0 === n && (n = !1), void 0 === s && (s = null), void 0 === r && (r = this.camera.scene); const o = this.camera; return !n && this.isRunning || (this.isRunning = !0, this.duration = e, this.progress = 0, this.source = o.zoom, this.destination = t, typeof i === 'string' && a.hasOwnProperty(i) ? this.ease = a[i] : typeof i === 'function' && (this.ease = i), this._elapsed = 0, this._onUpdate = s, this._onUpdateScope = r, this.camera.emit(h.ZOOM_START, this.camera, this, e, t)), o; }, update(t, e) { this.isRunning && (this._elapsed += e, this.progress = n(this._elapsed / this.duration, 0, 1), this._elapsed < this.duration ? (this.camera.zoom = this.source + (this.destination - this.source) * this.ease(this.progress), this._onUpdate && this._onUpdate.call(this._onUpdateScope, this.camera, this.progress, this.camera.zoom)) : (this.camera.zoom = this.destination, this._onUpdate && this._onUpdate.call(this._onUpdateScope, this.camera, this.progress, this.destination), this.effectComplete())); }, effectComplete() { this._onUpdate = null, this._onUpdateScope = null, this.isRunning = !1, this.camera.emit(h.ZOOM_COMPLETE, this.camera, this); }, reset() { this.isRunning = !1, this._onUpdate = null, this._onUpdateScope = null; }, destroy() { this.reset(), this.camera = null; },\n    }); t.exports = r;\n  }, function (t, e, i) {\n    const a = i(293); const n = i(0); const v = i(2); const s = i(23); const h = i(48); const r = i(92); const o = i(22); const l = new n({\n      initialize(t) { this.scene = t, this.systems = t.sys, this.roundPixels = t.sys.game.config.roundPixels, this.cameras = [], this.main, this.default, t.sys.events.once(o.BOOT, this.boot, this), t.sys.events.on(o.START, this.start, this); }, boot() { const t = this.systems; t.settings.cameras ? this.fromJSON(t.settings.cameras) : this.add(), this.main = this.cameras[0], this.default = new a(0, 0, t.scale.width, t.scale.height).setScene(this.scene), t.game.scale.on(r.RESIZE, this.onResize, this), this.systems.events.once(o.DESTROY, this.destroy, this); }, start() { let t; this.main || ((t = this.systems).settings.cameras ? this.fromJSON(t.settings.cameras) : this.add(), this.main = this.cameras[0]); const e = this.systems.events; e.on(o.UPDATE, this.update, this), e.once(o.SHUTDOWN, this.shutdown, this); }, add(t, e, i, n, s, r) { void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = this.scene.sys.scale.width), void 0 === n && (n = this.scene.sys.scale.height), void 0 === s && (s = !1), void 0 === r && (r = ''); const o = new a(t, e, i, n); return o.setName(r), o.setScene(this.scene), o.setRoundPixels(this.roundPixels), o.id = this.getNextID(), this.cameras.push(o), s && (this.main = o), o; }, addExisting(t, e) { return void 0 === e && (e = !1), this.cameras.indexOf(t) === -1 ? (t.id = this.getNextID(), t.setRoundPixels(this.roundPixels), this.cameras.push(t), e && (this.main = t), t) : null; }, getNextID() { for (let t = this.cameras, e = 1, i = 0; i < 32; i++) { for (var n = !1, s = 0; s < t.length; s++) { const r = t[s]; r && r.id === e && (n = !0); } if (!n) return e; e <<= 1; } return 0; }, getTotal(t) { void 0 === t && (t = !1); for (var e = 0, i = this.cameras, n = 0; n < i.length; n++) { const s = i[n]; (!t || t && s.visible) && e++; } return e; }, fromJSON(t) { Array.isArray(t) || (t = [t]); for (let e = this.scene.sys.scale.width, i = this.scene.sys.scale.height, n = 0; n < t.length; n++) { const s = t[n]; const r = v(s, 'x', 0); const o = v(s, 'y', 0); const a = v(s, 'width', e); const h = v(s, 'height', i); const l = this.add(r, o, a, h); l.name = v(s, 'name', ''), l.zoom = v(s, 'zoom', 1), l.rotation = v(s, 'rotation', 0), l.scrollX = v(s, 'scrollX', 0), l.scrollY = v(s, 'scrollY', 0), l.roundPixels = v(s, 'roundPixels', !1), l.visible = v(s, 'visible', !0); const u = v(s, 'backgroundColor', !1); u && l.setBackgroundColor(u); var c; var d; var f; var p; const g = v(s, 'bounds', null); g && (c = v(g, 'x', 0), d = v(g, 'y', 0), f = v(g, 'width', e), p = v(g, 'height', i), l.setBounds(c, d, f, p)); } return this; }, getCamera(t) { for (let e = this.cameras, i = 0; i < e.length; i++) if (e[i].name === t) return e[i]; return null; }, getCamerasBelowPointer(t) { for (var e = this.cameras, i = t.x, n = t.y, s = [], r = 0; r < e.length; r++) { const o = e[r]; o.visible && o.inputEnabled && h(o, i, n) && s.unshift(o); } return s; }, remove(t, e) { void 0 === e && (e = !0), Array.isArray(t) || (t = [t]); for (var i = 0, n = this.cameras, s = 0; s < t.length; s++) { const r = n.indexOf(t[s]); r !== -1 && (e && n[r].destroy(), n.splice(r, 1), i++); } return !this.main && n[0] && (this.main = n[0]), i; }, render(t, e, i) { for (let n = this.scene, s = this.cameras, r = 0; r < this.cameras.length; r++) { const o = s[r]; o.visible && o.alpha > 0 && (o.preRender(1), t.render(n, e, i, o)); } }, resetAll() { for (let t = 0; t < this.cameras.length; t++) this.cameras[t].destroy(); return this.cameras = [], this.main = this.add(), this.main; }, update(t, e) { for (let i = 0; i < this.cameras.length; i++) this.cameras[i].update(t, e); }, onResize(t, e, i, n, s, r) { for (let o = 0; o < this.cameras.length; o++) { const a = this.cameras[o]; a._x === 0 && a._y === 0 && a._width === s && a._height === r && a.setSize(e.width, e.height); } }, resize(t, e) { for (let i = 0; i < this.cameras.length; i++) this.cameras[i].setSize(t, e); }, shutdown() { this.main = void 0; for (let t = 0; t < this.cameras.length; t++) this.cameras[t].destroy(); this.cameras = []; const e = this.systems.events; e.off(o.UPDATE, this.update, this), e.off(o.SHUTDOWN, this.shutdown, this); }, destroy() { this.shutdown(), this.default.destroy(), this.scene.sys.events.off(o.START, this.start, this), this.scene = null, this.systems = null; },\n    }); s.register('CameraManager', l, 'cameras'), t.exports = l;\n  }, function (t, e) { t.exports = 'enterfullscreen'; }, function (t, e) { t.exports = 'fullscreenfailed'; }, function (t, e) { t.exports = 'fullscreenunsupported'; }, function (t, e) { t.exports = 'leavefullscreen'; }, function (t, e) { t.exports = 'orientationchange'; }, function (t, e) { t.exports = 'resize'; }, function (t, e) { t.exports = 'boot'; }, function (t, e) { t.exports = 'create'; }, function (t, e) { t.exports = 'destroy'; }, function (t, e) { t.exports = 'pause'; }, function (t, e) { t.exports = 'postupdate'; }, function (t, e) { t.exports = 'preupdate'; }, function (t, e) { t.exports = 'ready'; }, function (t, e) { t.exports = 'render'; }, function (t, e) { t.exports = 'resume'; }, function (t, e) { t.exports = 'shutdown'; }, function (t, e) { t.exports = 'sleep'; }, function (t, e) { t.exports = 'start'; }, function (t, e) { t.exports = 'transitioncomplete'; }, function (t, e) { t.exports = 'transitioninit'; }, function (t, e) { t.exports = 'transitionout'; }, function (t, e) { t.exports = 'transitionstart'; }, function (t, e) { t.exports = 'transitionwake'; }, function (t, e) { t.exports = 'update'; }, function (t, e) { t.exports = 'wake'; }, function (t, e, i) {\n    t.exports = {\n      Config: i(314), CreateRenderer: i(338), DebugHeader: i(342), Events: i(20), TimeStep: i(343), VisibilityHandler: i(345),\n    };\n  }, function (t, e) { let i; let n; const s = t.exports = {}; function r() { throw new Error('setTimeout has not been defined'); } function o() { throw new Error('clearTimeout has not been defined'); } function a(e) { if (i === setTimeout) return setTimeout(e, 0); if ((i === r || !i) && setTimeout) return i = setTimeout, setTimeout(e, 0); try { return i(e, 0); } catch (t) { try { return i.call(null, e, 0); } catch (t) { return i.call(this, e, 0); } } }!(function () { try { i = typeof setTimeout === 'function' ? setTimeout : r; } catch (t) { i = r; } try { n = typeof clearTimeout === 'function' ? clearTimeout : o; } catch (t) { n = o; } }()); let h; let l = []; let u = !1; let c = -1; function d() { u && h && (u = !1, h.length ? l = h.concat(l) : c = -1, l.length && f()); } function f() { if (!u) { const t = a(d); u = !0; for (let e = l.length; e;) { for (h = l, l = []; ++c < e;)h && h[c].run(); c = -1, e = l.length; }h = null, u = !1, (function (e) { if (n === clearTimeout) return clearTimeout(e); if ((n === o || !n) && clearTimeout) return n = clearTimeout, clearTimeout(e); try { n(e); } catch (t) { try { return n.call(null, e); } catch (t) { return n.call(this, e); } } }(t)); } } function p(t, e) { this.fun = t, this.array = e; } function g() {}s.nextTick = function (t) { const e = new Array(arguments.length - 1); if (arguments.length > 1) for (let i = 1; i < arguments.length; i++)e[i - 1] = arguments[i]; l.push(new p(t, e)), l.length !== 1 || u || a(f); }, p.prototype.run = function () { this.fun.apply(null, this.array); }, s.title = 'browser', s.browser = !0, s.env = {}, s.argv = [], s.version = '', s.versions = {}, s.on = g, s.addListener = g, s.once = g, s.off = g, s.removeListener = g, s.removeAllListeners = g, s.emit = g, s.prependListener = g, s.prependOnceListener = g, s.listeners = function (t) { return []; }, s.binding = function (t) { throw new Error('process.binding is not supported'); }, s.cwd = function () { return '/'; }, s.chdir = function (t) { throw new Error('process.chdir is not supported'); }, s.umask = function () { return 0; }; }, function (t, e, i) {\n    const n = i(118); const s = {\n      gamepads: !1, mspointer: !1, touch: !1, wheelEvent: null,\n    }; t.exports = (('ontouchstart' in document.documentElement || navigator.maxTouchPoints && navigator.maxTouchPoints >= 1) && (s.touch = !0), (navigator.msPointerEnabled || navigator.pointerEnabled) && (s.mspointer = !0), navigator.getGamepads && (s.gamepads = !0), 'onwheel' in window || n.ie && 'WheelEvent' in window ? s.wheelEvent = 'wheel' : 'onmousewheel' in window ? s.wheelEvent = 'mousewheel' : n.firefox && 'MouseScrollEvent' in window && (s.wheelEvent = 'DOMMouseScroll'), s);\n  }, function (t, e, i) {\n    const s = i(118); const r = {\n      audioData: !1, dolby: !1, m4a: !1, mp3: !1, ogg: !1, opus: !1, wav: !1, webAudio: !1, webm: !1,\n    }; t.exports = (function () { r.audioData = !!window.Audio, r.webAudio = !(!window.AudioContext && !window.webkitAudioContext); let t; let e; const i = document.createElement('audio'); const n = !!i.canPlayType; try { n && (i.canPlayType('audio/ogg; codecs=\"vorbis\"').replace(/^no$/, '') && (r.ogg = !0), (i.canPlayType('audio/ogg; codecs=\"opus\"').replace(/^no$/, '') || i.canPlayType('audio/opus;').replace(/^no$/, '')) && (r.opus = !0), i.canPlayType('audio/mpeg;').replace(/^no$/, '') && (r.mp3 = !0), i.canPlayType('audio/wav; codecs=\"1\"').replace(/^no$/, '') && (r.wav = !0), (i.canPlayType('audio/x-m4a;') || i.canPlayType('audio/aac;').replace(/^no$/, '')) && (r.m4a = !0), i.canPlayType('audio/webm; codecs=\"vorbis\"').replace(/^no$/, '') && (r.webm = !0), i.canPlayType('audio/mp4;codecs=\"ec-3\"') !== '' && (s.edge ? r.dolby = !0 : s.safari && s.safariVersion >= 9 && /Mac OS X (\\d+)_(\\d+)/.test(navigator.userAgent) && (t = parseInt(RegExp.$1, 10), e = parseInt(RegExp.$2, 10), (t === 10 && e >= 11 || t > 10) && (r.dolby = !0)))); } catch (t) {} return r; }());\n  }, function (t, e) {\n    const i = {\n      h264: !1, hls: !1, mp4: !1, ogg: !1, vp9: !1, webm: !1,\n    }; t.exports = (function () { const t = document.createElement('video'); const e = !!t.canPlayType; try { e && (t.canPlayType('video/ogg; codecs=\"theora\"').replace(/^no$/, '') && (i.ogg = !0), t.canPlayType('video/mp4; codecs=\"avc1.42E01E\"').replace(/^no$/, '') && (i.h264 = !0, i.mp4 = !0), t.canPlayType('video/webm; codecs=\"vp8, vorbis\"').replace(/^no$/, '') && (i.webm = !0), t.canPlayType('video/webm; codecs=\"vp9\"').replace(/^no$/, '') && (i.vp9 = !0), t.canPlayType('application/x-mpegURL; codecs=\"avc1.42E01E\"').replace(/^no$/, '') && (i.hls = !0)); } catch (t) {} return i; }());\n  }, function (t, e) {\n    const r = {\n      available: !1, cancel: '', keyboard: !1, request: '',\n    }; t.exports = (function () { for (var t = 'Fullscreen', e = 'FullScreen', i = [`request${t}`, `request${e}`, `webkitRequest${t}`, `webkitRequest${e}`, `msRequest${t}`, `msRequest${e}`, `mozRequest${e}`, `mozRequest${t}`], n = 0; n < i.length; n++) if (document.documentElement[i[n]]) { r.available = !0, r.request = i[n]; break; } const s = [`cancel${e}`, `exit${t}`, `webkitCancel${e}`, `webkitExit${t}`, `msCancel${e}`, `msExit${t}`, `mozCancel${e}`, `mozExit${t}`]; if (r.available) for (n = 0; n < s.length; n++) if (document[s[n]]) { r.cancel = s[n]; break; } return window.Element && Element.ALLOW_KEYBOARD_INPUT && !/ Version\\/5\\.1(?:\\.\\d+)? Safari\\//.test(navigator.userAgent) && (r.keyboard = !0), Object.defineProperty(r, 'active', { get() { return !!(document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement); } }), r; }());\n  }, function (t, e, i) {\n    t.exports = {\n      Between: i(317), BetweenPoints: i(318), BetweenPointsY: i(735), BetweenY: i(736), CounterClockwise: i(737), Normalize: i(319), Random: i(738), RandomDegrees: i(739), Reverse: i(740), RotateTo: i(741), ShortestBetween: i(742), Wrap: i(235), WrapDegrees: i(236),\n    };\n  }, function (t, e) { t.exports = function (t, e) { return Math.atan2(e.x - t.x, e.y - t.y); }; }, function (t, e) { t.exports = function (t, e, i, n) { return Math.atan2(i - t, n - e); }; }, function (t, e, i) { const n = i(13); t.exports = function (t) { return t > Math.PI && (t -= n.PI2), Math.abs(((t + n.TAU) % n.PI2 - n.PI2) % n.PI2); }; }, function (t, e, i) { const n = i(119); t.exports = function () { return n(-Math.PI, Math.PI); }; }, function (t, e, i) { const n = i(119); t.exports = function () { return n(-180, 180); }; }, function (t, e, i) { const n = i(319); t.exports = function (t) { return n(t + Math.PI); }; }, function (t, e, i) { const n = i(13); t.exports = function (t, e, i) { return void 0 === i && (i = 0.05), t === e || (Math.abs(e - t) <= i || Math.abs(e - t) >= n.PI2 - i ? t = e : (Math.abs(e - t) > Math.PI && (e < t ? e += n.PI2 : e -= n.PI2), t < e ? t += i : e < t && (t -= i))), t; }; }, function (t, e) { t.exports = function (t, e) { const i = e - t; return i == 0 ? 0 : i - 360 * Math.floor((i + 180) / 360); }; }, function (t, e, i) {\n    t.exports = {\n      Between: i(53), BetweenPoints: i(320), BetweenPointsSquared: i(744), Chebyshev: i(745), Power: i(746), Snake: i(747), Squared: i(321),\n    };\n  }, function (t, e) { t.exports = function (t, e) { const i = t.x - e.x; const n = t.y - e.y; return i * i + n * n; }; }, function (t, e) { t.exports = function (t, e, i, n) { return Math.max(Math.abs(t - i), Math.abs(e - n)); }; }, function (t, e) { t.exports = function (t, e, i, n, s) { return void 0 === s && (s = 2), Math.sqrt(Math.pow(i - t, s) + Math.pow(n - e, s)); }; }, function (t, e) { t.exports = function (t, e, i, n) { return Math.abs(t - i) + Math.abs(e - n); }; }, function (t, e, i) {\n    t.exports = {\n      Back: i(302), Bounce: i(303), Circular: i(304), Cubic: i(305), Elastic: i(306), Expo: i(307), Linear: i(308), Quadratic: i(309), Quartic: i(310), Quintic: i(311), Sine: i(312), Stepped: i(313),\n    };\n  }, function (t, e, i) {\n    t.exports = {\n      Ceil: i(750), Equal: i(106), Floor: i(751), GreaterThan: i(322), LessThan: i(323),\n    };\n  }, function (t, e) { t.exports = function (t, e) { return void 0 === e && (e = 1e-4), Math.ceil(t - e); }; }, function (t, e) { t.exports = function (t, e) { return void 0 === e && (e = 1e-4), Math.floor(t + e); }; }, function (t, e, i) {\n    t.exports = {\n      Bezier: i(753), CatmullRom: i(754), CubicBezier: i(326), Linear: i(755), QuadraticBezier: i(327), SmoothStep: i(328), SmootherStep: i(756),\n    };\n  }, function (t, e, i) { const r = i(324); t.exports = function (t, e) { for (var i = 0, n = t.length - 1, s = 0; s <= n; s++)i += Math.pow(1 - e, n - s) * Math.pow(e, s) * t[s] * r(n, s); return i; }; }, function (t, e, i) { const r = i(171); t.exports = function (t, e) { const i = t.length - 1; let n = i * e; let s = Math.floor(n); return t[0] === t[i] ? (e < 0 && (s = Math.floor(n = i * (1 + e))), r(n - s, t[(s - 1 + i) % i], t[s], t[(s + 1) % i], t[(s + 2) % i])) : e < 0 ? t[0] - (r(-n, t[0], t[0], t[1], t[1]) - t[0]) : e > 1 ? t[i] - (r(n - i, t[i], t[i], t[i - 1], t[i - 1]) - t[i]) : r(n - s, t[s ? s - 1 : 0], t[s], t[i < s + 1 ? i : s + 1], t[i < s + 2 ? i : s + 2]); }; }, function (t, e, i) { const r = i(116); t.exports = function (t, e) { const i = t.length - 1; const n = i * e; const s = Math.floor(n); return e < 0 ? r(t[0], t[1], n) : e > 1 ? r(t[i], t[i - 1], i - n) : r(t[s], t[i < s + 1 ? i : s + 1], n - s); }; }, function (t, e, i) { const n = i(160); t.exports = function (t, e, i) { return e + (i - e) * n(t, 0, 1); }; }, function (t, e, i) { t.exports = { GetNext: i(329), IsSize: i(120), IsValue: i(758) }; }, function (t, e) { t.exports = function (t) { return t > 0 && (t & t - 1) == 0; }; }, function (t, e, i) { t.exports = { Ceil: i(330), Floor: i(93), To: i(760) }; }, function (t, e) { t.exports = function (t, e, i, n) { return void 0 === i && (i = 0), e === 0 ? t : (t -= i, t = e * Math.round(t / e), n ? (i + t) / e : i + t); }; }, function (t, e, i) {\n    const n = new (i(0))({\n      initialize(t) { void 0 === t && (t = [(Date.now() * Math.random()).toString()]), this.c = 1, this.s0 = 0, this.s1 = 0, this.s2 = 0, this.n = 0, this.signs = [-1, 1], t && this.init(t); }, rnd() { const t = 2091639 * this.s0 + 2.3283064365386963e-10 * this.c; return this.c = 0 | t, this.s0 = this.s1, this.s1 = this.s2, this.s2 = t - this.c, this.s2; }, hash(t) { let e; let i = this.n; t = t.toString(); for (let n = 0; n < t.length; n++)e = 0.02519603282416938 * (i += t.charCodeAt(n)), e -= i = e >>> 0, i = (e *= i) >>> 0, i += 4294967296 * (e -= i); return 2.3283064365386963e-10 * ((this.n = i) >>> 0); }, init(t) { typeof t === 'string' ? this.state(t) : this.sow(t); }, sow(t) { if (this.n = 4022871197, this.s0 = this.hash(' '), this.s1 = this.hash(' '), this.s2 = this.hash(' '), this.c = 1, t) for (let e = 0; e < t.length && t[e] != null; e++) { const i = t[e]; this.s0 -= this.hash(i), this.s0 += ~~(this.s0 < 0), this.s1 -= this.hash(i), this.s1 += ~~(this.s1 < 0), this.s2 -= this.hash(i), this.s2 += ~~(this.s2 < 0); } }, integer() { return 4294967296 * this.rnd(); }, frac() { return this.rnd() + 11102230246251565e-32 * (2097152 * this.rnd() | 0); }, real() { return this.integer() + this.frac(); }, integerInRange(t, e) { return Math.floor(this.realInRange(0, e - t + 1) + t); }, between(t, e) { return Math.floor(this.realInRange(0, e - t + 1) + t); }, realInRange(t, e) { return this.frac() * (e - t) + t; }, normal() { return 1 - 2 * this.frac(); }, uuid() { for (var t = '', e = '', e = t = ''; t++ < 36; e += ~t % 5 | 3 * t & 4 ? (15 ^ t ? 8 ^ this.frac() * (20 ^ t ? 16 : 4) : 4).toString(16) : '-');return e; }, pick(t) { return t[this.integerInRange(0, t.length - 1)]; }, sign() { return this.pick(this.signs); }, weightedPick(t) { return t[~~(Math.pow(this.frac(), 2) * (t.length - 1) + 0.5)]; }, timestamp(t, e) { return this.realInRange(t || 9466848e5, e || 1577862e6); }, angle() { return this.integerInRange(-180, 180); }, rotation() { return this.realInRange(-3.1415926, 3.1415926); }, state(t) { return typeof t === 'string' && t.match(/^!rnd/) && (t = t.split(','), this.c = parseFloat(t[1]), this.s0 = parseFloat(t[2]), this.s1 = parseFloat(t[3]), this.s2 = parseFloat(t[4])), ['!rnd', this.c, this.s0, this.s1, this.s2].join(','); }, shuffle(t) { for (let e = t.length - 1; e > 0; e--) { const i = Math.floor(this.frac() * (e + 1)); const n = t[i]; t[i] = t[e], t[e] = n; } return t; },\n    }); t.exports = n;\n  }, function (t, e) { t.exports = function (t) { for (var e = 0, i = 0; i < t.length; i++)e += +t[i]; return e / t.length; }; }, function (t, e) { t.exports = function (t, e, i) { void 0 === e && (e = 0), void 0 === i && (i = 10); const n = Math.pow(i, -e); return Math.ceil(t * n) / n; }; }, function (t, e) { t.exports = function (t, e) { return Math.abs(t - e); }; }, function (t, e) { t.exports = function (t, e, i) { void 0 === e && (e = 0), void 0 === i && (i = 10); const n = Math.pow(i, -e); return Math.floor(t * n) / n; }; }, function (t, e) { t.exports = function (t, e) { return t / e / 1e3; }; }, function (t, e) { t.exports = function (t) { return t == parseFloat(t) ? !(t % 2) : void 0; }; }, function (t, e) { t.exports = function (t) { return t === parseFloat(t) ? !(t % 2) : void 0; }; }, function (t, e) { t.exports = function (t, e, i) { return Math.min(t + e, i); }; }, function (t, e) { t.exports = function (t, e, i) { return Math.max(t - e, i); }; }, function (t, e) { t.exports = function (t, e, i, n) { void 0 === i && (i = e + 1); let s = (t - e) / (i - e); return s > 1 ? void 0 !== n ? (s = (n - t) / (n - i)) < 0 && (s = 0) : s = 1 : s < 0 && (s = 0), s; }; }, function (t, e) { t.exports = function (t, e) { void 0 === e && (e = 1); const i = 2 * Math.random() * Math.PI; return t.x = Math.cos(i) * e, t.y = Math.sin(i) * e, t; }; }, function (t, e) { t.exports = function (t, e) { void 0 === e && (e = 1); const i = 2 * Math.random() * Math.PI; const n = 2 * Math.random() - 1; const s = Math.sqrt(1 - n * n) * e; return t.x = Math.cos(i) * s, t.y = Math.sin(i) * s, t.z = n * e, t; }; }, function (t, e) { t.exports = function (t, e) { return void 0 === e && (e = 1), t.x = (2 * Math.random() - 1) * e, t.y = (2 * Math.random() - 1) * e, t.z = (2 * Math.random() - 1) * e, t.w = (2 * Math.random() - 1) * e, t; }; }, function (t, e) { t.exports = function (t, e, i, n, s) { return t.x = e + s * Math.cos(n), t.y = i + s * Math.sin(n), t; }; }, function (t, e) { t.exports = function (t, e, i) { void 0 === e && (e = 0), void 0 === i && (i = 10); const n = Math.pow(i, -e); return Math.round(t * n) / n; }; }, function (t, e) { t.exports = function (t, e, i, n) { void 0 === e && (e = 1), void 0 === i && (i = 1), void 0 === n && (n = 1), n *= Math.PI / t; for (var s = [], r = [], o = 0; o < t; o++)e += (i -= e * n) * n, s[o] = i, r[o] = e; return { sin: r, cos: s, length: t }; }; }, function (t, e, i) { const o = i(3); t.exports = function (t, e, i, n) { void 0 === n && (n = new o()); let s = 0; let r = 0; return t > 0 && t <= e * i && (s = e - 1 < t ? t - (r = Math.floor(t / e)) * e : t, n.set(s, r)), n; }; }, function (t, e) { t.exports = function (t, e, i) { return Math.abs(t - e) <= i; }; }, function (t, e, i) { const n = i(174); const s = i(336); const r = i(337); const o = new s(); const a = new r(); const h = new n(); t.exports = function (t, e, i) { return a.setAxisAngle(e, i), o.fromRotationTranslation(a, h.set(0, 0, 0)), t.transformMat4(o); }; }, function (t, e) { t.exports = 'addtexture'; }, function (t, e) { t.exports = 'onerror'; }, function (t, e) { t.exports = 'onload'; }, function (t, e) { t.exports = 'ready'; }, function (t, e) { t.exports = 'removetexture'; }, function (t, e) { t.exports = ['#define SHADER_NAME PHASER_BITMAP_MASK_FS', '', 'precision mediump float;', '', 'uniform vec2 uResolution;', 'uniform sampler2D uMainSampler;', 'uniform sampler2D uMaskSampler;', 'uniform bool uInvertMaskAlpha;', '', 'void main()', '{', '    vec2 uv = gl_FragCoord.xy / uResolution;', '    vec4 mainColor = texture2D(uMainSampler, uv);', '    vec4 maskColor = texture2D(uMaskSampler, uv);', '    float alpha = mainColor.a;', '', '    if (!uInvertMaskAlpha)', '    {', '        alpha *= (maskColor.a);', '    }', '    else', '    {', '        alpha *= (1.0 - maskColor.a);', '    }', '', '    gl_FragColor = vec4(mainColor.rgb * alpha, alpha);', '}', ''].join('\\n'); }, function (t, e) { t.exports = ['#define SHADER_NAME PHASER_BITMAP_MASK_VS', '', 'precision mediump float;', '', 'attribute vec2 inPosition;', '', 'void main()', '{', '    gl_Position = vec4(inPosition, 0.0, 1.0);', '}', ''].join('\\n'); }, function (t, e) { t.exports = ['#define SHADER_NAME PHASER_FORWARD_DIFFUSE_FS', '', 'precision mediump float;', '', 'struct Light', '{', '    vec2 position;', '    vec3 color;', '    float intensity;', '    float radius;', '};', '', 'const int kMaxLights = %LIGHT_COUNT%;', '', 'uniform vec4 uCamera; /* x, y, rotation, zoom */', 'uniform vec2 uResolution;', 'uniform sampler2D uMainSampler;', 'uniform sampler2D uNormSampler;', 'uniform vec3 uAmbientLightColor;', 'uniform Light uLights[kMaxLights];', 'uniform mat3 uInverseRotationMatrix;', '', 'varying vec2 outTexCoord;', 'varying vec4 outTint;', '', 'void main()', '{', '    vec3 finalColor = vec3(0.0, 0.0, 0.0);', '    vec4 color = texture2D(uMainSampler, outTexCoord) * vec4(outTint.rgb * outTint.a, outTint.a);', '    vec3 normalMap = texture2D(uNormSampler, outTexCoord).rgb;', '    vec3 normal = normalize(uInverseRotationMatrix * vec3(normalMap * 2.0 - 1.0));', '    vec2 res = vec2(min(uResolution.x, uResolution.y)) * uCamera.w;', '', '    for (int index = 0; index < kMaxLights; ++index)', '    {', '        Light light = uLights[index];', '        vec3 lightDir = vec3((light.position.xy / res) - (gl_FragCoord.xy / res), 0.1);', '        vec3 lightNormal = normalize(lightDir);', '        float distToSurf = length(lightDir) * uCamera.w;', '        float diffuseFactor = max(dot(normal, lightNormal), 0.0);', '        float radius = (light.radius / res.x * uCamera.w) * uCamera.w;', '        float attenuation = clamp(1.0 - distToSurf * distToSurf / (radius * radius), 0.0, 1.0);', '        vec3 diffuse = light.color * diffuseFactor;', '        finalColor += (attenuation * diffuse) * light.intensity;', '    }', '', '    vec4 colorOutput = vec4(uAmbientLightColor + finalColor, 1.0);', '    gl_FragColor = color * vec4(colorOutput.rgb * colorOutput.a, colorOutput.a);', '', '}', ''].join('\\n'); }, function (t, e, i) { t.exports = { GenerateTexture: i(346), Palettes: i(790) }; }, function (t, e, i) {\n    t.exports = {\n      ARNE16: i(347), C64: i(791), CGA: i(792), JMP: i(793), MSX: i(794),\n    };\n  }, function (t, e) {\n    t.exports = {\n      0: '#000', 1: '#fff', 2: '#8b4131', 3: '#7bbdc5', 4: '#8b41ac', 5: '#6aac41', 6: '#3931a4', 7: '#d5de73', 8: '#945a20', 9: '#5a4100', A: '#bd736a', B: '#525252', C: '#838383', D: '#acee8b', E: '#7b73de', F: '#acacac',\n    };\n  }, function (t, e) {\n    t.exports = {\n      0: '#000', 1: '#2234d1', 2: '#0c7e45', 3: '#44aacc', 4: '#8a3622', 5: '#5c2e78', 6: '#aa5c3d', 7: '#b5b5b5', 8: '#5e606e', 9: '#4c81fb', A: '#6cd947', B: '#7be2f9', C: '#eb8a60', D: '#e23d69', E: '#ffd93f', F: '#fff',\n    };\n  }, function (t, e) {\n    t.exports = {\n      0: '#000', 1: '#191028', 2: '#46af45', 3: '#a1d685', 4: '#453e78', 5: '#7664fe', 6: '#833129', 7: '#9ec2e8', 8: '#dc534b', 9: '#e18d79', A: '#d6b97b', B: '#e9d8a1', C: '#216c4b', D: '#d365c8', E: '#afaab9', F: '#f5f4eb',\n    };\n  }, function (t, e) {\n    t.exports = {\n      0: '#000', 1: '#191028', 2: '#46af45', 3: '#a1d685', 4: '#453e78', 5: '#7664fe', 6: '#833129', 7: '#9ec2e8', 8: '#dc534b', 9: '#e18d79', A: '#d6b97b', B: '#e9d8a1', C: '#216c4b', D: '#d365c8', E: '#afaab9', F: '#fff',\n    };\n  }, function (t, e, i) {\n    t.exports = {\n      Path: i(796), CubicBezier: i(348), Curve: i(81), Ellipse: i(349), Line: i(350), QuadraticBezier: i(351), Spline: i(352),\n    };\n  }, function (t, e, i) {\n    const n = i(0); const u = i(348); const l = i(349); const s = i(5); const r = i(350); const o = i(797); const a = i(351); const h = i(11); const c = i(352); const d = i(3); const f = i(13); const p = new n({\n      initialize(t, e) { void 0 === t && (t = 0), void 0 === e && (e = 0), this.name = '', this.curves = [], this.cacheLengths = [], this.autoClose = !1, this.startPoint = new d(), this._tmpVec2A = new d(), this._tmpVec2B = new d(), typeof t === 'object' ? this.fromJSON(t) : this.startPoint.set(t, e); },\n      add(t) { return this.curves.push(t), this; },\n      circleTo(t, e, i) { return void 0 === e && (e = !1), this.ellipseTo(t, t, 0, 360, e, i); },\n      closePath() { const t = this.curves[0].getPoint(0); const e = this.curves[this.curves.length - 1].getPoint(1); return t.equals(e) || this.curves.push(new r(e, t)), this; },\n      cubicBezierTo(t, e, i, n, s, r) { let o; let a; const h = this.getEndPoint(); const l = t instanceof d ? (o = t, a = e, i) : (o = new d(i, n), a = new d(s, r), new d(t, e)); return this.add(new u(h, o, a, l)); },\n      quadraticBezierTo(t, e, i, n) { let s; const r = this.getEndPoint(); const o = t instanceof d ? (s = t, e) : (s = new d(i, n), new d(t, e)); return this.add(new a(r, s, o)); },\n      draw(t, e) { for (let i = 0; i < this.curves.length; i++) { const n = this.curves[i]; n.active && n.draw(t, e); } return t; },\n      ellipseTo(t, e, i, n, s, r) { const o = new l(0, 0, t, e, i, n, s, r); const a = this.getEndPoint(this._tmpVec2A); const h = o.getStartPoint(this._tmpVec2B); return a.subtract(h), o.x = a.x, o.y = a.y, this.add(o); },\n      fromJSON(t) { this.curves = [], this.cacheLengths = [], this.startPoint.set(t.x, t.y), this.autoClose = t.autoClose; for (let e = 0; e < t.curves.length; e++) { const i = t.curves[e]; switch (i.type) { case 'LineCurve': this.add(r.fromJSON(i)); break; case 'EllipseCurve': this.add(l.fromJSON(i)); break; case 'SplineCurve': this.add(c.fromJSON(i)); break; case 'CubicBezierCurve': this.add(u.fromJSON(i)); break; case 'QuadraticBezierCurve': this.add(a.fromJSON(i)); } } return this; },\n      getBounds(t, e) { void 0 === t && (t = new h()), void 0 === e && (e = 16), t.x = Number.MAX_VALUE, t.y = Number.MAX_VALUE; for (var i = new h(), n = f.MIN_SAFE_INTEGER, s = f.MIN_SAFE_INTEGER, r = 0; r < this.curves.length; r++) { const o = this.curves[r]; o.active && (o.getBounds(i, e), t.x = Math.min(t.x, i.x), t.y = Math.min(t.y, i.y), n = Math.max(n, i.right), s = Math.max(s, i.bottom)); } return t.right = n, t.bottom = s, t; },\n      getCurveLengths() { if (this.cacheLengths.length === this.curves.length) return this.cacheLengths; for (var t = [], e = 0, i = 0; i < this.curves.length; i++)e += this.curves[i].getLength(), t.push(e); return this.cacheLengths = t; },\n      getEndPoint(t) { return void 0 === t && (t = new d()), this.curves.length > 0 ? this.curves[this.curves.length - 1].getPoint(1, t) : t.copy(this.startPoint), t; },\n      getLength() { const t = this.getCurveLengths(); return t[t.length - 1]; },\n      getPoint(t, e) { void 0 === e && (e = new d()); for (let i = t * this.getLength(), n = this.getCurveLengths(), s = 0; s < n.length;) { if (n[s] >= i) { const r = n[s] - i; const o = this.curves[s]; const a = o.getLength(); const h = a === 0 ? 0 : 1 - r / a; return o.getPointAt(h, e); }s++; } return null; },\n      getPoints(t) { void 0 === t && (t = 12); for (var e, i = [], n = 0; n < this.curves.length; n++) { const s = this.curves[n]; if (s.active) for (let r = s.getResolution(t), o = s.getPoints(r), a = 0; a < o.length; a++) { const h = o[a]; e && e.equals(h) || (i.push(h), e = h); } } return this.autoClose && i.length > 1 && !i[i.length - 1].equals(i[0]) && i.push(i[0]), i; },\n      getRandomPoint(t) { return void 0 === t && (t = new d()), this.getPoint(Math.random(), t); },\n      getSpacedPoints(t) { void 0 === t && (t = 40); for (var e = [], i = 0; i <= t; i++)e.push(this.getPoint(i / t)); return this.autoClose && e.push(e[0]), e; },\n      getStartPoint(t) { return void 0 === t && (t = new d()), t.copy(this.startPoint); },\n      getTangent(t, e) { void 0 === e && (e = new d()); for (let i = t * this.getLength(), n = this.getCurveLengths(), s = 0; s < n.length;) { if (n[s] >= i) { const r = n[s] - i; const o = this.curves[s]; const a = o.getLength(); const h = a === 0 ? 0 : 1 - r / a; return o.getTangentAt(h, e); }s++; } return null; },\n      lineTo(t, e) { t instanceof d ? this._tmpVec2B.copy(t) : this._tmpVec2B.set(t, e); const i = this.getEndPoint(this._tmpVec2A); return this.add(new r([i.x, i.y, this._tmpVec2B.x, this._tmpVec2B.y])); },\n      splineTo(t) { return t.unshift(this.getEndPoint()), this.add(new c(t)); },\n      moveTo(t, e) { return t instanceof d ? this.add(new o(t.x, t.y)) : this.add(new o(t, e)); },\n      toJSON() {\n        for (var t = [], e = 0; e < this.curves.length; e++)t.push(this.curves[e].toJSON()); return {\n          type: 'Path', x: this.startPoint.x, y: this.startPoint.y, autoClose: this.autoClose, curves: t,\n        };\n      },\n      updateArcLengths() { this.cacheLengths = [], this.getCurveLengths(); },\n      destroy() { this.curves.length = 0, this.cacheLengths.length = 0, this.startPoint = void 0; },\n    }); s.register('path', (t, e) => new p(t, e)), t.exports = p;\n  }, function (t, e, i) {\n    const n = i(0); const s = i(3); const r = new n({\n      initialize(t, e) { this.active = !1, this.p0 = new s(t, e); }, getPoint(t, e) { return void 0 === e && (e = new s()), e.copy(this.p0); }, getPointAt(t, e) { return this.getPoint(t, e); }, getResolution() { return 1; }, getLength() { return 0; }, toJSON() { return { type: 'MoveTo', points: [this.p0.x, this.p0.y] }; },\n    }); t.exports = r;\n  }, function (t, e, i) { t.exports = { DataManager: i(113), DataManagerPlugin: i(799), Events: i(284) }; }, function (t, e, i) {\n    const n = i(0); const s = i(113); const r = i(23); const o = i(22); const a = new n({\n      Extends: s, initialize(t) { s.call(this, t, t.sys.events), this.scene = t, this.systems = t.sys, t.sys.events.once(o.BOOT, this.boot, this), t.sys.events.on(o.START, this.start, this); }, boot() { this.events = this.systems.events, this.events.once(o.DESTROY, this.destroy, this); }, start() { this.events.once(o.SHUTDOWN, this.shutdown, this); }, shutdown() { this.systems.events.off(o.SHUTDOWN, this.shutdown, this); }, destroy() { s.prototype.destroy.call(this), this.events.off(o.START, this.start, this), this.scene = null, this.systems = null; },\n    }); r.register('DataManagerPlugin', a, 'data'), t.exports = a;\n  }, function (t, e, i) {\n    t.exports = {\n      Align: i(801), BaseShader: i(353), Bounds: i(804), Canvas: i(808), Color: i(354), Masks: i(817),\n    };\n  }, function (t, e, i) { const n = i(105); var s = i(18)(!1, s = { In: i(802), To: i(803) }, n); t.exports = s; }, function (t, e, i) {\n    t.exports = {\n      BottomCenter: i(256), BottomLeft: i(257), BottomRight: i(258), Center: i(259), LeftCenter: i(261), QuickSet: i(255), RightCenter: i(262), TopCenter: i(263), TopLeft: i(264), TopRight: i(265),\n    };\n  }, function (t, e, i) {\n    t.exports = {\n      BottomCenter: i(243), BottomLeft: i(244), BottomRight: i(245), LeftBottom: i(246), LeftCenter: i(247), LeftTop: i(248), QuickSet: i(242), RightBottom: i(249), RightCenter: i(250), RightTop: i(251), TopCenter: i(252), TopLeft: i(253), TopRight: i(254),\n    };\n  }, function (t, e, i) {\n    t.exports = {\n      CenterOn: i(260), GetBottom: i(34), GetBounds: i(805), GetCenterX: i(76), GetCenterY: i(78), GetLeft: i(35), GetOffsetX: i(806), GetOffsetY: i(807), GetRight: i(36), GetTop: i(37), SetBottom: i(46), SetCenterX: i(77), SetCenterY: i(79), SetLeft: i(44), SetRight: i(45), SetTop: i(43),\n    };\n  }, function (t, e, i) { const s = i(34); const r = i(35); const o = i(36); const a = i(37); t.exports = function (t, e) { void 0 === e && (e = {}); const i = r(t); const n = a(t); return e.x = i, e.y = n, e.width = o(t) - i, e.height = s(t) - n, e; }; }, function (t, e) { t.exports = function (t) { return t.width * t.originX; }; }, function (t, e) { t.exports = function (t) { return t.height * t.originY; }; }, function (t, e, i) {\n    t.exports = {\n      CanvasInterpolation: i(339), CanvasPool: i(26), Smoothing: i(167), TouchAction: i(809), UserSelect: i(810),\n    };\n  }, function (t, e) { t.exports = function (t, e) { return void 0 === e && (e = 'none'), t.style.msTouchAction = e, t.style['ms-touch-action'] = e, t.style['touch-action'] = e, t; }; }, function (t, e) { t.exports = function (e, i) { void 0 === i && (i = 'none'); return ['-webkit-', '-khtml-', '-moz-', '-ms-', ''].forEach((t) => { e.style[`${t}user-select`] = i; }), e.style['-webkit-touch-callout'] = i, e.style['-webkit-tap-highlight-color'] = 'rgba(0, 0, 0, 0)', e; }; }, function (t, e) {\n    t.exports = function (t) {\n      const e = {\n        r: t >> 16 & 255, g: t >> 8 & 255, b: 255 & t, a: 255,\n      }; return t > 16777215 && (e.a = t >>> 24), e;\n    };\n  }, function (t, e, i) { const h = i(31); const l = i(356); t.exports = function (t, e, i) { let n; let s; let r = i; let o = i; let a = i; return e !== 0 && (r = l(s = 2 * i - (n = i < 0.5 ? i * (1 + e) : i + e - i * e), n, t + 1 / 3), o = l(s, n, t), a = l(s, n, t - 1 / 3)), (new h()).setGLTo(r, o, a, 1); }; }, function (t, e, i) { const s = i(166); t.exports = function (t, e) { void 0 === t && (t = 1), void 0 === e && (e = 1); for (var i = [], n = 0; n <= 359; n++)i.push(s(n / 359, t, e)); return i; }; }, function (t, e, i) { function o(t, e, i, n, s, r, o, a) { void 0 === o && (o = 100), void 0 === a && (a = 0); const h = a / o; return { r: l(t, n, h), g: l(e, s, h), b: l(i, r, h) }; } var l = i(116); t.exports = { RGBWithRGB: o, ColorWithRGB(t, e, i, n, s, r) { return void 0 === s && (s = 100), void 0 === r && (r = 0), o(t.r, t.g, t.b, e, i, n, s, r); }, ColorWithColor(t, e, i, n) { return void 0 === i && (i = 100), void 0 === n && (n = 0), o(t.r, t.g, t.b, e.r, e.g, e.b, i, n); } }; }, function (t, e, i) { const n = i(172); const s = i(31); t.exports = function (t, e) { return void 0 === t && (t = 0), void 0 === e && (e = 255), new s(n(t, e), n(t, e), n(t, e)); }; }, function (t, e, i) { const r = i(355); t.exports = function (t, e, i, n, s) { return void 0 === n && (n = 255), void 0 === s && (s = '#'), s === '#' ? `#${((1 << 24) + (t << 16) + (e << 8) + i).toString(16).slice(1)}` : `0x${r(n)}${r(t)}${r(e)}${r(i)}`; }; }, function (t, e, i) { t.exports = { BitmapMask: i(278), GeometryMask: i(279) }; }, function (t, e, i) {\n    const n = {\n      AddToDOM: i(122), DOMContentLoaded: i(357), GetScreenOrientation: i(358), GetTarget: i(363), ParseXML: i(364), RemoveFromDOM: i(178), RequestAnimationFrame: i(344),\n    }; t.exports = n;\n  }, function (t, e, i) { t.exports = { EventEmitter: i(820) }; }, function (t, e, i) {\n    const n = i(0); const s = i(10); const r = i(23); const o = new n({\n      Extends: s, initialize() { s.call(this); }, shutdown() { this.removeAllListeners(); }, destroy() { this.removeAllListeners(); },\n    }); r.register('EventEmitter', o, 'events'), t.exports = o;\n  }, function (t, e, i) {\n    const n = i(122); const s = i(289); const r = i(292); const o = i(26); const a = i(0); const h = i(314); const l = i(822); const u = i(338); const c = i(113); const d = i(342); const f = i(315); const p = i(357); const g = i(10); const v = i(20); const m = i(365); const y = i(23); const x = i(370); const T = i(371); const w = i(373); const b = i(121); const E = i(376); const S = i(343); const _ = i(345); const A = i(380); const C = new a({\n      initialize(t) { this.config = new h(t), this.renderer = null, this.domContainer = null, this.canvas = null, this.context = null, this.isBooted = !1, this.isRunning = !1, this.events = new g(), this.anims = new s(this), this.textures = new E(this), this.cache = new r(this), this.registry = new c(this), this.input = new m(this, this.config), this.scene = new w(this, this.config.sceneConfig), this.device = f, this.scale = new T(this, this.config), this.sound = null, this.sound = A.create(this), this.loop = new S(this, this.config.fps), this.plugins = new x(this, this.config), this.pendingDestroy = !1, this.removeCanvas = !1, this.noReturn = !1, this.hasFocus = !1, p(this.boot.bind(this)); }, boot() { y.hasCore('EventEmitter') ? (this.isBooted = !0, this.config.preBoot(this), this.scale.preBoot(), u(this), l(this), d(this), n(this.canvas, this.config.parent), this.textures.once(b.READY, this.texturesReady, this), this.events.emit(v.BOOT)) : console.warn('Aborting. Core Plugins missing.'); }, texturesReady() { this.events.emit(v.READY), this.start(); }, start() { this.isRunning = !0, this.config.postBoot(this), this.renderer ? this.loop.start(this.step.bind(this)) : this.loop.start(this.headlessStep.bind(this)), _(this); const t = this.events; t.on(v.HIDDEN, this.onHidden, this), t.on(v.VISIBLE, this.onVisible, this), t.on(v.BLUR, this.onBlur, this), t.on(v.FOCUS, this.onFocus, this); }, step(t, e) { if (this.pendingDestroy) return this.runDestroy(); const i = this.events; i.emit(v.PRE_STEP, t, e), i.emit(v.STEP, t, e), this.scene.update(t, e), i.emit(v.POST_STEP, t, e); const n = this.renderer; n.preRender(), i.emit(v.PRE_RENDER, n, t, e), this.scene.render(n), n.postRender(), i.emit(v.POST_RENDER, n, t, e); }, headlessStep(t, e) { if (this.pendingDestroy) return this.runDestroy(); const i = this.events; i.emit(v.PRE_STEP, t, e), i.emit(v.STEP, t, e), this.scene.update(t, e), i.emit(v.POST_STEP, t, e), i.emit(v.PRE_RENDER), i.emit(v.POST_RENDER); }, onHidden() { this.loop.pause(), this.events.emit(v.PAUSE); }, onVisible() { this.loop.resume(), this.events.emit(v.RESUME); }, onBlur() { this.hasFocus = !1, this.loop.blur(); }, onFocus() { this.hasFocus = !0, this.loop.focus(); }, getFrame() { return this.loop.frame; }, getTime() { return this.loop.now; }, destroy(t, e) { void 0 === e && (e = !1), this.pendingDestroy = !0, this.removeCanvas = t, this.noReturn = e; }, runDestroy() { this.scene.destroy(), this.events.emit(v.DESTROY), this.events.removeAllListeners(), this.renderer && this.renderer.destroy(), this.removeCanvas && this.canvas && (o.remove(this.canvas), this.canvas.parentNode && this.canvas.parentNode.removeChild(this.canvas)), this.domContainer && this.domContainer.parentNode.removeChild(this.domContainer), this.loop.destroy(), this.pendingDestroy = !1; },\n    }); t.exports = C;\n  }, function (t, e, i) { const n = i(122); t.exports = function (t) { let e; const i = t.config; i.parent && i.domCreateContainer && ((e = document.createElement('div')).style.cssText = ['display: block;', `width: ${t.scale.width}px;`, `height: ${t.scale.height}px;`, 'padding: 0; margin: 0;', 'position: absolute;', 'overflow: hidden;', 'pointer-events: none;', 'transform: scale(1);', 'transform-origin: left top;'].join(' '), t.domContainer = e, n(e, i.parent)); }; }, function (t, e) { t.exports = 'boot'; }, function (t, e) { t.exports = 'destroy'; }, function (t, e) { t.exports = 'dragend'; }, function (t, e) { t.exports = 'dragenter'; }, function (t, e) { t.exports = 'drag'; }, function (t, e) { t.exports = 'dragleave'; }, function (t, e) { t.exports = 'dragover'; }, function (t, e) { t.exports = 'dragstart'; }, function (t, e) { t.exports = 'drop'; }, function (t, e) { t.exports = 'gameout'; }, function (t, e) { t.exports = 'gameover'; }, function (t, e) { t.exports = 'gameobjectdown'; }, function (t, e) { t.exports = 'dragend'; }, function (t, e) { t.exports = 'dragenter'; }, function (t, e) { t.exports = 'drag'; }, function (t, e) { t.exports = 'dragleave'; }, function (t, e) { t.exports = 'dragover'; }, function (t, e) { t.exports = 'dragstart'; }, function (t, e) { t.exports = 'drop'; }, function (t, e) { t.exports = 'gameobjectmove'; }, function (t, e) { t.exports = 'gameobjectout'; }, function (t, e) { t.exports = 'gameobjectover'; }, function (t, e) { t.exports = 'pointerdown'; }, function (t, e) { t.exports = 'pointermove'; }, function (t, e) { t.exports = 'pointerout'; }, function (t, e) { t.exports = 'pointerover'; }, function (t, e) { t.exports = 'pointerup'; }, function (t, e) { t.exports = 'wheel'; }, function (t, e) { t.exports = 'gameobjectup'; }, function (t, e) { t.exports = 'gameobjectwheel'; }, function (t, e) { t.exports = 'boot'; }, function (t, e) { t.exports = 'process'; }, function (t, e) { t.exports = 'update'; }, function (t, e) { t.exports = 'pointerdown'; }, function (t, e) { t.exports = 'pointerdownoutside'; }, function (t, e) { t.exports = 'pointermove'; }, function (t, e) { t.exports = 'pointerout'; }, function (t, e) { t.exports = 'pointerover'; }, function (t, e) { t.exports = 'pointerup'; }, function (t, e) { t.exports = 'pointerupoutside'; }, function (t, e) { t.exports = 'wheel'; }, function (t, e) { t.exports = 'pointerlockchange'; }, function (t, e) { t.exports = 'preupdate'; }, function (t, e) { t.exports = 'shutdown'; }, function (t, e) { t.exports = 'start'; }, function (t, e) { t.exports = 'update'; }, function (t, e) { t.exports = function (t) { if (!t) return window.innerHeight; const e = Math.abs(window.orientation); const i = { w: 0, h: 0 }; let n = document.createElement('div'); return n.setAttribute('style', 'position: fixed; height: 100vh; width: 0; top: 0'), document.documentElement.appendChild(n), i.w = e === 90 ? n.offsetHeight : window.innerWidth, i.h = e === 90 ? window.innerWidth : n.offsetHeight, document.documentElement.removeChild(n), n = null, Math.abs(window.orientation) !== 90 ? i.h : i.w; }; }, function (t, e) { t.exports = 'addfile'; }, function (t, e) { t.exports = 'complete'; }, function (t, e) { t.exports = 'filecomplete'; }, function (t, e) { t.exports = 'filecomplete-'; }, function (t, e) { t.exports = 'loaderror'; }, function (t, e) { t.exports = 'load'; }, function (t, e) { t.exports = 'fileprogress'; }, function (t, e) { t.exports = 'postprocess'; }, function (t, e) { t.exports = 'progress'; }, function (t, e) { t.exports = 'start'; }, function (t, e, i) { const r = i(2); const o = i(181); t.exports = function (t) { const e = t.game.config.defaultPhysicsSystem; const i = r(t.settings, 'physics', !1); if (e || i) { const n = []; if (e && n.push(o(`${e}Physics`)), i) for (let s in i)s = o(s.concat('Physics')), n.indexOf(s) === -1 && n.push(s); return n; } }; }, function (t, e, i) { const n = i(2); t.exports = function (t) { const e = t.plugins.getDefaultScenePlugins(); const i = n(t.settings, 'plugins', !1); return Array.isArray(i) ? i : e || []; }; }, function (t, e, i) {\n    t.exports = {\n      game: 'game', anims: 'anims', cache: 'cache', plugins: 'plugins', registry: 'registry', scale: 'scale', sound: 'sound', textures: 'textures', events: 'events', cameras: 'cameras', add: 'add', make: 'make', scenePlugin: 'scene', displayList: 'children', lights: 'lights', data: 'data', input: 'input', load: 'load', time: 'time', tweens: 'tweens', arcadePhysics: 'physics', impactPhysics: 'impact', matterPhysics: 'matter',\n    };\n  }, function (t, e) { t.exports = function (t, e, i) { if (i.getElementsByTagName('TextureAtlas')) { const n = t.source[e]; t.add('__BASE', e, 0, 0, n.width, n.height); for (let s = i.getElementsByTagName('SubTexture'), r = 0; r < s.length; r++) { var o; var a; var h; var l; const u = s[r].attributes; const c = u.name.value; const d = parseInt(u.x.value, 10); const f = parseInt(u.y.value, 10); const p = parseInt(u.width.value, 10); const g = parseInt(u.height.value, 10); const v = t.add(c, e, d, f, p, g); u.frameX && (o = Math.abs(parseInt(u.frameX.value, 10)), a = Math.abs(parseInt(u.frameY.value, 10)), h = parseInt(u.frameWidth.value, 10), l = parseInt(u.frameHeight.value, 10), v.setTrim(p, g, o, a, h, l)); } return t; }console.warn('Invalid Texture Atlas XML given'); }; }, function (t, e) { t.exports = function (t, e) { const i = t.source[e]; return t.add('__BASE', e, 0, 0, i.width, i.height), t; }; }, function (t, e) { t.exports = function (t, e) { const i = t.source[e]; return t.add('__BASE', e, 0, 0, i.width, i.height), t; }; }, function (t, e, i) { const u = i(67); t.exports = function (t, e, i) { if (i.frames || i.textures) { const n = t.source[e]; t.add('__BASE', e, 0, 0, n.width, n.height); for (let s = Array.isArray(i.textures) ? i.textures[e].frames : i.frames, r = 0; r < s.length; r++) { const o = s[r]; const a = t.add(o.filename, e, o.frame.x, o.frame.y, o.frame.w, o.frame.h); o.trimmed && a.setTrim(o.sourceSize.w, o.sourceSize.h, o.spriteSourceSize.x, o.spriteSourceSize.y, o.spriteSourceSize.w, o.spriteSourceSize.h), o.rotated && (a.rotated = !0, a.updateUVsInverted()); const h = o.anchor || o.pivot; h && (a.customPivot = !0, a.pivotX = h.x, a.pivotY = h.y), a.customData = u(o); } for (const l in i)l !== 'frames' && (Array.isArray(i[l]) ? t.customData[l] = i[l].slice(0) : t.customData[l] = i[l]); return t; }console.warn('Invalid Texture Atlas JSON Array'); }; }, function (t, e, i) { const u = i(67); t.exports = function (t, e, i) { if (i.frames) { const n = t.source[e]; t.add('__BASE', e, 0, 0, n.width, n.height); const s = i.frames; for (const r in s) { const o = s[r]; const a = t.add(r, e, o.frame.x, o.frame.y, o.frame.w, o.frame.h); o.trimmed && a.setTrim(o.sourceSize.w, o.sourceSize.h, o.spriteSourceSize.x, o.spriteSourceSize.y, o.spriteSourceSize.w, o.spriteSourceSize.h), o.rotated && (a.rotated = !0, a.updateUVsInverted()); const h = o.anchor || o.pivot; h && (a.customPivot = !0, a.pivotX = h.x, a.pivotY = h.y), a.customData = u(o); } for (const l in i)l !== 'frames' && (Array.isArray(i[l]) ? t.customData[l] = i[l].slice(0) : t.customData[l] = i[l]); return t; }console.warn(\"Invalid Texture Atlas JSON Hash given, missing 'frames' Object\"); }; }, function (t, e, i) { const b = i(2); t.exports = function (t, e, i, n, s, r, o) { const a = b(o, 'frameWidth', null); const h = b(o, 'frameHeight', a); if (a === null) throw new Error('TextureManager.SpriteSheet: Invalid frameWidth given.'); const l = t.source[e]; t.add('__BASE', e, 0, 0, l.width, l.height); let u = b(o, 'startFrame', 0); const c = b(o, 'endFrame', -1); const d = b(o, 'margin', 0); const f = b(o, 'spacing', 0); let p = Math.floor((s - d + f) / (a + f)) * Math.floor((r - d + f) / (h + f)); p === 0 && console.warn('SpriteSheet frame dimensions will result in zero frames for texture:', t.key), (p < u || u < -p) && (u = 0), u < 0 && (u = p + u), c !== -1 && (p = u + (c + 1)); for (let g = d, v = d, m = 0, y = 0, x = 0; x < p; x++) { y = m = 0; const T = g + a; const w = v + h; s < T && (m = T - s), r < w && (y = w - r), t.add(x, e, i + g, n + v, a - m, h - y), s < (g += a + f) + a && (g = d, v += h + f); } return t; }; }, function (t, e, i) { const z = i(2); t.exports = function (t, e, i) { const n = z(i, 'frameWidth', null); const s = z(i, 'frameHeight', n); if (!n) throw new Error('TextureManager.SpriteSheetFromAtlas: Invalid frameWidth given.'); const r = t.source[0]; t.add('__BASE', 0, 0, 0, r.width, r.height); let o = z(i, 'startFrame', 0); const a = z(i, 'endFrame', -1); const h = z(i, 'margin', 0); const l = z(i, 'spacing', 0); const u = e.cutX; const c = e.cutY; const d = e.cutWidth; const f = e.cutHeight; const p = e.realWidth; const g = e.realHeight; const v = Math.floor((p - h + l) / (n + l)); const m = Math.floor((g - h + l) / (s + l)); let y = v * m; const { x } = e; const T = n - x; const w = n - (p - d - x); const b = e.y; const E = s - b; const S = s - (g - f - b); (y < o || o < -y) && (o = 0), o < 0 && (o = y + o), a !== -1 && (y = o + (a + 1)); for (let _ = h, A = h, C = 0, M = e.sourceIndex, P = 0; P < m; P++) { for (var O = P === 0, R = P === m - 1, L = 0; L < v; L++) { var k; var D; var F; var I; var B; var N; const Y = L === 0; const X = L === v - 1; const U = t.add(C, M, u + _, c + A, n, s); (Y || O || X || R) && (k = Y ? x : 0, D = O ? b : 0, I = F = 0, Y && (F += n - T), X && (F += n - w), O && (I += s - E), R && (I += s - S), B = n - F, N = s - I, U.cutWidth = B, U.cutHeight = N, U.setTrim(n, s, k, D, B, N)), _ += l, _ += Y ? T : X ? w : n, C++; }_ = h, A += l, A += O ? E : R ? S : s; } return t; }; }, function (t, e) {\n    function p(t, e, i, n) { const s = g - n.y - n.height; t.add(i, e, n.x, s, n.width, n.height); } var g = 0; t.exports = function (t, e, i) {\n      const n = t.source[e]; t.add('__BASE', e, 0, 0, n.width, n.height), g = n.height; for (var s = i.split('\\n'), r = /^[ ]*(- )*(\\w+)+[: ]+(.*)/, o = '', a = '', h = {\n          x: 0, y: 0, width: 0, height: 0,\n        }, l = 0; l < s.length; l++) {\n        const u = s[l].match(r); if (u) {\n          const c = u[1] === '- '; const d = u[2]; const f = u[3]; if (c && (a !== o && (p(t, e, a, h), o = a), h = {\n            x: 0, y: 0, width: 0, height: 0,\n          }), d !== 'name') switch (d) { case 'x': case 'y': case 'width': case 'height': h[d] = parseInt(f, 10); } else a = f;\n        }\n      } return a !== o && p(t, e, a, h), t;\n    };\n  }, function (t, e) { t.exports = 'complete'; }, function (t, e) { t.exports = 'decoded'; }, function (t, e) { t.exports = 'decodedall'; }, function (t, e) { t.exports = 'destroy'; }, function (t, e) { t.exports = 'detune'; }, function (t, e) { t.exports = 'detune'; }, function (t, e) { t.exports = 'mute'; }, function (t, e) { t.exports = 'rate'; }, function (t, e) { t.exports = 'volume'; }, function (t, e) { t.exports = 'loop'; }, function (t, e) { t.exports = 'looped'; }, function (t, e) { t.exports = 'mute'; }, function (t, e) { t.exports = 'pauseall'; }, function (t, e) { t.exports = 'pause'; }, function (t, e) { t.exports = 'play'; }, function (t, e) { t.exports = 'rate'; }, function (t, e) { t.exports = 'resumeall'; }, function (t, e) { t.exports = 'resume'; }, function (t, e) { t.exports = 'seek'; }, function (t, e) { t.exports = 'stopall'; }, function (t, e) { t.exports = 'stop'; }, function (t, e) { t.exports = 'unlocked'; }, function (t, e) { t.exports = 'volume'; }, function (t, e, i) {\n    const n = {\n      Events: i(90),\n      DisplayList: i(915),\n      GameObjectCreator: i(16),\n      GameObjectFactory: i(5),\n      UpdateList: i(941),\n      Components: i(12),\n      BuildGameObject: i(27),\n      BuildGameObjectAnimation: i(393),\n      GameObject: i(14),\n      BitmapText: i(132),\n      Blitter: i(188),\n      Container: i(189),\n      DOMElement: i(395),\n      DynamicBitmapText: i(190),\n      Extern: i(397),\n      Graphics: i(191),\n      Group: i(97),\n      Image: i(107),\n      Particles: i(973),\n      PathFollower: i(409),\n      RenderTexture: i(195),\n      RetroFont: i(982),\n      Rope: i(197),\n      Sprite: i(75),\n      Text: i(198),\n      TileSprite: i(199),\n      Zone: i(110),\n      Video: i(200),\n      Shape: i(30),\n      Arc: i(410),\n      Curve: i(411),\n      Ellipse: i(412),\n      Grid: i(413),\n      IsoBox: i(414),\n      IsoTriangle: i(415),\n      Line: i(416),\n      Polygon: i(417),\n      Rectangle: i(422),\n      Star: i(423),\n      Triangle: i(424),\n      Factories: {\n        Blitter: i(1033), Container: i(1034), DOMElement: i(1035), DynamicBitmapText: i(1036), Extern: i(1037), Graphics: i(1038), Group: i(1039), Image: i(1040), Particles: i(1041), PathFollower: i(1042), RenderTexture: i(1043), Rope: i(1044), Sprite: i(1045), StaticBitmapText: i(1046), Text: i(1047), TileSprite: i(1048), Zone: i(1049), Video: i(1050), Arc: i(1051), Curve: i(1052), Ellipse: i(1053), Grid: i(1054), IsoBox: i(1055), IsoTriangle: i(1056), Line: i(1057), Polygon: i(1058), Rectangle: i(1059), Star: i(1060), Triangle: i(1061),\n      },\n      Creators: {\n        Blitter: i(1062), Container: i(1063), DynamicBitmapText: i(1064), Graphics: i(1065), Group: i(1066), Image: i(1067), Particles: i(1068), RenderTexture: i(1069), Rope: i(1070), Sprite: i(1071), StaticBitmapText: i(1072), Text: i(1073), TileSprite: i(1074), Zone: i(1075), Video: i(1076),\n      },\n    }; n.Mesh = i(134), n.Quad = i(203), n.Shader = i(204), n.Factories.Mesh = i(1083), n.Factories.Quad = i(1084), n.Factories.Shader = i(1085), n.Creators.Mesh = i(1086), n.Creators.Quad = i(1087), n.Creators.Shader = i(1088), n.Light = i(428), i(429), i(1089), t.exports = n;\n  }, function (t, e, i) {\n    const n = i(0); const s = i(129); const r = i(23); const o = i(22); const a = i(131); const h = new n({\n      Extends: s, initialize(t) { s.call(this, t), this.sortChildrenFlag = !1, this.scene = t, this.systems = t.sys, t.sys.events.once(o.BOOT, this.boot, this), t.sys.events.on(o.START, this.start, this); }, boot() { this.systems.events.once(o.DESTROY, this.destroy, this); }, start() { this.systems.events.once(o.SHUTDOWN, this.shutdown, this); }, queueDepthSort() { this.sortChildrenFlag = !0; }, depthSort() { this.sortChildrenFlag && (a.inplace(this.list, this.sortByDepth), this.sortChildrenFlag = !1); }, sortByDepth(t, e) { return t._depth - e._depth; }, getChildren() { return this.list; }, shutdown() { for (let t = this.list.length; t--;) this.list[t].destroy(!0); this.list.length = 0, this.systems.events.off(o.SHUTDOWN, this.shutdown, this); }, destroy() { this.shutdown(), this.scene.sys.events.off(o.START, this.start, this), this.scene = null, this.systems = null; },\n    }); r.register('DisplayList', h, 'displayList'), t.exports = h;\n  }, function (t, e, i) {\n    t.exports = {\n      CheckMatrix: i(184), MatrixToString: i(917), ReverseColumns: i(918), ReverseRows: i(919), Rotate180: i(920), RotateLeft: i(921), RotateMatrix: i(130), RotateRight: i(922), TransposeMatrix: i(390),\n    };\n  }, function (t, e, i) { const o = i(163); const a = i(184); t.exports = function (t) { let e = ''; if (!a(t)) return e; for (let i = 0; i < t.length; i++) { for (let n = 0; n < t[i].length; n++) { const s = t[i][n].toString(); e += s !== 'undefined' ? o(s, 2) : '?', n < t[i].length - 1 && (e += ' |'); } if (i < t.length - 1) { e += '\\n'; for (let r = 0; r < t[i].length; r++)e += '---', r < t[i].length - 1 && (e += '+'); e += '\\n'; } } return e; }; }, function (t, e) { t.exports = function (t) { return t.reverse(); }; }, function (t, e) { t.exports = function (t) { for (let e = 0; e < t.length; e++)t[e].reverse(); return t; }; }, function (t, e, i) { const n = i(130); t.exports = function (t) { return n(t, 180); }; }, function (t, e, i) { const n = i(130); t.exports = function (t) { return n(t, 90); }; }, function (t, e, i) { const n = i(130); t.exports = function (t) { return n(t, -90); }; }, function (t, e) { t.exports = function (t, e, i, n, s) { if (void 0 === s && (s = t), i > 0) { var r = i - t.length; if (r <= 0) return null; } if (!Array.isArray(e)) return t.indexOf(e) === -1 ? (t.push(e), n && n.call(s, e), e) : null; for (var o = e.length - 1; o >= 0;)t.indexOf(e[o]) !== -1 && e.splice(o, 1), o--; if ((o = e.length) === 0) return null; i > 0 && r < o && (e.splice(r), o = r); for (let a = 0; a < o; a++) { const h = e[a]; t.push(h), n && n.call(s, h); } return e; }; }, function (t, e) { t.exports = function (t, e, i, n, s, r) { if (void 0 === i && (i = 0), void 0 === r && (r = t), n > 0) { var o = n - t.length; if (o <= 0) return null; } if (!Array.isArray(e)) return t.indexOf(e) === -1 ? (t.splice(i, 0, e), s && s.call(r, e), e) : null; for (var a = e.length - 1; a >= 0;)t.indexOf(e[a]) !== -1 && e.pop(), a--; if ((a = e.length) === 0) return null; n > 0 && o < a && (e.splice(o), a = o); for (let h = a - 1; h >= 0; h--) { const l = e[h]; t.splice(i, 0, l), s && s.call(r, l); } return e; }; }, function (t, e) { t.exports = function (t, e) { const i = t.indexOf(e); return i !== -1 && i < t.length && (t.splice(i, 1), t.push(e)), e; }; }, function (t, e, i) { const a = i(68); t.exports = function (t, e, i, n, s) { void 0 === n && (n = 0), void 0 === s && (s = t.length); let r = 0; if (a(t, n, s)) for (let o = n; o < s; o++) { t[o][e] === i && r++; } return r; }; }, function (t, e) { t.exports = function (t, e, i) { for (var n = [null], s = 3; s < arguments.length; s++)n.push(arguments[s]); for (s = 0; s < t.length; s++)n[0] = t[s], e.apply(i, n); return t; }; }, function (t, e, i) { const a = i(68); t.exports = function (t, e, i, n, s) { if (void 0 === n && (n = 0), void 0 === s && (s = t.length), a(t, n, s)) { for (var r = [null], o = 5; o < arguments.length; o++)r.push(arguments[o]); for (o = n; o < s; o++)r[0] = t[o], e.apply(i, r); } return t; }; }, function (t, e) { t.exports = function (t, e) { let i; let n; const s = t.indexOf(e); return s > 0 && (i = t[s - 1], n = t.indexOf(i), t[s] = i, t[n] = e), t; }; }, function (t, e) { t.exports = function (t, e, i) { const n = t.indexOf(e); if (n === -1 || i < 0 || i >= t.length) throw new Error('Supplied index out of bounds'); return n !== i && (t.splice(n, 1), t.splice(i, 0, e)), e; }; }, function (t, e) { t.exports = function (t, e) { let i; let n; const s = t.indexOf(e); return s !== -1 && s < t.length - 1 && (i = t[s + 1], n = t.indexOf(i), t[s] = i, t[n] = e), t; }; }, function (t, e) { t.exports = function (t, e, i, n) { for (var s, r = [], o = t; o <= e; o++) { i || n ? (s = i ? i + o.toString() : o.toString(), n && (s = s.concat(n)), r.push(s)) : r.push(o); } return r; }; }, function (t, e, i) { const o = i(332); t.exports = function (t, e, i) { void 0 === t && (t = 0), void 0 === e && (e = null), void 0 === i && (i = 1), e === null && (e = t, t = 0); for (var n = [], s = Math.max(o((e - t) / (i || 1)), 0), r = 0; r < s; r++)n.push(t), t += i; return n; }; }, function (t, e, i) { const r = i(80); t.exports = function (t, e, i, n) { if (void 0 === n && (n = t), e < 0 || e > t.length - 1) throw new Error('Index out of bounds'); const s = r(t, e); return i && i.call(n, s), s; }; }, function (t, e, i) { const l = i(68); t.exports = function (t, e, i, n, s) { if (void 0 === e && (e = 0), void 0 === i && (i = t.length), void 0 === s && (s = t), l(t, e, i)) { const r = i - e; const o = t.splice(e, r); if (n) for (let a = 0; a < o.length; a++) { const h = o[a]; n.call(s, h); } return o; } return []; }; }, function (t, e, i) { const s = i(80); t.exports = function (t, e, i) { void 0 === e && (e = 0), void 0 === i && (i = t.length); const n = e + Math.floor(Math.random() * i); return s(t, n); }; }, function (t, e) { t.exports = function (t, e, i) { const n = t.indexOf(e); const s = t.indexOf(i); return n !== -1 && s === -1 && (t[n] = i, !0); }; }, function (t, e) { t.exports = function (t, e) { const i = t.indexOf(e); return i !== -1 && i > 0 && (t.splice(i, 1), t.unshift(e)), e; }; }, function (t, e, i) { const a = i(68); t.exports = function (t, e, i, n, s) { if (void 0 === n && (n = 0), void 0 === s && (s = t.length), a(t, n, s)) for (let r = n; r < s; r++) { const o = t[r]; o.hasOwnProperty(e) && (o[e] = i); } return t; }; }, function (t, e) { t.exports = function (t, e, i) { if (e !== i) { const n = t.indexOf(e); const s = t.indexOf(i); if (n < 0 || s < 0) throw new Error('Supplied items must be elements of the same array'); return t[n] = i, t[s] = e, t; } }; }, function (t, e, i) {\n    const n = i(0); const s = i(186); const r = i(23); const o = i(22); const a = new n({\n      Extends: s, initialize(t) { s.call(this), this.scene = t, this.systems = t.sys, t.sys.events.once(o.BOOT, this.boot, this), t.sys.events.on(o.START, this.start, this); }, boot() { this.systems.events.once(o.DESTROY, this.destroy, this); }, start() { const t = this.systems.events; t.on(o.PRE_UPDATE, this.update, this), t.on(o.UPDATE, this.sceneUpdate, this), t.once(o.SHUTDOWN, this.shutdown, this); }, sceneUpdate(t, e) { for (let i = this._active, n = i.length, s = 0; s < n; s++) { const r = i[s]; r.active && r.preUpdate.call(r, t, e); } }, shutdown() { for (var t = this._active.length; t--;) this._active[t].destroy(!0); for (t = this._pending.length; t--;) this._pending[t].destroy(!0); for (t = this._destroy.length; t--;) this._destroy[t].destroy(!0); this._toProcess = 0, this._pending = [], this._active = [], this._destroy = [], this.removeAllListeners(); const e = this.systems.events; e.off(o.PRE_UPDATE, this.preUpdate, this), e.off(o.UPDATE, this.sceneUpdate, this), e.off(o.SHUTDOWN, this.shutdown, this); }, destroy() { this.shutdown(), this.systems.events.off(o.START, this.start, this), this.scene = null, this.systems = null; },\n    }); r.register('UpdateList', a, 'updateList'), t.exports = a;\n  }, function (t, e, i) { t.exports = { PROCESS_QUEUE_ADD: i(943), PROCESS_QUEUE_REMOVE: i(944) }; }, function (t, e) { t.exports = 'add'; }, function (t, e) { t.exports = 'remove'; }, function (t, e) {\n    t.exports = function (t, e, i) {\n      if (void 0 === i) {\n        return i = {\n          local: {\n            x: 0, y: 0, width: 0, height: 0,\n          },\n          global: {\n            x: 0, y: 0, width: 0, height: 0,\n          },\n          lines: {\n            shortest: 0, longest: 0, lengths: null, height: 0,\n          },\n          wrappedText: '',\n          words: [],\n          scaleX: 0,\n          scaleY: 0,\n        };\n      } let n; let s; let r; let o; let a; let h; let l; let u = t.text; let c = u.length; const d = t.maxWidth; const f = t.wordWrapCharCode; let p = Number.MAX_VALUE; let g = Number.MAX_VALUE; let v = 0; let m = 0; const y = t.fontData.chars; const x = t.fontData.lineHeight; const T = t.letterSpacing; let w = 0; let b = 0; let E = 0; let S = null; let _ = 0; const A = t.fontSize / t.fontData.size; const C = A * t.scaleX; const M = A * t.scaleY; let P = null; let O = 0; const R = []; let L = Number.MAX_VALUE; let k = 0; let D = 0; let F = 0; let I = []; let B = null; if (d > 0) {\n        for (X = 0; X < c; X++) {\n          (E = u.charCodeAt(X)) !== 10 ? (S = y[E]) && (P !== null && (n = S.kerning[O]), E === f ? B !== null && (I.push({\n            word: B.word, i: B.i, x: B.x * C, y: B.y * M, w: B.w * C, h: B.h * M, cr: !1,\n          }), B = null) : (B === null && (B = {\n            word: '', i: X, x: w, y: b, w: 0, h: x, cr: !1,\n          }), B.word = B.word.concat(u[X]), B.w += S.xOffset + S.xAdvance + (void 0 !== n ? n : 0)), w += S.xAdvance + T, P = S, O = E) : (B !== null && (I.push({\n            word: B.word, i: B.i, x: B.x * C, y: B.y * M, w: B.w * C, h: B.h * M, cr: !0,\n          }), B = null), w = 0, b += x, P = null);\n        }B !== null && I.push({\n          word: B.word, i: B.i, x: B.x * C, y: B.y * M, w: B.w * C, h: B.h * M, cr: !1,\n        }), P = null; for (var N = O = b = w = 0, Y = [], X = 0; X < I.length; X++) { var U; const z = I[X]; const G = z.x; const W = z.x + z.w; U && (N = G - (G - (U.x + U.w) + U.w), U = null), d < G - N || d < W - N ? (Y.push(z.i - 1), U = z.cr ? (Y.push(z.i + z.word.length), N = 0, null) : z) : z.cr && (Y.push(z.i + z.word.length), N = 0, U = null); } for (X = Y.length - 1; X >= 0; X--)s = u, r = Y[X], o = '\\n', u = s.substr(0, r) + o + s.substr(r + 1); c = (i.wrappedText = u).length, I = [], B = null;\n      } for (X = 0; X < c; X++) {\n        (E = u.charCodeAt(X)) !== 10 ? (S = y[E]) && (_ = w, P !== null && (_ += void 0 !== (a = S.kerning[O]) ? a : 0), _ < p && (p = _), b < g && (g = b), v < (h = _ + S.xAdvance) && (v = h), m < (l = b + x) && (m = l), E === f ? B !== null && (I.push({\n          word: B.word, i: B.i, x: B.x * C, y: B.y * M, w: B.w * C, h: B.h * M,\n        }), B = null) : (B === null && (B = {\n          word: '', i: X, x: w, y: b, w: 0, h: x,\n        }), B.word = B.word.concat(u[X]), B.w += S.xOffset + S.xAdvance + (void 0 !== a ? a : 0)), w += S.xAdvance + T, P = S, O = E, F = h * A) : (B !== null && (I.push({\n          word: B.word, i: B.i, x: B.x * C, y: B.y * M, w: B.w * C, h: B.h * M,\n        }), B = null), w = 0, b += x, P = null, k < (R[D] = F) && (k = F), F < L && (L = F), D++, F = 0);\n      }B !== null && I.push({\n        word: B.word, i: B.i, x: B.x * C, y: B.y * M, w: B.w * C, h: B.h * M,\n      }), k < (R[D] = F) && (k = F), F < L && (L = F); const V = i.local; const H = i.global; const j = i.lines; return V.x = p * A, V.y = g * A, V.width = v * A, V.height = m * A, H.x = t.x - t.displayOriginX + p * C, H.y = t.y - t.displayOriginY + g * M, H.width = v * C, H.height = m * M, j.shortest = L, j.longest = k, j.lengths = R, e && (V.x = Math.round(V.x), V.y = Math.round(V.y), V.width = Math.round(V.width), V.height = Math.round(V.height), H.x = Math.round(H.x), H.y = Math.round(H.y), H.width = Math.round(H.width), H.height = Math.round(H.height), j.shortest = Math.round(L), j.longest = Math.round(k)), i.words = I, i.lines.height = x, i.scaleX = t.scaleX, i.scaleY = t.scaleY, i;\n    };\n  }, function (t, e, i) { const u = i(187); t.exports = function (t, e, i, n, s, r, o) { const a = t.sys.textures.getFrame(i, n); const h = t.sys.cache.xml.get(s); if (a && h) { const l = u(h, r, o, a); return t.sys.cache.bitmapFont.add(e, { data: l, texture: i, frame: n }), !0; } return !1; }; }, function (t, e, i) { var n = i(1); var s = i(1); var n = i(948); var s = i(949); t.exports = { renderWebGL: n, renderCanvas: s }; }, function (t, e, i) { const at = i(9); t.exports = function (t, e, i, n, s) { let r = e._text; let o = r.length; if (o !== 0) { const a = this.pipeline; t.setPipeline(a, e); const h = a._tempMatrix1; const l = a._tempMatrix2; const u = a._tempMatrix3; l.applyITRS(e.x, e.y, e.rotation, e.scaleX, e.scaleY), h.copyFrom(n.matrix), s ? (h.multiplyWithOffset(s, -n.scrollX * e.scrollFactorX, -n.scrollY * e.scrollFactorY), l.e = e.x, l.f = e.y) : (l.e -= n.scrollX * e.scrollFactorX, l.f -= n.scrollY * e.scrollFactorY), h.multiply(l, u); const c = e.frame; const d = c.glTexture; const f = c.cutX; const p = c.cutY; const g = d.width; const v = d.height; const m = e._isTinted && e.tintFill; const y = at.getTintAppendFloatAlpha(e._tintTL, n.alpha * e._alphaTL); const x = at.getTintAppendFloatAlpha(e._tintTR, n.alpha * e._alphaTR); const T = at.getTintAppendFloatAlpha(e._tintBL, n.alpha * e._alphaBL); const w = at.getTintAppendFloatAlpha(e._tintBR, n.alpha * e._alphaBR); a.setTexture2D(d, 0); let b; let E; let S; let _; let A; let C; let M = 0; let P = 0; let O = 0; const R = e._letterSpacing; const L = e.fontData; const k = L.chars; const D = L.lineHeight; const F = e._fontSize / L.size; const I = e._align; let B = 0; let N = 0; const Y = e.getTextBounds(!1); e.maxWidth > 0 && (o = (r = Y.wrappedText).length); const X = e._bounds.lines; I === 1 ? N = (X.longest - X.lengths[0]) / 2 : I === 2 && (N = X.longest - X.lengths[0]); for (var U, z, G, W, V, H, j, q, K, J, Z, Q, $, tt, et, it, nt, st, rt = n.roundPixels, ot = 0; ot < o; ot++) { (b = r.charCodeAt(ot)) !== 10 ? (st = k[b]) && (E = f + st.x, S = p + st.y, _ = st.width, A = st.height, U = st.xOffset + M, z = st.yOffset + P, C !== null && (U += void 0 !== (G = st.kerning[O]) ? G : 0), M += st.xAdvance + R, C = st, O = b, _ !== 0 && A !== 0 && b !== 32 && (U *= F, z *= F, U -= e.displayOriginX, W = E / g, V = S / v, H = (E + _) / g, j = (S + A) / v, q = (U += N) + _ * F, K = (z -= e.displayOriginY) + A * F, J = u.getX(U, z), Z = u.getY(U, z), Q = u.getX(U, K), $ = u.getY(U, K), tt = u.getX(q, K), et = u.getY(q, K), it = u.getX(q, z), nt = u.getY(q, z), rt && (J = Math.round(J), Z = Math.round(Z), Q = Math.round(Q), $ = Math.round($), tt = Math.round(tt), et = Math.round(et), it = Math.round(it), nt = Math.round(nt)), a.batchQuad(J, Z, Q, $, tt, et, it, nt, W, V, H, j, y, x, T, w, m, d, 0))) : (B++, I === 1 ? N = (X.longest - X.lengths[B]) / 2 : I === 2 && (N = X.longest - X.lengths[B]), M = 0, P += D, C = null); } } }; }, function (t, e, i) { const I = i(28); t.exports = function (t, e, i, n, s) { let r = e._text; let o = r.length; const a = t.currentContext; if (o !== 0 && I(t, a, e, n, s)) { let h; const l = e.frame; const u = e.fontData.chars; const c = e.fontData.lineHeight; const d = e._letterSpacing; let f = 0; let p = 0; let g = null; let v = 0; let m = 0; let y = 0; let x = 0; let T = 0; let w = 0; let b = null; let E = 0; const S = e.frame.source.image; const _ = l.cutX; const A = l.cutY; const C = e._fontSize / e.fontData.size; const M = e._align; let P = 0; let O = 0; const R = e.getTextBounds(!1); e.maxWidth > 0 && (o = (r = R.wrappedText).length); const L = e._bounds.lines; M === 1 ? O = (L.longest - L.lengths[0]) / 2 : M === 2 && (O = L.longest - L.lengths[0]), a.translate(-e.displayOriginX, -e.displayOriginY); for (var k, D = n.roundPixels, F = 0; F < o; F++) { (h = r.charCodeAt(F)) !== 10 ? (g = u[h]) && (v = _ + g.x, m = A + g.y, y = g.width, x = g.height, T = g.xOffset + f, w = g.yOffset + p, b !== null && (T += void 0 !== (k = g.kerning[E]) ? k : 0), T *= C, w *= C, T += O, f += g.xAdvance + d, b = g, E = h, y !== 0 && x !== 0 && h !== 32 && (D && (T = Math.round(T), w = Math.round(w)), a.save(), a.translate(T, w), a.scale(C, C), a.drawImage(S, v, m, y, x, 0, 0, y, x), a.restore())) : (P++, M === 1 ? O = (L.longest - L.lengths[P]) / 2 : M === 2 && (O = L.longest - L.lengths[P]), f = 0, p += c, b = null); }a.restore(); } }; }, function (t, e, i) { var n = i(1); var s = i(1); var n = i(951); var s = i(952); t.exports = { renderWebGL: n, renderCanvas: s }; }, function (t, e, i) { const O = i(9); t.exports = function (t, e, i, n, s) { const r = e.getRenderList(); if (r.length !== 0) { const o = this.pipeline; t.setPipeline(o, e); let a = n.scrollX * e.scrollFactorX; let h = n.scrollY * e.scrollFactorY; const l = o._tempMatrix1; l.copyFrom(n.matrix), s && (l.multiplyWithOffset(s, -a, -h), h = a = 0); for (let u = e.x - a, c = e.y - h, d = -1, f = n.alpha * e.alpha, p = n.roundPixels, g = 0; g < r.length; g++) { var v; var m; var y; var x; var T; var w; var b; var E; var S; var _; var A; const C = r[g]; const M = C.frame; const P = C.alpha * f; P != 0 && (v = M.width, m = M.height, y = u + C.x + M.x, x = c + C.y + M.y, C.flipX && (v *= -1, y += M.width), C.flipY && (m *= -1, x += M.height), T = y + v, w = x + m, b = l.getX(y, x), E = l.getY(y, x), S = l.getX(T, w), _ = l.getY(T, w), A = O.getTintAppendFloatAlpha(C.tint, P), M.sourceIndex !== d && (o.setTexture2D(M.glTexture, 0), d = M.sourceIndex), p && (b = Math.round(b), E = Math.round(E), S = Math.round(S), _ = Math.round(_)), o.batchQuad(b, E, b, _, S, _, S, E, M.u0, M.v0, M.u1, M.v1, A, A, A, A, !1, M.glTexture, 0) && (d = -1)); } } }; }, function (t, e) { t.exports = function (t, e, i, n, s) { const r = e.getRenderList(); if (r.length !== 0) { const o = t.currentContext; const a = n.alpha * e.alpha; if (a != 0) { o.globalCompositeOperation = t.blendModes[e.blendMode], o.imageSmoothingEnabled = !(!t.antialias || e.frame.source.scaleMode); const h = e.x - n.scrollX * e.scrollFactorX; const l = e.y - n.scrollY * e.scrollFactorY; o.save(), s && s.copyToContext(o); for (let u = n.roundPixels, c = 0; c < r.length; c++) { const d = r[c]; const f = d.flipX || d.flipY; const p = d.frame; const g = p.canvasData; let v = p.x; let m = p.y; let y = 1; let x = 1; const T = d.alpha * a; T != 0 && (o.globalAlpha = T, f ? (d.flipX && (y = -1, v -= g.width), d.flipY && (x = -1, m -= g.height), o.save(), o.translate(d.x + h, d.y + l), o.scale(y, x), o.drawImage(p.source.image, g.x, g.y, g.width, g.height, v, m, g.width, g.height), o.restore()) : (u && (v = Math.round(v), m = Math.round(m)), o.drawImage(p.source.image, g.x, g.y, g.width, g.height, v + d.x + h, m + d.y + l, g.width, g.height))); }o.restore(); } } }; }, function (t, e, i) {\n    const n = i(0); const s = i(94); const r = new n({\n      initialize(t, e, i, n, s) { this.parent = t, this.x = e, this.y = i, this.frame = n, this.data = {}, this.tint = 16777215, this._visible = s, this._alpha = 1, this.flipX = !1, this.flipY = !1; }, setFrame(t) { return void 0 === t ? this.frame = this.parent.frame : t instanceof s && t.texture === this.parent.texture ? this.frame = t : this.frame = this.parent.texture.get(t), this; }, resetFlip() { return this.flipX = !1, this.flipY = !1, this; }, reset(t, e, i) { return this.x = t, this.y = e, this.flipX = !1, this.flipY = !1, this._alpha = 1, this._visible = !0, this.parent.dirty = !0, i && this.setFrame(i), this; }, setPosition(t, e) { return this.x = t, this.y = e, this; }, setFlipX(t) { return this.flipX = t, this; }, setFlipY(t) { return this.flipY = t, this; }, setFlip(t, e) { return this.flipX = t, this.flipY = e, this; }, setVisible(t) { return this.visible = t, this; }, setAlpha(t) { return this.alpha = t, this; }, setTint(t) { return this.tint = t, this; }, destroy() { this.parent.dirty = !0, this.parent.children.remove(this), this.parent = void 0, this.frame = void 0, this.data = void 0; }, visible: { get() { return this._visible; }, set(t) { this.parent.dirty |= this._visible !== t, this._visible = t; } }, alpha: { get() { return this._alpha; }, set(t) { this.parent.dirty |= this._alpha > 0 != t > 0, this._alpha = t; } },\n    }); t.exports = r;\n  }, function (t, e, i) { var n = i(1); var s = i(1); var n = i(955); var s = i(956); t.exports = { renderWebGL: n, renderCanvas: s }; }, function (t, e) { t.exports = function (t, e, i, n, s) { const r = e.list; if (r.length !== 0) { const o = e.localTransform; s ? (o.loadIdentity(), o.multiply(s), o.translate(e.x, e.y), o.rotate(e.rotation), o.scale(e.scaleX, e.scaleY)) : o.applyITRS(e.x, e.y, e.rotation, e.scaleX, e.scaleY); const a = e.blendMode !== -1; a || t.setBlendMode(0); for (let h = e.alpha, l = e.scrollFactorX, u = e.scrollFactorY, c = r, d = r.length, f = 0; f < d; f++) { var p; var g; var v; var m; var y; var x; var T; var w; const b = r[f]; b.willRender(n) && (m = void 0 !== b.alphaTopLeft ? (p = b.alphaTopLeft, g = b.alphaTopRight, v = b.alphaBottomLeft, b.alphaBottomRight) : v = g = p = b.alpha, y = b.scrollFactorX, x = b.scrollFactorY, a || b.blendMode === t.currentBlendMode || t.setBlendMode(b.blendMode), (T = b.mask) && T.preRenderWebGL(t, b, n), (w = b.type) !== t.currentType && (t.newType = !0, t.currentType = w), t.nextTypeMatch = f < d - 1 && c[f + 1].type === t.currentType, b.setScrollFactor(y * l, x * u), b.setAlpha(p * h, g * h, v * h, m * h), b.renderWebGL(t, b, i, n, o), b.setAlpha(p, g, v, m), b.setScrollFactor(y, x), T && T.postRenderWebGL(t, n), t.newType = !1); } } }; }, function (t, e) { t.exports = function (t, e, i, n, s) { const r = e.list; if (r.length !== 0) { const o = e.localTransform; s ? (o.loadIdentity(), o.multiply(s), o.translate(e.x, e.y), o.rotate(e.rotation), o.scale(e.scaleX, e.scaleY)) : o.applyITRS(e.x, e.y, e.rotation, e.scaleX, e.scaleY); const a = e.blendMode !== -1; a || t.setBlendMode(0); const h = e._alpha; const l = e.scrollFactorX; const u = e.scrollFactorY; e.mask && e.mask.preRenderCanvas(t, null, n); for (let c = 0; c < r.length; c++) { var d; var f; var p; const g = r[c]; g.willRender(n) && (d = g.alpha, f = g.scrollFactorX, p = g.scrollFactorY, a || g.blendMode === t.currentBlendMode || t.setBlendMode(g.blendMode), g.setScrollFactor(f * l, p * u), g.setAlpha(d * h), g.renderCanvas(t, g, i, n, o), g.setAlpha(d), g.setScrollFactor(f, p)); }e.mask && e.mask.postRenderCanvas(t); } }; }, function (t, e, i) { var n = i(1); var s = i(1); var n = i(396); var s = i(396); t.exports = { renderWebGL: n, renderCanvas: s }; }, function (t, e) { t.exports = ['normal', 'multiply', 'multiply', 'screen', 'overlay', 'darken', 'lighten', 'color-dodge', 'color-burn', 'hard-light', 'soft-light', 'difference', 'exclusion', 'hue', 'saturation', 'color', 'luminosity']; }, function (t, e, i) { var n = i(1); var s = i(1); var n = i(960); var s = i(961); t.exports = { renderWebGL: n, renderCanvas: s }; }, function (t, e, i) { const dt = i(9); t.exports = function (t, e, i, n, s) { const r = e.text; const o = r.length; if (o !== 0) { const a = this.pipeline; t.setPipeline(a, e); const h = e.cropWidth > 0 || e.cropHeight > 0; h && (a.flush(), t.pushScissor(e.x, e.y, e.cropWidth * e.scaleX, e.cropHeight * e.scaleY)); const l = a._tempMatrix1; const u = a._tempMatrix2; const c = a._tempMatrix3; const d = a._tempMatrix4; u.applyITRS(e.x, e.y, e.rotation, e.scaleX, e.scaleY), l.copyFrom(n.matrix), s ? (l.multiplyWithOffset(s, -n.scrollX * e.scrollFactorX, -n.scrollY * e.scrollFactorY), u.e = e.x, u.f = e.y) : (u.e -= n.scrollX * e.scrollFactorX, u.f -= n.scrollY * e.scrollFactorY), l.multiply(u, c); const f = e.frame; const p = f.glTexture; const g = f.cutX; const v = f.cutY; const m = p.width; const y = p.height; const x = e._isTinted && e.tintFill; let T = dt.getTintAppendFloatAlpha(e._tintTL, n.alpha * e._alphaTL); let w = dt.getTintAppendFloatAlpha(e._tintTR, n.alpha * e._alphaTR); let b = dt.getTintAppendFloatAlpha(e._tintBL, n.alpha * e._alphaBL); let E = dt.getTintAppendFloatAlpha(e._tintBR, n.alpha * e._alphaBR); a.setTexture2D(p, 0); let S; let _; let A; let C; let M; let P; let O = 0; let R = 0; let L = 0; const k = e.letterSpacing; const D = e.scrollX; const F = e.scrollY; const I = e.fontData; const B = I.chars; const N = I.lineHeight; let Y = e.fontSize / I.size; let X = 0; const U = e._align; let z = 0; let G = 0; e.getTextBounds(!1); const W = e._bounds.lines; U === 1 ? G = (W.longest - W.lengths[0]) / 2 : U === 2 && (G = W.longest - W.lengths[0]); for (var V, H, j, q, K, J, Z, Q, $, tt, et, it, nt, st, rt, ot, at, ht = n.roundPixels, lt = e.displayCallback, ut = e.callbackData, ct = 0; ct < o; ct++) { (S = r.charCodeAt(ct)) !== 10 ? (at = B[S]) && (_ = g + at.x, A = v + at.y, C = at.width, M = at.height, j = at.xOffset + O - D, q = at.yOffset + R - F, P !== null && (j += void 0 !== (V = at.kerning[L]) ? V : 0), O += at.xAdvance + k, P = at, L = S, C !== 0 && M !== 0 && S !== 32 && (Y = e.fontSize / e.fontData.size, X = 0, lt && (ut.color = 0, ut.tint.topLeft = T, ut.tint.topRight = w, ut.tint.bottomLeft = b, ut.tint.bottomRight = E, ut.index = ct, ut.charCode = S, ut.x = j, ut.y = q, ut.scale = Y, ut.rotation = X, ut.data = at.data, j = (H = lt(ut)).x, q = H.y, Y = H.scale, X = H.rotation, E = H.color ? (T = H.color, w = H.color, b = H.color, H.color) : (T = H.tint.topLeft, w = H.tint.topRight, b = H.tint.bottomLeft, H.tint.bottomRight), T = dt.getTintAppendFloatAlpha(T, n.alpha * e._alphaTL), w = dt.getTintAppendFloatAlpha(w, n.alpha * e._alphaTR), b = dt.getTintAppendFloatAlpha(b, n.alpha * e._alphaBL), E = dt.getTintAppendFloatAlpha(E, n.alpha * e._alphaBR)), j *= Y, q *= Y, j -= e.displayOriginX, q -= e.displayOriginY, j += G, d.applyITRS(j, q, X, Y, Y), c.multiply(d, u), K = _ / m, J = A / y, Z = (_ + C) / m, Q = (A + M) / y, $ = u.e, tt = u.f, et = M * u.c + u.e, it = M * u.d + u.f, nt = C * u.a + M * u.c + u.e, st = C * u.b + M * u.d + u.f, rt = C * u.a + u.e, ot = C * u.b + u.f, ht && ($ = Math.round($), tt = Math.round(tt), et = Math.round(et), it = Math.round(it), nt = Math.round(nt), st = Math.round(st), rt = Math.round(rt), ot = Math.round(ot)), a.batchQuad($, tt, et, it, nt, st, rt, ot, K, J, Z, Q, T, w, b, E, x, p, 0))) : (z++, U === 1 ? G = (W.longest - W.lengths[z]) / 2 : U === 2 && (G = W.longest - W.lengths[z]), O = 0, R += N, P = null); }h && (a.flush(), t.popScissor()); } }; }, function (t, e, i) { const X = i(28); t.exports = function (t, e, i, n, s) { const r = e._text; const o = r.length; const a = t.currentContext; if (o !== 0 && X(t, a, e, n, s)) { let h; const l = e.frame; const u = e.displayCallback; const c = e.callbackData; const d = e.fontData.chars; const f = e.fontData.lineHeight; const p = e._letterSpacing; let g = 0; let v = 0; let m = null; let y = 0; let x = 0; let T = 0; let w = 0; let b = 0; let E = 0; let S = null; let _ = 0; const A = e.frame.source.image; const C = l.cutX; const M = l.cutY; let P = 0; let O = 0; const R = e._fontSize / e.fontData.size; const L = e._align; let k = 0; let D = 0; e.getTextBounds(!1); const F = e._bounds.lines; L === 1 ? D = (F.longest - F.lengths[0]) / 2 : L === 2 && (D = F.longest - F.lengths[0]), a.translate(-e.displayOriginX, -e.displayOriginY); const I = n.roundPixels; e.cropWidth > 0 && e.cropHeight > 0 && (a.beginPath(), a.rect(0, 0, e.cropWidth, e.cropHeight), a.clip()); for (var B, N, Y = 0; Y < o; Y++) { O = R, P = 0, (h = r.charCodeAt(Y)) !== 10 ? (m = d[h]) && (y = C + m.x, x = M + m.y, T = m.width, w = m.height, b = m.xOffset + g - e.scrollX, E = m.yOffset + v - e.scrollY, S !== null && (b += void 0 !== (B = m.kerning[_]) ? B : 0), u && (c.index = Y, c.charCode = h, c.x = b, c.y = E, c.scale = O, c.rotation = P, c.data = m.data, b = (N = u(c)).x, E = N.y, O = N.scale, P = N.rotation), b *= O, E *= O, b += D, g += m.xAdvance + p, S = m, _ = h, T !== 0 && w !== 0 && h !== 32 && (I && (b = Math.round(b), E = Math.round(E)), a.save(), a.translate(b, E), a.rotate(P), a.scale(O, O), a.drawImage(A, y, x, T, w, 0, 0, T, w), a.restore())) : (k++, L === 1 ? D = (F.longest - F.lengths[k]) / 2 : L === 2 && (D = F.longest - F.lengths[k]), g = 0, v += f, S = null); }a.restore(); } }; }, function (t, e, i) { var n = i(1); var s = i(1); var n = i(963); var s = i(964); t.exports = { renderWebGL: n, renderCanvas: s }; }, function (t, e) { t.exports = function (t, e, i, n, s) { const r = t.currentPipeline; t.clearPipeline(); const o = t._tempMatrix1; const a = t._tempMatrix2; const h = t._tempMatrix3; a.applyITRS(e.x, e.y, e.rotation, e.scaleX, e.scaleY), o.copyFrom(n.matrix), s ? (o.multiplyWithOffset(s, -n.scrollX * e.scrollFactorX, -n.scrollY * e.scrollFactorY), a.e = e.x, a.f = e.y) : (a.e -= n.scrollX * e.scrollFactorX, a.f -= n.scrollY * e.scrollFactorY), o.multiply(a, h), e.render.call(e, t, n, h), t.rebindPipeline(r); }; }, function (t, e) {}, function (t, e, i) { var n = i(1); var s = i(1); var n = i(966); var s = i(401); s = i(401), t.exports = { renderWebGL: n, renderCanvas: s }; }, function (t, e, i) { function Y(t, e, i) { this.x = t, this.y = e, this.width = i; } function X(t, e, i) { this.points = [], this.pointsLength = 1, this.points[0] = new Y(t, e, i); } const U = i(192); const z = i(9); const G = []; t.exports = function (t, e, i, n, s) { if (e.commandBuffer.length !== 0) { const r = this.pipeline; t.setPipeline(r, e); const o = e._tempMatrix1; const a = e._tempMatrix2; const h = e._tempMatrix3; h.loadIdentity(), a.applyITRS(e.x, e.y, e.rotation, e.scaleX, e.scaleY), o.copyFrom(n.matrix), s ? (o.multiplyWithOffset(s, -n.scrollX * e.scrollFactorX, -n.scrollY * e.scrollFactorY), a.e = e.x, a.f = e.y) : (a.e -= n.scrollX * e.scrollFactorX, a.f -= n.scrollY * e.scrollFactorY), o.multiply(a); for (let l = e.commandBuffer, u = n.alpha * e.alpha, c = 1, d = r.fillTint, f = r.strokeTint, p = 0, g = 0, v = 0, m = 2 * Math.PI, y = [], x = 0, T = !1, w = null, b = z.getTintAppendFloatAlphaAndSwap, E = t.blankTexture.glTexture, S = 0; S < l.length; S++) switch (l[S]) { case U.BEGIN_PATH: y.length = 0, T = !(w = null); break; case U.CLOSE_PATH: T = !1, w && w.points.length && w.points.push(w.points[0]); break; case U.FILL_PATH: for (x = 0; x < y.length; x++)r.setTexture2D(E), r.batchFillPath(y[x].points, h, o); break; case U.STROKE_PATH: for (x = 0; x < y.length; x++)r.setTexture2D(E), r.batchStrokePath(y[x].points, c, T, h, o); break; case U.LINE_STYLE: c = l[++S]; var _ = b(l[++S], l[++S] * u); f.TL = _, f.TR = _, f.BL = _, f.BR = _; break; case U.FILL_STYLE: var A = b(l[++S], l[++S] * u); d.TL = A, d.TR = A, d.BL = A, d.BR = A; break; case U.GRADIENT_FILL_STYLE: var C = l[++S] * u; d.TL = b(l[++S], C), d.TR = b(l[++S], C), d.BL = b(l[++S], C), d.BR = b(l[++S], C); break; case U.GRADIENT_LINE_STYLE: c = l[++S]; var M = l[++S] * u; f.TL = b(l[++S], M), f.TR = b(l[++S], M), f.BL = b(l[++S], M), f.BR = b(l[++S], M); break; case U.ARC: var P = 0; var O = l[++S]; var R = l[++S]; var L = l[++S]; var k = l[++S]; var D = l[++S]; var F = l[++S]; var I = l[++S]; for (D -= k, F ? D < -m ? D = -m : D > 0 && (D = D % m - m) : m < D ? D = m : D < 0 && (D = m + D % m), w === null && (w = new X(O + Math.cos(k) * L, R + Math.sin(k) * L, c), y.push(w), P += 0.01); P < 1 + I;)v = D * P + k, p = O + Math.cos(v) * L, g = R + Math.sin(v) * L, w.points.push(new Y(p, g, c)), P += 0.01; v = D + k, p = O + Math.cos(v) * L, g = R + Math.sin(v) * L, w.points.push(new Y(p, g, c)); break; case U.FILL_RECT: r.setTexture2D(E), r.batchFillRect(l[++S], l[++S], l[++S], l[++S], h, o); break; case U.FILL_TRIANGLE: r.setTexture2D(E), r.batchFillTriangle(l[++S], l[++S], l[++S], l[++S], l[++S], l[++S], h, o); break; case U.STROKE_TRIANGLE: r.setTexture2D(E), r.batchStrokeTriangle(l[++S], l[++S], l[++S], l[++S], l[++S], l[++S], c, h, o); break; case U.LINE_TO: w !== null ? w.points.push(new Y(l[++S], l[++S], c)) : (w = new X(l[++S], l[++S], c), y.push(w)); break; case U.MOVE_TO: w = new X(l[++S], l[++S], c), y.push(w); break; case U.SAVE: G.push(h.copyToArray()); break; case U.RESTORE: h.copyFromArray(G.pop()); break; case U.TRANSLATE: O = l[++S], R = l[++S], h.translate(O, R); break; case U.SCALE: O = l[++S], R = l[++S], h.scale(O, R); break; case U.ROTATE: h.rotate(l[++S]); break; case U.SET_TEXTURE: var B = l[++S]; var N = l[++S]; r.currentFrame = B, r.setTexture2D(B.glTexture, 0), r.tintEffect = N, E = B.glTexture; break; case U.CLEAR_TEXTURE: r.currentFrame = t.blankTexture, r.tintEffect = 2, E = t.blankTexture.glTexture; } } }; }, function (t, e, i) { var n = i(1); var s = i(1); var n = i(968); var s = i(969); t.exports = { renderWebGL: n, renderCanvas: s }; }, function (t, e) { t.exports = function (t, e, i, n, s) { this.pipeline.batchSprite(e, n, s); }; }, function (t, e) { t.exports = function (t, e, i, n, s) { t.batchSprite(e, e.frame, n, s); }; }, function (t, e, i) { var n = i(1); var s = i(1); var n = i(971); var s = i(972); t.exports = { renderWebGL: n, renderCanvas: s }; }, function (t, e) { t.exports = function (t, e, i, n, s) { this.pipeline.batchSprite(e, n, s); }; }, function (t, e) { t.exports = function (t, e, i, n, s) { t.batchSprite(e, e.frame, n, s); }; }, function (t, e, i) {\n    t.exports = {\n      GravityWell: i(402), Particle: i(403), ParticleEmitter: i(404), ParticleEmitterManager: i(194), Zones: i(978),\n    };\n  }, function (t, e, i) {\n    const n = i(0); const s = i(119); const r = i(69); const o = i(2); const a = i(58); const h = new n({\n      initialize(t, e, i, n) { void 0 === n && (n = !1), this.propertyKey = e, this.propertyValue = i, this.defaultValue = i, this.steps = 0, this.counter = 0, this.start = 0, this.end = 0, this.ease, this.emitOnly = n, this.onEmit = this.defaultEmit, this.onUpdate = this.defaultUpdate, this.loadConfig(t); }, loadConfig(t, e) { void 0 === t && (t = {}), e && (this.propertyKey = e), this.propertyValue = o(t, this.propertyKey, this.defaultValue), this.setMethods(), this.emitOnly && (this.onUpdate = this.defaultUpdate); }, toJSON() { return this.propertyValue; }, onChange(t) { return this.propertyValue = t, this.setMethods(); }, setMethods() { let t; let e; let i; const n = this.propertyValue; const s = typeof n; return s == 'number' ? (this.onEmit = this.staticValueEmit, this.onUpdate = this.staticValueUpdate) : Array.isArray(n) ? this.onEmit = this.randomStaticValueEmit : s == 'function' ? this.emitOnly ? this.onEmit = n : this.onUpdate = n : s == 'object' && (this.has(n, 'random') || this.hasBoth(n, 'start', 'end') || this.hasBoth(n, 'min', 'max')) ? (this.start = this.has(n, 'start') ? n.start : n.min, this.end = this.has(n, 'end') ? n.end : n.max, (t = this.hasBoth(n, 'min', 'max') || !!n.random) && (e = n.random, Array.isArray(e) && (this.start = e[0], this.end = e[1]), this.onEmit = this.randomRangedValueEmit), this.has(n, 'steps') ? (this.steps = n.steps, this.counter = this.start, this.onEmit = this.steppedEmit) : (i = this.has(n, 'ease') ? n.ease : 'Linear', this.ease = r(i), t || (this.onEmit = this.easedValueEmit), this.onUpdate = this.easeValueUpdate)) : s == 'object' && this.hasEither(n, 'onEmit', 'onUpdate') && (this.has(n, 'onEmit') && (this.onEmit = n.onEmit), this.has(n, 'onUpdate') && (this.onUpdate = n.onUpdate)), this; }, has(t, e) { return t.hasOwnProperty(e); }, hasBoth(t, e, i) { return t.hasOwnProperty(e) && t.hasOwnProperty(i); }, hasEither(t, e, i) { return t.hasOwnProperty(e) || t.hasOwnProperty(i); }, defaultEmit(t, e, i) { return i; }, defaultUpdate(t, e, i, n) { return n; }, staticValueEmit() { return this.propertyValue; }, staticValueUpdate() { return this.propertyValue; }, randomStaticValueEmit() { const t = Math.floor(Math.random() * this.propertyValue.length); return this.propertyValue[t]; }, randomRangedValueEmit(t, e) { const i = s(this.start, this.end); return t && t.data[e] && (t.data[e].min = i), i; }, steppedEmit() { const t = this.counter; const e = this.counter + (this.end - this.start) / this.steps; return this.counter = a(e, this.start, this.end), t; }, easedValueEmit(t, e) { let i; return t && t.data[e] && ((i = t.data[e]).min = this.start, i.max = this.end), this.start; }, easeValueUpdate(t, e, i) { const n = t.data[e]; return (n.max - n.min) * this.ease(i) + n.min; },\n    }); t.exports = h;\n  }, function (t, e, i) { var n = i(1); var s = i(1); var n = i(976); var s = i(977); t.exports = { renderWebGL: n, renderCanvas: s }; }, function (t, e, i) { const N = i(9); t.exports = function (t, e, i, n, s) { const r = e.emitters.list; const o = r.length; if (o !== 0) { const a = this.pipeline; const h = a._tempMatrix1.copyFrom(n.matrix); const l = a._tempMatrix2; const u = a._tempMatrix3; const c = a._tempMatrix4.applyITRS(e.x, e.y, e.rotation, e.scaleX, e.scaleY); h.multiply(c), t.setPipeline(a); const d = n.roundPixels; const f = e.defaultFrame.glTexture; const p = N.getTintAppendFloatAlphaAndSwap; a.setTexture2D(f, 0); for (let g = 0; g < o; g++) { const v = r[g]; const m = v.alive; const y = m.length; if (v.visible && y !== 0) { let x = n.scrollX * v.scrollFactorX; let T = n.scrollY * v.scrollFactorY; s && (h.multiplyWithOffset(s, -x, -T), T = x = 0), t.setBlendMode(v.blendMode) && a.setTexture2D(f, 0), v.mask && (v.mask.preRenderWebGL(t, v, n), a.setTexture2D(f, 0)); for (let w = 0; w < y; w++) { var b; var E; var S; var _; var A; var C; var M; var P; var O; var R; var L; var k; var D; var F; const I = m[w]; const B = I.alpha * n.alpha; B <= 0 || (E = -(b = I.frame).halfWidth, S = -b.halfHeight, _ = E + b.width, A = S + b.height, u.applyITRS(0, 0, I.rotation, I.scaleX, I.scaleY), u.e = I.x - x, u.f = I.y - T, h.multiply(u, l), C = l.getX(E, S), M = l.getY(E, S), P = l.getX(E, A), O = l.getY(E, A), R = l.getX(_, A), L = l.getY(_, A), k = l.getX(_, S), D = l.getY(_, S), d && (C = Math.round(C), M = Math.round(M), P = Math.round(P), O = Math.round(O), R = Math.round(R), L = Math.round(L), k = Math.round(k), D = Math.round(D)), F = p(I.tint, B), a.batchQuad(C, M, P, O, R, L, k, D, b.u0, b.v0, b.u1, b.v1, F, F, F, F, 0, f, 0)); }v.mask && (v.mask.postRenderWebGL(t, n), a.setTexture2D(f, 0)); } } } }; }, function (t, e) { t.exports = function (t, e, i, n, s) { const r = e.emitters.list; const o = r.length; if (o !== 0) { const a = t._tempMatrix1.copyFrom(n.matrix); const h = t._tempMatrix2; const l = t._tempMatrix3; const u = t._tempMatrix4.applyITRS(e.x, e.y, e.rotation, e.scaleX, e.scaleY); a.multiply(u); const c = n.roundPixels; const d = t.currentContext; d.save(); for (let f = 0; f < o; f++) { const p = r[f]; const g = p.alive; const v = g.length; if (p.visible && v !== 0) { let m = n.scrollX * p.scrollFactorX; let y = n.scrollY * p.scrollFactorY; s && (a.multiplyWithOffset(s, -m, -y), y = m = 0), d.globalCompositeOperation = t.blendModes[p.blendMode]; for (let x = 0; x < v; x++) { var T; var w; var b; var E; const S = g[x]; const _ = S.alpha * n.alpha; _ <= 0 || (w = (T = S.frame).canvasData, b = -T.halfWidth, E = -T.halfHeight, l.applyITRS(0, 0, S.rotation, S.scaleX, S.scaleY), l.e = S.x - m, l.f = S.y - y, a.multiply(l, h), d.globalAlpha = _, d.save(), h.copyToContext(d), c && (b = Math.round(b), E = Math.round(E)), d.imageSmoothingEnabled = !(!t.antialias || T.source.scaleMode), d.drawImage(T.source.image, w.x, w.y, w.width, w.height, b, E, w.width, w.height), d.restore()); } } }d.restore(); } }; }, function (t, e, i) { t.exports = { DeathZone: i(405), EdgeZone: i(406), RandomZone: i(408) }; }, function (t, e, i) { var n = i(1); var s = i(1); var n = i(980); var s = i(981); t.exports = { renderWebGL: n, renderCanvas: s }; }, function (t, e, i) { const l = i(9); t.exports = function (t, e, i, n, s) { const r = e.frame; const o = r.width; const a = r.height; const h = l.getTintAppendFloatAlpha; this.pipeline.batchTexture(e, r.glTexture, o, a, e.x, e.y, o, a, e.scaleX, e.scaleY, e.rotation, e.flipX, !e.flipY, e.scrollFactorX, e.scrollFactorY, e.displayOriginX, e.displayOriginY, 0, 0, o, a, h(e._tintTL, n.alpha * e._alphaTL), h(e._tintTR, n.alpha * e._alphaTR), h(e._tintBL, n.alpha * e._alphaBL), h(e._tintBR, n.alpha * e._alphaBR), e._isTinted && e.tintFill, 0, 0, n, s), t.setBlankTexture(!0); }; }, function (t, e) { t.exports = function (t, e, i, n, s) { t.batchSprite(e, e.frame, n, s); }; }, function (t, e, i) { const n = i(983); var s = i(18)(!1, s = { Parse: i(984) }, n); t.exports = s; }, function (t, e) {\n    t.exports = {\n      TEXT_SET1: \" !\\\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\", TEXT_SET2: \" !\\\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ\", TEXT_SET3: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 ', TEXT_SET4: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ 0123456789', TEXT_SET5: \"ABCDEFGHIJKLMNOPQRSTUVWXYZ.,/() '!?-*:0123456789\", TEXT_SET6: \"ABCDEFGHIJKLMNOPQRSTUVWXYZ!?:;0123456789\\\"(),-.' \", TEXT_SET7: \"AGMSY+:4BHNTZ!;5CIOU.?06DJPV,(17EKQW\\\")28FLRX-'39\", TEXT_SET8: '0123456789 .ABCDEFGHIJKLMNOPQRSTUVWXYZ', TEXT_SET9: \"ABCDEFGHIJKLMNOPQRSTUVWXYZ()-0123456789.:,'\\\"?!\", TEXT_SET10: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ', TEXT_SET11: \"ABCDEFGHIJKLMNOPQRSTUVWXYZ.,\\\"-+!?()':;0123456789\",\n    };\n  }, function (t, e, i) {\n    const T = i(6); t.exports = function (t, e) {\n      const i = e.width; const n = e.height; const s = Math.floor(i / 2); const r = Math.floor(n / 2); const o = T(e, 'chars', ''); if (o !== '') {\n        const a = T(e, 'image', ''); const h = T(e, 'offset.x', 0); const l = T(e, 'offset.y', 0); const u = T(e, 'spacing.x', 0); const c = T(e, 'spacing.y', 0); const d = T(e, 'lineSpacing', 0); let f = T(e, 'charsPerRow', null); f === null && (f = t.sys.textures.getFrame(a).width / i) > o.length && (f = o.length); for (var p = h, g = l, v = {\n            retroFont: !0, font: a, size: i, lineHeight: n + d, chars: {},\n          }, m = 0, y = 0; y < o.length; y++) {\n          const x = o.charCodeAt(y); v.chars[x] = {\n            x: p, y: g, width: i, height: n, centerX: s, centerY: r, xOffset: 0, yOffset: 0, xAdvance: i, data: {}, kerning: {},\n          }, ++m === f ? (m = 0, p = h, g += n + c) : p += i + u;\n        } return { data: v, frame: null, texture: a };\n      }\n    };\n  }, function (t, e, i) { var n = i(1); var s = i(1); var n = i(986); var s = i(987); t.exports = { renderWebGL: n, renderCanvas: s }; }, function (t, e, i) { const R = i(9); t.exports = function (t, e, i, n, s) { const r = e.pipeline; t.setPipeline(r, e); const o = r._tempMatrix1; const a = r._tempMatrix2; const h = r._tempMatrix3; a.applyITRS(e.x, e.y, e.rotation, e.scaleX, e.scaleY), o.copyFrom(n.matrix), s ? (o.multiplyWithOffset(s, -n.scrollX * e.scrollFactorX, -n.scrollY * e.scrollFactorY), a.e = e.x, a.f = e.y) : (a.e -= n.scrollX * e.scrollFactorX, a.f -= n.scrollY * e.scrollFactorY), o.multiply(a, h); const l = e.frame.glTexture; const u = e.vertices; const c = e.uv; const d = e.colors; const f = e.alphas; const p = e.alpha; const g = R.getTintAppendFloatAlphaAndSwap; const v = n.roundPixels; const m = u.length; const y = Math.floor(0.5 * m); r.flush(), r.setTexture2D(l, 0); const x = r.vertexViewF32; const T = r.vertexViewU32; let w = r.vertexCount * r.vertexComponentCount - 1; let b = 0; const E = e.tintFill; e.dirty && e.updateVertices(); for (var S = e.debugCallback, _ = [], A = 0; A < m; A += 2) { const C = u[A + 0]; const M = u[A + 1]; let P = C * h.a + M * h.c + h.e; let O = C * h.b + M * h.d + h.f; v && (P = Math.round(P), O = Math.round(O)), x[++w] = P, x[++w] = O, x[++w] = c[A + 0], x[++w] = c[A + 1], x[++w] = E, T[++w] = g(d[b], n.alpha * (f[b] * p)), b++, S && (_[A + 0] = P, _[A + 1] = O); }S && S.call(e, e, m, _), r.vertexCount += y; }; }, function (t, e) { t.exports = function () {}; }, function (t, e) {\n    t.exports = function (t, e, i) {\n      const n = t.canvas; const s = t.context; const r = t.style; const o = []; let a = 0; let h = i.length; r.maxLines > 0 && r.maxLines < i.length && (h = r.maxLines), r.syncFont(n, s); for (let l = 0; l < h; l++) { let u = r.strokeThickness; u += s.measureText(i[l]).width, r.wordWrap && (u -= s.measureText(' ').width), o[l] = Math.ceil(u), a = Math.max(a, o[l]); } const c = e.fontSize + r.strokeThickness; let d = c * h; const f = t.lineSpacing; return h > 1 && (d += f * (h - 1)), {\n        width: a, height: d, lines: h, lineWidths: o, lineSpacing: f, lineHeight: c,\n      };\n    };\n  }, function (t, e, i) { var n = i(1); var s = i(1); var n = i(990); var s = i(991); t.exports = { renderWebGL: n, renderCanvas: s }; }, function (t, e, i) { const l = i(9); t.exports = function (t, e, i, n, s) { let r; let o; let a; let h; e.width !== 0 && e.height !== 0 && (o = (r = e.frame).width, a = r.height, h = l.getTintAppendFloatAlpha, this.pipeline.batchTexture(e, r.glTexture, o, a, e.x, e.y, o / e.style.resolution, a / e.style.resolution, e.scaleX, e.scaleY, e.rotation, e.flipX, e.flipY, e.scrollFactorX, e.scrollFactorY, e.displayOriginX, e.displayOriginY, 0, 0, o, a, h(e._tintTL, n.alpha * e._alphaTL), h(e._tintTR, n.alpha * e._alphaTR), h(e._tintBL, n.alpha * e._alphaBL), h(e._tintBR, n.alpha * e._alphaBR), e._isTinted && e.tintFill, 0, 0, n, s)); }; }, function (t, e) { t.exports = function (t, e, i, n, s) { e.width !== 0 && e.height !== 0 && t.batchSprite(e, e.frame, n, s); }; }, function (t, e, i) {\n    const n = i(0); const a = i(15); const h = i(6); const s = i(993); const l = {\n      fontFamily: ['fontFamily', 'Courier'], fontSize: ['fontSize', '16px'], fontStyle: ['fontStyle', ''], backgroundColor: ['backgroundColor', null], color: ['color', '#fff'], stroke: ['stroke', '#fff'], strokeThickness: ['strokeThickness', 0], shadowOffsetX: ['shadow.offsetX', 0], shadowOffsetY: ['shadow.offsetY', 0], shadowColor: ['shadow.color', '#000'], shadowBlur: ['shadow.blur', 0], shadowStroke: ['shadow.stroke', !1], shadowFill: ['shadow.fill', !1], align: ['align', 'left'], maxLines: ['maxLines', 0], fixedWidth: ['fixedWidth', 0], fixedHeight: ['fixedHeight', 0], resolution: ['resolution', 0], rtl: ['rtl', !1], testString: ['testString', '|MÃ‰qgy'], baselineX: ['baselineX', 1.2], baselineY: ['baselineY', 1.4], wordWrapWidth: ['wordWrap.width', null], wordWrapCallback: ['wordWrap.callback', null], wordWrapCallbackScope: ['wordWrap.callbackScope', null], wordWrapUseAdvanced: ['wordWrap.useAdvancedWrap', !1],\n    }; const r = new n({\n      initialize(t, e) { this.parent = t, this.fontFamily, this.fontSize, this.fontStyle, this.backgroundColor, this.color, this.stroke, this.strokeThickness, this.shadowOffsetX, this.shadowOffsetY, this.shadowColor, this.shadowBlur, this.shadowStroke, this.shadowFill, this.align, this.maxLines, this.fixedWidth, this.fixedHeight, this.resolution, this.rtl, this.testString, this.baselineX, this.baselineY, this.wordWrapWidth, this.wordWrapCallback, this.wordWrapCallbackScope, this.wordWrapUseAdvanced, this._font, this.setStyle(e, !1, !0); const i = h(e, 'metrics', !1); this.metrics = i ? { ascent: h(i, 'ascent', 0), descent: h(i, 'descent', 0), fontSize: h(i, 'fontSize', 0) } : s(this); }, setStyle(t, e, i) { for (const n in void 0 === e && (e = !0), void 0 === i && (i = !1), t && t.hasOwnProperty('fontSize') && typeof t.fontSize === 'number' && (t.fontSize = `${t.fontSize.toString()}px`), l) { const s = i ? l[n][1] : this[n]; this[n] = (n === 'wordWrapCallback' || n === 'wordWrapCallbackScope' ? h : a)(t, l[n][0], s); } const r = h(t, 'font', null); r !== null && this.setFont(r, !1), this._font = [this.fontStyle, this.fontSize, this.fontFamily].join(' ').trim(); const o = h(t, 'fill', null); return o !== null && (this.color = o), e ? this.update(!0) : this.parent; }, syncFont(t, e) { e.font = this._font; }, syncStyle(t, e) { e.textBaseline = 'alphabetic', e.fillStyle = this.color, e.strokeStyle = this.stroke, e.lineWidth = this.strokeThickness, e.lineCap = 'round', e.lineJoin = 'round'; }, syncShadow(t, e) { e ? (t.shadowOffsetX = this.shadowOffsetX, t.shadowOffsetY = this.shadowOffsetY, t.shadowColor = this.shadowColor, t.shadowBlur = this.shadowBlur) : (t.shadowOffsetX = 0, t.shadowOffsetY = 0, t.shadowColor = 0, t.shadowBlur = 0); }, update(t) { return t && (this._font = [this.fontStyle, this.fontSize, this.fontFamily].join(' ').trim(), this.metrics = s(this)), this.parent.updateText(); }, setFont(t, e) { void 0 === e && (e = !0); let i; let n; let s = t; let r = ''; let o = ''; return typeof t !== 'string' ? (s = h(t, 'fontFamily', 'Courier'), r = h(t, 'fontSize', '16px'), o = h(t, 'fontStyle', '')) : (n = 0, o = (i = t.split(' ')).length > 2 ? i[n++] : '', r = i[n++] || '16px', s = i[n++] || 'Courier'), s === this.fontFamily && r === this.fontSize && o === this.fontStyle || (this.fontFamily = s, this.fontSize = r, this.fontStyle = o, e && this.update(!0)), this.parent; }, setFontFamily(t) { return this.fontFamily !== t && (this.fontFamily = t, this.update(!0)), this.parent; }, setFontStyle(t) { return this.fontStyle !== t && (this.fontStyle = t, this.update(!0)), this.parent; }, setFontSize(t) { return typeof t === 'number' && (t = `${t.toString()}px`), this.fontSize !== t && (this.fontSize = t, this.update(!0)), this.parent; }, setTestString(t) { return this.testString = t, this.update(!0); }, setFixedSize(t, e) { return this.fixedWidth = t, this.fixedHeight = e, t && (this.parent.width = t), e && (this.parent.height = e), this.update(!1); }, setBackgroundColor(t) { return this.backgroundColor = t, this.update(!1); }, setFill(t) { return this.color = t, this.update(!1); }, setColor(t) { return this.color = t, this.update(!1); }, setResolution(t) { return this.resolution = t, this.update(!1); }, setStroke(t, e) { return void 0 === e && (e = this.strokeThickness), void 0 === t && this.strokeThickness !== 0 ? (this.strokeThickness = 0, this.update(!0)) : this.stroke === t && this.strokeThickness === e || (this.stroke = t, this.strokeThickness = e, this.update(!0)), this.parent; }, setShadow(t, e, i, n, s, r) { return void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = '#000'), void 0 === n && (n = 0), void 0 === s && (s = !1), void 0 === r && (r = !0), this.shadowOffsetX = t, this.shadowOffsetY = e, this.shadowColor = i, this.shadowBlur = n, this.shadowStroke = s, this.shadowFill = r, this.update(!1); }, setShadowOffset(t, e) { return void 0 === t && (t = 0), void 0 === e && (e = t), this.shadowOffsetX = t, this.shadowOffsetY = e, this.update(!1); }, setShadowColor(t) { return void 0 === t && (t = '#000'), this.shadowColor = t, this.update(!1); }, setShadowBlur(t) { return void 0 === t && (t = 0), this.shadowBlur = t, this.update(!1); }, setShadowStroke(t) { return this.shadowStroke = t, this.update(!1); }, setShadowFill(t) { return this.shadowFill = t, this.update(!1); }, setWordWrapWidth(t, e) { return void 0 === e && (e = !1), this.wordWrapWidth = t, this.wordWrapUseAdvanced = e, this.update(!1); }, setWordWrapCallback(t, e) { return void 0 === e && (e = null), this.wordWrapCallback = t, this.wordWrapCallbackScope = e, this.update(!1); }, setAlign(t) { return void 0 === t && (t = 'left'), this.align = t, this.update(!1); }, setMaxLines(t) { return void 0 === t && (t = 0), this.maxLines = t, this.update(!1); }, getTextMetrics() { const t = this.metrics; return { ascent: t.ascent, descent: t.descent, fontSize: t.fontSize }; }, toJSON() { const t = {}; for (const e in l)t[e] = this[e]; return t.metrics = this.getTextMetrics(), t; }, destroy() { this.parent = void 0; },\n    }); t.exports = r;\n  }, function (t, e, i) { const p = i(26); t.exports = function (t) { const e = p.create(this); const i = e.getContext('2d'); t.syncFont(e, i); const n = Math.ceil(i.measureText(t.testString).width * t.baselineX); const s = 2 * (r = n); var r = r * t.baselineY | 0; e.width = n, e.height = s, i.fillStyle = '#f00', i.fillRect(0, 0, n, s), i.font = t._font, i.textBaseline = 'alphabetic', i.fillStyle = '#000', i.fillText(t.testString, 0, r); const o = { ascent: 0, descent: 0, fontSize: 0 }; if (!i.getImageData(0, 0, n, s)) return o.ascent = r, o.descent = 6 + r, o.fontSize = o.ascent + o.descent, p.remove(e), o; for (var a, h = i.getImageData(0, 0, n, s).data, l = h.length, u = 4 * n, c = 0, d = !1, f = 0; f < r; f++) { for (a = 0; a < u; a += 4) if (h[c + a] !== 255) { d = !0; break; } if (d) break; c += u; } for (o.ascent = r - f, c = l - u, d = !1, f = s; r < f; f--) { for (a = 0; a < u; a += 4) if (h[c + a] !== 255) { d = !0; break; } if (d) break; c -= u; } return o.descent = f - r, o.fontSize = o.ascent + o.descent, p.remove(e), o; }; }, function (t, e, i) { var n = i(1); var s = i(1); var n = i(995); var s = i(996); t.exports = { renderWebGL: n, renderCanvas: s }; }, function (t, e, i) { const o = i(9); t.exports = function (t, e, i, n, s) { e.updateCanvas(); const r = o.getTintAppendFloatAlpha; this.pipeline.batchTexture(e, e.fillPattern, e.displayFrame.width * e.tileScaleX, e.displayFrame.height * e.tileScaleY, e.x, e.y, e.width, e.height, e.scaleX, e.scaleY, e.rotation, e.flipX, e.flipY, e.scrollFactorX, e.scrollFactorY, e.originX * e.width, e.originY * e.height, 0, 0, e.width, e.height, r(e._tintTL, n.alpha * e._alphaTL), r(e._tintTR, n.alpha * e._alphaTR), r(e._tintBL, n.alpha * e._alphaBL), r(e._tintBR, n.alpha * e._alphaBR), e._isTinted && e.tintFill, e.tilePositionX % e.displayFrame.width / e.displayFrame.width, e.tilePositionY % e.displayFrame.height / e.displayFrame.height, n, s); }; }, function (t, e) { t.exports = function (t, e, i, n, s) { e.updateCanvas(), t.batchSprite(e, e.frame, n, s); }; }, function (t, e, i) { var n = i(1); var s = i(1); var n = i(998); var s = i(999); t.exports = { renderWebGL: n, renderCanvas: s }; }, function (t, e) { t.exports = function (t, e, i, n, s) { e.videoTexture && this.pipeline.batchSprite(e, n, s); }; }, function (t, e) { t.exports = function (t, e, i, n, s) { e.videoTexture && t.batchSprite(e, e.frame, n, s); }; }, function (t, e, i) { var n = i(1); var s = i(1); var n = i(1001); var s = i(1002); t.exports = { renderWebGL: n, renderCanvas: s }; }, function (t, e, i) { const d = i(98); const f = i(70); t.exports = function (t, e, i, n, s) { const r = this.pipeline; const o = r._tempMatrix1; const a = r._tempMatrix2; const h = r._tempMatrix3; t.setPipeline(r), a.applyITRS(e.x, e.y, e.rotation, e.scaleX, e.scaleY), o.copyFrom(n.matrix), s ? (o.multiplyWithOffset(s, -n.scrollX * e.scrollFactorX, -n.scrollY * e.scrollFactorY), a.e = e.x, a.f = e.y) : (a.e -= n.scrollX * e.scrollFactorX, a.f -= n.scrollY * e.scrollFactorY), o.multiply(a, h); const l = e._displayOriginX; const u = e._displayOriginY; const c = n.alpha * e.alpha; e.isFilled && d(r, h, e, c, l, u), e.isStroked && f(r, e, c, l, u); }; }, function (t, e, i) { const a = i(39); const h = i(41); const l = i(49); const u = i(28); t.exports = function (t, e, i, n, s) { let r; const o = t.currentContext; u(t, o, e, n, s) && (r = e.radius, o.beginPath(), o.arc(r - e.originX * (2 * r), r - e.originY * (2 * r), r, a(e._startAngle), a(e._endAngle), e.anticlockwise), e.closePath && o.closePath(), e.isFilled && (h(o, e), o.fill()), e.isStroked && (l(o, e), o.stroke()), o.restore()); }; }, function (t, e, i) { var n = i(1); var s = i(1); var n = i(1004); var s = i(1005); t.exports = { renderWebGL: n, renderCanvas: s }; }, function (t, e, i) { const d = i(98); const f = i(70); t.exports = function (t, e, i, n, s) { const r = this.pipeline; const o = r._tempMatrix1; const a = r._tempMatrix2; const h = r._tempMatrix3; t.setPipeline(r), a.applyITRS(e.x, e.y, e.rotation, e.scaleX, e.scaleY), o.copyFrom(n.matrix), s ? (o.multiplyWithOffset(s, -n.scrollX * e.scrollFactorX, -n.scrollY * e.scrollFactorY), a.e = e.x, a.f = e.y) : (a.e -= n.scrollX * e.scrollFactorX, a.f -= n.scrollY * e.scrollFactorY), o.multiply(a, h); const l = e._displayOriginX + e._curveBounds.x; const u = e._displayOriginY + e._curveBounds.y; const c = n.alpha * e.alpha; e.isFilled && d(r, h, e, c, l, u), e.isStroked && f(r, e, c, l, u); }; }, function (t, e, i) { const g = i(41); const v = i(49); const m = i(28); t.exports = function (t, e, i, n, s) { const r = t.currentContext; if (m(t, r, e, n, s)) { const o = e._displayOriginX + e._curveBounds.x; const a = e._displayOriginY + e._curveBounds.y; const h = e.pathData; let l = h.length - 1; const u = h[0] - o; const c = h[1] - a; r.beginPath(), r.moveTo(u, c), e.closePath || (l -= 2); for (let d = 2; d < l; d += 2) { const f = h[d] - o; const p = h[d + 1] - a; r.lineTo(f, p); }e.closePath && r.closePath(), e.isFilled && (g(r, e), r.fill()), e.isStroked && (v(r, e), r.stroke()), r.restore(); } }; }, function (t, e, i) { var n = i(1); var s = i(1); var n = i(1007); var s = i(1008); t.exports = { renderWebGL: n, renderCanvas: s }; }, function (t, e, i) { const d = i(98); const f = i(70); t.exports = function (t, e, i, n, s) { const r = this.pipeline; const o = r._tempMatrix1; const a = r._tempMatrix2; const h = r._tempMatrix3; t.setPipeline(r), a.applyITRS(e.x, e.y, e.rotation, e.scaleX, e.scaleY), o.copyFrom(n.matrix), s ? (o.multiplyWithOffset(s, -n.scrollX * e.scrollFactorX, -n.scrollY * e.scrollFactorY), a.e = e.x, a.f = e.y) : (a.e -= n.scrollX * e.scrollFactorX, a.f -= n.scrollY * e.scrollFactorY), o.multiply(a, h); const l = e._displayOriginX; const u = e._displayOriginY; const c = n.alpha * e.alpha; e.isFilled && d(r, h, e, c, l, u), e.isStroked && f(r, e, c, l, u); }; }, function (t, e, i) { const g = i(41); const v = i(49); const m = i(28); t.exports = function (t, e, i, n, s) { const r = t.currentContext; if (m(t, r, e, n, s)) { const o = e._displayOriginX; const a = e._displayOriginY; const h = e.pathData; let l = h.length - 1; const u = h[0] - o; const c = h[1] - a; r.beginPath(), r.moveTo(u, c), e.closePath || (l -= 2); for (let d = 2; d < l; d += 2) { const f = h[d] - o; const p = h[d + 1] - a; r.lineTo(f, p); }r.closePath(), e.isFilled && (g(r, e), r.fill()), e.isStroked && (v(r, e), r.stroke()), r.restore(); } }; }, function (t, e, i) { var n = i(1); var s = i(1); var n = i(1010); var s = i(1011); t.exports = { renderWebGL: n, renderCanvas: s }; }, function (t, e, i) { const D = i(9); t.exports = function (t, e, i, n, s) { const r = this.pipeline; const o = r._tempMatrix1; const a = r._tempMatrix2; const h = r._tempMatrix3; t.setPipeline(r), a.applyITRS(e.x, e.y, e.rotation, e.scaleX, e.scaleY), o.copyFrom(n.matrix), s ? (o.multiplyWithOffset(s, -n.scrollX * e.scrollFactorX, -n.scrollY * e.scrollFactorY), a.e = e.x, a.f = e.y) : (a.e -= n.scrollX * e.scrollFactorX, a.f -= n.scrollY * e.scrollFactorY), o.multiply(a, h), h.translate(-e._displayOriginX, -e._displayOriginY); let l; let u; const c = n.alpha * e.alpha; const d = e.width; const f = e.height; const p = e.cellWidth; const g = e.cellHeight; const v = Math.ceil(d / p); const m = Math.ceil(f / g); let y = p; let x = g; let T = p - (v * p - d); let w = g - (m * g - f); const b = e.showCells; const E = e.showAltCells; const S = e.showOutline; let _ = 0; let A = 0; let C = 0; let M = 0; let P = 0; if (S && (y--, x--, T === p && T--, w === g && w--), b && e.fillAlpha > 0) for (l = r.fillTint, u = D.getTintAppendFloatAlphaAndSwap(e.fillColor, e.fillAlpha * c), l.TL = u, l.TR = u, l.BL = u, l.BR = u, A = 0; A < m; A++) for (E && (C = A % 2), _ = 0; _ < v; _++)E && C ? C = 0 : (C++, M = _ < v - 1 ? y : T, P = A < m - 1 ? x : w, r.setTexture2D(), r.batchFillRect(_ * p, A * g, M, P)); if (E && e.altFillAlpha > 0) for (l = r.fillTint, u = D.getTintAppendFloatAlphaAndSwap(e.altFillColor, e.altFillAlpha * c), l.TL = u, l.TR = u, l.BL = u, l.BR = u, A = 0; A < m; A++) for (E && (C = A % 2), _ = 0; _ < v; _++)!E || C ? (C = 0, M = _ < v - 1 ? y : T, P = A < m - 1 ? x : w, r.setTexture2D(), r.batchFillRect(_ * p, A * g, M, P)) : C = 1; if (S && e.outlineFillAlpha > 0) { const O = r.strokeTint; const R = D.getTintAppendFloatAlphaAndSwap(e.outlineFillColor, e.outlineFillAlpha * c); for (O.TL = R, O.TR = R, O.BL = R, O.BR = R, _ = 1; _ < v; _++) { const L = _ * p; r.setTexture2D(), r.batchLine(L, 0, L, f, 1, 1, 1, 0, !1); } for (A = 1; A < m; A++) { const k = A * g; r.setTexture2D(), r.batchLine(0, k, d, k, 1, 1, 1, 0, !1); } } }; }, function (t, e, i) { const P = i(41); const O = i(49); const R = i(28); t.exports = function (t, e, i, n, s) { const r = t.currentContext; if (R(t, r, e, n, s)) { const o = -e._displayOriginX; const a = -e._displayOriginY; const h = n.alpha * e.alpha; const l = e.width; const u = e.height; const c = e.cellWidth; const d = e.cellHeight; const f = Math.ceil(l / c); const p = Math.ceil(u / d); let g = c; let v = d; let m = c - (f * c - l); let y = d - (p * d - u); const x = e.showCells; const T = e.showAltCells; const w = e.showOutline; let b = 0; let E = 0; let S = 0; let _ = 0; let A = 0; if (w && (g--, v--, m === c && m--, y === d && y--), x && e.fillAlpha > 0) for (P(r, e), E = 0; E < p; E++) for (T && (S = E % 2), b = 0; b < f; b++)T && S ? S = 0 : (S++, _ = b < f - 1 ? g : m, A = E < p - 1 ? v : y, r.fillRect(o + b * c, a + E * d, _, A)); if (T && e.altFillAlpha > 0) for (P(r, e, e.altFillColor, e.altFillAlpha * h), E = 0; E < p; E++) for (T && (S = E % 2), b = 0; b < f; b++)!T || S ? (S = 0, _ = b < f - 1 ? g : m, A = E < p - 1 ? v : y, r.fillRect(o + b * c, a + E * d, _, A)) : S = 1; if (w && e.outlineFillAlpha > 0) { for (O(r, e, e.outlineFillColor, e.outlineFillAlpha * h), b = 1; b < f; b++) { const C = b * c; r.beginPath(), r.moveTo(C + o, a), r.lineTo(C + o, u + a), r.stroke(); } for (E = 1; E < p; E++) { const M = E * d; r.beginPath(), r.moveTo(o, M + a), r.lineTo(o + l, M + a), r.stroke(); } }r.restore(); } }; }, function (t, e, i) { var n = i(1); var s = i(1); var n = i(1013); var s = i(1014); t.exports = { renderWebGL: n, renderCanvas: s }; }, function (t, e, i) { const E = i(9); t.exports = function (t, e, i, n, s) { const r = this.pipeline; const o = r._tempMatrix1; const a = r._tempMatrix2; const h = r._tempMatrix3; t.setPipeline(r), a.applyITRS(e.x, e.y, e.rotation, e.scaleX, e.scaleY), o.copyFrom(n.matrix), s ? (o.multiplyWithOffset(s, -n.scrollX * e.scrollFactorX, -n.scrollY * e.scrollFactorY), a.e = e.x, a.f = e.y) : (a.e -= n.scrollX * e.scrollFactorX, a.f -= n.scrollY * e.scrollFactorY), o.multiply(a, h); let l; let u; let c; let d; let f; let p; let g; let v; let m; const y = e.width; const x = e.height; const T = y / 2; const w = y / e.projection; const b = n.alpha * e.alpha; e.isFilled && (e.showTop && (l = E.getTintAppendFloatAlphaAndSwap(e.fillTop, b), u = h.getX(-T, -x), c = h.getY(-T, -x), d = h.getX(0, -w - x), f = h.getY(0, -w - x), p = h.getX(T, -x), g = h.getY(T, -x), v = h.getX(0, w - x), m = h.getY(0, w - x), r.setTexture2D(), r.batchQuad(u, c, d, f, p, g, v, m, 0, 0, 1, 1, l, l, l, l, 2)), e.showLeft && (l = E.getTintAppendFloatAlphaAndSwap(e.fillLeft, b), u = h.getX(-T, 0), c = h.getY(-T, 0), d = h.getX(0, w), f = h.getY(0, w), p = h.getX(0, w - x), g = h.getY(0, w - x), v = h.getX(-T, -x), m = h.getY(-T, -x), r.setTexture2D(), r.batchQuad(u, c, d, f, p, g, v, m, 0, 0, 1, 1, l, l, l, l, 2)), e.showRight && (l = E.getTintAppendFloatAlphaAndSwap(e.fillRight, b), u = h.getX(T, 0), c = h.getY(T, 0), d = h.getX(0, w), f = h.getY(0, w), p = h.getX(0, w - x), g = h.getY(0, w - x), v = h.getX(T, -x), m = h.getY(T, -x), r.setTexture2D(), r.batchQuad(u, c, d, f, p, g, v, m, 0, 0, 1, 1, l, l, l, l, 2))); }; }, function (t, e, i) { const u = i(41); const c = i(28); t.exports = function (t, e, i, n, s) { let r; let o; let a; let h; const l = t.currentContext; c(t, l, e, n, s) && e.isFilled && (r = e.width, o = e.height, a = r / 2, h = r / e.projection, e.showTop && (u(l, e, e.fillTop), l.beginPath(), l.moveTo(-a, -o), l.lineTo(0, -h - o), l.lineTo(a, -o), l.lineTo(a, -1), l.lineTo(0, h - 1), l.lineTo(-a, -1), l.lineTo(-a, -o), l.fill()), e.showLeft && (u(l, e, e.fillLeft), l.beginPath(), l.moveTo(-a, 0), l.lineTo(0, h), l.lineTo(0, h - o), l.lineTo(-a, -o), l.lineTo(-a, 0), l.fill()), e.showRight && (u(l, e, e.fillRight), l.beginPath(), l.moveTo(a, 0), l.lineTo(0, h), l.lineTo(0, h - o), l.lineTo(a, -o), l.lineTo(a, 0), l.fill()), l.restore()); }; }, function (t, e, i) { var n = i(1); var s = i(1); var n = i(1016); var s = i(1017); t.exports = { renderWebGL: n, renderCanvas: s }; }, function (t, e, i) { const S = i(9); t.exports = function (t, e, i, n, s) { const r = this.pipeline; const o = r._tempMatrix1; const a = r._tempMatrix2; const h = r._tempMatrix3; t.setPipeline(r), a.applyITRS(e.x, e.y, e.rotation, e.scaleX, e.scaleY), o.copyFrom(n.matrix), s ? (o.multiplyWithOffset(s, -n.scrollX * e.scrollFactorX, -n.scrollY * e.scrollFactorY), a.e = e.x, a.f = e.y) : (a.e -= n.scrollX * e.scrollFactorX, a.f -= n.scrollY * e.scrollFactorY), o.multiply(a, h); let l; let u; let c; let d; let f; let p; let g; let v; let m; const y = e.width; const x = e.height; const T = y / 2; const w = y / e.projection; const b = e.isReversed; const E = n.alpha * e.alpha; e.isFilled && (e.showTop && b && (l = S.getTintAppendFloatAlphaAndSwap(e.fillTop, E), u = h.getX(-T, -x), c = h.getY(-T, -x), d = h.getX(0, -w - x), f = h.getY(0, -w - x), p = h.getX(T, -x), g = h.getY(T, -x), v = h.getX(0, w - x), m = h.getY(0, w - x), r.setTexture2D(), r.batchQuad(u, c, d, f, p, g, v, m, 0, 0, 1, 1, l, l, l, l, 2)), e.showLeft && (l = S.getTintAppendFloatAlphaAndSwap(e.fillLeft, E), g = (p = (f = (d = (c = b ? (u = h.getX(-T, -x), h.getY(-T, -x)) : (u = h.getX(-T, 0), h.getY(-T, 0)), h.getX(0, w)), h.getY(0, w)), h.getX(0, w - x)), h.getY(0, w - x)), r.setTexture2D(), r.batchTri(u, c, d, f, p, g, 0, 0, 1, 1, l, l, l, 2)), e.showRight && (l = S.getTintAppendFloatAlphaAndSwap(e.fillRight, E), g = (p = (f = (d = (c = b ? (u = h.getX(T, -x), h.getY(T, -x)) : (u = h.getX(T, 0), h.getY(T, 0)), h.getX(0, w)), h.getY(0, w)), h.getX(0, w - x)), h.getY(0, w - x)), r.setTexture2D(), r.batchTri(u, c, d, f, p, g, 0, 0, 1, 1, l, l, l, 2))); }; }, function (t, e, i) { const c = i(41); const d = i(28); t.exports = function (t, e, i, n, s) { let r; let o; let a; let h; let l; const u = t.currentContext; d(t, u, e, n, s) && e.isFilled && (r = e.width, o = e.height, a = r / 2, h = r / e.projection, l = e.isReversed, e.showTop && l && (c(u, e, e.fillTop), u.beginPath(), u.moveTo(-a, -o), u.lineTo(0, -h - o), u.lineTo(a, -o), u.lineTo(0, h - o), u.fill()), e.showLeft && (c(u, e, e.fillLeft), u.beginPath(), l ? u.moveTo(-a, -o) : u.moveTo(-a, 0), u.lineTo(0, h), u.lineTo(0, h - o), u.fill()), e.showRight && (c(u, e, e.fillRight), u.beginPath(), l ? u.moveTo(a, -o) : u.moveTo(a, 0), u.lineTo(0, h), u.lineTo(0, h - o), u.fill()), u.restore()); }; }, function (t, e, i) { var n = i(1); var s = i(1); var n = i(1019); var s = i(1020); t.exports = { renderWebGL: n, renderCanvas: s }; }, function (t, e, i) { const g = i(9); t.exports = function (t, e, i, n, s) { const r = this.pipeline; const o = r._tempMatrix1; const a = r._tempMatrix2; t.setPipeline(r), a.applyITRS(e.x, e.y, e.rotation, e.scaleX, e.scaleY), o.copyFrom(n.matrix), s ? (o.multiplyWithOffset(s, -n.scrollX * e.scrollFactorX, -n.scrollY * e.scrollFactorY), a.e = e.x, a.f = e.y) : (a.e -= n.scrollX * e.scrollFactorX, a.f -= n.scrollY * e.scrollFactorY); let h; let l; let u; let c; const d = e._displayOriginX; const f = e._displayOriginY; const p = n.alpha * e.alpha; e.isStroked && (h = r.strokeTint, l = g.getTintAppendFloatAlphaAndSwap(e.strokeColor, e.strokeAlpha * p), h.TL = l, h.TR = l, h.BL = l, h.BR = l, u = e._startWidth, c = e._endWidth, r.setTexture2D(), r.batchLine(e.geom.x1 - d, e.geom.y1 - f, e.geom.x2 - d, e.geom.y2 - f, u, c, 1, 0, !1, a, o)); }; }, function (t, e, i) { const h = i(49); const l = i(28); t.exports = function (t, e, i, n, s) { let r; let o; const a = t.currentContext; l(t, a, e, n, s) && (r = e._displayOriginX, o = e._displayOriginY, e.isStroked && (h(a, e), a.beginPath(), a.moveTo(e.geom.x1 - r, e.geom.y1 - o), a.lineTo(e.geom.x2 - r, e.geom.y2 - o), a.stroke()), a.restore()); }; }, function (t, e, i) { var n = i(1); var s = i(1); var n = i(1022); var s = i(1023); t.exports = { renderWebGL: n, renderCanvas: s }; }, function (t, e, i) { const d = i(98); const f = i(70); t.exports = function (t, e, i, n, s) { const r = this.pipeline; const o = r._tempMatrix1; const a = r._tempMatrix2; const h = r._tempMatrix3; t.setPipeline(r), a.applyITRS(e.x, e.y, e.rotation, e.scaleX, e.scaleY), o.copyFrom(n.matrix), s ? (o.multiplyWithOffset(s, -n.scrollX * e.scrollFactorX, -n.scrollY * e.scrollFactorY), a.e = e.x, a.f = e.y) : (a.e -= n.scrollX * e.scrollFactorX, a.f -= n.scrollY * e.scrollFactorY), o.multiply(a, h); const l = e._displayOriginX; const u = e._displayOriginY; const c = n.alpha * e.alpha; e.isFilled && d(r, h, e, c, l, u), e.isStroked && f(r, e, c, l, u); }; }, function (t, e, i) { const g = i(41); const v = i(49); const m = i(28); t.exports = function (t, e, i, n, s) { const r = t.currentContext; if (m(t, r, e, n, s)) { const o = e._displayOriginX; const a = e._displayOriginY; const h = e.pathData; let l = h.length - 1; const u = h[0] - o; const c = h[1] - a; r.beginPath(), r.moveTo(u, c), e.closePath || (l -= 2); for (let d = 2; d < l; d += 2) { const f = h[d] - o; const p = h[d + 1] - a; r.lineTo(f, p); }r.closePath(), e.isFilled && (g(r, e), r.fill()), e.isStroked && (v(r, e), r.stroke()), r.restore(); } }; }, function (t, e, i) { var n = i(1); var s = i(1); var n = i(1025); var s = i(1026); t.exports = { renderWebGL: n, renderCanvas: s }; }, function (t, e, i) { const p = i(70); const g = i(9); t.exports = function (t, e, i, n, s) { const r = this.pipeline; const o = r._tempMatrix1; const a = r._tempMatrix2; const h = r._tempMatrix3; t.setPipeline(r), a.applyITRS(e.x, e.y, e.rotation, e.scaleX, e.scaleY), o.copyFrom(n.matrix), s ? (o.multiplyWithOffset(s, -n.scrollX * e.scrollFactorX, -n.scrollY * e.scrollFactorY), a.e = e.x, a.f = e.y) : (a.e -= n.scrollX * e.scrollFactorX, a.f -= n.scrollY * e.scrollFactorY), o.multiply(a, h); let l; let u; const c = e._displayOriginX; const d = e._displayOriginY; const f = n.alpha * e.alpha; e.isFilled && (l = r.fillTint, u = g.getTintAppendFloatAlphaAndSwap(e.fillColor, e.fillAlpha * f), l.TL = u, l.TR = u, l.BL = u, l.BR = u, r.setTexture2D(), r.batchFillRect(-c, -d, e.width, e.height)), e.isStroked && p(r, e, f, c, d); }; }, function (t, e, i) { const h = i(41); const l = i(49); const u = i(28); t.exports = function (t, e, i, n, s) { let r; let o; const a = t.currentContext; u(t, a, e, n, s) && (r = e._displayOriginX, o = e._displayOriginY, e.isFilled && (h(a, e), a.fillRect(-r, -o, e.width, e.height)), e.isStroked && (l(a, e), a.beginPath(), a.rect(-r, -o, e.width, e.height), a.stroke()), a.restore()); }; }, function (t, e, i) { var n = i(1); var s = i(1); var n = i(1028); var s = i(1029); t.exports = { renderWebGL: n, renderCanvas: s }; }, function (t, e, i) { const d = i(98); const f = i(70); t.exports = function (t, e, i, n, s) { const r = this.pipeline; const o = r._tempMatrix1; const a = r._tempMatrix2; const h = r._tempMatrix3; t.setPipeline(r), a.applyITRS(e.x, e.y, e.rotation, e.scaleX, e.scaleY), o.copyFrom(n.matrix), s ? (o.multiplyWithOffset(s, -n.scrollX * e.scrollFactorX, -n.scrollY * e.scrollFactorY), a.e = e.x, a.f = e.y) : (a.e -= n.scrollX * e.scrollFactorX, a.f -= n.scrollY * e.scrollFactorY), o.multiply(a, h); const l = e._displayOriginX; const u = e._displayOriginY; const c = n.alpha * e.alpha; e.isFilled && d(r, h, e, c, l, u), e.isStroked && f(r, e, c, l, u); }; }, function (t, e, i) { const g = i(41); const v = i(49); const m = i(28); t.exports = function (t, e, i, n, s) { const r = t.currentContext; if (m(t, r, e, n, s)) { const o = e._displayOriginX; const a = e._displayOriginY; const h = e.pathData; let l = h.length - 1; const u = h[0] - o; const c = h[1] - a; r.beginPath(), r.moveTo(u, c), e.closePath || (l -= 2); for (let d = 2; d < l; d += 2) { const f = h[d] - o; const p = h[d + 1] - a; r.lineTo(f, p); }r.closePath(), e.isFilled && (g(r, e), r.fill()), e.isStroked && (v(r, e), r.stroke()), r.restore(); } }; }, function (t, e, i) { var n = i(1); var s = i(1); var n = i(1031); var s = i(1032); t.exports = { renderWebGL: n, renderCanvas: s }; }, function (t, e, i) { const T = i(70); const w = i(9); t.exports = function (t, e, i, n, s) { const r = this.pipeline; const o = r._tempMatrix1; const a = r._tempMatrix2; const h = r._tempMatrix3; t.setPipeline(r), a.applyITRS(e.x, e.y, e.rotation, e.scaleX, e.scaleY), o.copyFrom(n.matrix), s ? (o.multiplyWithOffset(s, -n.scrollX * e.scrollFactorX, -n.scrollY * e.scrollFactorY), a.e = e.x, a.f = e.y) : (a.e -= n.scrollX * e.scrollFactorX, a.f -= n.scrollY * e.scrollFactorY), o.multiply(a, h); let l; let u; let c; let d; let f; let p; let g; let v; const m = e._displayOriginX; const y = e._displayOriginY; const x = n.alpha * e.alpha; e.isFilled && (l = r.fillTint, u = w.getTintAppendFloatAlphaAndSwap(e.fillColor, e.fillAlpha * x), l.TL = u, l.TR = u, l.BL = u, l.BR = u, c = e.geom.x1 - m, d = e.geom.y1 - y, f = e.geom.x2 - m, p = e.geom.y2 - y, g = e.geom.x3 - m, v = e.geom.y3 - y, r.setTexture2D(), r.batchFillTriangle(c, d, f, p, g, v, a, o)), e.isStroked && T(r, e, x, m, y); }; }, function (t, e, i) { const p = i(41); const g = i(49); const v = i(28); t.exports = function (t, e, i, n, s) { let r; let o; let a; let h; let l; let u; let c; let d; const f = t.currentContext; v(t, f, e, n, s) && (r = e._displayOriginX, o = e._displayOriginY, a = e.geom.x1 - r, h = e.geom.y1 - o, l = e.geom.x2 - r, u = e.geom.y2 - o, c = e.geom.x3 - r, d = e.geom.y3 - o, f.beginPath(), f.moveTo(a, h), f.lineTo(l, u), f.lineTo(c, d), f.closePath(), e.isFilled && (p(f, e), f.fill()), e.isStroked && (g(f, e), f.stroke()), f.restore()); }; }, function (t, e, i) { const s = i(188); i(5).register('blitter', function (t, e, i, n) { return this.displayList.add(new s(this.scene, t, e, i, n)); }); }, function (t, e, i) { const n = i(189); i(5).register('container', function (t, e, i) { return this.displayList.add(new n(this.scene, t, e, i)); }); }, function (t, e, i) { const o = i(395); i(5).register('dom', function (t, e, i, n, s) { const r = new o(this.scene, t, e, i, n, s); return this.displayList.add(r), this.updateList.add(r), r; }); }, function (t, e, i) { const r = i(190); i(5).register('dynamicBitmapText', function (t, e, i, n, s) { return this.displayList.add(new r(this.scene, t, e, i, n, s)); }); }, function (t, e, i) { const n = i(397); i(5).register('extern', function () { const t = new n(this.scene); return this.displayList.add(t), this.updateList.add(t), t; }); }, function (t, e, i) { const n = i(191); i(5).register('graphics', function (t) { return this.displayList.add(new n(this.scene, t)); }); }, function (t, e, i) { const n = i(97); i(5).register('group', function (t, e) { return this.updateList.add(new n(this.scene, t, e)); }); }, function (t, e, i) { const s = i(107); i(5).register('image', function (t, e, i, n) { return this.displayList.add(new s(this.scene, t, e, i, n)); }); }, function (t, e, i) { const n = i(5); const s = i(194); n.register('particles', function (t, e, i) { const n = new s(this.scene, t, e, i); return this.displayList.add(n), this.updateList.add(n), n; }); }, function (t, e, i) { const n = i(5); const o = i(409); n.register('follower', function (t, e, i, n, s) { const r = new o(this.scene, t, e, i, n, s); return this.displayList.add(r), this.updateList.add(r), r; }); }, function (t, e, i) { const n = i(5); const o = i(195); n.register('renderTexture', function (t, e, i, n, s, r) { return this.displayList.add(new o(this.scene, t, e, i, n, s, r)); }); }, function (t, e, i) { const l = i(197); i(5).register('rope', function (t, e, i, n, s, r, o, a) { const h = new l(this.scene, t, e, i, n, s, r, o, a); return this.displayList.add(h), this.updateList.add(h); }); }, function (t, e, i) { const n = i(5); const r = i(75); n.register('sprite', function (t, e, i, n) { const s = new r(this.scene, t, e, i, n); return this.displayList.add(s), this.updateList.add(s), s; }); }, function (t, e, i) { const o = i(132); i(5).register('bitmapText', function (t, e, i, n, s, r) { return this.displayList.add(new o(this.scene, t, e, i, n, s, r)); }); }, function (t, e, i) { const s = i(198); i(5).register('text', function (t, e, i, n) { return this.displayList.add(new s(this.scene, t, e, i, n)); }); }, function (t, e, i) { const o = i(199); i(5).register('tileSprite', function (t, e, i, n, s, r) { return this.displayList.add(new o(this.scene, t, e, i, n, s, r)); }); }, function (t, e, i) { const s = i(110); i(5).register('zone', function (t, e, i, n) { return this.displayList.add(new s(this.scene, t, e, i, n)); }); }, function (t, e, i) { const s = i(200); i(5).register('video', function (t, e, i) { const n = new s(this.scene, t, e, i); return this.displayList.add(n), this.updateList.add(n), n; }); }, function (t, e, i) { const h = i(410); const n = i(5); n.register('arc', function (t, e, i, n, s, r, o, a) { return this.displayList.add(new h(this.scene, t, e, i, n, s, r, o, a)); }), n.register('circle', function (t, e, i, n, s) { return this.displayList.add(new h(this.scene, t, e, i, 0, 360, !1, n, s)); }); }, function (t, e, i) { const n = i(5); const r = i(411); n.register('curve', function (t, e, i, n, s) { return this.displayList.add(new r(this.scene, t, e, i, n, s)); }); }, function (t, e, i) { const o = i(412); i(5).register('ellipse', function (t, e, i, n, s, r) { return this.displayList.add(new o(this.scene, t, e, i, n, s, r)); }); }, function (t, e, i) { const n = i(5); const u = i(413); n.register('grid', function (t, e, i, n, s, r, o, a, h, l) { return this.displayList.add(new u(this.scene, t, e, i, n, s, r, o, a, h, l)); }); }, function (t, e, i) { const n = i(5); const a = i(414); n.register('isobox', function (t, e, i, n, s, r, o) { return this.displayList.add(new a(this.scene, t, e, i, n, s, r, o)); }); }, function (t, e, i) { const n = i(5); const h = i(415); n.register('isotriangle', function (t, e, i, n, s, r, o, a) { return this.displayList.add(new h(this.scene, t, e, i, n, s, r, o, a)); }); }, function (t, e, i) { const n = i(5); const h = i(416); n.register('line', function (t, e, i, n, s, r, o, a) { return this.displayList.add(new h(this.scene, t, e, i, n, s, r, o, a)); }); }, function (t, e, i) { const n = i(5); const r = i(417); n.register('polygon', function (t, e, i, n, s) { return this.displayList.add(new r(this.scene, t, e, i, n, s)); }); }, function (t, e, i) { const n = i(5); const o = i(422); n.register('rectangle', function (t, e, i, n, s, r) { return this.displayList.add(new o(this.scene, t, e, i, n, s, r)); }); }, function (t, e, i) { const a = i(423); i(5).register('star', function (t, e, i, n, s, r, o) { return this.displayList.add(new a(this.scene, t, e, i, n, s, r, o)); }); }, function (t, e, i) { const n = i(5); const u = i(424); n.register('triangle', function (t, e, i, n, s, r, o, a, h, l) { return this.displayList.add(new u(this.scene, t, e, i, n, s, r, o, a, h, l)); }); }, function (t, e, i) { const r = i(188); const o = i(27); const n = i(16); const a = i(15); n.register('blitter', function (t, e) { void 0 === t && (t = {}); const i = a(t, 'key', null); const n = a(t, 'frame', null); const s = new r(this.scene, 0, 0, i, n); return void 0 !== e && (t.add = e), o(this.scene, s, t), s; }); }, function (t, e, i) { const r = i(27); const o = i(189); const n = i(16); const a = i(15); n.register('container', function (t, e) { void 0 === t && (t = {}); const i = a(t, 'x', 0); const n = a(t, 'y', 0); const s = new o(this.scene, i, n); return void 0 !== e && (t.add = e), r(this.scene, s, t), s; }); }, function (t, e, i) { const o = i(190); const a = i(27); const n = i(16); const h = i(15); n.register('dynamicBitmapText', function (t, e) { void 0 === t && (t = {}); const i = h(t, 'font', ''); const n = h(t, 'text', ''); const s = h(t, 'size', !1); const r = new o(this.scene, 0, 0, i, n, s); return void 0 !== e && (t.add = e), a(this.scene, r, t), r; }); }, function (t, e, i) { const n = i(16); const s = i(191); n.register('graphics', function (t, e) { void 0 === t && (t = {}), void 0 !== e && (t.add = e); const i = new s(this.scene, t); return t.add && this.scene.sys.displayList.add(i), i; }); }, function (t, e, i) { const n = i(16); const s = i(97); n.register('group', function (t) { return new s(this.scene, null, t); }); }, function (t, e, i) { const r = i(27); const n = i(16); const o = i(15); const a = i(107); n.register('image', function (t, e) { void 0 === t && (t = {}); const i = o(t, 'key', null); const n = o(t, 'frame', null); const s = new a(this.scene, 0, 0, i, n); return void 0 !== e && (t.add = e), r(this.scene, s, t), s; }); }, function (t, e, i) { const n = i(16); const o = i(15); const a = i(2); const h = i(194); n.register('particles', function (t, e) { void 0 === t && (t = {}); const i = o(t, 'key', null); const n = o(t, 'frame', null); const s = a(t, 'emitters', null); const r = new h(this.scene, i, n, s); return void 0 !== e && (t.add = e), a(t, 'add', !1) && this.displayList.add(r), this.updateList.add(r), r; }); }, function (t, e, i) { const l = i(27); const n = i(16); const u = i(15); const c = i(195); n.register('renderTexture', function (t, e) { void 0 === t && (t = {}); const i = u(t, 'x', 0); const n = u(t, 'y', 0); const s = u(t, 'width', 32); const r = u(t, 'height', 32); const o = u(t, 'key', void 0); const a = u(t, 'frame', void 0); const h = new c(this.scene, i, n, s, r, o, a); return void 0 !== e && (t.add = e), l(this.scene, h, t), h; }); }, function (t, e, i) { const l = i(27); const n = i(16); const u = i(15); const c = i(6); const d = i(197); n.register('rope', function (t, e) { void 0 === t && (t = {}); const i = u(t, 'key', null); const n = u(t, 'frame', null); const s = u(t, 'horizontal', !0); const r = c(t, 'points', void 0); const o = c(t, 'colors', void 0); const a = c(t, 'alphas', void 0); const h = new d(this.scene, 0, 0, i, n, r, s, o, a); return void 0 !== e && (t.add = e), l(this.scene, h, t), h; }); }, function (t, e, i) { const r = i(27); const o = i(393); const n = i(16); const a = i(15); const h = i(75); n.register('sprite', function (t, e) { void 0 === t && (t = {}); const i = a(t, 'key', null); const n = a(t, 'frame', null); const s = new h(this.scene, 0, 0, i, n); return void 0 !== e && (t.add = e), r(this.scene, s, t), o(s, t), s; }); }, function (t, e, i) { const a = i(132); const h = i(27); const n = i(16); const l = i(15); const u = i(6); n.register('bitmapText', function (t, e) { void 0 === t && (t = {}); const i = u(t, 'font', ''); const n = l(t, 'text', ''); const s = l(t, 'size', !1); const r = u(t, 'align', 0); const o = new a(this.scene, 0, 0, i, n, s, r); return void 0 !== e && (t.add = e), h(this.scene, o, t), o; }); }, function (t, e, i) { const o = i(27); const n = i(16); const a = i(15); const h = i(198); n.register('text', function (t, e) { void 0 === t && (t = {}); const i = a(t, 'text', ''); const n = a(t, 'style', null); const s = a(t, 'padding', null); s !== null && (n.padding = s); const r = new h(this.scene, 0, 0, i, n); return void 0 !== e && (t.add = e), o(this.scene, r, t), r.autoRound = a(t, 'autoRound', !0), r.resolution = a(t, 'resolution', 1), r; }); }, function (t, e, i) { const l = i(27); const n = i(16); const u = i(15); const c = i(199); n.register('tileSprite', function (t, e) { void 0 === t && (t = {}); const i = u(t, 'x', 0); const n = u(t, 'y', 0); const s = u(t, 'width', 512); const r = u(t, 'height', 512); const o = u(t, 'key', ''); const a = u(t, 'frame', ''); const h = new c(this.scene, i, n, s, r, o, a); return void 0 !== e && (t.add = e), l(this.scene, h, t), h; }); }, function (t, e, i) { const n = i(16); const r = i(15); const o = i(110); n.register('zone', function (t) { const e = r(t, 'x', 0); const i = r(t, 'y', 0); const n = r(t, 'width', 1); const s = r(t, 'height', n); return new o(this.scene, e, i, n, s); }); }, function (t, e, i) { const s = i(27); const n = i(16); const r = i(15); const o = i(200); n.register('video', function (t, e) { void 0 === t && (t = {}); const i = r(t, 'key', null); const n = new o(this.scene, 0, 0, i); return void 0 !== e && (t.add = e), s(this.scene, n, t), n; }); }, function (t, e, i) { var n = i(1); var s = i(1); var n = i(1078); var s = i(1079); t.exports = { renderWebGL: n, renderCanvas: s }; }, function (t, e, i) { const A = i(9); t.exports = function (t, e, i, n, s) { const r = this.pipeline; t.setPipeline(r, e); const o = r._tempMatrix1; const a = r._tempMatrix2; const h = r._tempMatrix3; a.applyITRS(e.x, e.y, e.rotation, e.scaleX, e.scaleY), o.copyFrom(n.matrix), s ? (o.multiplyWithOffset(s, -n.scrollX * e.scrollFactorX, -n.scrollY * e.scrollFactorY), a.e = e.x, a.f = e.y) : (a.e -= n.scrollX * e.scrollFactorX, a.f -= n.scrollY * e.scrollFactorY), o.multiply(a, h); const l = e.frame.glTexture; const u = e.vertices; const c = e.uv; const d = e.colors; const f = e.alphas; const p = u.length; const g = Math.floor(0.5 * p); r.vertexCount + g > r.vertexCapacity && r.flush(), r.setTexture2D(l, 0); for (let v = r.vertexViewF32, m = r.vertexViewU32, y = r.vertexCount * r.vertexComponentCount - 1, x = 0, T = e.tintFill, w = 0; w < p; w += 2) { const b = u[w + 0]; const E = u[w + 1]; let S = b * h.a + E * h.c + h.e; let _ = b * h.b + E * h.d + h.f; n.roundPixels && (S = Math.round(S), _ = Math.round(_)), v[++y] = S, v[++y] = _, v[++y] = c[w + 0], v[++y] = c[w + 1], v[++y] = T, m[++y] = A.getTintAppendFloatAlpha(d[x], n.alpha * f[x]), x++; }r.vertexCount += g; }; }, function (t, e) { t.exports = function () {}; }, function (t, e, i) { var n = i(1); var s = i(1); var n = i(1081); var s = i(1082); t.exports = { renderWebGL: n, renderCanvas: s }; }, function (t, e) { t.exports = function (t, e, i, n, s) { let r; let o; let a; let h; e.shader && (r = t.currentPipeline, t.clearPipeline(), e.renderToTexture ? e.load() : (o = e._tempMatrix1, a = e._tempMatrix2, h = e._tempMatrix3, a.applyITRS(e.x, e.y, e.rotation, e.scaleX, e.scaleY), o.copyFrom(n.matrix), s ? (o.multiplyWithOffset(s, -n.scrollX * e.scrollFactorX, -n.scrollY * e.scrollFactorY), a.e = e.x, a.f = e.y) : (a.e -= n.scrollX * e.scrollFactorX, a.f -= n.scrollY * e.scrollFactorY), o.multiply(a, h), t.width === e._rendererWidth && t.height === e._rendererHeight || e.projOrtho(0, t.width, t.height, 0), e.load(h.matrix)), e.flush(), t.rebindPipeline(r)); }; }, function (t, e) { t.exports = function () {}; }, function (t, e, i) { const h = i(134); i(5).register('mesh', function (t, e, i, n, s, r, o, a) { return this.displayList.add(new h(this.scene, t, e, i, n, s, r, o, a)); }); }, function (t, e, i) { const s = i(203); i(5).register('quad', function (t, e, i, n) { return this.displayList.add(new s(this.scene, t, e, i, n)); }); }, function (t, e, i) { const a = i(204); i(5).register('shader', function (t, e, i, n, s, r, o) { return this.displayList.add(new a(this.scene, t, e, i, n, s, r, o)); }); }, function (t, e, i) { const l = i(27); const n = i(16); const u = i(15); const c = i(6); const d = i(134); n.register('mesh', function (t, e) { void 0 === t && (t = {}); const i = u(t, 'key', null); const n = u(t, 'frame', null); const s = c(t, 'vertices', []); const r = c(t, 'colors', []); const o = c(t, 'alphas', []); const a = c(t, 'uv', []); const h = new d(this.scene, 0, 0, s, a, r, o, i, n); return void 0 !== e && (t.add = e), l(this.scene, h, t), h; }); }, function (t, e, i) { const a = i(27); const n = i(16); const h = i(15); const l = i(203); n.register('quad', function (t, e) { void 0 === t && (t = {}); const i = h(t, 'x', 0); const n = h(t, 'y', 0); const s = h(t, 'key', null); const r = h(t, 'frame', null); const o = new l(this.scene, i, n, s, r); return void 0 !== e && (t.add = e), a(this.scene, o, t), o; }); }, function (t, e, i) { const h = i(27); const n = i(16); const l = i(15); const u = i(204); n.register('shader', function (t, e) { void 0 === t && (t = {}); const i = l(t, 'key', null); const n = l(t, 'x', 0); const s = l(t, 'y', 0); const r = l(t, 'width', 128); const o = l(t, 'height', 128); const a = new u(this.scene, i, n, s, r, o); return void 0 !== e && (t.add = e), h(this.scene, a, t), a; }); }, function (t, e, i) {\n    const n = i(0); const s = i(429); const r = i(23); const o = i(22); const a = new n({\n      Extends: s, initialize(t) { this.scene = t, this.systems = t.sys, t.sys.settings.isBooted || t.sys.events.once(o.BOOT, this.boot, this), s.call(this); }, boot() { const t = this.systems.events; t.on(o.SHUTDOWN, this.shutdown, this), t.on(o.DESTROY, this.destroy, this); }, destroy() { this.shutdown(), this.scene = void 0, this.systems = void 0; },\n    }); r.register('LightsPlugin', a, 'lights'), t.exports = a;\n  }, function (t, e, i) { const n = i(65); n.Area = i(1091), n.Circumference = i(268), n.CircumferencePoint = i(149), n.Clone = i(1092), n.Contains = i(55), n.ContainsPoint = i(1093), n.ContainsRect = i(1094), n.CopyFrom = i(1095), n.Equals = i(1096), n.GetBounds = i(1097), n.GetPoint = i(266), n.GetPoints = i(267), n.Offset = i(1098), n.OffsetPoint = i(1099), n.Random = i(150), t.exports = n; }, function (t, e) { t.exports = function (t) { return t.radius > 0 ? Math.PI * t.radius * t.radius : 0; }; }, function (t, e, i) { const n = i(65); t.exports = function (t) { return new n(t.x, t.y, t.radius); }; }, function (t, e, i) { const n = i(55); t.exports = function (t, e) { return n(t, e.x, e.y); }; }, function (t, e, i) { const n = i(55); t.exports = function (t, e) { return n(t, e.x, e.y) && n(t, e.right, e.y) && n(t, e.x, e.bottom) && n(t, e.right, e.bottom); }; }, function (t, e) { t.exports = function (t, e) { return e.setTo(t.x, t.y, t.radius); }; }, function (t, e) { t.exports = function (t, e) { return t.x === e.x && t.y === e.y && t.radius === e.radius; }; }, function (t, e, i) { const n = i(11); t.exports = function (t, e) { return void 0 === e && (e = new n()), e.x = t.left, e.y = t.top, e.width = t.diameter, e.height = t.diameter, e; }; }, function (t, e) { t.exports = function (t, e, i) { return t.x += e, t.y += i, t; }; }, function (t, e) { t.exports = function (t, e) { return t.x += e.x, t.y += e.y, t; }; }, function (t, e, i) { const n = i(95); n.Area = i(1101), n.Circumference = i(400), n.CircumferencePoint = i(193), n.Clone = i(1102), n.Contains = i(96), n.ContainsPoint = i(1103), n.ContainsRect = i(1104), n.CopyFrom = i(1105), n.Equals = i(1106), n.GetBounds = i(1107), n.GetPoint = i(398), n.GetPoints = i(399), n.Offset = i(1108), n.OffsetPoint = i(1109), n.Random = i(157), t.exports = n; }, function (t, e) { t.exports = function (t) { return t.isEmpty() ? 0 : t.getMajorRadius() * t.getMinorRadius() * Math.PI; }; }, function (t, e, i) { const n = i(95); t.exports = function (t) { return new n(t.x, t.y, t.width, t.height); }; }, function (t, e, i) { const n = i(96); t.exports = function (t, e) { return n(t, e.x, e.y); }; }, function (t, e, i) { const n = i(96); t.exports = function (t, e) { return n(t, e.x, e.y) && n(t, e.right, e.y) && n(t, e.x, e.bottom) && n(t, e.right, e.bottom); }; }, function (t, e) { t.exports = function (t, e) { return e.setTo(t.x, t.y, t.width, t.height); }; }, function (t, e) { t.exports = function (t, e) { return t.x === e.x && t.y === e.y && t.width === e.width && t.height === e.height; }; }, function (t, e, i) { const n = i(11); t.exports = function (t, e) { return void 0 === e && (e = new n()), e.x = t.left, e.y = t.top, e.width = t.width, e.height = t.height, e; }; }, function (t, e) { t.exports = function (t, e, i) { return t.x += e, t.y += i, t; }; }, function (t, e) { t.exports = function (t, e) { return t.x += e.x, t.y += e.y, t; }; }, function (t, e, i) { const g = i(4); const v = i(205); t.exports = function (t, e, i) { let n; let s; let r; let o; let a; let h; let l; let u; let c; let d; let f; let p; return void 0 === i && (i = []), v(t, e) && (n = t.x, s = t.y, r = t.radius, o = e.x, a = e.y, h = e.radius, s === a ? (p = (f = -2 * a) * f - 4 * (d = 1) * (o * o + (l = (h * h - r * r - o * o + n * n) / (2 * (n - o))) * l - 2 * o * l + a * a - h * h)) === 0 ? i.push(new g(l, -f / (2 * d))) : p > 0 && (i.push(new g(l, (-f + Math.sqrt(p)) / (2 * d))), i.push(new g(l, (-f - Math.sqrt(p)) / (2 * d)))) : (p = (f = 2 * s * (u = (n - o) / (s - a)) - 2 * (c = (h * h - r * r - o * o + n * n - a * a + s * s) / (2 * (s - a))) * u - 2 * n) * f - 4 * (d = u * u + 1) * (n * n + s * s + c * c - r * r - 2 * s * c)) === 0 ? (l = -f / (2 * d), i.push(new g(l, c - l * u))) : p > 0 && (l = (-f + Math.sqrt(p)) / (2 * d), i.push(new g(l, c - l * u)), l = (-f - Math.sqrt(p)) / (2 * d), i.push(new g(l, c - l * u)))), i; }; }, function (t, e, i) { const a = i(207); const h = i(206); t.exports = function (t, e, i) { let n; let s; let r; let o; return void 0 === i && (i = []), h(t, e) && (n = e.getLineA(), s = e.getLineB(), r = e.getLineC(), o = e.getLineD(), a(n, t, i), a(s, t, i), a(r, t, i), a(o, t, i)), i; }; }, function (t, e, i) { const n = i(11); const s = i(135); t.exports = function (t, e, i) { return void 0 === i && (i = new n()), s(t, e) && (i.x = Math.max(t.x, e.x), i.y = Math.max(t.y, e.y), i.width = Math.min(t.right, e.right) - i.x, i.height = Math.min(t.bottom, e.bottom) - i.y), i; }; }, function (t, e, i) { const a = i(209); const h = i(135); t.exports = function (t, e, i) { let n; let s; let r; let o; return void 0 === i && (i = []), h(t, e) && (n = t.getLineA(), s = t.getLineB(), r = t.getLineC(), o = t.getLineD(), a(n, e, i), a(s, e, i), a(r, e, i), a(o, e, i)), i; }; }, function (t, e, i) { const o = i(433); const a = i(209); t.exports = function (t, e, i) { let n; let s; let r; return void 0 === i && (i = []), o(t, e) && (n = e.getLineA(), s = e.getLineB(), r = e.getLineC(), a(n, t, i), a(s, t, i), a(r, t, i)), i; }; }, function (t, e, i) { const o = i(207); const a = i(435); t.exports = function (t, e, i) { let n; let s; let r; return void 0 === i && (i = []), a(t, e) && (n = t.getLineA(), s = t.getLineB(), r = t.getLineC(), o(n, e, i), o(s, e, i), o(r, e, i)), i; }; }, function (t, e, i) { const o = i(438); const a = i(436); t.exports = function (t, e, i) { let n; let s; let r; return void 0 === i && (i = []), o(t, e) && (n = e.getLineA(), s = e.getLineB(), r = e.getLineC(), a(t, n, i), a(t, s, i), a(t, r, i)), i; }; }, function (t, e, i) { const o = i(440); t.exports = function (t, e) { if (!o(t, e)) return !1; const i = Math.min(e.x1, e.x2); const n = Math.max(e.x1, e.x2); const s = Math.min(e.y1, e.y2); const r = Math.max(e.y1, e.y2); return t.x >= i && t.x <= n && t.y >= s && t.y <= r; }; }, function (t, e) { t.exports = function (t, e, i, n, s, r) { return void 0 === r && (r = 0), !(e > t.right + r || i < t.left - r || n > t.bottom + r || s < t.top - r); }; }, function (t, e, i) { const n = i(56); n.Angle = i(85), n.BresenhamPoints = i(288), n.CenterOn = i(1120), n.Clone = i(1121), n.CopyFrom = i(1122), n.Equals = i(1123), n.Extend = i(1124), n.GetEasedPoints = i(1125), n.GetMidPoint = i(1126), n.GetNearestPoint = i(1127), n.GetNormal = i(1128), n.GetPoint = i(275), n.GetPoints = i(153), n.GetShortestDistance = i(1129), n.Height = i(1130), n.Length = i(57), n.NormalAngle = i(441), n.NormalX = i(1131), n.NormalY = i(1132), n.Offset = i(1133), n.PerpSlope = i(1134), n.Random = i(154), n.ReflectAngle = i(1135), n.Rotate = i(1136), n.RotateAroundPoint = i(1137), n.RotateAroundXY = i(211), n.SetToAngle = i(1138), n.Slope = i(1139), n.Width = i(1140), t.exports = n; }, function (t, e) { t.exports = function (t, e, i) { const n = e - (t.x1 + t.x2) / 2; const s = i - (t.y1 + t.y2) / 2; return t.x1 += n, t.y1 += s, t.x2 += n, t.y2 += s, t; }; }, function (t, e, i) { const n = i(56); t.exports = function (t) { return new n(t.x1, t.y1, t.x2, t.y2); }; }, function (t, e) { t.exports = function (t, e) { return e.setTo(t.x1, t.y1, t.x2, t.y2); }; }, function (t, e) { t.exports = function (t, e) { return t.x1 === e.x1 && t.y1 === e.y1 && t.x2 === e.x2 && t.y2 === e.y2; }; }, function (t, e, i) { const o = i(57); t.exports = function (t, e, i) { void 0 === i && (i = e); const n = o(t); const s = t.x2 - t.x1; const r = t.y2 - t.y1; return e && (t.x1 -= s / n * e, t.y1 -= r / n * e), i && (t.x2 += s / n * i, t.y2 += r / n * i), t; }; }, function (t, e, i) { const y = i(320); const x = i(69); const T = i(4); t.exports = function (t, e, i, n, s) { void 0 === n && (n = 0), void 0 === s && (s = []); let r; const o = []; const a = t.x1; const h = t.y1; const l = t.x2 - a; const u = t.y2 - h; const c = x(e, s); const d = i - 1; for (g = 0; g < d; g++)r = c(g / d), o.push(new T(a + l * r, h + u * r)); if (r = c(1), o.push(new T(a + l * r, h + u * r)), n > 0) { for (var f = o[0], p = [f], g = 1; g < o.length - 1; g++) { const v = o[g]; y(f, v) >= n && (p.push(v), f = v); } const m = o[o.length - 1]; return y(f, m) < n && p.pop(), p.push(m), p; } return o; }; }, function (t, e, i) { const n = i(4); t.exports = function (t, e) { return void 0 === e && (e = new n()), e.x = (t.x1 + t.x2) / 2, e.y = (t.y1 + t.y2) / 2, e; }; }, function (t, e, i) { const l = i(4); t.exports = function (t, e, i) { void 0 === i && (i = new l()); const n = t.x1; const s = t.y1; const r = t.x2; const o = t.y2; const a = (r - n) * (r - n) + (o - s) * (o - s); if (a == 0) return i; const h = ((e.x - n) * (r - n) + (e.y - s) * (o - s)) / a; return i.x = n + h * (r - n), i.y = s + h * (o - s), i; }; }, function (t, e, i) { const n = i(13); const s = i(85); const r = i(4); t.exports = function (t, e) { void 0 === e && (e = new r()); const i = s(t) - n.TAU; return e.x = Math.cos(i), e.y = Math.sin(i), e; }; }, function (t, e) { t.exports = function (t, e) { const i = t.x1; const n = t.y1; const s = t.x2; const r = t.y2; const o = (s - i) * (s - i) + (r - n) * (r - n); if (o == 0) return !1; const a = ((n - e.y) * (s - i) - (i - e.x) * (r - n)) / o; return Math.abs(a) * Math.sqrt(o); }; }, function (t, e) { t.exports = function (t) { return Math.abs(t.y1 - t.y2); }; }, function (t, e, i) { const n = i(13); const s = i(85); t.exports = function (t) { return Math.cos(s(t) - n.TAU); }; }, function (t, e, i) { const n = i(13); const s = i(85); t.exports = function (t) { return Math.sin(s(t) - n.TAU); }; }, function (t, e) { t.exports = function (t, e, i) { return t.x1 += e, t.y1 += i, t.x2 += e, t.y2 += i, t; }; }, function (t, e) { t.exports = function (t) { return -((t.x2 - t.x1) / (t.y2 - t.y1)); }; }, function (t, e, i) { const n = i(85); const s = i(441); t.exports = function (t, e) { return 2 * s(e) - Math.PI - n(t); }; }, function (t, e, i) { const s = i(211); t.exports = function (t, e) { const i = (t.x1 + t.x2) / 2; const n = (t.y1 + t.y2) / 2; return s(t, i, n, e); }; }, function (t, e, i) { const n = i(211); t.exports = function (t, e, i) { return n(t, e.x, e.y, i); }; }, function (t, e) { t.exports = function (t, e, i, n, s) { return t.x1 = e, t.y1 = i, t.x2 = e + Math.cos(n) * s, t.y2 = i + Math.sin(n) * s, t; }; }, function (t, e) { t.exports = function (t) { return (t.y2 - t.y1) / (t.x2 - t.x1); }; }, function (t, e) { t.exports = function (t) { return Math.abs(t.x1 - t.x2); }; }, function (t, e, i) { const n = i(4); n.Ceil = i(1142), n.Clone = i(1143), n.CopyFrom = i(1144), n.Equals = i(1145), n.Floor = i(1146), n.GetCentroid = i(1147), n.GetMagnitude = i(442), n.GetMagnitudeSq = i(443), n.GetRectangleFromPoints = i(1148), n.Interpolate = i(1149), n.Invert = i(1150), n.Negative = i(1151), n.Project = i(1152), n.ProjectUnit = i(1153), n.SetMagnitude = i(1154), t.exports = n; }, function (t, e) { t.exports = function (t) { return t.setTo(Math.ceil(t.x), Math.ceil(t.y)); }; }, function (t, e, i) { const n = i(4); t.exports = function (t) { return new n(t.x, t.y); }; }, function (t, e) { t.exports = function (t, e) { return e.setTo(t.x, t.y); }; }, function (t, e) { t.exports = function (t, e) { return t.x === e.x && t.y === e.y; }; }, function (t, e) { t.exports = function (t) { return t.setTo(Math.floor(t.x), Math.floor(t.y)); }; }, function (t, e, i) { const s = i(4); t.exports = function (t, e) { if (void 0 === e && (e = new s()), !Array.isArray(t)) throw new Error('GetCentroid points argument must be an array'); const i = t.length; if (i < 1) throw new Error('GetCentroid points array must not be empty'); if (i === 1)e.x = t[0].x, e.y = t[0].y; else { for (let n = 0; n < i; n++)e.x += t[n].x, e.y += t[n].y; e.x /= i, e.y /= i; } return e; }; }, function (t, e, i) { const h = i(11); t.exports = function (t, e) { void 0 === e && (e = new h()); for (var i = Number.NEGATIVE_INFINITY, n = Number.POSITIVE_INFINITY, s = Number.NEGATIVE_INFINITY, r = Number.POSITIVE_INFINITY, o = 0; o < t.length; o++) { const a = t[o]; a.x > i && (i = a.x), a.x < n && (n = a.x), a.y > s && (s = a.y), a.y < r && (r = a.y); } return e.x = n, e.y = r, e.width = i - n, e.height = s - r, e; }; }, function (t, e, i) { const s = i(4); t.exports = function (t, e, i, n) { return void 0 === i && (i = 0), void 0 === n && (n = new s()), n.x = t.x + (e.x - t.x) * i, n.y = t.y + (e.y - t.y) * i, n; }; }, function (t, e) { t.exports = function (t) { return t.setTo(t.y, t.x); }; }, function (t, e, i) { const n = i(4); t.exports = function (t, e) { return void 0 === e && (e = new n()), e.setTo(-t.x, -t.y); }; }, function (t, e, i) { const s = i(4); const r = i(443); t.exports = function (t, e, i) { void 0 === i && (i = new s()); const n = (t.x * e.x + t.y * e.y) / r(e); return n != 0 && (i.x = n * e.x, i.y = n * e.y), i; }; }, function (t, e, i) { const s = i(4); t.exports = function (t, e, i) { void 0 === i && (i = new s()); const n = t.x * e.x + t.y * e.y; return n != 0 && (i.x = n * e.x, i.y = n * e.y), i; }; }, function (t, e, i) { const n = i(442); t.exports = function (t, e) { let i; return t.x === 0 && t.y === 0 || (i = n(t), t.x /= i, t.y /= i), t.x *= e, t.y *= e, t; }; }, function (t, e, i) { const n = i(201); n.Clone = i(1156), n.Contains = i(202), n.ContainsPoint = i(1157), n.GetAABB = i(418), n.GetNumberArray = i(1158), n.GetPoints = i(419), n.Perimeter = i(420), n.Reverse = i(1159), n.Smooth = i(421), t.exports = n; }, function (t, e, i) { const n = i(201); t.exports = function (t) { return new n(t.points); }; }, function (t, e, i) { const n = i(202); t.exports = function (t, e) { return n(t, e.x, e.y); }; }, function (t, e) { t.exports = function (t, e) { void 0 === e && (e = []); for (let i = 0; i < t.points.length; i++)e.push(t.points[i].x), e.push(t.points[i].y); return e; }; }, function (t, e) { t.exports = function (t) { return t.points.reverse(), t; }; }, function (t, e) { t.exports = function (t) { return t.width * t.height; }; }, function (t, e) { t.exports = function (t) { return t.x = Math.ceil(t.x), t.y = Math.ceil(t.y), t; }; }, function (t, e) { t.exports = function (t) { return t.x = Math.ceil(t.x), t.y = Math.ceil(t.y), t.width = Math.ceil(t.width), t.height = Math.ceil(t.height), t; }; }, function (t, e, i) { const n = i(11); t.exports = function (t) { return new n(t.x, t.y, t.width, t.height); }; }, function (t, e, i) { const n = i(48); t.exports = function (t, e) { return n(t, e.x, e.y); }; }, function (t, e) { t.exports = function (t, e) { return e.setTo(t.x, t.y, t.width, t.height); }; }, function (t, e) { t.exports = function (t, e) { return t.x === e.x && t.y === e.y && t.width === e.width && t.height === e.height; }; }, function (t, e, i) { const n = i(212); t.exports = function (t, e) { const i = n(t); return i < n(e) ? t.setSize(e.height * i, e.height) : t.setSize(e.width, e.width / i), t.setPosition(e.centerX - t.width / 2, e.centerY - t.height / 2); }; }, function (t, e, i) { const n = i(212); t.exports = function (t, e) { const i = n(t); return i > n(e) ? t.setSize(e.height * i, e.height) : t.setSize(e.width, e.width / i), t.setPosition(e.centerX - t.width / 2, e.centerY - t.height / 2); }; }, function (t, e) { t.exports = function (t) { return t.x = Math.floor(t.x), t.y = Math.floor(t.y), t; }; }, function (t, e) { t.exports = function (t) { return t.x = Math.floor(t.x), t.y = Math.floor(t.y), t.width = Math.floor(t.width), t.height = Math.floor(t.height), t; }; }, function (t, e, i) { const r = i(11); t.exports = function (t, e, i, n, s) { return void 0 === s && (s = new r()), s.setTo(Math.min(t, i), Math.min(e, n), Math.abs(t - i), Math.abs(e - n)); }; }, function (t, e, i) { const n = i(4); t.exports = function (t, e) { return void 0 === e && (e = new n()), e.x = t.centerX, e.y = t.centerY, e; }; }, function (t, e, i) { const n = i(4); t.exports = function (t, e) { return void 0 === e && (e = new n()), e.x = t.width, e.y = t.height, e; }; }, function (t, e, i) { const r = i(168); t.exports = function (t, e, i) { const n = t.centerX; const s = t.centerY; return t.setSize(t.width + 2 * e, t.height + 2 * i), r(t, n, s); }; }, function (t, e, i) { const n = i(11); const s = i(135); t.exports = function (t, e, i) { return void 0 === i && (i = new n()), s(t, e) ? (i.x = Math.max(t.x, e.x), i.y = Math.max(t.y, e.y), i.width = Math.min(t.right, e.right) - i.x, i.height = Math.min(t.bottom, e.bottom) - i.y) : i.setEmpty(), i; }; }, function (t, e) { t.exports = function (t, e) { for (var i = t.x, n = t.right, s = t.y, r = t.bottom, o = 0; o < e.length; o++)i = Math.min(i, e[o].x), n = Math.max(n, e[o].x), s = Math.min(s, e[o].y), r = Math.max(r, e[o].y); return t.x = i, t.y = s, t.width = n - i, t.height = r - s, t; }; }, function (t, e) { t.exports = function (t, e) { const i = Math.min(t.x, e.x); const n = Math.max(t.right, e.right); t.x = i, t.width = n - i; const s = Math.min(t.y, e.y); const r = Math.max(t.bottom, e.bottom); return t.y = s, t.height = r - s, t; }; }, function (t, e) { t.exports = function (t, e, i) { const n = Math.min(t.x, e); const s = Math.max(t.right, e); t.x = n, t.width = s - n; const r = Math.min(t.y, i); const o = Math.max(t.bottom, i); return t.y = r, t.height = o - r, t; }; }, function (t, e) { t.exports = function (t, e, i) { return t.x += e, t.y += i, t; }; }, function (t, e) { t.exports = function (t, e) { return t.x += e.x, t.y += e.y, t; }; }, function (t, e) { t.exports = function (t, e) { return t.x < e.right && t.right > e.x && t.y < e.bottom && t.bottom > e.y; }; }, function (t, e, i) { const a = i(4); const h = i(39); t.exports = function (t, e, i) { void 0 === i && (i = new a()), e = h(e); const n = Math.sin(e); const s = Math.cos(e); let r = s > 0 ? t.width / 2 : t.width / -2; let o = n > 0 ? t.height / 2 : t.height / -2; return Math.abs(r * n) < Math.abs(o * s) ? o = r * n / s : r = o * s / n, i.x = r + t.centerX, i.y = o + t.centerY, i; }; }, function (t, e, i) { const n = i(172); const s = i(445); const r = i(4); t.exports = function (t, e, i) { if (void 0 === i && (i = new r()), s(t, e)) switch (n(0, 3)) { case 0: i.x = t.x + Math.random() * (e.right - t.x), i.y = t.y + Math.random() * (e.top - t.y); break; case 1: i.x = e.x + Math.random() * (t.right - e.x), i.y = e.bottom + Math.random() * (t.bottom - e.bottom); break; case 2: i.x = t.x + Math.random() * (e.x - t.x), i.y = e.y + Math.random() * (t.bottom - e.y); break; case 3: i.x = e.right + Math.random() * (t.right - e.right), i.y = t.y + Math.random() * (e.bottom - t.y); } return i; }; }, function (t, e) { t.exports = function (t, e) { return t.width === e.width && t.height === e.height; }; }, function (t, e) { t.exports = function (t, e, i) { return void 0 === i && (i = e), t.width *= e, t.height *= i, t; }; }, function (t, e, i) { const n = i(71); n.Area = i(1187), n.BuildEquilateral = i(1188), n.BuildFromPolygon = i(1189), n.BuildRight = i(1190), n.CenterOn = i(1191), n.Centroid = i(446), n.CircumCenter = i(1192), n.CircumCircle = i(1193), n.Clone = i(1194), n.Contains = i(83), n.ContainsArray = i(210), n.ContainsPoint = i(1195), n.CopyFrom = i(1196), n.Decompose = i(439), n.Equals = i(1197), n.GetPoint = i(425), n.GetPoints = i(426), n.InCenter = i(448), n.Perimeter = i(1198), n.Offset = i(447), n.Random = i(158), n.Rotate = i(1199), n.RotateAroundPoint = i(1200), n.RotateAroundXY = i(213), t.exports = n; }, function (t, e) { t.exports = function (t) { const e = t.x1; const i = t.y1; const n = t.x2; const s = t.y2; const r = t.x3; const o = t.y3; return Math.abs(((r - e) * (s - i) - (n - e) * (o - i)) / 2); }; }, function (t, e, i) { const s = i(71); t.exports = function (t, e, i) { const n = i * (Math.sqrt(3) / 2); return new s(t, e, t + i / 2, e + n, t - i / 2, e + n); }; }, function (t, e, i) { const v = i(66); const m = i(71); t.exports = function (t, e, i, n, s) { void 0 === e && (e = null), void 0 === i && (i = 1), void 0 === n && (n = 1), void 0 === s && (s = []); for (var r, o, a, h, l, u, c, d, f, p = v(t, e), g = 0; g < p.length; g += 3)r = p[g], o = p[g + 1], a = p[g + 2], h = t[2 * r] * i, l = t[2 * r + 1] * n, u = t[2 * o] * i, c = t[2 * o + 1] * n, d = t[2 * a] * i, f = t[2 * a + 1] * n, s.push(new m(h, l, u, c, d, f)); return s; }; }, function (t, e, i) { const s = i(71); t.exports = function (t, e, i, n) { return void 0 === n && (n = i), new s(t, e, t, e - n, t + i, e); }; }, function (t, e, i) { const a = i(446); const h = i(447); t.exports = function (t, e, i, n) { void 0 === n && (n = a); const s = n(t); const r = e - s.x; const o = i - s.y; return h(t, r, o); }; }, function (t, e, i) { const c = i(3); t.exports = function (t, e) { void 0 === e && (e = new c()); const i = t.x3; const n = t.y3; const s = t.x1 - i; const r = t.y1 - n; const o = t.x2 - i; const a = t.y2 - n; const h = 2 * (s * a - r * o); const l = r * (o * o + a * a) - (s * s + r * r) * a; const u = s * (o * o + a * a) - (s * s + r * r) * o; return e.x = i - l / h, e.y = n + u / h, e; }; }, function (t, e, i) { const x = i(65); t.exports = function (t, e) { void 0 === e && (e = new x()); let i; let n; let s; let r; const o = t.x1; const a = t.y1; const h = t.x2; const l = t.y2; const u = t.x3; const c = t.y3; const d = h - o; const f = l - a; const p = u - o; const g = c - a; const v = d * (o + h) + f * (a + l); const m = p * (o + u) + g * (a + c); const y = 2 * (d * (c - l) - f * (u - h)); return Math.abs(y) < 1e-6 ? (i = Math.min(o, h, u), n = Math.min(a, l, c), s = 0.5 * (Math.max(o, h, u) - i), r = 0.5 * (Math.max(a, l, c) - n), e.x = i + s, e.y = n + r) : (e.x = (g * v - f * m) / y, e.y = (d * m - p * v) / y, s = e.x - o, r = e.y - a), e.radius = Math.sqrt(s * s + r * r), e; }; }, function (t, e, i) { const n = i(71); t.exports = function (t) { return new n(t.x1, t.y1, t.x2, t.y2, t.x3, t.y3); }; }, function (t, e, i) { const n = i(83); t.exports = function (t, e) { return n(t, e.x, e.y); }; }, function (t, e) { t.exports = function (t, e) { return e.setTo(t.x1, t.y1, t.x2, t.y2, t.x3, t.y3); }; }, function (t, e) { t.exports = function (t, e) { return t.x1 === e.x1 && t.y1 === e.y1 && t.x2 === e.x2 && t.y2 === e.y2 && t.x3 === e.x3 && t.y3 === e.y3; }; }, function (t, e, i) { const s = i(57); t.exports = function (t) { const e = t.getLineA(); const i = t.getLineB(); const n = t.getLineC(); return s(e) + s(i) + s(n); }; }, function (t, e, i) { const n = i(213); const s = i(448); t.exports = function (t, e) { const i = s(t); return n(t, i.x, i.y, e); }; }, function (t, e, i) { const n = i(213); t.exports = function (t, e, i) { return n(t, e.x, e.y, i); }; }, function (t, e, i) {\n    const n = i(179); var s = i(18)(!1, s = {\n      CreateInteractiveObject: i(449), Events: i(54), Gamepad: i(1202), InputManager: i(365), InputPlugin: i(1214), InputPluginCache: i(136), Keyboard: i(1216), Mouse: i(1233), Pointer: i(368), Touch: i(1234),\n    }, n); t.exports = s;\n  }, function (t, e, i) {\n    t.exports = {\n      Axis: i(450), Button: i(451), Events: i(214), Gamepad: i(452), GamepadPlugin: i(1209), Configs: i(1210),\n    };\n  }, function (t, e) { t.exports = 'down'; }, function (t, e) { t.exports = 'up'; }, function (t, e) { t.exports = 'connected'; }, function (t, e) { t.exports = 'disconnected'; }, function (t, e) { t.exports = 'down'; }, function (t, e) { t.exports = 'up'; }, function (t, e, i) {\n    const n = i(0); const s = i(10); const r = i(214); const h = i(452); const o = i(6); const a = i(136); const l = i(54); const u = new n({\n      Extends: s, initialize(t) { s.call(this), this.scene = t.scene, this.settings = this.scene.sys.settings, this.sceneInputPlugin = t, this.enabled = !0, this.target, this.gamepads = [], this.queue = [], this.onGamepadHandler, this._pad1, this._pad2, this._pad3, this._pad4, t.pluginEvents.once(l.BOOT, this.boot, this), t.pluginEvents.on(l.START, this.start, this); }, boot() { const t = this.scene.sys.game; const e = this.settings.input; const i = t.config; this.enabled = o(e, 'gamepad', i.inputGamepad) && t.device.input.gamepads, this.target = o(e, 'gamepad.target', i.inputGamepadEventTarget), this.sceneInputPlugin.pluginEvents.once(l.DESTROY, this.destroy, this); }, start() { this.enabled && this.startListeners(), this.sceneInputPlugin.pluginEvents.once(l.SHUTDOWN, this.shutdown, this); }, isActive() { return this.enabled && this.scene.sys.isActive(); }, startListeners() { function t(t) { !t.defaultPrevented && e.isActive() && (e.refreshPads(), e.queue.push(t)); } var e = this; const i = this.target; this.onGamepadHandler = t, i.addEventListener('gamepadconnected', t, !1), i.addEventListener('gamepaddisconnected', t, !1), this.sceneInputPlugin.pluginEvents.on(l.UPDATE, this.update, this); }, stopListeners() { this.target.removeEventListener('gamepadconnected', this.onGamepadHandler), this.target.removeEventListener('gamepaddisconnected', this.onGamepadHandler), this.sceneInputPlugin.pluginEvents.off(l.UPDATE, this.update); }, disconnectAll() { for (let t = 0; t < this.gamepads.length; t++) this.gamepads.connected = !1; }, refreshPads() { const t = navigator.getGamepads(); if (t) for (let e = this.gamepads, i = 0; i < t.length; i++) { var n; var s; var r; var o; const a = t[i]; a && (n = a.id, (r = e[s = a.index]) ? r.id !== n ? (r.destroy(), e[s] = new h(this, a)) : r.update(a) : (o = new h(this, a), e[s] = o, this._pad1 ? this._pad2 ? this._pad3 ? this._pad4 || (this._pad4 = o) : this._pad3 = o : this._pad2 = o : this._pad1 = o)); } else this.disconnectAll(); }, getAll() { for (var t = [], e = this.gamepads, i = 0; i < e.length; i++)e[i] && t.push(e[i]); return t; }, getPad(t) { for (let e = this.gamepads, i = 0; i < e.length; i++) if (e[i] && e[i].index === t) return e[i]; }, update() { if (this.enabled) { this.refreshPads(); const t = this.queue.length; if (t !== 0) for (let e = this.queue.splice(0, t), i = 0; i < t; i++) { const n = e[i]; const s = this.getPad(n.gamepad.index); n.type === 'gamepadconnected' ? this.emit(r.CONNECTED, s, n) : n.type === 'gamepaddisconnected' && this.emit(r.DISCONNECTED, s, n); } } }, shutdown() { this.stopListeners(), this.disconnectAll(), this.removeAllListeners(); }, destroy() { this.shutdown(); for (let t = 0; t < this.gamepads.length; t++) this.gamepads[t] && this.gamepads[t].destroy(); this.gamepads = [], this.scene = null, this.settings = null, this.sceneInputPlugin = null, this.target = null; }, total: { get() { return this.gamepads.length; } }, pad1: { get() { return this._pad1; } }, pad2: { get() { return this._pad2; } }, pad3: { get() { return this._pad3; } }, pad4: { get() { return this._pad4; } },\n    }); a.register('GamepadPlugin', u, 'gamepad', 'gamepad', 'inputGamepad'), t.exports = u;\n  }, function (t, e, i) { t.exports = { DUALSHOCK_4: i(1211), SNES_USB: i(1212), XBOX_360: i(1213) }; }, function (t, e) {\n    t.exports = {\n      UP: 12, DOWN: 13, LEFT: 14, RIGHT: 15, SHARE: 8, OPTIONS: 9, PS: 16, TOUCHBAR: 17, X: 0, CIRCLE: 1, SQUARE: 2, TRIANGLE: 3, L1: 4, R1: 5, L2: 6, R2: 7, L3: 10, R3: 11, LEFT_STICK_H: 0, LEFT_STICK_V: 1, RIGHT_STICK_H: 2, RIGHT_STICK_V: 3,\n    };\n  }, function (t, e) {\n    t.exports = {\n      UP: 12, DOWN: 13, LEFT: 14, RIGHT: 15, SELECT: 8, START: 9, B: 0, A: 1, Y: 2, X: 3, LEFT_SHOULDER: 4, RIGHT_SHOULDER: 5,\n    };\n  }, function (t, e) {\n    t.exports = {\n      UP: 12, DOWN: 13, LEFT: 14, RIGHT: 15, MENU: 16, A: 0, B: 1, X: 2, Y: 3, LB: 4, RB: 5, LT: 6, RT: 7, BACK: 8, START: 9, LS: 10, RS: 11, LEFT_STICK_H: 0, LEFT_STICK_V: 1, RIGHT_STICK_H: 2, RIGHT_STICK_V: 3,\n    };\n  }, function (t, e, i) {\n    const o = i(65); const a = i(55); const n = i(0); const h = i(179); const p = i(449); const s = i(1215); const r = i(53); const l = i(95); const u = i(96); const g = i(54); const c = i(10); const v = i(2); const d = i(47); const f = i(136); const m = i(7); const y = i(23); const x = i(11); const T = i(48); const w = i(22); const b = i(71); const E = i(83); const S = new n({\n      Extends: c,\n      initialize(t) {\n        c.call(this), this.scene = t, this.systems = t.sys, this.settings = t.sys.settings, this.manager = t.sys.game.input, this.pluginEvents = new c(), this.enabled = !0, this.displayList, this.cameras, f.install(this), this.mouse = this.manager.mouse, this.topOnly = !0, this.pollRate = -1, this._pollTimer = 0; const e = { cancelled: !1 }; this._eventContainer = { stopPropagation() { e.cancelled = !0; } }, this._eventData = e, this.dragDistanceThreshold = 0, this.dragTimeThreshold = 0, this._temp = [], this._tempZones = [], this._list = [], this._pendingInsertion = [], this._pendingRemoval = [], this._draggable = [], this._drag = {\n          0: [], 1: [], 2: [], 3: [], 4: [], 5: [], 6: [], 7: [], 8: [], 9: [], 10: [],\n        }, this._dragState = [], this._over = {\n          0: [], 1: [], 2: [], 3: [], 4: [], 5: [], 6: [], 7: [], 8: [], 9: [], 10: [],\n        }, this._validTypes = ['onDown', 'onUp', 'onOver', 'onOut', 'onMove', 'onDragStart', 'onDrag', 'onDragEnd', 'onDragEnter', 'onDragLeave', 'onDragOver', 'onDrop'], this._updatedThisFrame = !1, t.sys.events.once(w.BOOT, this.boot, this), t.sys.events.on(w.START, this.start, this);\n      },\n      boot() { this.cameras = this.systems.cameras, this.displayList = this.systems.displayList, this.systems.events.once(w.DESTROY, this.destroy, this), this.pluginEvents.emit(g.BOOT); },\n      start() { const t = this.systems.events; t.on(w.TRANSITION_START, this.transitionIn, this), t.on(w.TRANSITION_OUT, this.transitionOut, this), t.on(w.TRANSITION_COMPLETE, this.transitionComplete, this), t.on(w.PRE_UPDATE, this.preUpdate, this), t.once(w.SHUTDOWN, this.shutdown, this), this.manager.events.on(g.GAME_OUT, this.onGameOut, this), this.manager.events.on(g.GAME_OVER, this.onGameOver, this), this.enabled = !0, this._dragState = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], this.pluginEvents.emit(g.START); },\n      onGameOver(t) { this.isActive() && this.emit(g.GAME_OVER, t.timeStamp, t); },\n      onGameOut(t) { this.isActive() && this.emit(g.GAME_OUT, t.timeStamp, t); },\n      preUpdate() { this.pluginEvents.emit(g.PRE_UPDATE); const t = this._pendingRemoval; const e = this._pendingInsertion; const i = t.length; const n = e.length; if (i !== 0 || n !== 0) { for (var s = this._list, r = 0; r < i; r++) { const o = t[r]; const a = s.indexOf(o); a > -1 && (s.splice(a, 1), this.clear(o, !0)); }t.length = 0, this._pendingRemoval.length = 0, this._list = s.concat(e.splice(0)); } },\n      isActive() { return this.enabled && this.scene.sys.isActive(); },\n      updatePoll(t, e) { if (!this.isActive()) return !1; if (this.pluginEvents.emit(g.UPDATE, t, e), this._updatedThisFrame) return this._updatedThisFrame = !1; for (var i = this.manager, n = i.pointers, s = i.pointersTotal, r = 0; r < s; r++)n[r].updateMotion(); if (this._list.length === 0) return !1; const o = this.pollRate; if (o === -1) return !1; if (o > 0) { if (this._pollTimer -= e, !(this._pollTimer < 0)) return !1; this._pollTimer = this.pollRate; } let a = !1; for (r = 0; r < s; r++) { let h = 0; const l = n[r]; this._tempZones = [], this._temp = this.hitTestPointer(l), this.sortGameObjects(this._temp), this.sortGameObjects(this._tempZones), this.topOnly && (this._temp.length && this._temp.splice(1), this._tempZones.length && this._tempZones.splice(1)), h += this.processOverOutEvents(l), this.getDragState(l) === 2 && this.processDragThresholdEvent(l, t), h > 0 && (a = !0); } return a; },\n      update(t, e) { if (!this.isActive()) return !1; for (var i = e.length, n = !1, s = 0; s < i; s++) { let r = 0; const o = e[s]; switch (this._tempZones = [], this._temp = this.hitTestPointer(o), this.sortGameObjects(this._temp), this.sortGameObjects(this._tempZones), this.topOnly && (this._temp.length && this._temp.splice(1), this._tempZones.length && this._tempZones.splice(1)), t) { case h.MOUSE_DOWN: r += this.processDragDownEvent(o), r += this.processDownEvents(o), r += this.processOverOutEvents(o); break; case h.MOUSE_UP: r += this.processDragUpEvent(o), r += this.processUpEvents(o), r += this.processOverOutEvents(o); break; case h.TOUCH_START: r += this.processDragDownEvent(o), r += this.processDownEvents(o), r += this.processOverEvents(o); break; case h.TOUCH_END: case h.TOUCH_CANCEL: r += this.processDragUpEvent(o), r += this.processUpEvents(o), r += this.processOutEvents(o); break; case h.MOUSE_MOVE: case h.TOUCH_MOVE: r += this.processDragMoveEvent(o), r += this.processMoveEvents(o), r += this.processOverOutEvents(o); break; case h.MOUSE_WHEEL: r += this.processWheelEvent(o); }r > 0 && (n = !0); } return this._updatedThisFrame = !0, n; },\n      clear(t, e) { void 0 === e && (e = !1); const i = t.input; if (i) { e || this.queueForRemoval(t), i.gameObject = void 0, i.target = void 0, i.hitArea = void 0, i.hitAreaCallback = void 0, i.callbackContext = void 0, this.manager.resetCursor(i), t.input = null; let n = this._draggable.indexOf(t); return n > -1 && this._draggable.splice(n, 1), (n = this._drag[0].indexOf(t)) > -1 && this._drag[0].splice(n, 1), (n = this._over[0].indexOf(t)) > -1 && this._over[0].splice(n, 1), t; } },\n      disable(t) { t.input.enabled = !1; },\n      enable(t, e, i, n) { return void 0 === n && (n = !1), t.input ? t.input.enabled = !0 : this.setHitArea(t, e, i), t.input && n && !t.input.dropZone && (t.input.dropZone = n), this; },\n      hitTestPointer(t) { for (var e = this.cameras.getCamerasBelowPointer(t), i = 0; i < e.length; i++) { for (var n = e[i], s = this.manager.hitTest(t, this._list, n), r = 0; r < s.length; r++) { const o = s[r]; o.input.dropZone && this._tempZones.push(o); } if (s.length > 0) return t.camera = n, s; } return t.camera = e[0], []; },\n      processDownEvents(t) { for (var e = 0, i = this._temp, n = this._eventData, s = this._eventContainer, r = n.cancelled = !1, o = 0; o < i.length; o++) { const a = i[o]; if (a.input) { if (e++, a.emit(g.GAMEOBJECT_POINTER_DOWN, t, a.input.localX, a.input.localY, s), n.cancelled || !a.input) { r = !0; break; } if (this.emit(g.GAMEOBJECT_DOWN, t, a, s), n.cancelled || !a.input) { r = !0; break; } } } return !r && this.manager && (t.downElement === this.manager.game.canvas ? this.emit(g.POINTER_DOWN, t, i) : this.emit(g.POINTER_DOWN_OUTSIDE, t)), e; },\n      getDragState(t) { return this._dragState[t.id]; },\n      setDragState(t, e) { this._dragState[t.id] = e; },\n      processDragThresholdEvent(t, e) { let i = !1; const n = this.dragTimeThreshold; const s = this.dragDistanceThreshold; if ((s > 0 && r(t.x, t.y, t.downX, t.downY) >= s || n > 0 && e >= t.downTime + n) && (i = !0), i) return this.setDragState(t, 3), this.processDragStartList(t); },\n      processDragStartList(t) { if (this.getDragState(t) !== 3) return 0; for (var e = this._drag[t.id], i = 0; i < e.length; i++) { const n = e[i]; const s = n.input; s.dragState = 2, s.dragStartX = n.x, s.dragStartY = n.y, s.dragStartXGlobal = t.worldX, s.dragStartYGlobal = t.worldY, s.dragX = s.dragStartXGlobal - s.dragStartX, s.dragY = s.dragStartYGlobal - s.dragStartY, n.emit(g.GAMEOBJECT_DRAG_START, t, s.dragX, s.dragY), this.emit(g.DRAG_START, t, n); } return this.setDragState(t, 4), e.length; },\n      processDragDownEvent(t) { const e = this._temp; if (this._draggable.length === 0 || e.length === 0 || !t.primaryDown || this.getDragState(t) !== 0) return 0; this.setDragState(t, 1); for (var i = [], n = 0; n < e.length; n++) { const s = e[n]; s.input.draggable && s.input.dragState === 0 && i.push(s); } return i.length === 0 ? (this.setDragState(t, 0), 0) : (i.length > 1 && (this.sortGameObjects(i), this.topOnly && i.splice(1)), this._drag[t.id] = i, this.dragDistanceThreshold === 0 && this.dragTimeThreshold === 0 ? (this.setDragState(t, 3), this.processDragStartList(t)) : (this.setDragState(t, 2), 0)); },\n      processDragMoveEvent(t) { if (this.getDragState(t) === 2 && this.processDragThresholdEvent(t, this.manager.game.loop.now), this.getDragState(t) !== 4) return 0; for (var e = this._tempZones, i = this._drag[t.id], n = 0; n < i.length; n++) { var s; var r; var o; var a; var h; var l; var u; var c; const d = i[n]; const f = d.input; let p = f.target; p ? (s = e.indexOf(p)) === 0 ? (d.emit(g.GAMEOBJECT_DRAG_OVER, t, p), this.emit(g.DRAG_OVER, t, d, p)) : s > 0 ? (d.emit(g.GAMEOBJECT_DRAG_LEAVE, t, p), this.emit(g.DRAG_LEAVE, t, d, p), f.target = e[0], p = f.target, d.emit(g.GAMEOBJECT_DRAG_ENTER, t, p), this.emit(g.DRAG_ENTER, t, d, p)) : (d.emit(g.GAMEOBJECT_DRAG_LEAVE, t, p), this.emit(g.DRAG_LEAVE, t, d, p), e[0] ? (f.target = e[0], p = f.target, d.emit(g.GAMEOBJECT_DRAG_ENTER, t, p), this.emit(g.DRAG_ENTER, t, d, p)) : f.target = null) : !p && e[0] && (f.target = e[0], p = f.target, d.emit(g.GAMEOBJECT_DRAG_ENTER, t, p), this.emit(g.DRAG_ENTER, t, d, p)), o = d.parentContainer ? (a = t.worldX - f.dragStartXGlobal, h = t.worldY - f.dragStartYGlobal, l = d.getParentRotation(), u = a * Math.cos(l) + h * Math.sin(l), c = h * Math.cos(l) - a * Math.sin(l), u *= 1 / d.parentContainer.scaleX, c *= 1 / d.parentContainer.scaleY, r = u + f.dragStartX, c + f.dragStartY) : (r = t.worldX - f.dragX, t.worldY - f.dragY), d.emit(g.GAMEOBJECT_DRAG, t, r, o), this.emit(g.DRAG, t, d, r, o); } return i.length; },\n      processDragUpEvent(t) { for (var e = this._drag[t.id], i = 0; i < e.length; i++) { var n; var s; const r = e[i]; const o = r.input; o && o.dragState === 2 && (o.dragState = 0, o.dragX = o.localX - r.displayOriginX, o.dragY = o.localY - r.displayOriginY, n = !1, (s = o.target) && (r.emit(g.GAMEOBJECT_DROP, t, s), this.emit(g.DROP, t, r, s), n = !(o.target = null)), r.input && (r.emit(g.GAMEOBJECT_DRAG_END, t, o.dragX, o.dragY, n), this.emit(g.DRAG_END, t, r, n))); } return this.setDragState(t, 0), e.splice(0), 0; },\n      processMoveEvents(t) { for (var e = 0, i = this._temp, n = this._eventData, s = this._eventContainer, r = n.cancelled = !1, o = 0; o < i.length; o++) { const a = i[o]; if (a.input) { if (e++, a.emit(g.GAMEOBJECT_POINTER_MOVE, t, a.input.localX, a.input.localY, s), n.cancelled || !a.input) { r = !0; break; } if (this.emit(g.GAMEOBJECT_MOVE, t, a, s), n.cancelled || !a.input) { r = !0; break; } if (this.topOnly) break; } } return r || this.emit(g.POINTER_MOVE, t, i), e; },\n      processWheelEvent(t) { for (var e = 0, i = this._temp, n = this._eventData, s = this._eventContainer, r = n.cancelled = !1, o = t.deltaX, a = t.deltaY, h = t.deltaZ, l = 0; l < i.length; l++) { const u = i[l]; if (u.input) { if (e++, u.emit(g.GAMEOBJECT_POINTER_WHEEL, t, o, a, h, s), n.cancelled || !u.input) { r = !0; break; } if (this.emit(g.GAMEOBJECT_WHEEL, t, u, o, a, h, s), n.cancelled || !u.input) { r = !0; break; } } } return r || this.emit(g.POINTER_WHEEL, t, i, o, a, h), e; },\n      processOverEvents(t) { const e = this._temp; let i = 0; const n = e.length; const s = []; if (n > 0) { for (var r = this.manager, o = this._eventData, a = this._eventContainer, h = o.cancelled = !1, l = 0; l < n; l++) { const u = e[l]; if (u.input) { if (s.push(u), r.setCursor(u.input), u.emit(g.GAMEOBJECT_POINTER_OVER, t, u.input.localX, u.input.localY, a), i++, o.cancelled || !u.input) { h = !0; break; } if (this.emit(g.GAMEOBJECT_OVER, t, u, a), o.cancelled || !u.input) { h = !0; break; } } }h || this.emit(g.POINTER_OVER, t, s); } return this._over[t.id] = s, i; },\n      processOutEvents(t) { const e = this._over[t.id]; let i = 0; const n = e.length; if (n > 0) { const s = this.manager; const r = this._eventData; const o = this._eventContainer; let a = r.cancelled = !1; this.sortGameObjects(e); for (var h = 0; h < n; h++) { for (var l = e[h], h = 0; h < n; h++) if ((l = e[h]).input) { if (s.resetCursor(l.input), l.emit(g.GAMEOBJECT_POINTER_OUT, t, o), i++, r.cancelled || !l.input) { a = !0; break; } if (this.emit(g.GAMEOBJECT_OUT, t, l, o), r.cancelled || !l.input) { a = !0; break; } }a || this.emit(g.POINTER_OUT, t, e); } this._over[t.id] = []; } return i; },\n      processOverOutEvents(t) { for (var e, i = this._temp, n = [], s = [], r = [], o = this._over[t.id], a = this._drag[t.id], h = this.manager, l = 0; l < o.length; l++)e = o[l], i.indexOf(e) === -1 && a.indexOf(e) === -1 ? n.push(e) : r.push(e); for (l = 0; l < i.length; l++)e = i[l], o.indexOf(e) === -1 && s.push(e); let u = n.length; let c = 0; const d = this._eventData; const f = this._eventContainer; let p = d.cancelled = !1; if (u > 0) { for (this.sortGameObjects(n), l = 0; l < u; l++) if ((e = n[l]).input) { if (h.resetCursor(e.input), e.emit(g.GAMEOBJECT_POINTER_OUT, t, f), c++, d.cancelled || !e.input) { p = !0; break; } if (this.emit(g.GAMEOBJECT_OUT, t, e, f), d.cancelled || !e.input) { p = !0; break; } }p || this.emit(g.POINTER_OUT, t, n); } if (u = s.length, p = d.cancelled = !1, u > 0) { for (this.sortGameObjects(s), l = 0; l < u; l++) if ((e = s[l]).input) { if (h.setCursor(e.input), e.emit(g.GAMEOBJECT_POINTER_OVER, t, e.input.localX, e.input.localY, f), c++, d.cancelled || !e.input) { p = !0; break; } if (this.emit(g.GAMEOBJECT_OVER, t, e, f), d.cancelled || !e.input) { p = !0; break; } }p || this.emit(g.POINTER_OVER, t, s); } return o = r.concat(s), this._over[t.id] = this.sortGameObjects(o), c; },\n      processUpEvents(t) { for (var e = this._temp, i = this._eventData, n = this._eventContainer, s = i.cancelled = !1, r = 0; r < e.length; r++) { const o = e[r]; if (o.input) { if (o.emit(g.GAMEOBJECT_POINTER_UP, t, o.input.localX, o.input.localY, n), i.cancelled || !o.input) { s = !0; break; } if (this.emit(g.GAMEOBJECT_UP, t, o, n), i.cancelled || !o.input) { s = !0; break; } } } return !s && this.manager && (t.upElement === this.manager.game.canvas ? this.emit(g.POINTER_UP, t, e) : this.emit(g.POINTER_UP_OUTSIDE, t)), e.length; },\n      queueForInsertion(t) { return this._pendingInsertion.indexOf(t) === -1 && this._list.indexOf(t) === -1 && this._pendingInsertion.push(t), this; },\n      queueForRemoval(t) { return this._pendingRemoval.push(t), this; },\n      setDraggable(t, e) { void 0 === e && (e = !0), Array.isArray(t) || (t = [t]); for (let i = 0; i < t.length; i++) { const n = t[i]; n.input.draggable = e; const s = this._draggable.indexOf(n); e && s === -1 ? this._draggable.push(n) : !e && s > -1 && this._draggable.splice(s, 1); } return this; },\n      makePixelPerfect(t) { void 0 === t && (t = 1); const e = this.systems.textures; return s(e, t); },\n      setHitArea(t, e, i) { if (void 0 === e) return this.setHitAreaFromTexture(t); Array.isArray(t) || (t = [t]); let n; let s; let r = !1; let o = !1; let a = !1; let h = !1; let l = !1; let u = !0; m(e) ? (e = v(n = e, 'hitArea', null), i = v(n, 'hitAreaCallback', null), r = v(n, 'draggable', !1), o = v(n, 'dropZone', !1), a = v(n, 'cursor', !1), h = v(n, 'useHandCursor', !1), l = v(n, 'pixelPerfect', !1), s = v(n, 'alphaTolerance', 1), l && (e = {}, i = this.makePixelPerfect(s)), e && i || (this.setHitAreaFromTexture(t), u = !1)) : typeof e !== 'function' || i || (i = e, e = {}); for (let c = 0; c < t.length; c++) { var d; const f = t[c]; l && f.type === 'Container' ? console.warn('Cannot pixelPerfect test a Container. Use a custom callback.') : ((d = f.input ? f.input : p(f, e, i)).customHitArea = u, d.dropZone = o, d.cursor = h ? 'pointer' : a, f.input = d, r && this.setDraggable(f), this.queueForInsertion(f)); } return this; },\n      setHitAreaCircle(t, e, i, n, s) { void 0 === s && (s = a); const r = new o(e, i, n); return this.setHitArea(t, r, s); },\n      setHitAreaEllipse(t, e, i, n, s, r) { void 0 === r && (r = u); const o = new l(e, i, n, s); return this.setHitArea(t, o, r); },\n      setHitAreaFromTexture(t, e) { void 0 === e && (e = T), Array.isArray(t) || (t = [t]); for (let i = 0; i < t.length; i++) { const n = t[i]; const s = n.frame; let r = 0; let o = 0; n.width ? (r = n.width, o = n.height) : s && (r = s.realWidth, o = s.realHeight), n.type !== 'Container' || r !== 0 && o !== 0 ? r !== 0 && o !== 0 && (n.input = p(n, new x(0, 0, r, o), e), this.queueForInsertion(n)) : console.warn('Container.setInteractive must specify a Shape or call setSize() first'); } return this; },\n      setHitAreaRectangle(t, e, i, n, s, r) { void 0 === r && (r = T); const o = new x(e, i, n, s); return this.setHitArea(t, o, r); },\n      setHitAreaTriangle(t, e, i, n, s, r, o, a) { void 0 === a && (a = E); const h = new b(e, i, n, s, r, o); return this.setHitArea(t, h, a); },\n      enableDebug(o, a) { void 0 === a && (a = 65280); const t = o.input; if (!t || !t.hitArea) return this; const e = t.hitArea; const i = e.type; let h = t.hitAreaDebug; const n = this.systems.add; const s = this.systems.updateList; h && (s.remove(h), h.destroy(), h = null); let l = 0; let u = 0; switch (i) { case d.CIRCLE: h = n.arc(0, 0, e.radius), l = e.x - e.radius, u = e.y - e.radius; break; case d.ELLIPSE: h = n.ellipse(0, 0, e.width, e.height), l = e.x - e.width / 2, u = e.y - e.height / 2; break; case d.LINE: h = n.line(0, 0, e.x1, e.y1, e.x2, e.y2); break; case d.POLYGON: h = n.polygon(0, 0, e.points); break; case d.RECTANGLE: h = n.rectangle(0, 0, e.width, e.height), l = e.x, u = e.y; break; case d.TRIANGLE: h = n.triangle(0, 0, e.x1, e.y1, e.x2, e.y2, e.x3, e.y3); } return h && (h.isFilled = !1, h.preUpdate = function () { h.setStrokeStyle(1 / o.scale, a), h.setDisplayOrigin(o.displayOriginX, o.displayOriginY); let t; let e = o.x; let i = o.y; let n = o.rotation; let s = o.scaleX; let r = o.scaleY; o.parentContainer && (e = (t = o.getWorldTransformMatrix()).tx, i = t.ty, n = t.rotation, s = t.scaleX, r = t.scaleY), h.setRotation(n), h.setScale(s, r), h.setPosition(e + l, i + u), h.setScrollFactor(o.scrollFactorX, o.scrollFactorY), h.setDepth(o.depth); }, s.add(h), t.hitAreaDebug = h), this; },\n      removeDebug(t) { let e; const i = t.input; return i && i.hitAreaDebug && (e = i.hitAreaDebug, this.systems.updateList.remove(e), e.destroy(), i.hitAreaDebug = null), this; },\n      setPollAlways() { return this.setPollRate(0); },\n      setPollOnMove() { return this.setPollRate(-1); },\n      setPollRate(t) { return this.pollRate = t, this._pollTimer = 0, this; },\n      setGlobalTopOnly(t) { return this.manager.globalTopOnly = t, this; },\n      setTopOnly(t) { return this.topOnly = t, this; },\n      sortGameObjects(t) { return t.length < 2 ? t : (this.scene.sys.depthSort(), t.sort(this.sortHandlerGO.bind(this))); },\n      sortHandlerGO(t, e) { if (t.parentContainer || e.parentContainer) { if (t.parentContainer === e.parentContainer) return e.parentContainer.getIndex(e) - t.parentContainer.getIndex(t); if (t.parentContainer === e) return -1; if (e.parentContainer === t) return 1; for (var i = t.getIndexList(), n = e.getIndexList(), s = Math.min(i.length, n.length), r = 0; r < s; r++) { const o = i[r]; const a = n[r]; if (o !== a) return a - o; } return n.length - i.length; } return this.displayList.getIndex(e) - this.displayList.getIndex(t); },\n      stopPropagation() { return this.manager._tempSkip = !0, this; },\n      addPointer(t) { return this.manager.addPointer(t); },\n      setDefaultCursor(t) { return this.manager.setDefaultCursor(t), this; },\n      transitionIn() { this.enabled = this.settings.transitionAllowInput; },\n      transitionComplete() { this.settings.transitionAllowInput || (this.enabled = !0); },\n      transitionOut() { this.enabled = this.settings.transitionAllowInput; },\n      shutdown() { this.pluginEvents.emit(g.SHUTDOWN), this._temp.length = 0, this._list.length = 0, this._draggable.length = 0, this._pendingRemoval.length = 0, this._pendingInsertion.length = 0; for (let t = this._dragState.length = 0; t < 10; t++) this._drag[t] = [], this._over[t] = []; this.removeAllListeners(); const e = this.systems.events; e.off(w.TRANSITION_START, this.transitionIn, this), e.off(w.TRANSITION_OUT, this.transitionOut, this), e.off(w.TRANSITION_COMPLETE, this.transitionComplete, this), e.off(w.PRE_UPDATE, this.preUpdate, this), this.manager.events.off(g.GAME_OUT, this.onGameOut, this), this.manager.events.off(g.GAME_OVER, this.onGameOver, this), e.off(w.SHUTDOWN, this.shutdown, this); },\n      destroy() { this.shutdown(), this.pluginEvents.emit(g.DESTROY), this.pluginEvents.removeAllListeners(), this.scene.sys.events.off(w.START, this.start, this), this.scene = null, this.cameras = null, this.manager = null, this.events = null, this.mouse = null; },\n      x: { get() { return this.manager.activePointer.x; } },\n      y: { get() { return this.manager.activePointer.y; } },\n      isOver: { get() { return this.manager.isOver; } },\n      mousePointer: { get() { return this.manager.mousePointer; } },\n      activePointer: { get() { return this.manager.activePointer; } },\n      pointer1: { get() { return this.manager.pointers[1]; } },\n      pointer2: { get() { return this.manager.pointers[2]; } },\n      pointer3: { get() { return this.manager.pointers[3]; } },\n      pointer4: { get() { return this.manager.pointers[4]; } },\n      pointer5: { get() { return this.manager.pointers[5]; } },\n      pointer6: { get() { return this.manager.pointers[6]; } },\n      pointer7: { get() { return this.manager.pointers[7]; } },\n      pointer8: { get() { return this.manager.pointers[8]; } },\n      pointer9: { get() { return this.manager.pointers[9]; } },\n      pointer10: { get() { return this.manager.pointers[10]; } },\n    }); y.register('InputPlugin', S, 'input'), t.exports = S;\n  }, function (t, e) { t.exports = function (r, o) { return function (t, e, i, n) { const s = r.getPixelAlpha(e, i, n.texture.key, n.frame.name); return s && o <= s; }; }; }, function (t, e, i) {\n    t.exports = {\n      Events: i(137), KeyboardManager: i(366), KeyboardPlugin: i(1224), Key: i(453), KeyCodes: i(124), KeyCombo: i(454), JustDown: i(1229), JustUp: i(1230), DownDuration: i(1231), UpDuration: i(1232),\n    };\n  }, function (t, e) { t.exports = 'keydown'; }, function (t, e) { t.exports = 'keyup'; }, function (t, e) { t.exports = 'keycombomatch'; }, function (t, e) { t.exports = 'down'; }, function (t, e) { t.exports = 'keydown-'; }, function (t, e) { t.exports = 'keyup-'; }, function (t, e) { t.exports = 'up'; }, function (t, e, i) {\n    const n = i(0); const s = i(10); const h = i(137); const r = i(20); const o = i(6); const a = i(54); const l = i(136); const u = i(453); const c = i(124); const d = i(454); const f = i(1228); const p = i(93); const g = new n({\n      Extends: s,\n      initialize(t) { s.call(this), this.game = t.systems.game, this.scene = t.scene, this.settings = this.scene.sys.settings, this.sceneInputPlugin = t, this.manager = t.manager.keyboard, this.enabled = !0, this.keys = [], this.combos = [], t.pluginEvents.once(a.BOOT, this.boot, this), t.pluginEvents.on(a.START, this.start, this); },\n      boot() { const t = this.settings.input; this.enabled = o(t, 'keyboard', !0); const e = o(t, 'keyboard.capture', null); e && this.addCaptures(e), this.sceneInputPlugin.pluginEvents.once(a.DESTROY, this.destroy, this); },\n      start() { this.sceneInputPlugin.manager.useQueue ? this.sceneInputPlugin.pluginEvents.on(a.UPDATE, this.update, this) : this.sceneInputPlugin.manager.events.on(a.MANAGER_PROCESS, this.update, this), this.sceneInputPlugin.pluginEvents.once(a.SHUTDOWN, this.shutdown, this), this.game.events.on(r.BLUR, this.resetKeys, this); },\n      isActive() { return this.enabled && this.scene.sys.isActive(); },\n      addCapture(t) { return this.manager.addCapture(t), this; },\n      removeCapture(t) { return this.manager.removeCapture(t), this; },\n      getCaptures() { return this.manager.captures; },\n      enableGlobalCapture() { return this.manager.preventDefault = !0, this; },\n      disableGlobalCapture() { return this.manager.preventDefault = !1, this; },\n      clearCaptures() { return this.manager.clearCaptures(), this; },\n      createCursorKeys() {\n        return this.addKeys({\n          up: c.UP, down: c.DOWN, left: c.LEFT, right: c.RIGHT, space: c.SPACE, shift: c.SHIFT,\n        });\n      },\n      addKeys(t, e, i) { void 0 === e && (e = !0), void 0 === i && (i = !1); const n = {}; if (typeof t === 'string') { t = t.split(','); for (let s = 0; s < t.length; s++) { const r = t[s].trim(); r && (n[r] = this.addKey(r, e, i)); } } else for (const o in t)n[o] = this.addKey(t[o], e, i); return n; },\n      addKey(t, e, i) { void 0 === e && (e = !0), void 0 === i && (i = !1); const n = this.keys; if (t instanceof u) { const s = n.indexOf(t); return s > -1 ? n[s] = t : n[t.keyCode] = t, e && this.addCapture(t.keyCode), t.setEmitOnRepeat(i), t; } return typeof t === 'string' && (t = c[t.toUpperCase()]), n[t] || (n[t] = new u(this, t), e && this.addCapture(t), n[t].setEmitOnRepeat(i)), n[t]; },\n      removeKey(t, e) { void 0 === e && (e = !1); let i; let n; const s = this.keys; return t instanceof u ? (n = s.indexOf(t)) > -1 && (i = this.keys[n], this.keys[n] = void 0) : typeof t === 'string' && (t = c[t.toUpperCase()]), s[t] && (i = s[t], s[t] = void 0), i && (i.plugin = null, e && i.destroy()), this; },\n      removeAllKeys(t) { for (let e = this.keys, i = 0; i < e.length; i++) { const n = e[i]; n && (e[i] = void 0, t && n.destroy()); } return this; },\n      createCombo(t, e) { return new d(this, t, e); },\n      checkDown(t, e) { if (void 0 === e && (e = 0), this.enabled && t.isDown) { const i = p(this.time - t.timeDown, e); if (i > t._tick) return t._tick = i, !0; } return !1; },\n      update() { const t = this.manager.queue; const e = t.length; if (this.isActive() && e !== 0) for (let i = this.keys, n = 0; n < e; n++) { var s = t[n]; const r = s.keyCode; const o = i[r]; let a = !1; void 0 === s.cancelled && (s.cancelled = 0, s.stopImmediatePropagation = function () { s.cancelled = 1; }, s.stopPropagation = function () { s.cancelled = -1; }), s.cancelled !== -1 && (s.type === 'keydown' ? (o && (a = o.isDown, o.onDown(s)), s.cancelled || o && a || (f[r] && (this.emit(h.KEY_DOWN + f[r], s), this.emit(`keydown_${f[r]}`, s)), s.cancelled || this.emit(h.ANY_KEY_DOWN, s))) : (o && o.onUp(s), s.cancelled || (f[r] && (this.emit(h.KEY_UP + f[r], s), this.emit(`keyup_${f[r]}`, s)), s.cancelled || this.emit(h.ANY_KEY_UP, s))), s.cancelled === 1 && (s.cancelled = 0)); } },\n      resetKeys() { for (let t = this.keys, e = 0; e < t.length; e++)t[e] && t[e].reset(); return this; },\n      shutdown() { this.resetKeys(), this.sceneInputPlugin.manager.useQueue ? this.sceneInputPlugin.pluginEvents.off(a.UPDATE, this.update, this) : this.sceneInputPlugin.manager.events.off(a.MANAGER_PROCESS, this.update, this), this.game.events.off(r.BLUR, this.resetKeys), this.removeAllListeners(), this.queue = []; },\n      destroy() { this.shutdown(); for (let t = this.keys, e = 0; e < t.length; e++)t[e] && t[e].destroy(); this.keys = [], this.combos = [], this.queue = [], this.scene = null, this.settings = null, this.sceneInputPlugin = null, this.manager = null; },\n      time: { get() { return this.sceneInputPlugin.manager.time; } },\n    }); l.register('KeyboardPlugin', g, 'keyboard', 'keyboard', 'inputKeyboard'), t.exports = g;\n  }, function (t, e, i) { const r = i(1226); t.exports = function (t, e) { if (e.matched) return !0; let i; let n = !1; let s = !1; return t.keyCode === e.current && (e.index > 0 && e.maxKeyDelay > 0 ? (i = e.timeLastMatched + e.maxKeyDelay, t.timeStamp <= i && (s = !0, n = r(t, e))) : (s = !0, n = r(t, e))), !s && e.resetOnWrongKey && (e.index = 0, e.current = e.keyCodes[0]), n && (e.timeLastMatched = t.timeStamp, e.matched = !0, e.timeMatched = t.timeStamp), n; }; }, function (t, e) { t.exports = function (t, e) { return e.timeLastMatched = t.timeStamp, e.index++, e.index === e.size || (e.current = e.keyCodes[e.index], !1); }; }, function (t, e) { t.exports = function (t) { return t.current = t.keyCodes[0], t.index = 0, t.timeLastMatched = 0, t.matched = !1, t.timeMatched = 0, t; }; }, function (t, e, i) { const n = i(124); const s = {}; for (const r in n)s[n[r]] = r; t.exports = s; }, function (t, e) { t.exports = function (t) { return !!t._justDown && !(t._justDown = !1); }; }, function (t, e) { t.exports = function (t) { return !!t._justUp && !(t._justUp = !1); }; }, function (t, e) { t.exports = function (t, e) { void 0 === e && (e = 50); const i = t.plugin.game.loop.time - t.timeDown; return t.isDown && i < e; }; }, function (t, e) { t.exports = function (t, e) { void 0 === e && (e = 50); const i = t.plugin.game.loop.time - t.timeUp; return t.isUp && i < e; }; }, function (t, e, i) { t.exports = { MouseManager: i(367) }; }, function (t, e, i) { t.exports = { TouchManager: i(369) }; }, function (t, e, i) {\n    const n = i(17); var s = i(18)(!1, s = {\n      Events: i(82), FileTypes: i(1236), File: i(21), FileTypesManager: i(8), GetURL: i(138), LoaderPlugin: i(1260), MergeXHRSettings: i(215), MultiFile: i(61), XHRLoader: i(455), XHRSettings: i(139),\n    }, n); t.exports = s;\n  }, function (t, e, i) {\n    t.exports = {\n      AnimationJSONFile: i(1237), AtlasJSONFile: i(1238), AtlasXMLFile: i(1239), AudioFile: i(456), AudioSpriteFile: i(1240), BinaryFile: i(1241), BitmapFontFile: i(1242), CSSFile: i(1243), GLSLFile: i(1244), HTML5AudioFile: i(457), HTMLFile: i(1245), HTMLTextureFile: i(1246), ImageFile: i(72), JSONFile: i(60), MultiAtlasFile: i(1247), MultiScriptFile: i(1248), PackFile: i(1249), PluginFile: i(1250), SceneFile: i(1251), ScenePluginFile: i(1252), ScriptFile: i(458), SpriteSheetFile: i(1253), SVGFile: i(1254), TextFile: i(459), TilemapCSVFile: i(1255), TilemapImpactFile: i(1256), TilemapJSONFile: i(1257), UnityAtlasFile: i(1258), VideoFile: i(1259), XMLFile: i(216),\n    };\n  }, function (t, e, i) {\n    const n = i(0); const s = i(8); const r = i(60); const o = i(82); const a = new n({\n      Extends: r, initialize(t, e, i, n, s) { r.call(this, t, e, i, n, s), this.type = 'animationJSON'; }, onProcess() { this.loader.once(o.POST_PROCESS, this.onLoadComplete, this), r.prototype.onProcess.call(this); }, onLoadComplete() { this.loader.systems.anims.fromJSON(this.data); },\n    }); s.register('animation', function (t, e, i, n) { if (Array.isArray(t)) for (let s = 0; s < t.length; s++) this.addFile(new a(this, t[s])); else this.addFile(new a(this, t, e, n, i)); return this; }), t.exports = a;\n  }, function (t, e, i) {\n    const n = i(0); const s = i(8); const l = i(2); const u = i(72); const c = i(7); const d = i(60); const f = i(61); const a = new n({\n      Extends: f,\n      initialize(t, e, i, n, s, r) {\n        let o; let a; const h = c(e) ? (e = l(a = e, 'key'), o = new u(t, {\n          key: e, url: l(a, 'textureURL'), extension: l(a, 'textureExtension', 'png'), normalMap: l(a, 'normalMap'), xhrSettings: l(a, 'textureXhrSettings'),\n        }), new d(t, {\n          key: e, url: l(a, 'atlasURL'), extension: l(a, 'atlasExtension', 'json'), xhrSettings: l(a, 'atlasXhrSettings'),\n        })) : (o = new u(t, e, i, s), new d(t, e, n, r)); o.linkFile ? f.call(this, t, 'atlasjson', e, [o, h, o.linkFile]) : f.call(this, t, 'atlasjson', e, [o, h]);\n      },\n      addToCache() { let t; let e; let i; this.isReadyToProcess() && (t = this.files[0], e = this.files[1], i = this.files[2] ? this.files[2].data : null, this.loader.textureManager.addAtlas(t.key, t.data, e.data, i), e.addToCache(), this.complete = !0); },\n    }); s.register('atlas', function (t, e, i, n, s) { let r; if (Array.isArray(t)) for (let o = 0; o < t.length; o++)r = new a(this, t[o]), this.addFile(r.files); else r = new a(this, t, e, i, n, s), this.addFile(r.files); return this; }), t.exports = a;\n  }, function (t, e, i) {\n    const n = i(0); const s = i(8); const l = i(2); const u = i(72); const c = i(7); const d = i(61); const f = i(216); const a = new n({\n      Extends: d,\n      initialize(t, e, i, n, s, r) {\n        let o; let a; const h = c(e) ? (e = l(a = e, 'key'), o = new u(t, {\n          key: e, url: l(a, 'textureURL'), extension: l(a, 'textureExtension', 'png'), normalMap: l(a, 'normalMap'), xhrSettings: l(a, 'textureXhrSettings'),\n        }), new f(t, {\n          key: e, url: l(a, 'atlasURL'), extension: l(a, 'atlasExtension', 'xml'), xhrSettings: l(a, 'atlasXhrSettings'),\n        })) : (o = new u(t, e, i, s), new f(t, e, n, r)); o.linkFile ? d.call(this, t, 'atlasxml', e, [o, h, o.linkFile]) : d.call(this, t, 'atlasxml', e, [o, h]);\n      },\n      addToCache() { let t; let e; let i; this.isReadyToProcess() && (t = this.files[0], e = this.files[1], i = this.files[2] ? this.files[2].data : null, this.loader.textureManager.addAtlasXML(t.key, t.data, e.data, i), e.addToCache(), this.complete = !0); },\n    }); s.register('atlasXML', function (t, e, i, n, s) { let r; if (Array.isArray(t)) for (let o = 0; o < t.length; o++)r = new a(this, t[o]), this.addFile(r.files); else r = new a(this, t, e, i, n, s), this.addFile(r.files); return this; }), t.exports = a;\n  }, function (t, e, i) {\n    const u = i(456); const n = i(0); const s = i(8); const c = i(2); const d = i(7); const f = i(60); const p = i(61); const g = new n({\n      Extends: p, initialize(t, e, i, n, s, r, o) { let a; let h; let l; d(e) && (e = c(a = e, 'key'), i = c(a, 'jsonURL'), n = c(a, 'audioURL'), s = c(a, 'audioConfig'), r = c(a, 'audioXhrSettings'), o = c(a, 'jsonXhrSettings')), n ? (l = u.create(t, e, n, s, r)) && (h = new f(t, e, i, o), p.call(this, t, 'audiosprite', e, [l, h]), this.config.resourceLoad = !1) : (h = new f(t, e, i, o), p.call(this, t, 'audiosprite', e, [h]), this.config.resourceLoad = !0, this.config.audioConfig = s, this.config.audioXhrSettings = r); }, onFileComplete(t) { let e; let i; let n; let s; this.files.indexOf(t) !== -1 && (this.pending--, this.config.resourceLoad && t.type === 'json' && t.data.hasOwnProperty('resources') && (e = t.data.resources, i = c(this.config, 'audioConfig'), n = c(this.config, 'audioXhrSettings'), (s = u.create(this.loader, t.key, e, i, n)) && (this.addToMultiFile(s), this.loader.addFile(s)))); }, addToCache() { let t; let e; this.isReadyToProcess() && (t = this.files[0], e = this.files[1], t.addToCache(), e.addToCache(), this.complete = !0); },\n    }); s.register('audioSprite', function (t, e, i, n, s, r) { let o; const a = this.systems.game; const h = a.config.audio; const l = a.device.audio; if (h && h.noAudio || !l.webAudio && !l.audioData) return this; if (Array.isArray(t)) for (let u = 0; u < t.length; u++)(o = new g(this, t[u])).files && this.addFile(o.files); else (o = new g(this, t, e, i, n, s, r)).files && this.addFile(o.files); return this; });\n  }, function (t, e, i) {\n    const n = i(0); const s = i(17); const h = i(21); const r = i(8); const l = i(2); const u = i(7); const o = new n({\n      Extends: h,\n      initialize(t, e, i, n, s) {\n        let r; let o = 'bin'; u(e) && (e = l(r = e, 'key'), i = l(r, 'url'), n = l(r, 'xhrSettings'), o = l(r, 'extension', o), s = l(r, 'dataType', s)); const a = {\n          type: 'binary', cache: t.cacheManager.binary, extension: o, responseType: 'arraybuffer', key: e, url: i, xhrSettings: n, config: { dataType: s },\n        }; h.call(this, t, a);\n      },\n      onProcess() { this.state = s.FILE_PROCESSING; const t = this.config.dataType; this.data = t ? new t(this.xhrLoader.response) : this.xhrLoader.response, this.onProcessComplete(); },\n    }); r.register('binary', function (t, e, i, n) { if (Array.isArray(t)) for (let s = 0; s < t.length; s++) this.addFile(new o(this, t[s])); else this.addFile(new o(this, t, e, n, i)); return this; }), t.exports = o;\n  }, function (t, e, i) {\n    const n = i(0); const s = i(8); const l = i(2); const u = i(72); const c = i(7); const d = i(61); const r = i(187); const f = i(216); const a = new n({\n      Extends: d,\n      initialize(t, e, i, n, s, r) {\n        let o; let a; const h = c(e) ? (e = l(a = e, 'key'), o = new u(t, {\n          key: e, url: l(a, 'textureURL'), extension: l(a, 'textureExtension', 'png'), normalMap: l(a, 'normalMap'), xhrSettings: l(a, 'textureXhrSettings'),\n        }), new f(t, {\n          key: e, url: l(a, 'fontDataURL'), extension: l(a, 'fontDataExtension', 'xml'), xhrSettings: l(a, 'fontDataXhrSettings'),\n        })) : (o = new u(t, e, i, s), new f(t, e, n, r)); o.linkFile ? d.call(this, t, 'bitmapfont', e, [o, h, o.linkFile]) : d.call(this, t, 'bitmapfont', e, [o, h]);\n      },\n      addToCache() { let t; let e; this.isReadyToProcess() && (t = this.files[0], e = this.files[1], t.addToCache(), e.addToCache(), this.loader.cacheManager.bitmapFont.add(t.key, { data: r(e.data), texture: t.key, frame: null }), this.complete = !0); },\n    }); s.register('bitmapFont', function (t, e, i, n, s) { let r; if (Array.isArray(t)) for (let o = 0; o < t.length; o++)r = new a(this, t[o]), this.addFile(r.files); else r = new a(this, t, e, i, n, s), this.addFile(r.files); return this; }), t.exports = a;\n  }, function (t, e, i) {\n    const n = i(0); const s = i(17); const a = i(21); const r = i(8); const h = i(2); const l = i(7); const o = new n({\n      Extends: a,\n      initialize(t, e, i, n) {\n        let s; let r = 'css'; l(e) && (e = h(s = e, 'key'), i = h(s, 'url'), n = h(s, 'xhrSettings'), r = h(s, 'extension', r)); const o = {\n          type: 'script', cache: !1, extension: r, responseType: 'text', key: e, url: i, xhrSettings: n,\n        }; a.call(this, t, o);\n      },\n      onProcess() { this.state = s.FILE_PROCESSING, this.data = document.createElement('style'), this.data.defer = !1, this.data.innerHTML = this.xhrLoader.responseText, document.head.appendChild(this.data), this.onProcessComplete(); },\n    }); r.register('css', function (t, e, i) { if (Array.isArray(t)) for (let n = 0; n < t.length; n++) this.addFile(new o(this, t[n])); else this.addFile(new o(this, t, e, i)); return this; }), t.exports = o;\n  }, function (t, e, i) {\n    const n = i(0); const s = i(17); const h = i(21); const r = i(8); const l = i(2); const u = i(7); const a = i(353); const o = new n({\n      Extends: h,\n      initialize(t, e, i, n, s) {\n        let r; let o = 'glsl'; u(e) ? (e = l(r = e, 'key'), i = l(r, 'url'), n = l(r, 'shaderType', 'fragment'), s = l(r, 'xhrSettings'), o = l(r, 'extension', o)) : void 0 === n && (n = 'fragment'); const a = {\n          type: 'glsl', cache: t.cacheManager.shader, extension: o, responseType: 'text', key: e, url: i, config: { shaderType: n }, xhrSettings: s,\n        }; h.call(this, t, a);\n      },\n      onProcess() { this.state = s.FILE_PROCESSING, this.data = this.xhrLoader.responseText, this.onProcessComplete(); },\n      addToCache() { const t = this.data.split('\\n'); let e = this.extractBlock(t, 0); if (e) for (;e;) { var i; const n = this.getShaderName(e.header); const s = this.getShaderType(e.header); const r = this.getShaderUniforms(e.header); const o = e.shader; this.cache.has(n) ? (i = this.cache.get(n), s === 'fragment' ? i.fragmentSrc = o : i.vertexSrc = o, i.uniforms || (i.uniforms = r)) : s === 'fragment' ? this.cache.add(n, new a(n, o, '', r)) : this.cache.add(n, new a(n, '', o, r)), e = this.extractBlock(t, e.offset); } else this.config.shaderType === 'fragment' ? this.cache.add(this.key, new a(this.key, this.data)) : this.cache.add(this.key, new a(this.key, '', this.data)); this.pendingDestroy(); },\n      getShaderName(t) { for (let e = 0; e < t.length; e++) { const i = t[e].trim(); if (i.substring(0, 5) === 'name:') return i.substring(5).trim(); } return this.key; },\n      getShaderType(t) { for (let e = 0; e < t.length; e++) { const i = t[e].trim(); if (i.substring(0, 5) === 'type:') return i.substring(5).trim(); } return this.config.shaderType; },\n      getShaderUniforms(t) { for (var e = {}, i = 0; i < t.length; i++) { const n = t[i].trim(); if (n.substring(0, 8) === 'uniform.') { const s = n.indexOf(':'); if (s) { const r = n.substring(8, s); try { e[r] = JSON.parse(n.substring(s + 1)); } catch (t) { console.warn(`Invalid uniform JSON: ${r}`); } } } } return e; },\n      extractBlock(t, e) { for (var i = -1, n = -1, s = -1, r = !1, o = !1, a = [], h = [], l = e; l < t.length; l++) { const u = t[l].trim(); if (u === '---') if (i === -1)i = l, r = !0; else { if (!r) { o = !1; break; }n = l, o = !(r = !1); } else r ? a.push(u) : o && (h.push(u), s = l); } return r || n === -1 ? null : { header: a, shader: h.join('\\n'), offset: s }; },\n    }); r.register('glsl', function (t, e, i, n) { if (Array.isArray(t)) for (let s = 0; s < t.length; s++) this.addFile(new o(this, t[s])); else this.addFile(new o(this, t, e, i, n)); return this; }), t.exports = o;\n  }, function (t, e, i) {\n    const n = i(0); const s = i(17); const a = i(21); const r = i(8); const h = i(2); const l = i(7); const o = new n({\n      Extends: a,\n      initialize(t, e, i, n) {\n        let s; let r = 'html'; l(e) && (e = h(s = e, 'key'), i = h(s, 'url'), n = h(s, 'xhrSettings'), r = h(s, 'extension', r)); const o = {\n          type: 'text', cache: t.cacheManager.html, extension: r, responseType: 'text', key: e, url: i, xhrSettings: n,\n        }; a.call(this, t, o);\n      },\n      onProcess() { this.state = s.FILE_PROCESSING, this.data = this.xhrLoader.responseText, this.onProcessComplete(); },\n    }); r.register('html', function (t, e, i) { if (Array.isArray(t)) for (let n = 0; n < t.length; n++) this.addFile(new o(this, t[n])); else this.addFile(new o(this, t, e, i)); return this; }), t.exports = o;\n  }, function (t, e, i) {\n    const n = i(0); const o = i(17); const l = i(21); const s = i(8); const u = i(2); const c = i(7); const a = new n({\n      Extends: l,\n      initialize(t, e, i, n, s, r) {\n        void 0 === n && (n = 512), void 0 === s && (s = 512); let o; let a = 'html'; c(e) && (e = u(o = e, 'key'), i = u(o, 'url'), r = u(o, 'xhrSettings'), a = u(o, 'extension', a), n = u(o, 'width', n), s = u(o, 'height', s)); const h = {\n          type: 'html', cache: t.textureManager, extension: a, responseType: 'text', key: e, url: i, xhrSettings: r, config: { width: n, height: s },\n        }; l.call(this, t, h);\n      },\n      onProcess() { this.state = o.FILE_PROCESSING; const t = this.config.width; const e = this.config.height; const i = []; i.push(`<svg width=\"${t}px\" height=\"${e}px\" viewBox=\"0 0 ${t} ${e}\" xmlns=\"http://www.w3.org/2000/svg\">`), i.push('<foreignObject width=\"100%\" height=\"100%\">'), i.push('<body xmlns=\"http://www.w3.org/1999/xhtml\">'), i.push(this.xhrLoader.responseText), i.push('</body>'), i.push('</foreignObject>'), i.push('</svg>'); const n = [i.join('\\n')]; const s = this; try { var r = new window.Blob(n, { type: 'image/svg+xml;charset=utf-8' }); } catch (t) { return s.state = o.FILE_ERRORED, void s.onProcessComplete(); } this.data = new Image(), this.data.crossOrigin = this.crossOrigin, this.data.onload = function () { l.revokeObjectURL(s.data), s.onProcessComplete(); }, this.data.onerror = function () { l.revokeObjectURL(s.data), s.onProcessError(); }, l.createObjectURL(this.data, r, 'image/svg+xml'); },\n      addToCache() { const t = this.cache.addImage(this.key, this.data); this.pendingDestroy(t); },\n    }); s.register('htmlTexture', function (t, e, i, n, s) { if (Array.isArray(t)) for (let r = 0; r < t.length; r++) this.addFile(new a(this, t[r])); else this.addFile(new a(this, t, e, i, n, s)); return this; }), t.exports = a;\n  }, function (t, e, i) {\n    const n = i(0); const s = i(8); const v = i(2); const m = i(72); const l = i(7); const u = i(60); const c = i(61); const a = new n({\n      Extends: c, initialize(t, e, i, n, s, r, o) { let a; l(e) && (e = v(a = e, 'key'), i = v(a, 'url', !1) ? v(a, 'url') : v(a, 'atlasURL'), r = v(a, 'xhrSettings'), n = v(a, 'path'), s = v(a, 'baseURL'), o = v(a, 'textureXhrSettings')); const h = new u(t, e, i, r); c.call(this, t, 'multiatlas', e, [h]), this.config.path = n, this.config.baseURL = s, this.config.textureXhrSettings = o; }, onFileComplete(t) { if (this.files.indexOf(t) !== -1 && (this.pending--, t.type === 'json' && t.data.hasOwnProperty('textures'))) { const e = t.data.textures; const i = this.config; const n = this.loader; const s = n.baseURL; const r = n.path; const o = n.prefix; const a = v(i, 'baseURL', this.baseURL); const h = v(i, 'path', this.path); const l = v(i, 'prefix', this.prefix); const u = v(i, 'textureXhrSettings'); n.setBaseURL(a), n.setPath(h), n.setPrefix(l); for (let c = 0; c < e.length; c++) { var d; const f = e[c].image; const p = `MA${this.multiKeyIndex}_${f}`; const g = new m(n, p, f, u); this.addToMultiFile(g), n.addFile(g), e[c].normalMap && ((d = new m(n, p, e[c].normalMap, u)).type = 'normalMap', g.setLink(d), this.addToMultiFile(d), n.addFile(d)); }n.setBaseURL(s), n.setPath(r), n.setPrefix(o); } }, addToCache() { if (this.isReadyToProcess()) { for (var t = this.files[0], e = [], i = [], n = [], s = 1; s < this.files.length; s++) { const r = this.files[s]; if (r.type !== 'normalMap') for (let o = r.key.indexOf('_'), a = r.key.substr(o + 1), h = r.data, l = 0; l < t.data.textures.length; l++) { const u = t.data.textures[l]; if (u.image === a) { i.push(h), e.push(u), r.linkFile && n.push(r.linkFile.data); break; } } } for (n.length === 0 && (n = void 0), this.loader.textureManager.addAtlasJSONArray(this.key, i, e, n), this.complete = !0, s = 0; s < this.files.length; s++) this.files[s].pendingDestroy(); } },\n    }); s.register('multiatlas', function (t, e, i, n, s) { let r; if (Array.isArray(t)) for (let o = 0; o < t.length; o++)r = new a(this, t[o]), this.addFile(r.files); else r = new a(this, t, e, i, n, s), this.addFile(r.files); return this; }), t.exports = a;\n  }, function (t, e, i) {\n    const n = i(0); const s = i(8); const l = i(2); const u = i(7); const c = i(61); const d = i(458); const r = new n({\n      Extends: c,\n      initialize(t, e, i, n) {\n        let s; let r = 'js'; const o = []; u(e) && (e = l(s = e, 'key'), i = l(s, 'url'), n = l(s, 'xhrSettings'), r = l(s, 'extension', r)), Array.isArray(i) || (i = [i]); for (let a = 0; a < i.length; a++) {\n          const h = new d(t, {\n            key: `${e}_${a.toString()}`, url: i[a], extension: r, xhrSettings: n,\n          }); h.onProcess = function () { this.onProcessComplete(); }, o.push(h);\n        }c.call(this, t, 'scripts', e, o);\n      },\n      addToCache() { if (this.isReadyToProcess()) { for (let t = 0; t < this.files.length; t++) { const e = this.files[t]; e.data = document.createElement('script'), e.data.language = 'javascript', e.data.type = 'text/javascript', e.data.defer = !1, e.data.text = e.xhrLoader.responseText, document.head.appendChild(e.data); } this.complete = !0; } },\n    }); s.register('scripts', function (t, e, i) { let n; if (Array.isArray(t)) for (let s = 0; s < t.length; s++)n = new r(this, t[s]), this.addFile(n.files); else n = new r(this, t, e, i), this.addFile(n.files); return this; }), t.exports = r;\n  }, function (t, e, i) { const n = i(0); const s = i(17); const r = i(8); const o = i(60); const a = new n({ Extends: o, initialize(t, e, i, n, s) { o.call(this, t, e, i, n, s), this.type = 'packfile'; }, onProcess() { this.state !== s.FILE_POPULATED && (this.state = s.FILE_PROCESSING, this.data = JSON.parse(this.xhrLoader.responseText)), this.loader.addPack(this.data, this.config), this.onProcessComplete(); } }); r.register('pack', function (t, e, i, n) { if (Array.isArray(t)) for (let s = 0; s < t.length; s++) this.addFile(new a(this, t[s])); else this.addFile(new a(this, t, e, n, i)); return this; }), t.exports = a; }, function (t, e, i) {\n    const n = i(0); const l = i(17); const u = i(21); const s = i(8); const c = i(2); const d = i(7); const o = new n({\n      Extends: u,\n      initialize(t, e, i, n, s, r) {\n        let o; let a = 'js'; d(e) && (e = c(o = e, 'key'), i = c(o, 'url'), r = c(o, 'xhrSettings'), a = c(o, 'extension', a), n = c(o, 'start'), s = c(o, 'mapping')); const h = {\n          type: 'plugin', cache: !1, extension: a, responseType: 'text', key: e, url: i, xhrSettings: r, config: { start: n, mapping: s },\n        }; u.call(this, t, h), typeof i === 'function' && (this.data = i, this.state = l.FILE_POPULATED);\n      },\n      onProcess() { let t; const e = this.loader.systems.plugins; const i = this.config; const n = c(i, 'start', !1); const s = c(i, 'mapping', null); this.state === l.FILE_POPULATED ? e.install(this.key, this.data, n, s) : (this.state = l.FILE_PROCESSING, this.data = document.createElement('script'), this.data.language = 'javascript', this.data.type = 'text/javascript', this.data.defer = !1, this.data.text = this.xhrLoader.responseText, document.head.appendChild(this.data), t = e.install(this.key, window[this.key], n, s), (n || s) && (this.loader.systems[s] = t, this.loader.scene[s] = t)), this.onProcessComplete(); },\n    }); s.register('plugin', function (t, e, i, n, s) { if (Array.isArray(t)) for (let r = 0; r < t.length; r++) this.addFile(new o(this, t[r])); else this.addFile(new o(this, t, e, i, n, s)); return this; }), t.exports = o;\n  }, function (t, e, i) {\n    const n = i(0); const s = i(17); const a = i(21); const r = i(8); const h = i(2); const l = i(7); const o = new n({\n      Extends: a,\n      initialize(t, e, i, n) {\n        let s; let r = 'js'; l(e) && (e = h(s = e, 'key'), i = h(s, 'url'), n = h(s, 'xhrSettings'), r = h(s, 'extension', r)); const o = {\n          type: 'text', cache: t.cacheManager.text, extension: r, responseType: 'text', key: e, url: i, xhrSettings: n,\n        }; a.call(this, t, o);\n      },\n      onProcess() { this.state = s.FILE_PROCESSING, this.data = this.xhrLoader.responseText, this.onProcessComplete(); },\n      addToCache() { const t = this.data.concat(`(function(){\\nreturn new ${this.key}();\\n}).call(this);`); const e = eval; this.loader.sceneManager.add(this.key, e(t)), this.complete = !0; },\n    }); r.register('sceneFile', function (t, e, i) { if (Array.isArray(t)) for (let n = 0; n < t.length; n++) this.addFile(new o(this, t[n])); else this.addFile(new o(this, t, e, i)); return this; }), t.exports = o;\n  }, function (t, e, i) {\n    const n = i(0); const l = i(17); const u = i(21); const s = i(8); const c = i(2); const d = i(7); const o = new n({\n      Extends: u,\n      initialize(t, e, i, n, s, r) {\n        let o; let a = 'js'; d(e) && (e = c(o = e, 'key'), i = c(o, 'url'), r = c(o, 'xhrSettings'), a = c(o, 'extension', a), n = c(o, 'systemKey'), s = c(o, 'sceneKey')); const h = {\n          type: 'scenePlugin', cache: !1, extension: a, responseType: 'text', key: e, url: i, xhrSettings: r, config: { systemKey: n, sceneKey: s },\n        }; u.call(this, t, h), typeof i === 'function' && (this.data = i, this.state = l.FILE_POPULATED);\n      },\n      onProcess() { const t = this.loader.systems.plugins; const e = this.config; const i = this.key; const n = c(e, 'systemKey', i); const s = c(e, 'sceneKey', i); this.state === l.FILE_POPULATED ? t.installScenePlugin(n, this.data, s, this.loader.scene, !0) : (this.state = l.FILE_PROCESSING, this.data = document.createElement('script'), this.data.language = 'javascript', this.data.type = 'text/javascript', this.data.defer = !1, this.data.text = this.xhrLoader.responseText, document.head.appendChild(this.data), t.installScenePlugin(n, window[this.key], s, this.loader.scene, !0)), this.onProcessComplete(); },\n    }); s.register('scenePlugin', function (t, e, i, n, s) { if (Array.isArray(t)) for (let r = 0; r < t.length; r++) this.addFile(new o(this, t[r])); else this.addFile(new o(this, t, e, i, n, s)); return this; }), t.exports = o;\n  }, function (t, e, i) { const n = i(0); const s = i(8); const r = i(72); const o = new n({ Extends: r, initialize(t, e, i, n, s) { r.call(this, t, e, i, s, n), this.type = 'spritesheet'; }, addToCache() { const t = this.cache.addSpriteSheet(this.key, this.data, this.config); this.pendingDestroy(t); } }); s.register('spritesheet', function (t, e, i, n) { if (Array.isArray(t)) for (let s = 0; s < t.length; s++) this.addFile(new o(this, t[s])); else this.addFile(new o(this, t, e, i, n)); return this; }), t.exports = o; }, function (t, e, i) {\n    const n = i(0); const f = i(17); const p = i(21); const s = i(8); const h = i(2); const l = i(7); const r = new n({\n      Extends: p,\n      initialize(t, e, i, n, s) {\n        let r; let o = 'svg'; l(e) && (e = h(r = e, 'key'), i = h(r, 'url'), n = h(r, 'svgConfig', {}), s = h(r, 'xhrSettings'), o = h(r, 'extension', o)); const a = {\n          type: 'svg', cache: t.textureManager, extension: o, responseType: 'text', key: e, url: i, xhrSettings: s, config: { width: h(n, 'width'), height: h(n, 'height'), scale: h(n, 'scale') },\n        }; p.call(this, t, a);\n      },\n      onProcess() { this.state = f.FILE_PROCESSING; const t = this.xhrLoader.responseText; let e = [t]; let i = this.config.width; let n = this.config.height; const s = this.config.scale; t:if (i && n || s) { let r; const o = (new DOMParser()).parseFromString(t, 'text/xml').getElementsByTagName('svg')[0]; const a = o.hasAttribute('viewBox'); let h = parseFloat(o.getAttribute('width')); let l = parseFloat(o.getAttribute('height')); if (!a && h && l ? o.setAttribute('viewBox', `0  0 ${h} ${l}`) : !a || h || l || (h = (r = o.getAttribute('viewBox').split(/\\s+|,/))[2], l = r[3]), s) { if (!h || !l) break t; i = h * s, n = l * s; }o.setAttribute('width', `${i.toString()}px`), o.setAttribute('height', `${n.toString()}px`), e = [(new XMLSerializer()).serializeToString(o)]; } try { var u = new window.Blob(e, { type: 'image/svg+xml;charset=utf-8' }); } catch (t) { return void this.onProcessError(); } this.data = new Image(), this.data.crossOrigin = this.crossOrigin; const c = this; let d = !1; this.data.onload = function () { d || p.revokeObjectURL(c.data), c.onProcessComplete(); }, this.data.onerror = function () { d ? c.onProcessError() : (d = !0, p.revokeObjectURL(c.data), c.data.src = `data:image/svg+xml,${encodeURIComponent(e.join(''))}`); }, p.createObjectURL(this.data, u, 'image/svg+xml'); },\n      addToCache() { const t = this.cache.addImage(this.key, this.data); this.pendingDestroy(t); },\n    }); s.register('svg', function (t, e, i, n) { if (Array.isArray(t)) for (let s = 0; s < t.length; s++) this.addFile(new r(this, t[s])); else this.addFile(new r(this, t, e, i, n)); return this; }), t.exports = r;\n  }, function (t, e, i) {\n    const n = i(0); const s = i(17); const a = i(21); const r = i(8); const h = i(2); const l = i(7); const u = i(32); const o = new n({\n      Extends: a,\n      initialize(t, e, i, n) {\n        let s; let r = 'csv'; l(e) && (e = h(s = e, 'key'), i = h(s, 'url'), n = h(s, 'xhrSettings'), r = h(s, 'extension', r)); const o = {\n          type: 'tilemapCSV', cache: t.cacheManager.tilemap, extension: r, responseType: 'text', key: e, url: i, xhrSettings: n,\n        }; a.call(this, t, o), this.tilemapFormat = u.CSV;\n      },\n      onProcess() { this.state = s.FILE_PROCESSING, this.data = this.xhrLoader.responseText, this.onProcessComplete(); },\n      addToCache() { const t = { format: this.tilemapFormat, data: this.data }; this.cache.add(this.key, t), this.pendingDestroy(t); },\n    }); r.register('tilemapCSV', function (t, e, i) { if (Array.isArray(t)) for (let n = 0; n < t.length; n++) this.addFile(new o(this, t[n])); else this.addFile(new o(this, t, e, i)); return this; }), t.exports = o;\n  }, function (t, e, i) { const n = i(0); const s = i(8); const r = i(60); const o = i(32); const a = new n({ Extends: r, initialize(t, e, i, n) { r.call(this, t, e, i, n), this.type = 'tilemapJSON', this.cache = t.cacheManager.tilemap; }, addToCache() { const t = { format: o.WELTMEISTER, data: this.data }; this.cache.add(this.key, t), this.pendingDestroy(t); } }); s.register('tilemapImpact', function (t, e, i) { if (Array.isArray(t)) for (let n = 0; n < t.length; n++) this.addFile(new a(this, t[n])); else this.addFile(new a(this, t, e, i)); return this; }), t.exports = a; }, function (t, e, i) { const n = i(0); const s = i(8); const r = i(60); const o = i(32); const a = new n({ Extends: r, initialize(t, e, i, n) { r.call(this, t, e, i, n), this.type = 'tilemapJSON', this.cache = t.cacheManager.tilemap; }, addToCache() { const t = { format: o.TILED_JSON, data: this.data }; this.cache.add(this.key, t), this.pendingDestroy(t); } }); s.register('tilemapTiledJSON', function (t, e, i) { if (Array.isArray(t)) for (let n = 0; n < t.length; n++) this.addFile(new a(this, t[n])); else this.addFile(new a(this, t, e, i)); return this; }), t.exports = a; }, function (t, e, i) {\n    const n = i(0); const s = i(8); const l = i(2); const u = i(72); const c = i(7); const d = i(61); const f = i(459); const a = new n({\n      Extends: d,\n      initialize(t, e, i, n, s, r) {\n        let o; let a; const h = c(e) ? (e = l(a = e, 'key'), o = new u(t, {\n          key: e, url: l(a, 'textureURL'), extension: l(a, 'textureExtension', 'png'), normalMap: l(a, 'normalMap'), xhrSettings: l(a, 'textureXhrSettings'),\n        }), new f(t, {\n          key: e, url: l(a, 'atlasURL'), extension: l(a, 'atlasExtension', 'txt'), xhrSettings: l(a, 'atlasXhrSettings'),\n        })) : (o = new u(t, e, i, s), new f(t, e, n, r)); o.linkFile ? d.call(this, t, 'unityatlas', e, [o, h, o.linkFile]) : d.call(this, t, 'unityatlas', e, [o, h]);\n      },\n      addToCache() { let t; let e; let i; this.isReadyToProcess() && (t = this.files[0], e = this.files[1], i = this.files[2] ? this.files[2].data : null, this.loader.textureManager.addUnityAtlas(t.key, t.data, e.data, i), e.addToCache(), this.complete = !0); },\n    }); s.register('unityAtlas', function (t, e, i, n, s) { let r; if (Array.isArray(t)) for (let o = 0; o < t.length; o++)r = new a(this, t[o]), this.addFile(r.files); else r = new a(this, t, e, i, n, s), this.addFile(r.files); return this; }), t.exports = a;\n  }, function (t, e, i) {\n    const n = i(0); const s = i(17); const h = i(21); const r = i(8); const o = i(138); const l = i(2); const u = i(7); const c = new n({\n      Extends: h,\n      initialize(t, e, i, n, s, r, o) {\n        void 0 === n && (n = 'loadeddata'), void 0 === s && (s = !1), void 0 === r && (r = !1), n !== 'loadeddata' && n !== 'canplay' && n !== 'canplaythrough' && (n = 'loadeddata'); const a = {\n          type: 'video', cache: t.cacheManager.video, extension: i.type, responseType: 'blob', key: e, url: i.url, xhrSettings: o, config: { loadEvent: n, asBlob: s, noAudio: r },\n        }; this.onLoadCallback = this.onVideoLoadHandler.bind(this), this.onErrorCallback = this.onVideoErrorHandler.bind(this), h.call(this, t, a);\n      },\n      onProcess() { let t; let e; this.state = s.FILE_PROCESSING, this.config.asBlob ? (t = this.createVideoElement(), this.data = t, (e = this).data.onloadeddata = function () { e.onProcessComplete(); }, this.data.onerror = function () { h.revokeObjectURL(e.data), e.onProcessError(); }, h.createObjectURL(t, this.xhrLoader.response, ''), t.load()) : this.onProcessComplete(); },\n      createVideoElement() { const t = document.createElement('video'); return t.controls = !1, t.crossOrigin = this.loader.crossOrigin, this.config.noAudio && (t.muted = !0, t.defaultMuted = !0, t.setAttribute('autoplay', 'autoplay')), t.setAttribute('playsinline', 'playsinline'), t.setAttribute('preload', 'auto'), t; },\n      onVideoLoadHandler(t) { const e = t.target; e.removeEventListener(this.config.loadEvent, this.onLoadCallback, !0), e.removeEventListener('error', this.onErrorCallback, !0), this.data = e, this.resetXHR(), this.loader.nextFile(this, !0); },\n      onVideoErrorHandler(t) { const e = t.target; e && (e.removeEventListener(this.config.loadEvent, this.onLoadCallback, !0), e.removeEventListener('error', this.onErrorCallback, !0)), this.resetXHR(), this.loader.nextFile(this, !1); },\n      load() { let t; const e = this.config.loadEvent; this.config.asBlob ? h.prototype.load.call(this) : (this.percentComplete = 0, (t = this.createVideoElement()).addEventListener(e, this.onLoadCallback, !0), t.addEventListener('error', this.onErrorCallback, !0), t.src = o(this, this.loader.baseURL), t.load()); },\n    }); c.create = function (t, e, i, n, s, r, o) { const a = t.systems.game; u(e) && (i = l(e, 'url', []), n = l(e, 'loadEvent', 'loadeddata'), s = l(e, 'asBlob', !1), r = l(e, 'noAudio', !1), o = l(e, 'xhrSettings')); const h = c.getVideoURL(a, i); if (h) return new c(t, e, h, n, s, r, o); }, c.getVideoURL = function (t, e) { Array.isArray(e) || (e = [e]); for (let i = 0; i < e.length; i++) { var n; const s = l(e[i], 'url', e[i]); if (s.indexOf('blob:') === 0) return { url: s, type: '' }; if (n = s.indexOf('data:') === 0 ? s.split(',')[0].match(/\\/(.*?);/) : s.match(/\\.([a-zA-Z0-9]+)($|\\?)/), n = l(e[i], 'type', n ? n[1] : '').toLowerCase(), t.device.video[n]) return { url: s, type: n }; } return null; }, r.register('video', function (t, e, i, n, s, r) { let o; if (Array.isArray(t)) for (let a = 0; a < t.length; a++)(o = c.create(this, t[a])) && this.addFile(o); else (o = c.create(this, t, e, i, n, s, r)) && this.addFile(o); return this; }), t.exports = c;\n  }, function (t, e, i) {\n    const n = i(0); const s = i(17); const r = i(133); const o = i(10); const a = i(82); const h = i(8); const v = i(2); const l = i(23); const u = i(22); const c = i(139); const d = new n({\n      Extends: o, initialize(t) { o.call(this); const e = t.sys.game.config; const i = t.sys.settings.loader; this.scene = t, this.systems = t.sys, this.cacheManager = t.sys.cache, this.textureManager = t.sys.textures, this.sceneManager = t.sys.game.scene, h.install(this), this.prefix = '', this.path = '', this.baseURL = '', this.setBaseURL(v(i, 'baseURL', e.loaderBaseURL)), this.setPath(v(i, 'path', e.loaderPath)), this.setPrefix(v(i, 'prefix', e.loaderPrefix)), this.maxParallelDownloads = v(i, 'maxParallelDownloads', e.loaderMaxParallelDownloads), this.xhr = c(v(i, 'responseType', e.loaderResponseType), v(i, 'async', e.loaderAsync), v(i, 'user', e.loaderUser), v(i, 'password', e.loaderPassword), v(i, 'timeout', e.loaderTimeout), v(i, 'withCredentials', e.loaderWithCredentials)), this.crossOrigin = v(i, 'crossOrigin', e.loaderCrossOrigin), this.totalToLoad = 0, this.progress = 0, this.list = new r(), this.inflight = new r(), this.queue = new r(), this._deleteQueue = new r(), this.totalFailed = 0, this.totalComplete = 0, this.state = s.LOADER_IDLE, this.multiKeyIndex = 0, t.sys.events.once(u.BOOT, this.boot, this), t.sys.events.on(u.START, this.pluginStart, this); }, boot() { this.systems.events.once(u.DESTROY, this.destroy, this); }, pluginStart() { this.systems.events.once(u.SHUTDOWN, this.shutdown, this); }, setBaseURL(t) { return void 0 === t && (t = ''), t !== '' && t.substr(-1) !== '/' && (t = t.concat('/')), this.baseURL = t, this; }, setPath(t) { return void 0 === t && (t = ''), t !== '' && t.substr(-1) !== '/' && (t = t.concat('/')), this.path = t, this; }, setPrefix(t) { return void 0 === t && (t = ''), this.prefix = t, this; }, setCORS(t) { return this.crossOrigin = t, this; }, addFile(t) { Array.isArray(t) || (t = [t]); for (let e = 0; e < t.length; e++) { const i = t[e]; this.keyExists(i) || (this.list.set(i), this.emit(a.ADD, i.key, i.type, this, i), this.isLoading() && (this.totalToLoad++, this.updateProgress())); } }, keyExists(e) { let i = e.hasCacheConflict(); return i || this.list.iterate((t) => { if (t.type === e.type && t.key === e.key) return !(i = !0); }), !i && this.isLoading() && (this.inflight.iterate((t) => { if (t.type === e.type && t.key === e.key) return !(i = !0); }), this.queue.iterate((t) => { if (t.type === e.type && t.key === e.key) return !(i = !0); })), i; }, addPack(t, e) { e && t.hasOwnProperty(e) && (t = { packKey: t[e] }); let i = 0; const n = this.baseURL; const s = this.path; const r = this.prefix; for (const o in t) if (Object.prototype.hasOwnProperty.call(t, o)) { const a = t[o]; const h = v(a, 'baseURL', n); const l = v(a, 'path', s); const u = v(a, 'prefix', r); const c = v(a, 'files', null); const d = v(a, 'defaultType', 'void'); if (Array.isArray(c)) { this.setBaseURL(h), this.setPath(l), this.setPrefix(u); for (let f = 0; f < c.length; f++) { const p = c[f]; const g = p.hasOwnProperty('type') ? p.type : d; this[g] && (this[g](p), i++); } } } return this.setBaseURL(n), this.setPath(s), this.setPrefix(r), i > 0; }, isLoading() { return this.state === s.LOADER_LOADING || this.state === s.LOADER_PROCESSING; }, isReady() { return this.state === s.LOADER_IDLE || this.state === s.LOADER_COMPLETE; }, start() { this.isReady() && (this.progress = 0, this.totalFailed = 0, this.totalComplete = 0, this.totalToLoad = this.list.size, this.emit(a.START, this), this.list.size === 0 ? this.loadComplete() : (this.state = s.LOADER_LOADING, this.inflight.clear(), this.queue.clear(), this.updateProgress(), this.checkLoadQueue(), this.systems.events.on(u.UPDATE, this.update, this))); }, updateProgress() { this.progress = 1 - (this.list.size + this.inflight.size) / this.totalToLoad, this.emit(a.PROGRESS, this.progress); }, update() { this.state === s.LOADER_LOADING && this.list.size > 0 && this.inflight.size < this.maxParallelDownloads && this.checkLoadQueue(); }, checkLoadQueue() { this.list.each(function (t) { if ((t.state === s.FILE_POPULATED || t.state === s.FILE_PENDING && this.inflight.size < this.maxParallelDownloads) && (this.inflight.set(t), this.list.delete(t), t.crossOrigin || (t.crossOrigin = this.crossOrigin), t.load()), this.inflight.size === this.maxParallelDownloads) return !1; }, this); }, nextFile(t, e) { this.inflight && (this.inflight.delete(t), this.updateProgress(), e ? (this.totalComplete++, this.queue.set(t), this.emit(a.FILE_LOAD, t), t.onProcess()) : (this.totalFailed++, this._deleteQueue.set(t), this.emit(a.FILE_LOAD_ERROR, t), this.fileProcessComplete(t))); }, fileProcessComplete(t) { this.scene && this.systems && this.systems.game && !this.systems.game.pendingDestroy && (t.state === s.FILE_ERRORED ? t.multiFile && t.multiFile.onFileFailed(t) : t.state === s.FILE_COMPLETE && (t.multiFile ? t.multiFile.isReadyToProcess() && t.multiFile.addToCache() : t.addToCache()), this.queue.delete(t), this.list.size === 0 && this.inflight.size === 0 && this.queue.size === 0 && this.loadComplete()); }, loadComplete() { this.emit(a.POST_PROCESS, this), this.list.clear(), this.inflight.clear(), this.queue.clear(), this.progress = 1, this.state = s.LOADER_COMPLETE, this.systems.events.off(u.UPDATE, this.update, this), this._deleteQueue.iterateLocal('destroy'), this._deleteQueue.clear(), this.emit(a.COMPLETE, this, this.totalComplete, this.totalFailed); }, flagForRemoval(t) { this._deleteQueue.set(t); }, saveJSON(t, e) { return this.save(JSON.stringify(t), e); }, save(t, e, i) { void 0 === e && (e = 'file.json'), void 0 === i && (i = 'application/json'); const n = new Blob([t], { type: i }); const s = URL.createObjectURL(n); const r = document.createElement('a'); return r.download = e, r.textContent = `Download ${e}`, r.href = s, r.click(), this; }, reset() { this.list.clear(), this.inflight.clear(), this.queue.clear(); const t = this.systems.game.config; const e = this.systems.settings.loader; this.setBaseURL(v(e, 'baseURL', t.loaderBaseURL)), this.setPath(v(e, 'path', t.loaderPath)), this.setPrefix(v(e, 'prefix', t.loaderPrefix)), this.state = s.LOADER_IDLE; }, shutdown() { this.reset(), this.state = s.LOADER_SHUTDOWN, this.systems.events.off(u.UPDATE, this.update, this), this.systems.events.off(u.SHUTDOWN, this.shutdown, this); }, destroy() { this.shutdown(), this.state = s.LOADER_DESTROYED, this.systems.events.off(u.UPDATE, this.update, this), this.systems.events.off(u.START, this.pluginStart, this), this.list = null, this.inflight = null, this.queue = null, this.scene = null, this.systems = null, this.textureManager = null, this.cacheManager = null, this.sceneManager = null; },\n    }); l.register('Loader', d, 'load'), t.exports = d;\n  }, function (t, e, i) {\n    const n = i(50); var s = i(18)(!1, s = {\n      ArcadePhysics: i(1262), Body: i(466), Collider: i(467), Components: i(217), Events: i(218), Factory: i(460), Group: i(462), Image: i(461), Sprite: i(140), StaticBody: i(472), StaticGroup: i(463), World: i(465),\n    }, n); t.exports = s;\n  }, function (t, e, i) {\n    const n = i(0); const s = i(39); const o = i(53); const c = i(321); const r = i(460); const a = i(2); const h = i(126); const l = i(1275); const u = i(464); const d = i(23); const f = i(22); const p = i(3); const g = i(465); const v = new n({\n      initialize(t) { this.scene = t, this.systems = t.sys, this.config = this.getConfig(), this.world, this.add, t.sys.events.once(f.BOOT, this.boot, this), t.sys.events.on(f.START, this.start, this); }, boot() { this.world = new g(this.scene, this.config), this.add = new r(this.world), this.systems.events.once(f.DESTROY, this.destroy, this); }, start() { this.world || (this.world = new g(this.scene, this.config), this.add = new r(this.world)); const t = this.systems.events; t.on(f.UPDATE, this.world.update, this.world), t.on(f.POST_UPDATE, this.world.postUpdate, this.world), t.once(f.SHUTDOWN, this.shutdown, this); }, getConfig() { const t = this.systems.game.config.physics; const e = this.systems.settings.physics; return h(a(e, 'arcade', {}), a(t, 'arcade', {})); }, overlap(t, e, i, n, s) { return void 0 === i && (i = null), void 0 === n && (n = null), void 0 === s && (s = i), this.world.collideObjects(t, e, i, n, s, !0); }, collide(t, e, i, n, s) { return void 0 === i && (i = null), void 0 === n && (n = null), void 0 === s && (s = i), this.world.collideObjects(t, e, i, n, s, !1); }, collideTiles(t, e, i, n, s) { return this.world.collideTiles(t, e, i, n, s); }, overlapTiles(t, e, i, n, s) { return this.world.overlapTiles(t, e, i, n, s); }, pause() { return this.world.pause(); }, resume() { return this.world.resume(); }, accelerateTo(t, e, i, n, s, r) { void 0 === n && (n = 60); const o = Math.atan2(i - t.y, e - t.x); return t.body.acceleration.setToPolar(o, n), void 0 !== s && void 0 !== r && t.body.maxVelocity.set(s, r), o; }, accelerateToObject(t, e, i, n, s) { return this.accelerateTo(t, e.x, e.y, i, n, s); }, closest(t, e) { e = e || this.world.bodies.entries; for (var i = Number.MAX_VALUE, n = null, s = t.x, r = t.y, o = e.length, a = 0; a < o; a++) { var h; const l = e[a]; const u = l.body || l; t !== l && t !== u && t !== u.gameObject && t !== u.center && ((h = c(s, r, u.center.x, u.center.y)) < i && (n = l, i = h)); } return n; }, furthest(t, e) { e = e || this.world.bodies.entries; for (var i = -1, n = null, s = t.x, r = t.y, o = e.length, a = 0; a < o; a++) { var h; const l = e[a]; const u = l.body || l; t !== l && t !== u && t !== u.gameObject && t !== u.center && (i < (h = c(s, r, u.center.x, u.center.y)) && (n = l, i = h)); } return n; }, moveTo(t, e, i, n, s) { void 0 === n && (n = 60), void 0 === s && (s = 0); const r = Math.atan2(i - t.y, e - t.x); return s > 0 && (n = o(t.x, t.y, e, i) / (s / 1e3)), t.body.velocity.setToPolar(r, n), r; }, moveToObject(t, e, i, n) { return this.moveTo(t, e.x, e.y, i, n); }, velocityFromAngle(t, e, i) { return void 0 === e && (e = 60), void 0 === i && (i = new p()), i.setToPolar(s(t), e); }, velocityFromRotation(t, e, i) { return void 0 === e && (e = 60), void 0 === i && (i = new p()), i.setToPolar(t, e); }, overlapRect(t, e, i, n, s, r) { return u(this.world, t, e, i, n, s, r); }, overlapCirc(t, e, i, n, s) { return l(this.world, t, e, i, n, s); }, shutdown() { let t; this.world && ((t = this.systems.events).off(f.UPDATE, this.world.update, this.world), t.off(f.POST_UPDATE, this.world.postUpdate, this.world), t.off(f.SHUTDOWN, this.shutdown, this), this.add.destroy(), this.world.destroy(), this.add = null, this.world = null); }, destroy() { this.shutdown(), this.scene.sys.events.off(f.START, this.start, this), this.scene = null, this.systems = null; },\n    }); d.register('ArcadePhysics', v, 'arcadePhysics'), t.exports = v;\n  }, function (t, e) { t.exports = { setAcceleration(t, e) { return this.body.acceleration.set(t, e), this; }, setAccelerationX(t) { return this.body.acceleration.x = t, this; }, setAccelerationY(t) { return this.body.acceleration.y = t, this; } }; }, function (t, e) { t.exports = { setAngularVelocity(t) { return this.body.angularVelocity = t, this; }, setAngularAcceleration(t) { return this.body.angularAcceleration = t, this; }, setAngularDrag(t) { return this.body.angularDrag = t, this; } }; }, function (t, e) {\n    t.exports = {\n      setBounce(t, e) { return this.body.bounce.set(t, e), this; }, setBounceX(t) { return this.body.bounce.x = t, this; }, setBounceY(t) { return this.body.bounce.y = t, this; }, setCollideWorldBounds(t, e, i) { return this.body.setCollideWorldBounds(t, e, i), this; },\n    };\n  }, function (t, e) {\n    t.exports = {\n      setDebug(t, e, i) { return this.debugShowBody = t, this.debugShowVelocity = e, this.debugBodyColor = i, this; }, setDebugBodyColor(t) { return this.body.debugBodyColor = t, this; }, debugShowBody: { get() { return this.body.debugShowBody; }, set(t) { this.body.debugShowBody = t; } }, debugShowVelocity: { get() { return this.body.debugShowVelocity; }, set(t) { this.body.debugShowVelocity = t; } }, debugBodyColor: { get() { return this.body.debugBodyColor; }, set(t) { this.body.debugBodyColor = t; } },\n    };\n  }, function (t, e) {\n    t.exports = {\n      setDrag(t, e) { return this.body.drag.set(t, e), this; }, setDragX(t) { return this.body.drag.x = t, this; }, setDragY(t) { return this.body.drag.y = t, this; }, setDamping(t) { return this.body.useDamping = t, this; },\n    };\n  }, function (t, e) { const i = { enableBody(t, e, i, n, s) { return t && this.body.reset(e, i), n && (this.body.gameObject.active = !0), s && (this.body.gameObject.visible = !0), this.body.enable = !0, this; }, disableBody(t, e) { return void 0 === t && (t = !1), void 0 === e && (e = !1), this.body.stop(), this.body.enable = !1, t && (this.body.gameObject.active = !1), e && (this.body.gameObject.visible = !1), this; }, refreshBody() { return this.body.updateFromGameObject(), this; } }; t.exports = i; }, function (t, e) { t.exports = { setFriction(t, e) { return this.body.friction.set(t, e), this; }, setFrictionX(t) { return this.body.friction.x = t, this; }, setFrictionY(t) { return this.body.friction.y = t, this; } }; }, function (t, e) { t.exports = { setGravity(t, e) { return this.body.gravity.set(t, e), this; }, setGravityX(t) { return this.body.gravity.x = t, this; }, setGravityY(t) { return this.body.gravity.y = t, this; } }; }, function (t, e) { const i = { setImmovable(t) { return void 0 === t && (t = !0), this.body.immovable = t, this; } }; t.exports = i; }, function (t, e) { t.exports = { setMass(t) { return this.body.mass = t, this; } }; }, function (t, e) {\n    t.exports = {\n      setOffset(t, e) { return this.body.setOffset(t, e), this; }, setSize(t, e, i) { return this.body.setSize(t, e, i), this; }, setBodySize(t, e, i) { return this.body.setSize(t, e, i), this; }, setCircle(t, e, i) { return this.body.setCircle(t, e, i), this; },\n    };\n  }, function (t, e) {\n    t.exports = {\n      setVelocity(t, e) { return this.body.setVelocity(t, e), this; }, setVelocityX(t) { return this.body.setVelocityX(t), this; }, setVelocityY(t) { return this.body.setVelocityY(t), this; }, setMaxVelocity(t, e) { return this.body.maxVelocity.set(t, e), this; },\n    };\n  }, function (t, e, i) { const d = i(464); const f = i(65); const p = i(205); const g = i(206); t.exports = function (t, e, i, n, s, r) { const o = d(t, e - n, i - n, 2 * n, 2 * n, s, r); if (o.length === 0) return o; for (var a = new f(e, i, n), h = new f(), l = [], u = 0; u < o.length; u++) { const c = o[u]; c.isCircle ? (h.setTo(c.center.x, c.center.y, c.halfWidth), p(a, h) && l.push(c)) : g(a, c) && l.push(c); } return l; }; }, function (t, e) { t.exports = 'collide'; }, function (t, e) { t.exports = 'overlap'; }, function (t, e) { t.exports = 'pause'; }, function (t, e) { t.exports = 'resume'; }, function (t, e) { t.exports = 'tilecollide'; }, function (t, e) { t.exports = 'tileoverlap'; }, function (t, e) { t.exports = 'worldbounds'; }, function (t, e) { t.exports = 'worldstep'; }, function (t, e) { t.exports = function (t, e) { return t.collisionCallback ? !t.collisionCallback.call(t.collisionCallbackContext, e, t) : !t.layer.callbacks[t.index] || !t.layer.callbacks[t.index].callback.call(t.layer.callbacks[t.index].callbackContext, e, t); }; }, function (t, e, i) { const m = i(1286); const y = i(1288); const x = i(471); t.exports = function (t, e, i, n, s, r, o) { const a = n.left; const h = n.top; const l = n.right; const u = n.bottom; let c = i.faceLeft || i.faceRight; let d = i.faceTop || i.faceBottom; if (o || (d = c = !0), !c && !d) return !1; let f = 0; let p = 0; let g = 0; let v = 1; if (e.deltaAbsX() > e.deltaAbsY() ? g = -1 : e.deltaAbsX() < e.deltaAbsY() && (v = -1), e.deltaX() !== 0 && e.deltaY() !== 0 && c && d && (g = Math.min(Math.abs(e.position.x - l), Math.abs(e.right - a)), v = Math.min(Math.abs(e.position.y - u), Math.abs(e.bottom - h))), g < v) { if (c && (f = m(e, i, a, l, r, o)) !== 0 && !x(n, e)) return !0; d && (p = y(e, i, h, u, r, o)); } else { if (d && (p = y(e, i, h, u, r, o)) !== 0 && !x(n, e)) return !0; c && (f = m(e, i, a, l, r, o)); } return f !== 0 || p !== 0; }; }, function (t, e, i) { const c = i(1287); t.exports = function (t, e, i, n, s, r) { let o = 0; let a = e.faceLeft; let h = e.faceRight; let l = e.collideLeft; let u = e.collideRight; return r || (u = l = h = a = !0), t.deltaX() < 0 && u && t.checkCollision.left ? h && t.x < n && (o = t.x - n) < -s && (o = 0) : t.deltaX() > 0 && l && t.checkCollision.right && a && t.right > i && s < (o = t.right - i) && (o = 0), o !== 0 && (t.customSeparateX ? t.overlapX = o : c(t, o)), o; }; }, function (t, e) { t.exports = function (t, e) { e < 0 ? (t.blocked.none = !1, t.blocked.left = !0) : e > 0 && (t.blocked.none = !1, t.blocked.right = !0), t.position.x -= e, t.bounce.x === 0 ? t.velocity.x = 0 : t.velocity.x = -t.velocity.x * t.bounce.x; }; }, function (t, e, i) { const c = i(1289); t.exports = function (t, e, i, n, s, r) { let o = 0; let a = e.faceTop; let h = e.faceBottom; let l = e.collideUp; let u = e.collideDown; return r || (u = l = h = a = !0), t.deltaY() < 0 && u && t.checkCollision.up ? h && t.y < n && (o = t.y - n) < -s && (o = 0) : t.deltaY() > 0 && l && t.checkCollision.down && a && t.bottom > i && s < (o = t.bottom - i) && (o = 0), o !== 0 && (t.customSeparateY ? t.overlapY = o : c(t, o)), o; }; }, function (t, e) { t.exports = function (t, e) { e < 0 ? (t.blocked.none = !1, t.blocked.up = !0) : e > 0 && (t.blocked.none = !1, t.blocked.down = !0), t.position.y -= e, t.bounce.y === 0 ? t.velocity.y = 0 : t.velocity.y = -t.velocity.y * t.bounce.y; }; }, function (t, e, i) { const u = i(468); t.exports = function (t, e, i, n) { let s = u(t, e, i, n); if (i || s === 0 || t.immovable && e.immovable || t.customSeparateX || e.customSeparateX) return s !== 0 || t.embedded && e.embedded; let r; let o; let a; const h = t.velocity.x; const l = e.velocity.x; return t.immovable || e.immovable ? t.immovable ? (e.x += s, e.velocity.x = h - l * e.bounce.x, t.moves && (e.y += (t.y - t.prev.y) * t.friction.y)) : (t.x -= s, t.velocity.x = l - h * t.bounce.x, e.moves && (t.y += (e.y - e.prev.y) * e.friction.y)) : (s *= 0.5, t.x -= s, e.x += s, r = Math.sqrt(l * l * e.mass / t.mass) * (l > 0 ? 1 : -1), r -= a = 0.5 * (r + (o = Math.sqrt(h * h * t.mass / e.mass) * (h > 0 ? 1 : -1))), o -= a, t.velocity.x = a + r * t.bounce.x, e.velocity.x = a + o * e.bounce.x), !0; }; }, function (t, e, i) { const u = i(469); t.exports = function (t, e, i, n) { let s = u(t, e, i, n); if (i || s === 0 || t.immovable && e.immovable || t.customSeparateY || e.customSeparateY) return s !== 0 || t.embedded && e.embedded; let r; let o; let a; const h = t.velocity.y; const l = e.velocity.y; return t.immovable || e.immovable ? t.immovable ? (e.y += s, e.velocity.y = h - l * e.bounce.y, t.moves && (e.x += (t.x - t.prev.x) * t.friction.x)) : (t.y -= s, t.velocity.y = l - h * t.bounce.y, e.moves && (t.x += (e.x - e.prev.x) * e.friction.x)) : (s *= 0.5, t.y -= s, e.y += s, r = Math.sqrt(l * l * e.mass / t.mass) * (l > 0 ? 1 : -1), r -= a = 0.5 * (r + (o = Math.sqrt(h * h * t.mass / e.mass) * (h > 0 ? 1 : -1))), o -= a, t.velocity.y = a + r * t.bounce.y, e.velocity.y = a + o * e.bounce.y), !0; }; }, function (t, e, i) {\n    const f = {}; t.exports = f; const y = i(148); const g = i(219); const v = i(42); const x = i(62); const p = i(109); f.stack = function (t, e, i, n, s, r, o) { for (var a, h = y.create({ label: 'Stack' }), l = t, u = e, c = 0, d = 0; d < n; d++) { for (var f = 0, p = 0; p < i; p++) { var g; var v; const m = o(l, u, p, d, a, c); m ? (g = m.bounds.max.y - m.bounds.min.y, v = m.bounds.max.x - m.bounds.min.x, f < g && (f = g), x.translate(m, { x: 0.5 * v, y: 0.5 * g }), l = m.bounds.max.x + s, y.addBody(h, m), a = m, c += 1) : l += s; }u += f + r, l = t; } return h; }, f.chain = function (t, e, i, n, s, r) {\n      for (let o = t.bodies, a = 1; a < o.length; a++) {\n        const h = o[a - 1]; const l = o[a]; const u = h.bounds.max.y - h.bounds.min.y; const c = h.bounds.max.x - h.bounds.min.x; const d = l.bounds.max.y - l.bounds.min.y; const f = {\n          bodyA: h, pointA: { x: c * e, y: u * i }, bodyB: l, pointB: { x: (l.bounds.max.x - l.bounds.min.x) * n, y: d * s },\n        }; const p = v.extend(f, r); y.addConstraint(t, g.create(p));\n      } return t.label += ' Chain', t;\n    }, f.mesh = function (t, e, i, n, s) { for (var r, o, a, h, l = t.bodies, u = 0; u < i; u++) { for (r = 1; r < e; r++)o = l[r - 1 + u * e], a = l[r + u * e], y.addConstraint(t, g.create(v.extend({ bodyA: o, bodyB: a }, s))); if (u > 0) for (r = 0; r < e; r++)o = l[r + (u - 1) * e], a = l[r + u * e], y.addConstraint(t, g.create(v.extend({ bodyA: o, bodyB: a }, s))), n && r > 0 && (h = l[r - 1 + (u - 1) * e], y.addConstraint(t, g.create(v.extend({ bodyA: h, bodyB: a }, s)))), n && r < e - 1 && (h = l[r + 1 + (u - 1) * e], y.addConstraint(t, g.create(v.extend({ bodyA: h, bodyB: a }, s)))); } return t.label += ' Mesh', t; }, f.pyramid = function (h, t, l, u, c, e, d) { return f.stack(h, t, l, u, c, e, (t, e, i, n, s, r) => { const o = Math.min(u, Math.ceil(l / 2)); const a = s ? s.bounds.max.x - s.bounds.min.x : 0; if (!(o < n) && !(i < (n = o - n) || l - 1 - n < i)) return r === 1 && x.translate(s, { x: (i + (l % 2 == 1 ? 1 : -1)) * a, y: 0 }), d(h + (s ? i * a : 0) + i * c, e, i, n, s, r); }); }, f.newtonsCradle = function (t, e, i, n, s) {\n      for (var r = y.create({ label: 'Newtons Cradle' }), o = 0; o < i; o++) {\n        const a = p.circle(t + o * (1.9 * n), e + s, n, {\n          inertia: 1 / 0, restitution: 1, friction: 0, frictionAir: 1e-4, slop: 1,\n        }); const h = g.create({ pointA: { x: t + o * (1.9 * n), y: e }, bodyB: a }); y.addBody(r, a), y.addConstraint(r, h);\n      } return r;\n    }, f.car = function (t, e, i, n, s) {\n      const r = x.nextGroup(!0); const o = 0.5 * -i + 20; const a = 0.5 * i - 20; const h = y.create({ label: 'Car' }); const l = p.rectangle(t, e, i, n, { collisionFilter: { group: r }, chamfer: { radius: 0.5 * n }, density: 2e-4 }); const u = p.circle(t + o, e + 0, s, { collisionFilter: { group: r }, friction: 0.8 }); const c = p.circle(t + a, e + 0, s, { collisionFilter: { group: r }, friction: 0.8 }); const d = g.create({\n        bodyB: l, pointB: { x: o, y: 0 }, bodyA: u, stiffness: 1, length: 0,\n      }); const f = g.create({\n        bodyB: l, pointB: { x: a, y: 0 }, bodyA: c, stiffness: 1, length: 0,\n      }); return y.addBody(h, l), y.addBody(h, u), y.addBody(h, c), y.addConstraint(h, d), y.addConstraint(h, f), h;\n    }, f.softBody = function (t, e, i, n, s, r, o, a, h, l) { h = v.extend({ inertia: 1 / 0 }, h), l = v.extend({ stiffness: 0.2, render: { type: 'line', anchors: !1 } }, l); const u = f.stack(t, e, i, n, s, r, (t, e) => p.circle(t, e, a, h)); return f.mesh(u, i, n, o, l), u.label = 'Soft Body', u; };\n  }, function (t, e, i) { const x = {}; t.exports = x; i(100); const T = i(42); x.pathToVertices = function (t, e) { typeof window === 'undefined' || 'SVGPathSeg' in window || T.warn('Svg.pathToVertices: SVGPathSeg not defined, a polyfill is required.'); let i; let n; let s; let r; let o; let a; let h; let l; let u; let c; let d; const f = []; let p = 0; let g = 0; let v = 0; e = e || 15; function m(t, e, i) { let n; const s = i % 2 == 1 && i > 1; u && t == u.x && e == u.y || (d = u && s ? (c = u.x, u.y) : c = 0, n = { x: c + t, y: d + e }, !s && u || (u = n), f.push(n), g = c + t, v = d + e); } function y(t) { const e = t.pathSegTypeAsLetter.toUpperCase(); if (e !== 'Z') { switch (e) { case 'M': case 'L': case 'T': case 'C': case 'S': case 'Q': g = t.x, v = t.y; break; case 'H': g = t.x; break; case 'V': v = t.y; }m(g, v, t.pathSegType); } } for (x._svgPathToAbsolute(t), s = t.getTotalLength(), a = [], i = 0; i < t.pathSegList.numberOfItems; i += 1)a.push(t.pathSegList.getItem(i)); for (h = a.concat(); p < s;) { if ((o = a[t.getPathSegAtLength(p)]) != l) { for (;h.length && h[0] != o;)y(h.shift()); l = o; } switch (o.pathSegTypeAsLetter.toUpperCase()) { case 'C': case 'T': case 'S': case 'Q': case 'A': r = t.getPointAtLength(p), m(r.x, r.y, 0); }p += e; } for (i = 0, n = h.length; i < n; ++i)y(h[i]); return f; }, x._svgPathToAbsolute = function (t) { for (var e, i, n, s, r, o, a = t.pathSegList, h = 0, l = 0, u = a.numberOfItems, c = 0; c < u; ++c) { const d = a.getItem(c); const f = d.pathSegTypeAsLetter; if (/[MLHVCSQTA]/.test(f))'x' in d && (h = d.x), 'y' in d && (l = d.y); else switch ('x1' in d && (n = h + d.x1), 'x2' in d && (r = h + d.x2), 'y1' in d && (s = l + d.y1), 'y2' in d && (o = l + d.y2), 'x' in d && (h += d.x), 'y' in d && (l += d.y), f) { case 'm': a.replaceItem(t.createSVGPathSegMovetoAbs(h, l), c); break; case 'l': a.replaceItem(t.createSVGPathSegLinetoAbs(h, l), c); break; case 'h': a.replaceItem(t.createSVGPathSegLinetoHorizontalAbs(h), c); break; case 'v': a.replaceItem(t.createSVGPathSegLinetoVerticalAbs(l), c); break; case 'c': a.replaceItem(t.createSVGPathSegCurvetoCubicAbs(h, l, n, s, r, o), c); break; case 's': a.replaceItem(t.createSVGPathSegCurvetoCubicSmoothAbs(h, l, r, o), c); break; case 'q': a.replaceItem(t.createSVGPathSegCurvetoQuadraticAbs(h, l, n, s), c); break; case 't': a.replaceItem(t.createSVGPathSegCurvetoQuadraticSmoothAbs(h, l), c); break; case 'a': a.replaceItem(t.createSVGPathSegArcAbs(h, l, d.r1, d.r2, d.angle, d.largeArcFlag, d.sweepFlag), c); break; case 'z': case 'Z': h = e, l = i; }f != 'M' && f != 'm' || (e = h, i = l); } }; }, function (t, e, i) { const o = i(109); const c = i(62); const d = i(42); const f = i(2); const s = i(86); const n = { parseBody(t, e, i, n) { void 0 === n && (n = {}); for (var s = f(i, 'fixtures', []), r = [], o = 0; o < s.length; o++) for (let a = this.parseFixture(s[o]), h = 0; h < a.length; h++)r.push(a[h]); const l = d.clone(i, !0); d.extend(l, n, !0), delete l.fixtures, delete l.type; const u = c.create(l); return c.setParts(u, r), c.setPosition(u, { x: t, y: e }), u; }, parseFixture(t) { let e; let i; let n; let s; const r = d.extend({}, !1, t); return delete r.circle, delete r.vertices, t.circle ? (e = f(t.circle, 'x'), i = f(t.circle, 'y'), n = f(t.circle, 'radius'), s = [o.circle(e, i, n, r)]) : t.vertices && (s = this.parseVertices(t.vertices, r)), s; }, parseVertices(t, e) { void 0 === e && (e = {}); for (var i = [], n = 0; n < t.length; n++)s.clockwiseSort(t[n]), i.push(c.create(d.extend({ position: s.centre(t[n]), vertices: t[n] }, e))); return o.flagCoincidentParts(i); } }; t.exports = n; }, function (t, e, i) { const l = i(109); const u = i(62); const n = { parseBody(t, e, i, n) { let s; void 0 === n && (n = {}); const r = i.vertices; if (r.length === 1)n.vertices = r[0], s = u.create(n), l.flagCoincidentParts(s.parts); else { for (var o = [], a = 0; a < r.length; a++) { const h = u.create({ vertices: r[a] }); o.push(h); }l.flagCoincidentParts(o), n.parts = o, s = u.create(n); } return s.label = i.label, u.setPosition(s, { x: t, y: e }), s; } }; t.exports = n; }, function (t, e, i) {\n    t.exports = {\n      AFTER_ADD: i(1407), AFTER_REMOVE: i(1408), AFTER_UPDATE: i(1409), BEFORE_ADD: i(1410), BEFORE_REMOVE: i(1411), BEFORE_UPDATE: i(1412), COLLISION_ACTIVE: i(1413), COLLISION_END: i(1414), COLLISION_START: i(1415), DRAG_END: i(1416), DRAG: i(1417), DRAG_START: i(1418), PAUSE: i(1419), RESUME: i(1420), SLEEP_END: i(1421), SLEEP_START: i(1422),\n    };\n  }, function (t, e, i) {\n    const y = i(109); const x = i(62); const n = i(0); const s = i(514); const o = i(10); const T = i(2); const w = i(108); const b = i(86); const r = new n({\n      Extends: o, Mixins: [s.Bounce, s.Collision, s.Friction, s.Gravity, s.Mass, s.Sensor, s.Sleep, s.Static], initialize(t, e, i) { o.call(this), this.tile = e, this.world = t, e.physics.matterBody && e.physics.matterBody.destroy(), e.physics.matterBody = this; let n; const s = T(i, 'body', null); const r = T(i, 'addToWorld', !0); s ? this.setBody(s, r) : (n = e.getCollisionGroup(), T(n, 'objects', []).length > 0 ? this.setFromTileCollision(i) : this.setFromTileRectangle(i)); }, setFromTileRectangle(t) { void 0 === t && (t = {}), w(t, 'isStatic') || (t.isStatic = !0), w(t, 'addToWorld') || (t.addToWorld = !0); const e = this.tile.getBounds(); const i = e.x + e.width / 2; const n = e.y + e.height / 2; const s = y.rectangle(i, n, e.width, e.height, t); return this.setBody(s, t.addToWorld), this; }, setFromTileCollision(t) { void 0 === t && (t = {}), w(t, 'isStatic') || (t.isStatic = !0), w(t, 'addToWorld') || (t.addToWorld = !0); for (var e = this.tile.tilemapLayer.scaleX, i = this.tile.tilemapLayer.scaleY, n = this.tile.getLeft(), s = this.tile.getTop(), r = this.tile.getCollisionGroup(), o = T(r, 'objects', []), a = [], h = 0; h < o.length; h++) { var l; var u; var c; const d = o[h]; let f = n + d.x * e; let p = s + d.y * i; const g = d.width * e; const v = d.height * i; let m = null; d.rectangle ? m = y.rectangle(f + g / 2, p + v / 2, g, v, t) : d.ellipse ? m = y.circle(f + g / 2, p + v / 2, g / 2, t) : (d.polygon || d.polyline) && (l = (d.polygon ? d.polygon : d.polyline).map((t) => ({ x: t.x * e, y: t.y * i })), u = b.create(l), f += (c = b.centre(u)).x, p += c.y, m = y.fromVertices(f, p, u, t)), m && a.push(m); } return a.length === 1 ? this.setBody(a[0], t.addToWorld) : a.length > 1 && (t.parts = a, this.setBody(x.create(t), t.addToWorld)), this; }, setBody(t, e) { return void 0 === e && (e = !0), this.body && this.removeBody(), this.body = t, this.body.gameObject = this, e && this.world.add(this.body), this; }, removeBody() { return this.body && (this.world.remove(this.body), this.body.gameObject = void 0, this.body = void 0), this; }, destroy() { this.removeBody(), this.tile.physics.matterBody = void 0, this.removeAllListeners(); },\n    }); t.exports = r;\n  }, function (t, e, i) { const n = i(1389); n.Body = i(62), n.Composite = i(148), n.World = i(1300), n.Detector = i(515), n.Grid = i(1301), n.Pairs = i(1302), n.Pair = i(473), n.Query = i(1390), n.Resolver = i(1303), n.SAT = i(516), n.Constraint = i(219), n.Common = i(42), n.Engine = i(1391), n.Events = i(240), n.Sleeping = i(239), n.Plugin = i(1299), n.Bodies = i(109), n.Composites = i(1292), n.Axes = i(513), n.Bounds = i(100), n.Svg = i(1293), n.Vector = i(99), n.Vertices = i(86), n.World.add = n.Composite.add, n.World.remove = n.Composite.remove, n.World.addComposite = n.Composite.addComposite, n.World.addBody = n.Composite.addBody, n.World.addConstraint = n.Composite.addConstraint, n.World.clear = n.Composite.clear, t.exports = n; }, function (t, e, i) {\n    const a = {}; t.exports = a; const h = i(42); a._registry = {}, a.register = function (t) { let e; let i; let n; return a.isPlugin(t) || h.warn('Plugin.register:', a.toString(t), 'does not implement all required fields.'), t.name in a._registry ? (e = a._registry[t.name], i = a.versionParse(t.version).number, (n = a.versionParse(e.version).number) < i ? (h.warn('Plugin.register:', a.toString(e), 'was upgraded to', a.toString(t)), a._registry[t.name] = t) : i < n ? h.warn('Plugin.register:', a.toString(e), 'can not be downgraded to', a.toString(t)) : t !== e && h.warn('Plugin.register:', a.toString(t), 'is already registered to different plugin object')) : a._registry[t.name] = t, t; }, a.resolve = function (t) { return a._registry[a.dependencyParse(t).name]; }, a.toString = function (t) { return typeof t === 'string' ? t : `${t.name || 'anonymous'}@${t.version || t.range || '0.0.0'}`; }, a.isPlugin = function (t) { return t && t.name && t.version && t.install; }, a.isUsed = function (t, e) { return t.used.indexOf(e) > -1; }, a.isFor = function (t, e) { const i = t.for && a.dependencyParse(t.for); return !t.for || e.name === i.name && a.versionSatisfies(e.version, i.range); }, a.use = function (t, e) { if (t.uses = (t.uses || []).concat(e || []), t.uses.length !== 0) { for (var i, n = a.dependencies(t), s = h.topologicalSort(n), r = [], o = 0; o < s.length; o += 1) { s[o] !== t.name && ((i = a.resolve(s[o])) ? a.isUsed(t, i.name) || (a.isFor(i, t) || (h.warn('Plugin.use:', a.toString(i), 'is for', i.for, 'but installed on', `${a.toString(t)}.`), i._warned = !0), i.install ? i.install(t) : (h.warn('Plugin.use:', a.toString(i), 'does not specify an install function.'), i._warned = !0), i._warned ? (r.push(`🔶 ${a.toString(i)}`), delete i._warned) : r.push(`✅ ${a.toString(i)}`), t.used.push(i.name)) : r.push(`❌ ${s[o]}`)); }r.length > 0 && !i.silent && h.info(r.join('  ')); } else h.warn('Plugin.use:', a.toString(t), 'does not specify any dependencies to install.'); }, a.dependencies = function (n, t) { const s = a.dependencyParse(n); const e = s.name; if (!(e in (t = t || {}))) { n = a.resolve(n) || n, t[e] = h.map(n.uses || [], (t) => { a.isPlugin(t) && a.register(t); const e = a.dependencyParse(t); const i = a.resolve(t); return i && !a.versionSatisfies(i.version, e.range) ? (h.warn('Plugin.dependencies:', a.toString(i), 'does not satisfy', a.toString(e), 'used by', `${a.toString(s)}.`), i._warned = !0, n._warned = !0) : i || (h.warn('Plugin.dependencies:', a.toString(t), 'used by', a.toString(s), 'could not be resolved.'), n._warned = !0), e.name; }); for (let i = 0; i < t[e].length; i += 1)a.dependencies(t[e][i], t); return t; } }, a.dependencyParse = function (t) { if (h.isString(t)) { return /^[\\w-]+(@(\\*|[\\^~]?\\d+\\.\\d+\\.\\d+(-[0-9A-Za-z-]+)?))?$/.test(t) || h.warn('Plugin.dependencyParse:', t, 'is not a valid dependency string.'), { name: t.split('@')[0], range: t.split('@')[1] || '*' }; } return { name: t.name, range: t.range || t.version }; }, a.versionParse = function (t) {\n      /^\\*|[\\^~]?\\d+\\.\\d+\\.\\d+(-[0-9A-Za-z-]+)?$/.test(t) || h.warn('Plugin.versionParse:', t, 'is not a valid version or range.'); const e = t.split('-'); t = e[0]; const i = isNaN(Number(t[0])); const n = i ? t.substr(1) : t; const s = h.map(n.split('.'), (t) => Number(t)); return {\n        isRange: i, version: n, range: t, operator: i ? t[0] : '', parts: s, prerelease: e[1], number: 1e8 * s[0] + 1e4 * s[1] + s[2],\n      };\n    }, a.versionSatisfies = function (t, e) { e = e || '*'; const i = a.versionParse(e); const n = i.parts; const s = a.versionParse(t); const r = s.parts; if (i.isRange) { if (i.operator === '*' || t === '*') return !0; if (i.operator === '~') return r[0] === n[0] && r[1] === n[1] && r[2] >= n[2]; if (i.operator === '^') return n[0] > 0 ? r[0] === n[0] && s.number >= i.number : n[1] > 0 ? r[1] === n[1] && r[2] >= n[2] : r[2] === n[2]; } return t === e || t === '*'; };\n  }, function (t, e, i) { const n = {}; t.exports = n; const s = i(148); const r = (i(219), i(42)); n.create = function (t) { const e = s.create(); const i = { label: 'World', gravity: { x: 0, y: 1, scale: 0.001 }, bounds: { min: { x: -1 / 0, y: -1 / 0 }, max: { x: 1 / 0, y: 1 / 0 } } }; return r.extend(e, i, t); }; }, function (t, e, i) {\n    const y = {}; t.exports = y; const a = i(473); const n = i(515); const r = i(42); y.create = function (t) {\n      const e = {\n        controller: y, detector: n.collisions, buckets: {}, pairs: {}, pairsList: [], bucketWidth: 48, bucketHeight: 48,\n      }; return r.extend(e, t);\n    }, y.update = function (t, e, i, n) { for (var s, r, o, a = i.world, h = t.buckets, l = !1, u = i.metrics, c = u.broadphaseTests = 0; c < e.length; c++) { const d = e[c]; if ((!d.isSleeping || n) && !(d.bounds.max.x < a.bounds.min.x || d.bounds.min.x > a.bounds.max.x || d.bounds.max.y < a.bounds.min.y || d.bounds.min.y > a.bounds.max.y)) { const f = y._getRegion(t, d); if (!d.region || f.id !== d.region.id || n) { u.broadphaseTests += 1, d.region && !n || (d.region = f); for (let p = y._regionUnion(f, d.region), g = p.startCol; g <= p.endCol; g++) for (s = p.startRow; s <= p.endRow; s++) { r = h[o = y._getBucketId(g, s)]; const v = g >= f.startCol && g <= f.endCol && s >= f.startRow && s <= f.endRow; const m = g >= d.region.startCol && g <= d.region.endCol && s >= d.region.startRow && s <= d.region.endRow; !v && m && m && r && y._bucketRemoveBody(t, r, d), (d.region === f || v && !m || n) && (r = r || y._createBucket(h, o), y._bucketAddBody(t, r, d)); }d.region = f, l = !0; } } }l && (t.pairsList = y._createActivePairsList(t)); }, y.clear = function (t) { t.buckets = {}, t.pairs = {}, t.pairsList = []; }, y._regionUnion = function (t, e) { const i = Math.min(t.startCol, e.startCol); const n = Math.max(t.endCol, e.endCol); const s = Math.min(t.startRow, e.startRow); const r = Math.max(t.endRow, e.endRow); return y._createRegion(i, n, s, r); }, y._getRegion = function (t, e) { const i = e.bounds; const n = Math.floor(i.min.x / t.bucketWidth); const s = Math.floor(i.max.x / t.bucketWidth); const r = Math.floor(i.min.y / t.bucketHeight); const o = Math.floor(i.max.y / t.bucketHeight); return y._createRegion(n, s, r, o); }, y._createRegion = function (t, e, i, n) {\n      return {\n        id: `${t},${e},${i},${n}`, startCol: t, endCol: e, startRow: i, endRow: n,\n      };\n    }, y._getBucketId = function (t, e) { return `C${t}R${e}`; }, y._createBucket = function (t, e) { return t[e] = []; }, y._bucketAddBody = function (t, e, i) { for (let n = 0; n < e.length; n++) { var s; var r; const o = e[n]; i.id === o.id || i.isStatic && o.isStatic || (s = a.id(i, o), (r = t.pairs[s]) ? r[2] += 1 : t.pairs[s] = [i, o, 1]); }e.push(i); }, y._bucketRemoveBody = function (t, e, i) { e.splice(e.indexOf(i), 1); for (let n = 0; n < e.length; n++) { const s = e[n]; const r = a.id(i, s); const o = t.pairs[r]; o && --o[2]; } }, y._createActivePairsList = function (t) { for (var e, i = [], n = r.keys(t.pairs), s = 0; s < n.length; s++)(e = t.pairs[n[s]])[2] > 0 ? i.push(e) : delete t.pairs[n[s]]; return i; };\n  }, function (t, e, i) {\n    const l = {}; t.exports = l; const d = i(473); const n = i(42); l._pairMaxIdleLife = 1e3, l.create = function (t) {\n      return n.extend({\n        table: {}, list: [], collisionStart: [], collisionActive: [], collisionEnd: [],\n      }, t);\n    }, l.update = function (t, e, i) { let n; let s; let r; let o; const a = t.list; const h = t.table; const l = t.collisionStart; const u = t.collisionEnd; const c = t.collisionActive; for (l.length = 0, u.length = 0, o = c.length = 0; o < a.length; o++)a[o].confirmedActive = !1; for (o = 0; o < e.length; o++)(n = e[o]).collided && ((r = h[s = d.id(n.bodyA, n.bodyB)]) ? (r.isActive ? c.push(r) : l.push(r), d.update(r, n, i), r.confirmedActive = !0) : (r = d.create(n, i), h[s] = r, l.push(r), a.push(r))); for (o = 0; o < a.length; o++)(r = a[o]).isActive && !r.confirmedActive && (d.setActive(r, !1, i), u.push(r)); }, l.removeOld = function (t, e) { for (var i, n, s, r = t.list, o = t.table, a = [], h = 0; h < r.length; h++)(n = (i = r[h]).collision).bodyA.isSleeping || n.bodyB.isSleeping ? i.timeUpdated = e : e - i.timeUpdated > l._pairMaxIdleLife && a.push(h); for (h = 0; h < a.length; h++) delete o[(i = r[s = a[h] - h]).id], r.splice(s, 1); }, l.clear = function (t) { return t.table = {}, t.list.length = 0, t.collisionStart.length = 0, t.collisionActive.length = 0, t.collisionEnd.length = 0, t; };\n  }, function (t, e, i) { const Y = {}; t.exports = Y; const r = i(86); const X = i(99); const U = i(42); const o = i(100); Y._restingThresh = 4, Y._restingThreshTangent = 6, Y._positionDampen = 0.9, Y._positionWarming = 0.8, Y._frictionNormalMultiplier = 5, Y.preSolvePosition = function (t) { for (var e, i, n = 0; n < t.length; n++)(e = t[n]).isActive && (i = e.activeContacts.length, e.collision.parentA.totalContacts += i, e.collision.parentB.totalContacts += i); }, Y.solvePosition = function (t, e, i) { for (var n, s, r, o, a, h, l, u, c, d, f, p, g, v, m, y = i * Y._positionDampen, x = 0; x < e.length; x++) { const T = e[x]; T.previousPositionImpulse.x = T.positionImpulse.x, T.previousPositionImpulse.y = T.positionImpulse.y; } for (x = 0; x < t.length; x++)(r = t[x]).isActive && !r.isSensor && (a = (o = r.collision).parentA, h = o.parentB, l = o.normal, d = a.previousPositionImpulse, f = h.previousPositionImpulse, c = o.penetration, g = f.x - d.x + c.x, v = f.y - d.y + c.y, u = (n = l.x) * g + (s = l.y) * v, m = ((r.separation = u) - r.slop) * y, (a.isStatic || h.isStatic) && (m *= 2), a.isStatic || a.isSleeping || (p = m / a.totalContacts, a.positionImpulse.x += n * p, a.positionImpulse.y += s * p), h.isStatic || h.isSleeping || (p = m / h.totalContacts, h.positionImpulse.x -= n * p, h.positionImpulse.y -= s * p)); }, Y.postSolvePosition = function (t) { for (let e = 0; e < t.length; e++) { const i = t[e]; if ((i.totalContacts = 0) !== i.positionImpulse.x || i.positionImpulse.y !== 0) { for (let n = 0; n < i.parts.length; n++) { const s = i.parts[n]; r.translate(s.vertices, i.positionImpulse), o.update(s.bounds, s.vertices, i.velocity), s.position.x += i.positionImpulse.x, s.position.y += i.positionImpulse.y; }i.positionPrev.x += i.positionImpulse.x, i.positionPrev.y += i.positionImpulse.y, X.dot(i.positionImpulse, i.velocity) < 0 ? (i.positionImpulse.x = 0, i.positionImpulse.y = 0) : (i.positionImpulse.x *= Y._positionWarming, i.positionImpulse.y *= Y._positionWarming); } } }, Y.preSolveVelocity = function (t) { for (var e, i, n, s, r, o, a, h, l, u, c, d, f, p = X._temp[0], g = X._temp[1], v = 0; v < t.length; v++) if ((i = t[v]).isActive && !i.isSensor) for (n = i.activeContacts, r = (s = i.collision).parentA, o = s.parentB, a = s.normal, h = s.tangent, e = 0; e < n.length; e++)u = (l = n[e]).vertex, c = l.normalImpulse, d = l.tangentImpulse, c === 0 && d === 0 || (p.x = a.x * c + h.x * d, p.y = a.y * c + h.y * d, r.isStatic || r.isSleeping || (f = X.sub(u, r.position, g), r.positionPrev.x += p.x * r.inverseMass, r.positionPrev.y += p.y * r.inverseMass, r.anglePrev += X.cross(f, p) * r.inverseInertia), o.isStatic || o.isSleeping || (f = X.sub(u, o.position, g), o.positionPrev.x -= p.x * o.inverseMass, o.positionPrev.y -= p.y * o.inverseMass, o.anglePrev -= X.cross(f, p) * o.inverseInertia)); }, Y.solveVelocity = function (t, e) { for (let i = e * e, n = X._temp[0], s = X._temp[1], r = X._temp[2], o = X._temp[3], a = X._temp[4], h = X._temp[5], l = 0; l < t.length; l++) { const u = t[l]; if (u.isActive && !u.isSensor) { const c = u.collision; const d = c.parentA; const f = c.parentB; const p = c.normal; const g = c.tangent; const v = u.activeContacts; const m = 1 / v.length; d.velocity.x = d.position.x - d.positionPrev.x, d.velocity.y = d.position.y - d.positionPrev.y, f.velocity.x = f.position.x - f.positionPrev.x, f.velocity.y = f.position.y - f.positionPrev.y, d.angularVelocity = d.angle - d.anglePrev, f.angularVelocity = f.angle - f.anglePrev; for (let y = 0; y < v.length; y++) { const x = v[y]; const T = x.vertex; const w = X.sub(T, d.position, s); const b = X.sub(T, f.position, r); const E = X.add(d.velocity, X.mult(X.perp(w), d.angularVelocity), o); const S = X.add(f.velocity, X.mult(X.perp(b), f.angularVelocity), a); const _ = X.sub(E, S, h); const A = X.dot(p, _); const C = X.dot(g, _); const M = Math.abs(C); const P = U.sign(C); let O = (1 + u.restitution) * A; const R = U.clamp(u.separation + A, 0, 1) * Y._frictionNormalMultiplier; let L = C; let k = 1 / 0; M > u.friction * u.frictionStatic * R * i && (k = M, L = U.clamp(u.friction * P * i, -k, k)); var D; var F; const I = X.cross(w, p); const B = X.cross(b, p); const N = m / (d.inverseMass + f.inverseMass + d.inverseInertia * I * I + f.inverseInertia * B * B); O *= N, L *= N, A < 0 && A * A > Y._restingThresh * i ? x.normalImpulse = 0 : (D = x.normalImpulse, x.normalImpulse = Math.min(x.normalImpulse + O, 0), O = x.normalImpulse - D), C * C > Y._restingThreshTangent * i ? x.tangentImpulse = 0 : (F = x.tangentImpulse, x.tangentImpulse = U.clamp(x.tangentImpulse + L, -k, k), L = x.tangentImpulse - F), n.x = p.x * O + g.x * L, n.y = p.y * O + g.y * L, d.isStatic || d.isSleeping || (d.positionPrev.x += n.x * d.inverseMass, d.positionPrev.y += n.y * d.inverseMass, d.anglePrev += X.cross(w, n) * d.inverseInertia), f.isStatic || f.isSleeping || (f.positionPrev.x -= n.x * f.inverseMass, f.positionPrev.y -= n.y * f.inverseMass, f.anglePrev -= X.cross(b, n) * f.inverseInertia); } } } }; }, function (t, e, i) {\n    t.exports = {\n      BasePlugin: i(474), DefaultPlugins: i(175), PluginCache: i(23), PluginManager: i(370), ScenePlugin: i(1305),\n    };\n  }, function (t, e, i) {\n    const n = i(474); const s = i(0); const r = i(22); const o = new s({\n      Extends: n, initialize(t, e) { n.call(this, e), this.scene = t, this.systems = t.sys, t.sys.events.once(r.BOOT, this.boot, this); }, boot() {}, destroy() { this.pluginManager = null, this.game = null, this.scene = null, this.systems = null; },\n    }); t.exports = o;\n  }, function (t, e, i) {\n    const n = i(18); const s = i(177); var r = n(!1, r = {\n      Center: i(359), Events: i(92), Orientation: i(360), ScaleManager: i(371), ScaleModes: i(361), Zoom: i(362),\n    }, s.CENTER); r = n(!1, r, s.ORIENTATION), r = n(!1, r, s.SCALE_MODE), r = n(!1, r, s.ZOOM), t.exports = r;\n  }, function (t, e, i) {\n    const n = i(125); var s = i(18)(!1, s = {\n      Events: i(22), SceneManager: i(373), ScenePlugin: i(1308), Settings: i(375), Systems: i(180),\n    }, n); t.exports = s;\n  }, function (t, e, i) {\n    const n = i(19); const s = i(0); const a = i(22); const h = i(2); const r = i(23); const o = new s({\n      initialize(t) { this.scene = t, this.systems = t.sys, this.settings = t.sys.settings, this.key = t.sys.settings.key, this.manager = t.sys.game.scene, this.transitionProgress = 0, this._elapsed = 0, this._target = null, this._duration = 0, this._onUpdate, this._onUpdateScope, this._willSleep = !1, this._willRemove = !1, t.sys.events.once(a.BOOT, this.boot, this), t.sys.events.on(a.START, this.pluginStart, this); }, boot() { this.systems.events.once(a.DESTROY, this.destroy, this); }, pluginStart() { this._target = null, this.systems.events.once(a.SHUTDOWN, this.shutdown, this); }, start(t, e) { return void 0 === t && (t = this.key), this.manager.queueOp('stop', this.key), this.manager.queueOp('start', t, e), this; }, restart(t) { const e = this.key; return this.manager.queueOp('stop', e), this.manager.queueOp('start', e, t), this; }, transition(t) { void 0 === t && (t = {}); const e = h(t, 'target', !1); const i = this.manager.getScene(e); if (!e || !this.checkValidTransition(i)) return !1; const n = h(t, 'duration', 1e3); this._elapsed = 0, this._target = i, this._duration = n, this._willSleep = h(t, 'sleep', !1), this._willRemove = h(t, 'remove', !1); const s = h(t, 'onUpdate', null); s && (this._onUpdate = s, this._onUpdateScope = h(t, 'onUpdateScope', this.scene)); const r = h(t, 'allowInput', !1); this.settings.transitionAllowInput = r; const o = i.sys.settings; return o.isTransition = !0, o.transitionFrom = this.scene, o.transitionDuration = n, o.transitionAllowInput = r, h(t, 'moveAbove', !1) ? this.manager.moveAbove(this.key, e) : h(t, 'moveBelow', !1) && this.manager.moveBelow(this.key, e), i.sys.isSleeping() ? i.sys.wake(h(t, 'data')) : this.manager.start(e, h(t, 'data')), this.systems.events.emit(a.TRANSITION_OUT, i, n), this.systems.events.on(a.UPDATE, this.step, this), !0; }, checkValidTransition(t) { return !(!t || t.sys.isActive() || t.sys.isTransitioning() || t === this.scene || this.systems.isTransitioning()); }, step(t, e) { this._elapsed += e, this.transitionProgress = n(this._elapsed / this._duration, 0, 1), this._onUpdate && this._onUpdate.call(this._onUpdateScope, this.transitionProgress), this._elapsed >= this._duration && this.transitionComplete(); }, transitionComplete() { const t = this._target.sys; const e = this._target.sys.settings; this.systems.events.off(a.UPDATE, this.step, this), t.events.emit(a.TRANSITION_COMPLETE, this.scene), e.isTransition = !1, e.transitionFrom = null, this._duration = 0, this._target = null, this._onUpdate = null, this._onUpdateScope = null, this._willRemove ? this.manager.remove(this.key) : this._willSleep ? this.systems.sleep() : this.manager.stop(this.key); }, add(t, e, i, n) { return this.manager.add(t, e, i, n); }, launch(t, e) { return t && t !== this.key && this.manager.queueOp('start', t, e), this; }, run(t, e) { return t && t !== this.key && this.manager.queueOp('run', t, e), this; }, pause(t, e) { return void 0 === t && (t = this.key), this.manager.queueOp('pause', t, e), this; }, resume(t, e) { return void 0 === t && (t = this.key), this.manager.queueOp('resume', t, e), this; }, sleep(t, e) { return void 0 === t && (t = this.key), this.manager.queueOp('sleep', t, e), this; }, wake(t, e) { return void 0 === t && (t = this.key), this.manager.queueOp('wake', t, e), this; }, switch(t) { return t !== this.key && this.manager.queueOp('switch', this.key, t), this; }, stop(t, e) { return void 0 === t && (t = this.key), this.manager.queueOp('stop', t, e), this; }, setActive(t, e, i) { void 0 === e && (e = this.key); const n = this.manager.getScene(e); return n && n.sys.setActive(t, i), this; }, setVisible(t, e) { void 0 === e && (e = this.key); const i = this.manager.getScene(e); return i && i.sys.setVisible(t), this; }, isSleeping(t) { return void 0 === t && (t = this.key), this.manager.isSleeping(t); }, isActive(t) { return void 0 === t && (t = this.key), this.manager.isActive(t); }, isPaused(t) { return void 0 === t && (t = this.key), this.manager.isPaused(t); }, isVisible(t) { return void 0 === t && (t = this.key), this.manager.isVisible(t); }, swapPosition(t, e) { return void 0 === e && (e = this.key), t !== e && this.manager.swapPosition(t, e), this; }, moveAbove(t, e) { return void 0 === e && (e = this.key), t !== e && this.manager.moveAbove(t, e), this; }, moveBelow(t, e) { return void 0 === e && (e = this.key), t !== e && this.manager.moveBelow(t, e), this; }, remove(t) { return void 0 === t && (t = this.key), this.manager.remove(t), this; }, moveUp(t) { return void 0 === t && (t = this.key), this.manager.moveUp(t), this; }, moveDown(t) { return void 0 === t && (t = this.key), this.manager.moveDown(t), this; }, bringToTop(t) { return void 0 === t && (t = this.key), this.manager.bringToTop(t), this; }, sendToBack(t) { return void 0 === t && (t = this.key), this.manager.sendToBack(t), this; }, get(t) { return this.manager.getScene(t); }, getIndex(t) { return void 0 === t && (t = this.key), this.manager.getIndex(t); }, shutdown() { const t = this.systems.events; t.off(a.SHUTDOWN, this.shutdown, this), t.off(a.POST_UPDATE, this.step, this), t.off(a.TRANSITION_OUT); }, destroy() { this.shutdown(), this.scene.sys.events.off(a.START, this.start, this), this.scene = null, this.systems = null, this.settings = null, this.manager = null; },\n    }); r.register('ScenePlugin', o, 'scenePlugin'), t.exports = o;\n  }, function (t, e, i) {\n    t.exports = {\n      List: i(129), Map: i(162), ProcessQueue: i(186), RTree: i(470), Set: i(133), Size: i(372),\n    };\n  }, function (t, e, i) {\n    const n = i(18); const s = i(1311); var r = n(!1, r = {\n      CanvasTexture: i(377), Events: i(121), FilterMode: s, Frame: i(94), Parsers: i(379), Texture: i(182), TextureManager: i(376), TextureSource: i(378),\n    }, s); t.exports = r;\n  }, function (t, e) { t.exports = { LINEAR: 0, NEAREST: 1 }; }, function (t, e, i) {\n    t.exports = {\n      Components: i(141), Parsers: i(1342), Formats: i(32), ImageCollection: i(485), ParseToTilemap: i(227), Tile: i(74), Tilemap: i(494), TilemapCreator: i(1351), TilemapFactory: i(1352), Tileset: i(104), LayerData: i(102), MapData: i(103), ObjectLayer: i(488), DynamicTilemapLayer: i(495), StaticTilemapLayer: i(496),\n    };\n  }, function (t, e, i) { const p = i(24); const g = i(51); t.exports = function (t, e, i, n, s, r, o, a) { t < 0 && (t = 0), e < 0 && (e = 0), void 0 === o && (o = !0); for (let h = p(t, e, i, n, null, a), l = s - t, u = r - e, c = 0; c < h.length; c++) { const d = h[c].x + l; const f = h[c].y + u; d >= 0 && d < a.width && f >= 0 && f < a.height && a.data[f][d] && a.data[f][d].copy(h[c]); }o && g(s - 1, r - 1, i + 2, n + 2, a); }; }, function (t, e, i) { const d = i(143); const f = i(144); const p = i(24); const g = i(475); t.exports = function (t, e, i, n, s, r) { void 0 === i && (i = {}), Array.isArray(t) || (t = [t]); const o = r.tilemapLayer; void 0 === n && (n = o.scene), void 0 === s && (s = n.cameras.main); for (var a = p(0, 0, r.width, r.height, null, r), h = [], l = 0; l < a.length; l++) { var u; const c = a[l]; t.indexOf(c.index) !== -1 && (i.x = d(c.x, s, r), i.y = f(c.y, s, r), u = n.make.sprite(i), h.push(u)); } if (typeof e === 'number') for (l = 0; l < t.length; l++)g(t[l], e, 0, 0, r.width, r.height, r); else if (Array.isArray(e)) for (l = 0; l < t.length; l++)g(t[l], e[l], 0, 0, r.width, r.height, r); return h; }; }, function (t, e, i) { const b = i(93); const E = i(330); t.exports = function (t, e, i, n) { void 0 === i && (i = []), void 0 === n && (n = 0), i.length = 0; let s; let r; let o; let a; let h; let l; let u; const c = t.tilemapLayer.tilemap; const d = t.tilemapLayer; const f = t.data; const p = t.width; const g = t.height; const v = Math.floor(c.tileWidth * d.scaleX); const m = Math.floor(c.tileHeight * d.scaleY); let y = 0; let x = p; let T = 0; let w = g; if (d.skipCull || d.scrollFactorX !== 1 || d.scrollFactorY !== 1 || (s = b(e.worldView.x - d.x, v, 0, !0) - d.cullPaddingX, r = E(e.worldView.right - d.x, v, 0, !0) + d.cullPaddingX, o = b(e.worldView.y - d.y, m, 0, !0) - d.cullPaddingY, a = E(e.worldView.bottom - d.y, m, 0, !0) + d.cullPaddingY, y = Math.max(0, s), x = Math.min(p, r), T = Math.max(0, o), w = Math.min(g, a)), n === 0) for (l = T; l < w; l++) for (h = y; f[l] && h < x; h++)(u = f[l][h]) && u.index !== -1 && u.visible && u.alpha !== 0 && i.push(u); else if (n === 1) for (l = T; l < w; l++) for (h = x; f[l] && y <= h; h--)(u = f[l][h]) && u.index !== -1 && u.visible && u.alpha !== 0 && i.push(u); else if (n === 2) for (l = w; T <= l; l--) for (h = y; f[l] && h < x; h++)(u = f[l][h]) && u.index !== -1 && u.visible && u.alpha !== 0 && i.push(u); else if (n === 3) for (l = w; T <= l; l--) for (h = x; f[l] && y <= h; h--)(u = f[l][h]) && u.index !== -1 && u.visible && u.alpha !== 0 && i.push(u); return d.tilesDrawn = i.length, d.tilesTotal = p * g, i; }; }, function (t, e, i) { const u = i(24); const c = i(51); const d = i(73); t.exports = function (t, e, i, n, s, r, o) { for (let a = o.collideIndexes.indexOf(t) !== -1, h = u(e, i, n, s, null, o), l = 0; l < h.length; l++)h[l].index = t, d(h[l], a); r && c(e - 1, i - 1, n + 2, s + 2, o); }; }, function (t, e, i) { const h = i(24); t.exports = function (t, e, i, n, s, r, o, a) { return h(i, n, s, r, o, a).filter(t, e); }; }, function (t, e) { t.exports = function (t, e, i, n) { void 0 === e && (e = 0), void 0 === i && (i = !1); let s; let r; let o; let a = 0; if (i) { for (r = n.height - 1; r >= 0; r--) for (s = n.width - 1; s >= 0; s--) if ((o = n.data[r][s]) && o.index === t) { if (a === e) return o; a += 1; } } else for (r = 0; r < n.height; r++) for (s = 0; s < n.width; s++) if ((o = n.data[r][s]) && o.index === t) { if (a === e) return o; a += 1; } return null; }; }, function (t, e, i) { const h = i(24); t.exports = function (t, e, i, n, s, r, o, a) { return h(i, n, s, r, o, a).find(t, e) || null; }; }, function (t, e, i) { const h = i(24); t.exports = function (t, e, i, n, s, r, o, a) { h(i, n, s, r, o, a).forEach(t, e); }; }, function (t, e, i) { const a = i(142); const h = i(63); const l = i(64); t.exports = function (t, e, i, n, s) { const r = h(t, !0, n, s); const o = l(e, !0, n, s); return a(r, o, i, s); }; }, function (t, e, i) { function y(t, e) { return w.RectangleToTriangle(e, t); } const x = i(430); const T = i(24); var w = i(431); const b = i(1); const E = i(143); const S = i(144); const _ = i(63); const A = i(64); t.exports = function (t, e, i, n) { if (void 0 === t) return []; let s = b; t instanceof x.Circle ? s = w.CircleToRectangle : t instanceof x.Rectangle ? s = w.RectangleToRectangle : t instanceof x.Triangle ? s = y : t instanceof x.Line && (s = w.LineToRectangle); const r = _(t.left, !0, i, n); const o = A(t.top, !0, i, n); const a = Math.ceil(_(t.right, !1, i, n)); const h = Math.ceil(A(t.bottom, !1, i, n)); const l = Math.max(a - r, 1); const u = Math.max(h - o, 1); const c = T(r, o, l, u, e, n); let d = n.tileWidth; let f = n.tileHeight; n.tilemapLayer && (d *= n.tilemapLayer.scaleX, f *= n.tilemapLayer.scaleY); for (var p = [], g = new x.Rectangle(0, 0, d, f), v = 0; v < c.length; v++) { const m = c[v]; g.x = E(m.x, i, n), g.y = S(m.y, i, n), s(t, g) && p.push(m); } return p; }; }, function (t, e, i) { const c = i(24); const d = i(63); const f = i(64); t.exports = function (t, e, i, n, s, r, o) { const a = d(t, !0, r, o); const h = f(e, !0, r, o); const l = Math.ceil(d(t + i, !1, r, o)); const u = Math.ceil(f(e + n, !1, r, o)); return c(a, h, l - a, u - h, s, o); }; }, function (t, e, i) { const o = i(476); const a = i(63); const h = i(64); t.exports = function (t, e, i, n) { const s = a(t, !0, i, n); const r = h(e, !0, i, n); return o(s, r, n); }; }, function (t, e, i) { const h = i(221); const l = i(63); const u = i(64); t.exports = function (t, e, i, n, s, r) { const o = l(e, !0, s, r); const a = u(i, !0, s, r); return h(t, o, a, n, r); }; }, function (t, e, i) { const u = i(51); const c = i(221); t.exports = function (t, e, i, n, s) { if (!Array.isArray(t)) return null; void 0 === n && (n = !0), Array.isArray(t[0]) || (t = [t]); for (var r = t.length, o = t[0].length, a = 0; a < r; a++) for (let h = 0; h < o; h++) { const l = t[a][h]; c(l, e + h, i + a, !1, s); }n && u(e - 1, i - 1, o + 2, r + 2, s); }; }, function (t, e, i) { const h = i(24); const l = i(185); t.exports = function (t, e, i, n, s, r) { let o; const a = h(t, e, i, n, null, r); if (void 0 === s) for (s = [], o = 0; o < a.length; o++)s.indexOf(a[o].index) === -1 && s.push(a[o].index); for (o = 0; o < a.length; o++)a[o].index = l(s); }; }, function (t, e, i) { const h = i(477); const l = i(63); const u = i(64); t.exports = function (t, e, i, n, s, r) { const o = l(t, !0, s, r); const a = u(e, !0, s, r); return h(o, a, i, n, r); }; }, function (t, e, i) { const p = i(24); const n = i(354); const g = new n(105, 210, 231, 150); const v = new n(243, 134, 48, 200); const m = new n(40, 39, 37, 150); t.exports = function (t, e, i) { void 0 === e && (e = {}); const n = void 0 !== e.tileColor ? e.tileColor : g; const s = void 0 !== e.collidingTileColor ? e.collidingTileColor : v; const r = void 0 !== e.faceColor ? e.faceColor : m; const o = p(0, 0, i.width, i.height, null, i); t.translateCanvas(i.tilemapLayer.x, i.tilemapLayer.y), t.scaleCanvas(i.tilemapLayer.scaleX, i.tilemapLayer.scaleY); for (let a = 0; a < o.length; a++) { const h = o[a]; let l = h.width; let u = h.height; let c = h.pixelX; let d = h.pixelY; const f = h.collides ? s : n; f !== null && (t.fillStyle(f.color, f.alpha / 255), t.fillRect(c, d, l, u)), c += 1, d += 1, l -= 2, u -= 2, r !== null && (t.lineStyle(1, r.color, r.alpha / 255), h.faceTop && t.lineBetween(c, d, c + l, d), h.faceRight && t.lineBetween(c + l, d, c + l, d + u), h.faceBottom && t.lineBetween(c, d + u, c + l, d + u), h.faceLeft && t.lineBetween(c, d, c, d + u)); } }; }, function (t, e, i) { const l = i(73); const u = i(51); const c = i(222); t.exports = function (t, e, i, n, s) { void 0 === e && (e = !0), void 0 === i && (i = !0), Array.isArray(t) || (t = [t]), void 0 === s && (s = !0); for (let r = 0; r < t.length; r++)c(t[r], e, n); if (s) for (let o = 0; o < n.height; o++) for (let a = 0; a < n.width; a++) { const h = n.data[o][a]; h && t.indexOf(h.index) !== -1 && l(h, e); }i && u(0, 0, n.width, n.height, n); }; }, function (t, e, i) { const u = i(73); const c = i(51); const d = i(222); t.exports = function (t, e, i, n, s, r) { if (void 0 === i && (i = !0), void 0 === n && (n = !0), void 0 === r && (r = !0), !(e < t)) { for (let o = t; o <= e; o++)d(o, i, s); if (r) for (let a = 0; a < s.height; a++) for (let h = 0; h < s.width; h++) { const l = s.data[a][h]; l && l.index >= t && l.index <= e && u(l, i); }n && c(0, 0, s.width, s.height, s); } }; }, function (t, e, i) { const a = i(73); const h = i(51); const l = i(222); t.exports = function (t, e, i, n) { void 0 === e && (e = !0), void 0 === i && (i = !0), Array.isArray(t) || (t = [t]); for (let s = 0; s < n.height; s++) for (let r = 0; r < n.width; r++) { const o = n.data[s][r]; o && t.indexOf(o.index) === -1 && (a(o, e), l(o.index, e, n)); }i && h(0, 0, n.width, n.height, n); }; }, function (t, e, i) { const u = i(73); const c = i(51); const d = i(108); t.exports = function (t, e, i, n) { void 0 === e && (e = !0), void 0 === i && (i = !0); for (let s = 0; s < n.height; s++) for (let r = 0; r < n.width; r++) { const o = n.data[s][r]; if (o) for (const a in t) if (d(o.properties, a)) { let h = t[a]; Array.isArray(h) || (h = [h]); for (let l = 0; l < h.length; l++)o.properties[a] === h[l] && u(o, e); } }i && c(0, 0, n.width, n.height, n); }; }, function (t, e, i) { const a = i(73); const h = i(51); t.exports = function (t, e, i) { void 0 === t && (t = !0), void 0 === e && (e = !0); for (let n = 0; n < i.height; n++) for (let s = 0; s < i.width; s++) { var r; const o = i.data[n][s]; o && ((r = o.getCollisionGroup()) && r.objects && r.objects.length > 0 && a(o, t)); }e && h(0, 0, i.width, i.height, i); }; }, function (t, e) { t.exports = function (t, e, i, n) { if (typeof t === 'number')n.callbacks[t] = e !== null ? { callback: e, callbackContext: i } : void 0; else for (let s = 0, r = t.length; s < r; s++)n.callbacks[t[s]] = e !== null ? { callback: e, callbackContext: i } : void 0; }; }, function (t, e, i) { const l = i(24); t.exports = function (t, e, i, n, s, r, o) { for (let a = l(t, e, i, n, null, o), h = 0; h < a.length; h++)a[h].setCollisionCallback(s, r); }; }, function (t, e, i) { const h = i(24); const l = i(114); t.exports = function (t, e, i, n, s) { const r = h(t, e, i, n, null, s); const o = r.map((t) => t.index); l(o); for (let a = 0; a < r.length; a++)r[a].index = o[a]; }; }, function (t, e, i) { const l = i(24); t.exports = function (t, e, i, n, s, r, o) { for (let a = l(i, n, s, r, null, o), h = 0; h < a.length; h++)a[h] && (a[h].index === t ? a[h].index = e : a[h].index === e && (a[h].index = t)); }; }, function (t, e, i) { const r = i(143); const o = i(144); const a = i(3); t.exports = function (t, e, i, n, s) { return void 0 === i && (i = new a(0, 0)), i.x = r(t, n, s), i.y = o(e, n, s), i; }; }, function (t, e, i) { const p = i(24); t.exports = function (t, e, i, n, s, r) { if (void 0 !== s) { for (var o = p(t, e, i, n, null, r), a = 0, h = 0; h < s.length; h++)a += s[h].weight; if (!(a <= 0)) for (h = 0; h < o.length; h++) { for (var l = Math.random() * a, u = 0, c = -1, d = 0; d < s.length; d++) if (l <= (u += s[d].weight)) { const f = s[d].index; var c = Array.isArray(f) ? f[Math.floor(Math.random() * f.length)] : f; break; }o[h].index = c; } } }; }, function (t, e, i) { const o = i(63); const a = i(64); const h = i(3); t.exports = function (t, e, i, n, s, r) { return void 0 === n && (n = new h(0, 0)), n.x = o(t, i, s, r), n.y = a(e, i, s, r), n; }; }, function (t, e, i) {\n    t.exports = {\n      Parse: i(478), Parse2DArray: i(223), ParseCSV: i(479), Impact: i(1343), Tiled: i(1344),\n    };\n  }, function (t, e, i) { t.exports = { ParseTileLayers: i(492), ParseTilesets: i(493), ParseWeltmeister: i(491) }; }, function (t, e, i) {\n    t.exports = {\n      AssignTileProperties: i(490), Base64Decode: i(482), BuildTilesetIndex: i(489), ParseGID: i(224), ParseImageLayers: i(483), ParseJSONTiled: i(480), ParseObject: i(226), ParseObjectLayers: i(487), ParseTileLayers: i(481), ParseTilesets: i(484),\n    };\n  }, function (t, e, i) { var n = i(1); var s = i(1); var n = i(1346); var s = i(1347); t.exports = { renderWebGL: n, renderCanvas: s }; }, function (t, e, i) { const R = i(9); t.exports = function (t, e, i, n) { e.cull(n); const s = e.culledTiles; const r = s.length; const o = n.alpha * e.alpha; if (!(r === 0 || o <= 0)) for (let a = e.gidMap, h = e.pipeline, l = R.getTintAppendFloatAlphaAndSwap, u = e.scrollFactorX, c = e.scrollFactorY, d = e.x, f = e.y, p = e.scaleX, g = e.scaleY, v = e.tileset, m = 0; m < v.length; m++) for (let y = v[m], x = y.glTexture, T = 0; T < r; T++) { var w; var b; var E; var S; var _; var A; var C; var M; const P = s[T]; const O = a[P.index]; O === y && ((w = O.getTileTextureCoordinates(P.index)) !== null && (b = P.width, E = P.height, S = w.x, _ = w.y, A = 0.5 * P.width, C = 0.5 * P.height, M = l(P.tint, o * P.alpha), h.batchTexture(e, x, x.width, x.height, d + (A + P.pixelX) * p, f + (C + P.pixelY) * g, P.width, P.height, p, g, P.rotation, P.flipX, P.flipY, u, c, A, C, S, _, b, E, M, M, M, M, !1, 0, 0, n, null, !0))); } }; }, function (t, e) { t.exports = function (t, e, i, n, s) { e.cull(n); const r = e.culledTiles; const o = r.length; if (o !== 0) { const a = t._tempMatrix1; const h = t._tempMatrix2; const l = t._tempMatrix3; h.applyITRS(e.x, e.y, e.rotation, e.scaleX, e.scaleY), a.copyFrom(n.matrix); const u = t.currentContext; const c = e.gidMap; u.save(), s ? (a.multiplyWithOffset(s, -n.scrollX * e.scrollFactorX, -n.scrollY * e.scrollFactorY), h.e = e.x, h.f = e.y, a.multiply(h, l), l.copyToContext(u)) : (h.e -= n.scrollX * e.scrollFactorX, h.f -= n.scrollY * e.scrollFactorY, h.copyToContext(u)); const d = n.alpha * e.alpha; (!t.antialias || e.scaleX > 1 || e.scaleY > 1) && (u.imageSmoothingEnabled = !1); for (let f = 0; f < o; f++) { var p; var g; var v; var m; const y = r[f]; const x = c[y.index]; x && (p = x.image.getSourceImage(), (g = x.getTileTextureCoordinates(y.index)) && (v = y.width / 2, m = y.height / 2, u.save(), u.translate(y.pixelX + v, y.pixelY + m), y.rotation !== 0 && u.rotate(y.rotation), (y.flipX || y.flipY) && u.scale(y.flipX ? -1 : 1, y.flipY ? -1 : 1), u.globalAlpha = d * y.alpha, u.drawImage(p, g.x, g.y, y.width, y.height, -v, -m, y.width, y.height), u.restore())); }u.restore(); } }; }, function (t, e, i) { var n = i(1); var s = i(1); var n = i(1349); var s = i(1350); t.exports = { renderWebGL: n, renderCanvas: s }; }, function (t, e) { t.exports = function (t, e, i, n) { const s = e.tileset; const r = e.pipeline; const o = r.vertexBuffer; t.setPipeline(r), r.modelIdentity(), r.modelTranslate(e.x - n.scrollX * e.scrollFactorX, e.y - n.scrollY * e.scrollFactorY, 0), r.modelScale(e.scaleX, e.scaleY, 1), r.viewLoad2D(n.matrix.matrix); for (let a = 0; a < s.length; a++)e.upload(n, a), e.vertexCount[a] > 0 && (t.currentPipeline && t.currentPipeline.vertexCount > 0 && t.flush(), r.vertexBuffer = e.vertexBuffer[a], t.setPipeline(r), t.setTexture2D(s[a].glTexture, 0), t.gl.drawArrays(r.topology, 0, e.vertexCount[a])); r.vertexBuffer = o, r.viewIdentity(), r.modelIdentity(); }; }, function (t, e) { t.exports = function (t, e, i, n, s) { e.cull(n); const r = e.culledTiles; const o = r.length; if (o !== 0) { const a = t._tempMatrix1; const h = t._tempMatrix2; const l = t._tempMatrix3; h.applyITRS(e.x, e.y, e.rotation, e.scaleX, e.scaleY), a.copyFrom(n.matrix); const u = t.currentContext; const c = e.gidMap; u.save(), s ? (a.multiplyWithOffset(s, -n.scrollX * e.scrollFactorX, -n.scrollY * e.scrollFactorY), h.e = e.x, h.f = e.y, a.multiply(h, l), l.copyToContext(u)) : (h.e -= n.scrollX * e.scrollFactorX, h.f -= n.scrollY * e.scrollFactorY, h.copyToContext(u)); const d = n.alpha * e.alpha; (!t.antialias || e.scaleX > 1 || e.scaleY > 1) && (u.imageSmoothingEnabled = !1); for (let f = 0; f < o; f++) { var p; var g; var v; var m; var y; var x; const T = r[f]; const w = c[T.index]; w && (p = w.image.getSourceImage(), (g = w.getTileTextureCoordinates(T.index)) && (y = (v = w.tileWidth) / 2, x = (m = w.tileHeight) / 2, u.save(), u.translate(T.pixelX + y, T.pixelY + x), T.rotation !== 0 && u.rotate(T.rotation), (T.flipX || T.flipY) && u.scale(T.flipX ? -1 : 1, T.flipY ? -1 : 1), u.globalAlpha = d * T.alpha, u.drawImage(p, g.x, g.y, v, m, -y, -x, v, m), u.restore())); }u.restore(); } }; }, function (t, e, i) { const n = i(16); const s = i(227); n.register('tilemap', function (t) { const e = void 0 !== t ? t : {}; return s(this.scene, e.key, e.tileWidth, e.tileHeight, e.width, e.height, e.data, e.insertNull); }); }, function (t, e, i) { const n = i(5); const a = i(227); n.register('tilemap', function (t, e, i, n, s, r, o) { return t === null && (t = void 0), e === null && (e = void 0), i === null && (i = void 0), n === null && (n = void 0), s === null && (s = void 0), a(this.scene, t, e, i, n, s, r, o); }); }, function (t, e, i) { t.exports = { Clock: i(1354), TimerEvent: i(497) }; }, function (t, e, i) {\n    const n = i(0); const s = i(23); const r = i(22); const o = i(497); const a = new n({\n      initialize(t) { this.scene = t, this.systems = t.sys, this.now = 0, this.timeScale = 1, this.paused = !1, this._active = [], this._pendingInsertion = [], this._pendingRemoval = [], t.sys.events.once(r.BOOT, this.boot, this), t.sys.events.on(r.START, this.start, this); },\n      boot() { this.now = this.systems.game.loop.time, this.systems.events.once(r.DESTROY, this.destroy, this); },\n      start() { const t = this.systems.events; t.on(r.PRE_UPDATE, this.preUpdate, this), t.on(r.UPDATE, this.update, this), t.once(r.SHUTDOWN, this.shutdown, this); },\n      addEvent(t) { const e = new o(t); return this._pendingInsertion.push(e), e; },\n      delayedCall(t, e, i, n) {\n        return this.addEvent({\n          delay: t, callback: e, args: i, callbackScope: n,\n        });\n      },\n      clearPendingEvents() { return this._pendingInsertion = [], this; },\n      removeAllEvents() { return this._pendingRemoval = this._pendingRemoval.concat(this._active), this; },\n      preUpdate() { const t = this._pendingRemoval.length; const e = this._pendingInsertion.length; if (t !== 0 || e !== 0) { for (var i, n = 0; n < t; n++) { i = this._pendingRemoval[n]; const s = this._active.indexOf(i); s > -1 && this._active.splice(s, 1), i.destroy(); } for (n = 0; n < e; n++)i = this._pendingInsertion[n], this._active.push(i); this._pendingRemoval.length = 0, this._pendingInsertion.length = 0; } },\n      update(t, e) { if (this.now = t, !this.paused) { e *= this.timeScale; for (let i = 0; i < this._active.length; i++) { var n; const s = this._active[i]; s.paused || (s.elapsed += e * s.timeScale, s.elapsed >= s.delay && (n = s.elapsed - s.delay, s.elapsed = s.delay, !s.hasDispatched && s.callback && (s.hasDispatched = !0, s.callback.apply(s.callbackScope, s.args)), s.repeatCount > 0 ? (s.repeatCount--, s.elapsed = n, s.hasDispatched = !1) : this._pendingRemoval.push(s))); } } },\n      shutdown() { for (var t = 0; t < this._pendingInsertion.length; t++) this._pendingInsertion[t].destroy(); for (t = 0; t < this._active.length; t++) this._active[t].destroy(); for (t = 0; t < this._pendingRemoval.length; t++) this._pendingRemoval[t].destroy(); this._active.length = 0, this._pendingRemoval.length = 0, this._pendingInsertion.length = 0; const e = this.systems.events; e.off(r.PRE_UPDATE, this.preUpdate, this), e.off(r.UPDATE, this.update, this), e.off(r.SHUTDOWN, this.shutdown, this); },\n      destroy() { this.shutdown(), this.scene.sys.events.off(r.START, this.start, this), this.scene = null, this.systems = null; },\n    }); s.register('Clock', a, 'time'), t.exports = a;\n  }, function (t, e, i) {\n    const n = i(89); var s = i(18)(!1, s = {\n      Builders: i(1356), Events: i(232), TweenManager: i(1372), Tween: i(231), TweenData: i(233), Timeline: i(503),\n    }, n); t.exports = s;\n  }, function (t, e, i) {\n    t.exports = {\n      GetBoolean: i(88), GetEaseFunction: i(69), GetNewValue: i(145), GetProps: i(498), GetTargets: i(228), GetTweens: i(499), GetValueOp: i(229), NumberTweenBuilder: i(500), StaggerBuilder: i(501), TimelineBuilder: i(502), TweenBuilder: i(146),\n    };\n  }, function (t, e) { t.exports = ['callbackScope', 'completeDelay', 'delay', 'duration', 'ease', 'easeParams', 'flipX', 'flipY', 'hold', 'loop', 'loopDelay', 'offset', 'onActive', 'onActiveParams', 'onActiveScope', 'onComplete', 'onCompleteParams', 'onCompleteScope', 'onLoop', 'onLoopParams', 'onLoopScope', 'onRepeat', 'onRepeatParams', 'onRepeatScope', 'onStart', 'onStartParams', 'onStartScope', 'onStop', 'onStopParams', 'onStopScope', 'onUpdate', 'onUpdateParams', 'onUpdateScope', 'onYoyo', 'onYoyoParams', 'onYoyoScope', 'paused', 'props', 'repeat', 'repeatDelay', 'targets', 'useFrames', 'yoyo']; }, function (t, e) { t.exports = 'complete'; }, function (t, e) { t.exports = 'loop'; }, function (t, e) { t.exports = 'pause'; }, function (t, e) { t.exports = 'resume'; }, function (t, e) { t.exports = 'start'; }, function (t, e) { t.exports = 'update'; }, function (t, e) { t.exports = 'active'; }, function (t, e) { t.exports = 'complete'; }, function (t, e) { t.exports = 'loop'; }, function (t, e) { t.exports = 'repeat'; }, function (t, e) { t.exports = 'start'; }, function (t, e) { t.exports = 'stop'; }, function (t, e) { t.exports = 'update'; }, function (t, e) { t.exports = 'yoyo'; }, function (t, e, i) {\n    const n = i(123); const s = i(0); const r = i(500); const o = i(23); const a = i(22); const h = i(501); const l = i(502); const u = i(89); const c = i(146); const d = new s({\n      initialize(t) { this.scene = t, this.systems = t.sys, this.timeScale = 1, this._add = [], this._pending = [], this._active = [], this._destroy = [], this._toProcess = 0, t.sys.events.once(a.BOOT, this.boot, this), t.sys.events.on(a.START, this.start, this); }, boot() { this.systems.events.once(a.DESTROY, this.destroy, this); }, start() { const t = this.systems.events; t.on(a.PRE_UPDATE, this.preUpdate, this), t.on(a.UPDATE, this.update, this), t.once(a.SHUTDOWN, this.shutdown, this), this.timeScale = 1; }, createTimeline(t) { return l(this, t); }, timeline(t) { const e = l(this, t); return e.paused || (this._add.push(e), this._toProcess++), e; }, create(t) { return c(this, t); }, add(t) { const e = c(this, t); return this._add.push(e), this._toProcess++, e; }, existing(t) { return this._add.push(t), this._toProcess++, this; }, addCounter(t) { const e = r(this, t); return this._add.push(e), this._toProcess++, e; }, stagger(t, e) { return h(t, e); }, preUpdate() { if (this._toProcess !== 0) { for (var t, e = this._destroy, i = this._active, n = this._pending, s = 0; s < e.length; s++) { t = e[s]; let r = i.indexOf(t); r === -1 ? (r = n.indexOf(t)) > -1 && (t.state = u.REMOVED, n.splice(r, 1)) : (t.state = u.REMOVED, i.splice(r, 1)); } for (e.length = 0, e = this._add, s = 0; s < e.length; s++)(t = e[s]).state === u.PENDING_ADD && (t.init() ? (t.play(), this._active.push(t)) : this._pending.push(t)); e.length = 0, this._toProcess = 0; } }, update(t, e) { let i; const n = this._active; e *= this.timeScale; for (let s = 0; s < n.length; s++)(i = n[s]).update(t, e) && (this._destroy.push(i), this._toProcess++); }, remove(t) { return n(this._add, t), n(this._pending, t), n(this._active, t), n(this._destroy, t), t.state = u.REMOVED, this; }, makeActive(t) { if (this._add.indexOf(t) !== -1 || this._active.indexOf(t) !== -1) return this; const e = this._pending.indexOf(t); return e !== -1 && this._pending.splice(e, 1), this._add.push(t), t.state = u.PENDING_ADD, this._toProcess++, this; }, each(t, e) { for (var i = [null], n = 1; n < arguments.length; n++)i.push(arguments[n]); for (const s in this.list)i[0] = this.list[s], t.apply(e, i); }, getAllTweens() { for (var t = this._active, e = [], i = 0; i < t.length; i++)e.push(t[i]); return e; }, getGlobalTimeScale() { return this.timeScale; }, getTweensOf(t) { let e; let i; const n = this._active; const s = []; if (Array.isArray(t)) for (i = 0; i < n.length; i++) { e = n[i]; for (let r = 0; r < t.length; r++)e.hasTarget(t[r]) && s.push(e); } else for (i = 0; i < n.length; i++)(e = n[i]).hasTarget(t) && s.push(e); return s; }, isTweening(t) { for (var e, i = this._active, n = 0; n < i.length; n++) if ((e = i[n]).hasTarget(t) && e.isPlaying()) return !0; return !1; }, killAll() { for (let t = this.getAllTweens(), e = 0; e < t.length; e++)t[e].stop(); return this; }, killTweensOf(t) { for (let e = this.getTweensOf(t), i = 0; i < e.length; i++)e[i].stop(); return this; }, pauseAll() { for (let t = this._active, e = 0; e < t.length; e++)t[e].pause(); return this; }, resumeAll() { for (let t = this._active, e = 0; e < t.length; e++)t[e].resume(); return this; }, setGlobalTimeScale(t) { return this.timeScale = t, this; }, shutdown() { this.killAll(), this._add = [], this._pending = [], this._active = [], this._destroy = [], this._toProcess = 0; const t = this.systems.events; t.off(a.PRE_UPDATE, this.preUpdate, this), t.off(a.UPDATE, this.update, this), t.off(a.SHUTDOWN, this.shutdown, this); }, destroy() { this.shutdown(), this.scene.sys.events.off(a.START, this.start, this), this.scene = null, this.systems = null; },\n    }); o.register('TweenManager', d, 'tweens'), t.exports = d;\n  }, function (t, e, i) {\n    t.exports = {\n      Array: i(183), Base64: i(1374), Objects: i(1376), String: i(1380),\n    };\n  }, function (t, e, i) { t.exports = { ArrayBufferToBase64: i(1375), Base64ToArrayBuffer: i(388) }; }, function (t, e) { const o = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'; t.exports = function (t, e) { for (var i = new Uint8Array(t), n = i.length, s = e ? `data:${e};base64,` : '', r = 0; r < n; r += 3)s += o[i[r] >> 2], s += o[(3 & i[r]) << 4 | i[r + 1] >> 4], s += o[(15 & i[r + 1]) << 2 | i[r + 2] >> 6], s += o[63 & i[r + 2]]; return n % 3 == 2 ? s = `${s.substring(0, s.length - 1)}=` : n % 3 == 1 && (s = `${s.substring(0, s.length - 2)}==`), s; }; }, function (t, e, i) {\n    t.exports = {\n      Clone: i(67), Extend: i(18), GetAdvancedValue: i(15), GetFastValue: i(2), GetMinMaxValue: i(1377), GetValue: i(6), HasAll: i(1378), HasAny: i(407), HasValue: i(108), IsPlainObject: i(7), Merge: i(126), MergeRight: i(1379), Pick: i(486), SetValue: i(427),\n    };\n  }, function (t, e, i) { const o = i(6); const a = i(19); t.exports = function (t, e, i, n, s) { void 0 === s && (s = i); const r = o(t, e, s); return a(r, i, n); }; }, function (t, e) { t.exports = function (t, e) { for (let i = 0; i < e.length; i++) if (!t.hasOwnProperty(e[i])) return !1; return !0; }; }, function (t, e, i) { const s = i(67); t.exports = function (t, e) { const i = s(t); for (const n in e)i.hasOwnProperty(n) && (i[n] = e[n]); return i; }; }, function (t, e, i) {\n    t.exports = {\n      Format: i(1381), Pad: i(163), Reverse: i(1382), UppercaseFirst: i(181), UUID: i(196),\n    };\n  }, function (t, e) { t.exports = function (t, i) { return t.replace(/%([0-9]+)/g, (t, e) => i[Number(e) - 1]); }; }, function (t, e) { t.exports = function (t) { return t.split('').reverse().join(''); }; }, function (t, e, i) {\n    t.exports = {\n      SoundManagerCreator: i(380), Events: i(59), BaseSound: i(128), BaseSoundManager: i(127), WebAudioSound: i(389), WebAudioSoundManager: i(387), HTML5AudioSound: i(384), HTML5AudioSoundManager: i(381), NoAudioSound: i(386), NoAudioSoundManager: i(385),\n    };\n  }, function (t, e, i) {\n    const n = i(0); const r = i(3); const s = new n({\n      initialize() { this.boundsCenter = new r(), this.centerDiff = new r(); }, parseBody(t) { if (!(t = t.hasOwnProperty('body') ? t.body : t).hasOwnProperty('bounds') || !t.hasOwnProperty('centerOfMass')) return !1; const e = this.boundsCenter; const i = this.centerDiff; const n = t.bounds.max.x - t.bounds.min.x; const s = t.bounds.max.y - t.bounds.min.y; const r = n * t.centerOfMass.x; const o = s * t.centerOfMass.y; return e.set(n / 2, s / 2), i.set(r - e.x, o - e.y), !0; }, getTopLeft(t, e, i) { if (void 0 === e && (e = 0), void 0 === i && (i = 0), this.parseBody(t)) { const n = this.boundsCenter; const s = this.centerDiff; return new r(e + n.x + s.x, i + n.y + s.y); } return !1; }, getTopCenter(t, e, i) { if (void 0 === e && (e = 0), void 0 === i && (i = 0), this.parseBody(t)) { const n = this.boundsCenter; const s = this.centerDiff; return new r(e + s.x, i + n.y + s.y); } return !1; }, getTopRight(t, e, i) { if (void 0 === e && (e = 0), void 0 === i && (i = 0), this.parseBody(t)) { const n = this.boundsCenter; const s = this.centerDiff; return new r(e - (n.x - s.x), i + n.y + s.y); } return !1; }, getLeftCenter(t, e, i) { if (void 0 === e && (e = 0), void 0 === i && (i = 0), this.parseBody(t)) { const n = this.boundsCenter; const s = this.centerDiff; return new r(e + n.x + s.x, i + s.y); } return !1; }, getCenter(t, e, i) { if (void 0 === e && (e = 0), void 0 === i && (i = 0), this.parseBody(t)) { const n = this.centerDiff; return new r(e + n.x, i + n.y); } return !1; }, getRightCenter(t, e, i) { if (void 0 === e && (e = 0), void 0 === i && (i = 0), this.parseBody(t)) { const n = this.boundsCenter; const s = this.centerDiff; return new r(e - (n.x - s.x), i + s.y); } return !1; }, getBottomLeft(t, e, i) { if (void 0 === e && (e = 0), void 0 === i && (i = 0), this.parseBody(t)) { const n = this.boundsCenter; const s = this.centerDiff; return new r(e + n.x + s.x, i - (n.y - s.y)); } return !1; }, getBottomCenter(t, e, i) { if (void 0 === e && (e = 0), void 0 === i && (i = 0), this.parseBody(t)) { const n = this.boundsCenter; const s = this.centerDiff; return new r(e + s.x, i - (n.y - s.y)); } return !1; }, getBottomRight(t, e, i) { if (void 0 === e && (e = 0), void 0 === i && (i = 0), this.parseBody(t)) { const n = this.boundsCenter; const s = this.centerDiff; return new r(e - (n.x - s.x), i - (n.y - s.y)); } return !1; },\n    }); t.exports = s;\n  }, function (t, e, i) {\n    const c = i(109); const n = i(0); const d = i(1292); const o = i(219); const f = i(1293); const s = i(1396); const p = i(1387); const a = i(1388); const r = i(1297); const h = i(1294); const l = i(1295); const u = i(1425); const g = i(86); const v = new n({\n      initialize(t) { this.world = t, this.scene = t.scene, this.sys = t.scene.sys; }, rectangle(t, e, i, n, s) { const r = c.rectangle(t, e, i, n, s); return this.world.add(r), r; }, trapezoid(t, e, i, n, s, r) { const o = c.trapezoid(t, e, i, n, s, r); return this.world.add(o), o; }, circle(t, e, i, n, s) { const r = c.circle(t, e, i, n, s); return this.world.add(r), r; }, polygon(t, e, i, n, s) { const r = c.polygon(t, e, i, n, s); return this.world.add(r), r; }, fromVertices(t, e, i, n, s, r, o) { typeof i === 'string' && (i = g.fromPath(i)); const a = c.fromVertices(t, e, i, n, s, r, o); return this.world.add(a), a; }, fromPhysicsEditor(t, e, i, n, s) { void 0 === s && (s = !0); const r = h.parseBody(t, e, i, n); return s && !this.world.has(r) && this.world.add(r), r; }, fromSVG(t, e, i, n, s, r) { void 0 === n && (n = 1), void 0 === s && (s = {}), void 0 === r && (r = !0); for (var o = i.getElementsByTagName('path'), a = [], h = 0; h < o.length; h++) { const l = f.pathToVertices(o[h], 30); n !== 1 && g.scale(l, n, n), a.push(l); } const u = c.fromVertices(t, e, a, s); return r && this.world.add(u), u; }, fromJSON(t, e, i, n, s) { void 0 === n && (n = {}), void 0 === s && (s = !0); const r = l.parseBody(t, e, i, n); return r && s && this.world.add(r), r; }, imageStack(n, s, t, e, i, r, o, a, h) { void 0 === o && (o = 0), void 0 === a && (a = 0), void 0 === h && (h = {}); const l = this.world; const u = this.sys.displayList; h.addToWorld = !1; const c = d.stack(t, e, i, r, o, a, (t, e) => { const i = new p(l, t, e, n, s, h); return u.add(i), i.body; }); return l.add(c), c; }, stack(t, e, i, n, s, r, o) { const a = d.stack(t, e, i, n, s, r, o); return this.world.add(a), a; }, pyramid(t, e, i, n, s, r, o) { const a = d.pyramid(t, e, i, n, s, r, o); return this.world.add(a), a; }, chain(t, e, i, n, s, r) { return d.chain(t, e, i, n, s, r); }, mesh(t, e, i, n, s) { return d.mesh(t, e, i, n, s); }, newtonsCradle(t, e, i, n, s) { const r = d.newtonsCradle(t, e, i, n, s); return this.world.add(r), r; }, car(t, e, i, n, s) { const r = d.car(t, e, i, n, s); return this.world.add(r), r; }, softBody(t, e, i, n, s, r, o, a, h, l) { const u = d.softBody(t, e, i, n, s, r, o, a, h, l); return this.world.add(u), u; }, joint(t, e, i, n, s) { return this.constraint(t, e, i, n, s); }, spring(t, e, i, n, s) { return this.constraint(t, e, i, n, s); }, constraint(t, e, i, n, s) { void 0 === n && (n = 1), void 0 === s && (s = {}), s.bodyA = t.type === 'body' ? t : t.body, s.bodyB = e.type === 'body' ? e : e.body, isNaN(i) || (s.length = i), s.stiffness = n; const r = o.create(s); return this.world.add(r), r; }, worldConstraint(t, e, i, n) { void 0 === i && (i = 1), void 0 === n && (n = {}), n.bodyB = t.type === 'body' ? t : t.body, isNaN(e) || (n.length = e), n.stiffness = i; const s = o.create(n); return this.world.add(s), s; }, mouseSpring(t) { return this.pointerConstraint(t); }, pointerConstraint(t) { void 0 === t && (t = {}), t.hasOwnProperty('render') || (t.render = { visible: !1 }); const e = new u(this.scene, this.world, t); return this.world.add(e.constraint), e; }, image(t, e, i, n, s) { const r = new p(this.world, t, e, i, n, s); return this.sys.displayList.add(r), r; }, tileBody(t, e) { return new r(this.world, t, e); }, sprite(t, e, i, n, s) { const r = new a(this.world, t, e, i, n, s); return this.sys.displayList.add(r), this.sys.updateList.add(r), r; }, gameObject(t, e, i) { return s(this.world, t, e, i); }, destroy() { this.world = null, this.scene = null, this.sys = null; },\n    }); t.exports = v;\n  }, function (t, e) {\n    function s(t, e, i, n) { const s = e[0] - t[0]; const r = e[1] - t[1]; const o = n[0] - i[0]; const a = n[1] - i[1]; if (o * r - a * s != 0) { const h = (s * (i[1] - t[1]) + r * (t[0] - i[0])) / (o * r - a * s); const l = (o * (t[1] - i[1]) + a * (i[0] - t[0])) / (a * s - o * r); return h >= 0 && h <= 1 && l >= 0 && l <= 1; } } function l(t, e, i) { return (e[0] - t[0]) * (i[1] - t[1]) - (i[0] - t[0]) * (e[1] - t[1]); } function S(t, e, i) { return l(t, e, i) > 0; } function _(t, e, i) { return l(t, e, i) >= 0; } function A(t, e, i) { return l(t, e, i) < 0; } function C(t, e, i) { return l(t, e, i) <= 0; }t.exports = {\n      decomp(t) { const e = (function t(e) { let i = []; let n = []; let s = []; const r = []; let o = Number.MAX_VALUE; for (let a = 0; a < e.length; ++a) if (R(e, a)) for (let h = 0; h < e.length; ++h) if (f(e, a, h)) { n = t(p(e, a, h, r)), s = t(p(e, h, a, r)); for (let l = 0; l < s.length; l++)n.push(s[l]); n.length < o && (o = (i = n).length, i.push([P(e, a), P(e, h)])); } return i; }(t)); return e.length > 0 ? (function t(e, i) { if (i.length === 0) return [e]; { if (i instanceof Array && i.length && i[0] instanceof Array && i[0].length === 2 && i[0][0] instanceof Array) { for (var n = [e], s = 0; s < i.length; s++) for (var r = i[s], o = 0; o < n.length; o++) { const a = n[o]; const h = t(a, r); if (h) { n.splice(o, 1), n.push(h[0], h[1]); break; } } return n; } var r = i; var s = e.indexOf(r[0]); var o = e.indexOf(r[1]); return s !== -1 && o !== -1 && [p(e, s, o), p(e, o, s)]; } }(t, e)) : [t]; }, quickDecomp: function t(e, i, n, s, r, o, a) { o = o || 100; a = a || 0; r = r || 25; i = void 0 !== i ? i : []; n = n || []; s = s || []; let h = [0, 0]; let l = [0, 0]; let u = [0, 0]; let c = 0; let d = 0; let f = 0; let p = 0; let g = 0; let v = 0; let m = 0; const y = []; const x = []; const T = e; const w = e; if (w.length < 3) return i; a++; if (o < a) return console.warn(`quickDecomp: max level (${o}) reached.`), i; for (let b = 0; b < e.length; ++b) if (R(T, b)) { n.push(T[b]), c = d = Number.MAX_VALUE; for (var E = 0; E < e.length; ++E)S(P(T, b - 1), P(T, b), P(T, E)) && C(P(T, b - 1), P(T, b), P(T, E - 1)) && (u = k(P(T, b - 1), P(T, b), P(T, E), P(T, E - 1)), A(P(T, b + 1), P(T, b), u) && (f = M(T[b], u)) < d && (d = f, l = u, v = E)), S(P(T, b + 1), P(T, b), P(T, E + 1)) && C(P(T, b + 1), P(T, b), P(T, E)) && (u = k(P(T, b + 1), P(T, b), P(T, E), P(T, E + 1)), S(P(T, b - 1), P(T, b), u) && (f = M(T[b], u)) < c && (c = f, h = u, g = E)); if (v === (g + 1) % e.length)u[0] = (l[0] + h[0]) / 2, u[1] = (l[1] + h[1]) / 2, s.push(u), b < g ? (O(y, T, b, g + 1), y.push(u), x.push(u), v !== 0 && O(x, T, v, T.length), O(x, T, 0, b + 1)) : (b !== 0 && O(y, T, b, T.length), O(y, T, 0, g + 1), y.push(u), x.push(u), O(x, T, v, b + 1)); else { if (g < v && (g += e.length), p = Number.MAX_VALUE, g < v) return i; for (var E = v; E <= g; ++E)_(P(T, b - 1), P(T, b), P(T, E)) && C(P(T, b + 1), P(T, b), P(T, E)) && (f = M(P(T, b), P(T, E))) < p && L(T, b, E) && (p = f, m = E % e.length); b < m ? (O(y, T, b, m + 1), m !== 0 && O(x, T, m, w.length), O(x, T, 0, b + 1)) : (b !== 0 && O(y, T, b, w.length), O(y, T, 0, m + 1), O(x, T, m, b + 1)); } return y.length < x.length ? (t(y, i, n, s, r, o, a), t(x, i, n, s, r, o, a)) : (t(x, i, n, s, r, o, a), t(y, i, n, s, r, o, a)), i; }i.push(e); return i; }, isSimple(t) { let e; const i = t; for (e = 0; e < i.length - 1; e++) for (let n = 0; n < e - 1; n++) if (s(i[e], i[e + 1], i[n], i[n + 1])) return !1; for (e = 1; e < i.length - 2; e++) if (s(i[0], i[i.length - 1], i[e], i[e + 1])) return !1; return !0; }, removeCollinearPoints(t, e) { for (var i = 0, n = t.length - 1; t.length > 3 && n >= 0; --n)!(function (t, e, i, n) { { if (n) { const s = u; const r = c; s[0] = e[0] - t[0], s[1] = e[1] - t[1], r[0] = i[0] - e[0], r[1] = i[1] - e[1]; const o = s[0] * r[0] + s[1] * r[1]; const a = Math.sqrt(s[0] * s[0] + s[1] * s[1]); const h = Math.sqrt(r[0] * r[0] + r[1] * r[1]); return Math.acos(o / (a * h)) < n; } return l(t, e, i) === 0; } }(P(t, n - 1), P(t, n), P(t, n + 1), e)) || (t.splice(n % t.length, 1), i++); return i; }, removeDuplicatePoints(t, e) { for (let i = t.length - 1; i >= 1; --i) for (let n = t[i], s = i - 1; s >= 0; --s)!(function (t, e, i) { return g(t[0], e[0], i) && g(t[1], e[1], i); }(n, t[s], e)) || t.splice(i, 1); }, makeCCW(t) { for (var e = 0, i = t, n = 1; n < t.length; ++n)(i[n][1] < i[e][1] || i[n][1] === i[e][1] && i[n][0] > i[e][0]) && (e = n); return !S(P(t, e - 1), P(t, e), P(t, e + 1)) && ((function (t) { for (var e = [], i = t.length, n = 0; n !== i; n++)e.push(t.pop()); for (n = 0; n !== i; n++)t[n] = e[n]; }(t)), !0); },\n    }; var u = []; var c = []; function M(t, e) { const i = e[0] - t[0]; const n = e[1] - t[1]; return i * i + n * n; } function P(t, e) { const i = t.length; return t[e < 0 ? e % i + i : e % i]; } function O(t, e, i, n) { for (let s = i; s < n; s++)t.push(e[s]); } function R(t, e) { return A(P(t, e - 1), P(t, e), P(t, e + 1)); } const h = []; const d = []; function f(t, e, i) { let n; let s; const r = h; const o = d; if (!_(P(t, e + 1), P(t, e), P(t, i)) || !C(P(t, e - 1), P(t, e), P(t, i))) { s = M(P(t, e), P(t, i)); for (let a = 0; a !== t.length; ++a) if ((a + 1) % t.length !== e && a !== e && _(P(t, e), P(t, i), P(t, a + 1)) && C(P(t, e), P(t, i), P(t, a)) && (r[0] = P(t, e), r[1] = P(t, i), o[0] = P(t, a), o[1] = P(t, a + 1), n = (function (t, e, i) { i = i || 0; const n = [0, 0]; const s = t[1][1] - t[0][1]; const r = t[0][0] - t[1][0]; const o = s * t[0][0] + r * t[0][1]; const a = e[1][1] - e[0][1]; const h = e[0][0] - e[1][0]; const l = a * e[0][0] + h * e[0][1]; const u = s * h - a * r; return g(u, 0, i) || (n[0] = (h * o - r * l) / u, n[1] = (s * l - a * o) / u), n; }(r, o)), M(P(t, e), n) < s)) return; return 1; } } function L(t, e, i) { for (let n = 0; n !== t.length; ++n) if (n !== e && n !== i && (n + 1) % t.length !== e && (n + 1) % t.length !== i && s(P(t, e), P(t, i), P(t, n), P(t, n + 1))) return; return 1; } function p(t, e, i, n) { const s = n || []; if (s.length = 0, e < i) for (var r = e; r <= i; r++)s.push(t[r]); else { for (r = 0; r <= i; r++)s.push(t[r]); for (r = e; r < t.length; r++)s.push(t[r]); } return s; } function k(t, e, i, n, s) { s = s || 0; const r = e[1] - t[1]; const o = t[0] - e[0]; const a = r * t[0] + o * t[1]; const h = n[1] - i[1]; const l = i[0] - n[0]; const u = h * i[0] + l * i[1]; const c = r * l - h * o; return g(c, 0, s) ? [0, 0] : [(l * a - o * u) / c, (r * u - h * a) / c]; } function g(t, e, i) { return i = i || 0, Math.abs(t - e) <= i; }\n  }, function (t, e, i) { const n = i(0); const s = i(514); const a = i(14); const h = i(2); const r = i(107); const o = i(156); const l = i(3); const u = new n({ Extends: r, Mixins: [s.Bounce, s.Collision, s.Force, s.Friction, s.Gravity, s.Mass, s.Sensor, s.SetBody, s.Sleep, s.Static, s.Transform, s.Velocity, o], initialize(t, e, i, n, s, r) { a.call(this, t.scene, 'Image'), this._crop = this.resetCropObject(), this.setTexture(n, s), this.setSizeToFrame(), this.setOrigin(), this.world = t, this._tempVec2 = new l(e, i); const o = h(r, 'shape', null); o ? this.setBody(o, r) : this.setRectangle(this.width, this.height, r), this.setPosition(e, i), this.initPipeline('TextureTintPipeline'); } }); t.exports = u; }, function (t, e, i) { const a = i(504); const n = i(0); const s = i(514); const h = i(14); const l = i(2); const r = i(156); const o = i(75); const u = i(3); const c = new n({ Extends: o, Mixins: [s.Bounce, s.Collision, s.Force, s.Friction, s.Gravity, s.Mass, s.Sensor, s.SetBody, s.Sleep, s.Static, s.Transform, s.Velocity, r], initialize(t, e, i, n, s, r) { h.call(this, t.scene, 'Sprite'), this._crop = this.resetCropObject(), this.anims = new a(this), this.setTexture(n, s), this.setSizeToFrame(), this.setOrigin(), this.world = t, this._tempVec2 = new u(e, i); const o = l(r, 'shape', null); o ? this.setBody(o, r) : this.setRectangle(this.width, this.height, r), this.setPosition(e, i), this.initPipeline('TextureTintPipeline'); } }); t.exports = c; }, function (t, e, i) { const n = {}; t.exports = n; const s = i(1299); const r = i(42); n.name = 'matter-js', n.version = '0.14.2', n.uses = [], n.used = [], n.use = function () { s.use(n, Array.prototype.slice.call(arguments)); }, n.before = function (t, e) { return t = t.replace(/^Matter./, ''), r.chainPathBefore(n, t, e); }, n.after = function (t, e) { return t = t.replace(/^Matter./, ''), r.chainPathAfter(n, t, e); }; }, function (t, e, i) { const d = {}; t.exports = d; const f = i(99); const h = i(516); const l = i(100); const p = i(109); const a = i(86); d.collides = function (t, e) { for (var i = [], n = 0; n < e.length; n++) { const s = e[n]; if (t !== s && l.overlaps(s.bounds, t.bounds)) for (let r = s.parts.length === 1 ? 0 : 1; r < s.parts.length; r++) { const o = s.parts[r]; if (l.overlaps(o.bounds, t.bounds)) { const a = h.collides(o, t); if (a.collided) { i.push(a); break; } } } } return i; }, d.ray = function (t, e, i, n) { n = n || 1e-100; for (var s = f.angle(e, i), r = f.magnitude(f.sub(e, i)), o = 0.5 * (i.x + e.x), a = 0.5 * (i.y + e.y), h = p.rectangle(o, a, r, n, { angle: s }), l = d.collides(h, t), u = 0; u < l.length; u += 1) { const c = l[u]; c.body = c.bodyB = c.bodyA; } return l; }, d.region = function (t, e, i) { for (var n = [], s = 0; s < t.length; s++) { const r = t[s]; const o = l.overlaps(r.bounds, e); (o && !i || !o && i) && n.push(r); } return n; }, d.point = function (t, e) { for (var i = [], n = 0; n < t.length; n++) { const s = t[n]; if (l.contains(s.bounds, e)) for (let r = s.parts.length === 1 ? 0 : 1; r < s.parts.length; r++) { const o = s.parts[r]; if (l.contains(o.bounds, e) && a.contains(o.vertices, e)) { i.push(s); break; } } } return i; }; }, function (t, e, i) {\n    const p = {}; t.exports = p; const s = i(1300); const g = i(239); const v = i(1303); const m = i(1302); const y = i(1426); const r = i(1301); const x = i(240); const T = i(148); const w = i(219); const o = i(42); const a = i(62); p.create = function (t, e) {\n      e = (e = o.isElement(t) ? e : t) || {}, ((t = o.isElement(t) ? t : null) || e.render) && o.warn('Engine.create: engine.render is deprecated (see docs)'); const i = {\n        positionIterations: 6, velocityIterations: 4, constraintIterations: 2, enableSleeping: !1, events: [], plugin: {}, timing: { timestamp: 0, timeScale: 1 }, broadphase: { controller: r },\n      }; const n = o.extend(i, e); return n.world = e.world || s.create(n.world), n.pairs = m.create(), n.broadphase = n.broadphase.controller.create(n.broadphase), n.metrics = n.metrics || { extended: !1 }, n.metrics = y.create(n.metrics), n;\n    }, p.update = function (t, e, i) { e = e || 1e3 / 60, i = i || 1; let n; const s = t.world; const r = t.timing; const o = t.broadphase; let a = []; r.timestamp += e * r.timeScale; const h = { timestamp: r.timestamp }; x.trigger(t, 'beforeUpdate', h); const l = T.allBodies(s); const u = T.allConstraints(s); for (y.reset(t.metrics), t.enableSleeping && g.update(l, r.timeScale), p._bodiesApplyGravity(l, s.gravity), p._bodiesUpdate(l, e, r.timeScale, i, s.bounds), w.preSolveAll(l), n = 0; n < t.constraintIterations; n++)w.solveAll(u, r.timeScale); w.postSolveAll(l), a = o.controller ? (s.isModified && o.controller.clear(o), o.controller.update(o, l, t, s.isModified), o.pairsList) : l, s.isModified && T.setModified(s, !1, !1, !0); const c = o.detector(a, t); const d = t.pairs; const f = r.timestamp; for (m.update(d, c, f), m.removeOld(d, f), t.enableSleeping && g.afterCollisions(d.list, r.timeScale), d.collisionStart.length > 0 && x.trigger(t, 'collisionStart', { pairs: d.collisionStart }), v.preSolvePosition(d.list), n = 0; n < t.positionIterations; n++)v.solvePosition(d.list, l, r.timeScale); for (v.postSolvePosition(l), w.preSolveAll(l), n = 0; n < t.constraintIterations; n++)w.solveAll(u, r.timeScale); for (w.postSolveAll(l), v.preSolveVelocity(d.list), n = 0; n < t.velocityIterations; n++)v.solveVelocity(d.list, r.timeScale); return d.collisionActive.length > 0 && x.trigger(t, 'collisionActive', { pairs: d.collisionActive }), d.collisionEnd.length > 0 && x.trigger(t, 'collisionEnd', { pairs: d.collisionEnd }), y.update(t.metrics, t), p._bodiesClearForces(l), x.trigger(t, 'afterUpdate', h), t; }, p.merge = function (t, e) { if (o.extend(t, e), e.world) { t.world = e.world, p.clear(t); for (let i = T.allBodies(t.world), n = 0; n < i.length; n++) { const s = i[n]; g.set(s, !1), s.id = o.nextId(); } } }, p.clear = function (t) { const e = t.world; m.clear(t.pairs); let i; const n = t.broadphase; n.controller && (i = T.allBodies(e), n.controller.clear(n), n.controller.update(n, i, t, !0)); }, p._bodiesClearForces = function (t) { for (let e = 0; e < t.length; e++) { const i = t[e]; i.force.x = 0, i.force.y = 0, i.torque = 0; } }, p._bodiesApplyGravity = function (t, e) { const i = void 0 !== e.scale ? e.scale : 0.001; if ((e.x !== 0 || e.y !== 0) && i !== 0) for (let n = 0; n < t.length; n++) { const s = t[n]; s.ignoreGravity || s.isStatic || s.isSleeping || (s.force.x += s.mass * e.x * i * s.gravityScale.x, s.force.y += s.mass * e.y * i * s.gravityScale.y); } }, p._bodiesUpdate = function (t, e, i, n, s) { for (let r = 0; r < t.length; r++) { const o = t[r]; o.isStatic || o.isSleeping || a.update(o, e, i, n); } };\n  }, function (t, e, i) {\n    const o = i(109); const n = i(62); const s = i(0); const y = i(42); const u = i(148); const T = i(1391); const w = i(10); const a = i(1296); const b = i(2); const E = i(6); const r = i(62); const h = i(240); const l = i(1297); const c = i(1300); const x = i(99); const d = new s({\n      Extends: w,\n      initialize(t, e) {\n        w.call(this), this.scene = t, this.engine = T.create(e), this.localWorld = this.engine.world; const i = E(e, 'gravity', null); i ? this.setGravity(i.x, i.y, i.scale) : !1 === i && this.setGravity(0, 0, 0), this.walls = {\n          left: null, right: null, top: null, bottom: null,\n        }, this.enabled = E(e, 'enabled', !0), this.correction = E(e, 'correction', 1), this.getDelta = E(e, 'getDelta', this.update60Hz); const n = b(e, 'runner', {}); const s = b(n, 'fps', !1); let r = b(n, 'fps', 60); const o = b(n, 'delta', 1e3 / r); const a = b(n, 'deltaMin', 1e3 / r); const h = b(n, 'deltaMax', 1e3 / (0.5 * r)); s || (r = 1e3 / o), this.runner = {\n          fps: r, correction: b(n, 'correction', 1), deltaSampleSize: b(n, 'deltaSampleSize', 60), counterTimestamp: 0, frameCounter: 0, deltaHistory: [], timePrev: null, timeScalePrev: 1, frameRequestId: null, isFixed: b(n, 'isFixed', !1), delta: o, deltaMin: a, deltaMax: h,\n        }, this.autoUpdate = E(e, 'autoUpdate', !0); let l; let u; let c; let d; let f; let p; let g; let v; let m; let y; const x = E(e, 'debug', !1); this.drawDebug = typeof x === 'object' || x, this.debugGraphic, this.debugConfig = {\n          showAxes: b(x, 'showAxes', !1), showAngleIndicator: b(x, 'showAngleIndicator', !1), angleColor: b(x, 'angleColor', 15208787), showBroadphase: b(x, 'showBroadphase', !1), broadphaseColor: b(x, 'broadphaseColor', 16757760), showBounds: b(x, 'showBounds', !1), boundsColor: b(x, 'boundsColor', 16777215), showVelocity: b(x, 'showVelocity', !1), velocityColor: b(x, 'velocityColor', 44783), showCollisions: b(x, 'showCollisions', !1), collisionColor: b(x, 'collisionColor', 16094476), showSeparations: b(x, 'showSeparations', !1), separationColor: b(x, 'separationColor', 16753920), showBody: b(x, 'showBody', !0), showStaticBody: b(x, 'showStaticBody', !0), showInternalEdges: b(x, 'showInternalEdges', !1), renderFill: b(x, 'renderFill', !1), renderLine: b(x, 'renderLine', !0), fillColor: b(x, 'fillColor', 1075465), fillOpacity: b(x, 'fillOpacity', 1), lineColor: b(x, 'lineColor', 2678297), lineOpacity: b(x, 'lineOpacity', 1), lineThickness: b(x, 'lineThickness', 1), staticFillColor: b(x, 'staticFillColor', 857979), staticLineColor: b(x, 'staticLineColor', 1255396), showSleeping: b(x, 'showSleeping', !1), staticBodySleepOpacity: b(x, 'staticBodySleepOpacity', 0.7), sleepFillColor: b(x, 'sleepFillColor', 4605510), sleepLineColor: b(x, 'sleepLineColor', 10066585), showSensors: b(x, 'showSensors', !0), sensorFillColor: b(x, 'sensorFillColor', 857979), sensorLineColor: b(x, 'sensorLineColor', 1255396), showPositions: b(x, 'showPositions', !0), positionSize: b(x, 'positionSize', 4), positionColor: b(x, 'positionColor', 14697178), showJoint: b(x, 'showJoint', !0), jointColor: b(x, 'jointColor', 14737474), jointLineOpacity: b(x, 'jointLineOpacity', 1), jointLineThickness: b(x, 'jointLineThickness', 2), pinSize: b(x, 'pinSize', 4), pinColor: b(x, 'pinColor', 4382944), springColor: b(x, 'springColor', 14697184), anchorColor: b(x, 'anchorColor', 15724527), anchorSize: b(x, 'anchorSize', 4), showConvexHulls: b(x, 'showConvexHulls', !1), hullColor: b(x, 'hullColor', 14091216),\n        }, this.drawDebug && this.createDebugGraphic(), this.setEventsProxy(), b(e, 'setBounds', !1) && (typeof (l = e.setBounds) === 'boolean' ? this.setBounds() : (u = b(l, 'x', 0), c = b(l, 'y', 0), d = b(l, 'width', t.sys.scale.width), f = b(l, 'height', t.sys.scale.height), p = b(l, 'thickness', 64), g = b(l, 'left', !0), v = b(l, 'right', !0), m = b(l, 'top', !0), y = b(l, 'bottom', !0), this.setBounds(u, c, d, f, p, g, v, m, y)));\n      },\n      setCompositeRenderStyle(t) { for (var e, i, n = t.bodies, s = t.constraints, r = t.composites, o = 0; o < n.length; o++)i = (e = n[o]).render, this.setBodyRenderStyle(e, i.lineColor, i.lineOpacity, i.lineThickness, i.fillColor, i.fillOpacity); for (o = 0; o < s.length; o++)i = (e = s[o]).render, this.setConstraintRenderStyle(e, i.lineColor, i.lineOpacity, i.lineThickness, i.pinSize, i.anchorColor, i.anchorSize); for (o = 0; o < r.length; o++)e = r[o], this.setCompositeRenderStyle(e); return this; },\n      setBodyRenderStyle(t, e, i, n, s, r) { const o = t.render; const a = this.debugConfig; return o && (e == null && (e = t.isStatic ? a.staticLineColor : a.lineColor), i == null && (i = a.lineOpacity), n == null && (n = a.lineThickness), s == null && (s = t.isStatic ? a.staticFillColor : a.fillColor), r == null && (r = a.fillOpacity), !1 !== e && (o.lineColor = e), !1 !== i && (o.lineOpacity = i), !1 !== n && (o.lineThickness = n), !1 !== s && (o.fillColor = s), !1 !== r && (o.fillOpacity = r)), this; },\n      setConstraintRenderStyle(t, e, i, n, s, r, o) { let a; const h = t.render; const l = this.debugConfig; return h && (e == null && ((a = h.type) === 'line' ? e = l.jointColor : a === 'pin' ? e = l.pinColor : a === 'spring' && (e = l.springColor)), i == null && (i = l.jointLineOpacity), n == null && (n = l.jointLineThickness), s == null && (s = l.pinSize), r == null && (r = l.anchorColor), o == null && (o = l.anchorSize), !1 !== e && (h.lineColor = e), !1 !== i && (h.lineOpacity = i), !1 !== n && (h.lineThickness = n), !1 !== s && (h.pinSize = s), !1 !== r && (h.anchorColor = r), !1 !== o && (h.anchorSize = o)), this; },\n      setEventsProxy() { const r = this; const t = this.engine; const e = this.localWorld; this.drawDebug && (h.on(e, 'compositeModified', (t) => { r.setCompositeRenderStyle(t); }), h.on(e, 'beforeAdd', (t) => { for (let e = [].concat(t.object), i = 0; i < e.length; i++) { const n = e[i]; const s = n.render; n.type === 'body' ? r.setBodyRenderStyle(n, s.lineColor, s.lineOpacity, s.lineThickness, s.fillColor, s.fillOpacity) : n.type === 'composite' ? r.setCompositeRenderStyle(n) : n.type === 'constraint' && r.setConstraintRenderStyle(n, s.lineColor, s.lineOpacity, s.lineThickness, s.pinSize, s.anchorColor, s.anchorSize); } })), h.on(e, 'beforeAdd', (t) => { r.emit(a.BEFORE_ADD, t); }), h.on(e, 'afterAdd', (t) => { r.emit(a.AFTER_ADD, t); }), h.on(e, 'beforeRemove', (t) => { r.emit(a.BEFORE_REMOVE, t); }), h.on(e, 'afterRemove', (t) => { r.emit(a.AFTER_REMOVE, t); }), h.on(t, 'beforeUpdate', (t) => { r.emit(a.BEFORE_UPDATE, t); }), h.on(t, 'afterUpdate', (t) => { r.emit(a.AFTER_UPDATE, t); }), h.on(t, 'collisionStart', (t) => { let e; let i; const n = t.pairs; n.length > 0 && (e = n[0].bodyA, i = n[0].bodyB), r.emit(a.COLLISION_START, t, e, i); }), h.on(t, 'collisionActive', (t) => { let e; let i; const n = t.pairs; n.length > 0 && (e = n[0].bodyA, i = n[0].bodyB), r.emit(a.COLLISION_ACTIVE, t, e, i); }), h.on(t, 'collisionEnd', (t) => { let e; let i; const n = t.pairs; n.length > 0 && (e = n[0].bodyA, i = n[0].bodyB), r.emit(a.COLLISION_END, t, e, i); }); },\n      setBounds(t, e, i, n, s, r, o, a, h) { return void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = this.scene.sys.scale.width), void 0 === n && (n = this.scene.sys.scale.height), void 0 === s && (s = 64), void 0 === r && (r = !0), void 0 === o && (o = !0), void 0 === a && (a = !0), void 0 === h && (h = !0), this.updateWall(r, 'left', t - s, e - s, s, n + 2 * s), this.updateWall(o, 'right', t + i, e - s, s, n + 2 * s), this.updateWall(a, 'top', t, e - s, i, s), this.updateWall(h, 'bottom', t, e + n, i, s), this; },\n      updateWall(t, e, i, n, s, r) { const o = this.walls[e]; t ? (o && c.remove(this.localWorld, o), i += s / 2, n += r / 2, this.walls[e] = this.create(i, n, s, r, { isStatic: !0, friction: 0, frictionStatic: 0 })) : (o && c.remove(this.localWorld, o), this.walls[e] = null); },\n      createDebugGraphic() { const t = this.scene.sys.add.graphics({ x: 0, y: 0 }); return t.setDepth(Number.MAX_VALUE), this.debugGraphic = t, this.drawDebug = !0, t; },\n      disableGravity() { return this.localWorld.gravity.x = 0, this.localWorld.gravity.y = 0, this.localWorld.gravity.scale = 0, this; },\n      setGravity(t, e, i) { return void 0 === t && (t = 0), void 0 === e && (e = 1), this.localWorld.gravity.x = t, this.localWorld.gravity.y = e, void 0 !== i && (this.localWorld.gravity.scale = i), this; },\n      create(t, e, i, n, s) { const r = o.rectangle(t, e, i, n, s); return c.add(this.localWorld, r), r; },\n      add(t) { return c.add(this.localWorld, t), this; },\n      remove(t, e) { Array.isArray(t) || (t = [t]); for (let i = 0; i < t.length; i++) { const n = t[i]; const s = n.body ? n.body : n; u.remove(this.localWorld, s, e); } return this; },\n      removeConstraint(t, e) { return u.remove(this.localWorld, t, e), this; },\n      convertTilemapLayer(t, e) { const i = t.layer; const n = t.getTilesWithin(0, 0, i.width, i.height, { isColliding: !0 }); return this.convertTiles(n, e), this; },\n      convertTiles(t, e) { if (t.length === 0) return this; for (let i = 0; i < t.length; i++) new l(this, t[i], e); return this; },\n      nextGroup(t) { return r.nextGroup(t); },\n      nextCategory() { return r.nextCategory(); },\n      pause() { return this.enabled = !1, this.emit(a.PAUSE), this; },\n      resume() { return this.enabled = !0, this.emit(a.RESUME), this; },\n      update(t, e) { let i; let n; let s; let r; this.enabled && this.autoUpdate && (i = this.engine, n = this.runner, s = i.timing, r = this.correction, n.isFixed ? e = this.getDelta(t, e) : (e = t - n.timePrev || n.delta, n.timePrev = t, n.deltaHistory.push(e), n.deltaHistory = n.deltaHistory.slice(-n.deltaSampleSize), r = (e = (e = (e = Math.min.apply(null, n.deltaHistory)) < n.deltaMin ? n.deltaMin : e) > n.deltaMax ? n.deltaMax : e) / n.delta, n.delta = e), n.timeScalePrev !== 0 && (r *= s.timeScale / n.timeScalePrev), s.timeScale === 0 && (r = 0), n.timeScalePrev = s.timeScale, n.correction = r, n.frameCounter += 1, t - n.counterTimestamp >= 1e3 && (n.fps = n.frameCounter * ((t - n.counterTimestamp) / 1e3), n.counterTimestamp = t, n.frameCounter = 0), T.update(i, e, r)); },\n      step(t, e) { T.update(this.engine, t, e); },\n      update60Hz() { return 1e3 / 60; },\n      update30Hz() { return 1e3 / 30; },\n      has(t) { const e = t.hasOwnProperty('body') ? t.body : t; return u.get(this.localWorld, e.id, e.type) !== null; },\n      getAllBodies() { return u.allBodies(this.localWorld); },\n      getAllConstraints() { return u.allConstraints(this.localWorld); },\n      getAllComposites() { return u.allComposites(this.localWorld); },\n      postUpdate() { let t; let e; let i; let n; this.drawDebug && (t = this.debugConfig, e = this.engine, i = this.debugGraphic, n = u.allBodies(this.localWorld), this.debugGraphic.clear(), t.showBroadphase && e.broadphase.controller && this.renderGrid(e.broadphase, i, t.broadphaseColor, 0.5), t.showBounds && this.renderBodyBounds(n, i, t.boundsColor, 0.5), (t.showBody || t.showStaticBody) && this.renderBodies(n), t.showJoint && this.renderJoints(), (t.showAxes || t.showAngleIndicator) && this.renderBodyAxes(n, i, t.showAxes, t.angleColor, 0.5), t.showVelocity && this.renderBodyVelocity(n, i, t.velocityColor, 1, 2), t.showSeparations && this.renderSeparations(e.pairs.list, i, t.separationColor), t.showCollisions && this.renderCollisions(e.pairs.list, i, t.collisionColor)); },\n      renderGrid(t, e, i, n) { e.lineStyle(1, i, n); for (let s = y.keys(t.buckets), r = 0; r < s.length; r++) { var o; const a = s[r]; t.buckets[a].length < 2 || (o = a.split(/C|R/), e.strokeRect(parseInt(o[1], 10) * t.bucketWidth, parseInt(o[2], 10) * t.bucketHeight, t.bucketWidth, t.bucketHeight)); } return this; },\n      renderSeparations(t, e, i) { e.lineStyle(1, i, 1); for (let n = 0; n < t.length; n++) { var s; var r; var o; var a; var h; var l; var u; const c = t[n]; c.isActive && (r = (s = c.collision).bodyA, o = s.bodyB, a = r.position, h = o.position, l = s.penetration, u = r.isStatic || o.isStatic ? 1 : 4, o.isStatic && (u = 0), e.lineBetween(h.x, h.y, h.x - l.x * u, h.y - l.y * u), u = r.isStatic || o.isStatic ? 1 : 4, r.isStatic && (u = 0), e.lineBetween(a.x, a.y, a.x - l.x * u, a.y - l.y * u)); } return this; },\n      renderCollisions(t, e, i) { let n; let s; let r; let o; let a; let h; for (e.lineStyle(1, i, 0.5), e.fillStyle(i, 1), n = 0; n < t.length; n++) if ((s = t[n]).isActive) for (let l = 0; l < s.activeContacts.length; l++) { const u = s.activeContacts[l].vertex; e.fillRect(u.x - 2, u.y - 2, 5, 5); } for (n = 0; n < t.length; n++) { (s = t[n]).isActive && (r = s.collision, (o = s.activeContacts).length > 0 && (a = o[0].vertex.x, h = o[0].vertex.y, o.length === 2 && (a = (o[0].vertex.x + o[1].vertex.x) / 2, h = (o[0].vertex.y + o[1].vertex.y) / 2), r.bodyB === r.supports[0].body || r.bodyA.isStatic ? e.lineBetween(a - 8 * r.normal.x, h - 8 * r.normal.y, a, h) : e.lineBetween(a + 8 * r.normal.x, h + 8 * r.normal.y, a, h))); } return this; },\n      renderBodyBounds(t, e, i, n) { e.lineStyle(1, i, n); for (let s = 0; s < t.length; s++) { const r = t[s]; if (r.render.visible) { const o = r.bounds; if (o)e.strokeRect(o.min.x, o.min.y, o.max.x - o.min.x, o.max.y - o.min.y); else for (let a = r.parts, h = a.length > 1 ? 1 : 0; h < a.length; h++) { const l = a[h]; e.strokeRect(l.bounds.min.x, l.bounds.min.y, l.bounds.max.x - l.bounds.min.x, l.bounds.max.y - l.bounds.min.y); } } } return this; },\n      renderBodyAxes(t, e, i, n, s) { e.lineStyle(1, n, s); for (let r = 0; r < t.length; r++) { var o; var a; var h; const l = t[r]; const u = l.parts; if (l.render.visible) if (i) for (a = u.length > 1 ? 1 : 0; a < u.length; a++) for (o = u[a], h = 0; h < o.axes.length; h++) { const c = o.axes[h]; e.lineBetween(o.position.x, o.position.y, o.position.x + 20 * c.x, o.position.y + 20 * c.y); } else for (a = u.length > 1 ? 1 : 0; a < u.length; a++) for (o = u[a], h = 0; h < o.axes.length; h++)e.lineBetween(o.position.x, o.position.y, (o.vertices[0].x + o.vertices[o.vertices.length - 1].x) / 2, (o.vertices[0].y + o.vertices[o.vertices.length - 1].y) / 2); } return this; },\n      renderBodyVelocity(t, e, i, n, s) { e.lineStyle(s, i, n); for (let r = 0; r < t.length; r++) { const o = t[r]; o.render.visible && e.lineBetween(o.position.x, o.position.y, o.position.x + 2 * (o.position.x - o.positionPrev.x), o.position.y + 2 * (o.position.y - o.positionPrev.y)); } return this; },\n      renderBodies(t) { for (let e = this.debugGraphic, i = this.debugConfig, n = i.showBody, s = i.showStaticBody, r = i.showSleeping, o = i.showInternalEdges, a = i.showConvexHulls, h = i.renderFill, l = i.renderLine, u = i.staticBodySleepOpacity, c = i.sleepFillColor, d = i.sleepLineColor, f = i.hullColor, p = 0; p < t.length; p++) { var g; var v; var m; var y; var x; var T; const w = t[p]; w.render.visible && (!s && w.isStatic || !n && !w.isStatic || (g = w.render.lineColor, v = w.render.lineOpacity, m = w.render.lineThickness, y = w.render.fillColor, x = w.render.fillOpacity, r && w.isSleeping && (w.isStatic ? (v *= u, x *= u) : (g = d, y = c)), h || (y = null), l || (g = null), this.renderBody(w, e, o, g, v, m, y, x), T = w.parts.length, a && T > 1 && this.renderConvexHull(w, e, f, m))); } },\n      renderBody(t, e, i, n, s, r, o, a) { void 0 === n && (n = null), void 0 === s && (s = null), void 0 === r && (r = 1), void 0 === o && (o = null), void 0 === a && (a = null); for (var h, l, u, c = this.debugConfig, d = c.sensorFillColor, f = c.sensorLineColor, p = t.parts, g = p.length, v = g > 1 ? 1 : 0; v < g; v++) { const m = p[v]; const y = m.render; const x = y.opacity; if (y.visible && x !== 0 && (!m.isSensor || c.showSensors)) { const T = m.circleRadius; if (e.beginPath(), m.isSensor ? (o !== null && e.fillStyle(d, a * x), n !== null && e.lineStyle(r, f, s * x)) : (o !== null && e.fillStyle(o, a * x), n !== null && e.lineStyle(r, n, s * x)), T)e.arc(m.position.x, m.position.y, T, 0, 2 * Math.PI); else { const w = m.vertices; const b = w.length; e.moveTo(w[0].x, w[0].y); for (let E = 1; E < b; E++) { var S; const _ = w[E]; !w[E - 1].isInternal || i ? e.lineTo(_.x, _.y) : e.moveTo(_.x, _.y), E < b && _.isInternal && !i && (S = (E + 1) % b, e.moveTo(w[S].x, w[S].y)); }e.closePath(); }o !== null && e.fillPath(), n !== null && e.strokePath(); } } return c.showPositions && !t.isStatic && (h = t.position.x, l = t.position.y, u = Math.ceil(c.positionSize / 2), e.fillStyle(c.positionColor, 1), e.fillRect(h - u, l - u, c.positionSize, c.positionSize)), this; },\n      renderConvexHull(t, e, i, n) { if (void 0 === n && (n = 1), t.parts.length > 1) { const s = t.vertices; e.lineStyle(n, i), e.beginPath(), e.moveTo(s[0].x, s[0].y); for (let r = 1; r < s.length; r++)e.lineTo(s[r].x, s[r].y); e.lineTo(s[0].x, s[0].y), e.strokePath(); } return this; },\n      renderJoints() { for (let t = this.debugGraphic, e = u.allConstraints(this.localWorld), i = 0; i < e.length; i++) { const n = e[i].render; const s = n.lineColor; const r = n.lineOpacity; const o = n.lineThickness; const a = n.pinSize; const h = n.anchorColor; const l = n.anchorSize; this.renderConstraint(e[i], t, s, r, o, a, h, l); } },\n      renderConstraint(t, e, i, n, s, r, o, a) { const h = t.render; if (!h.visible || !t.pointA || !t.pointB) return this; e.lineStyle(s, i, n); let l; const u = t.bodyA; const c = t.bodyB; const d = u ? x.add(u.position, t.pointA) : t.pointA; if (h.type === 'pin')e.strokeCircle(d.x, d.y, r); else { if (l = c ? x.add(c.position, t.pointB) : t.pointB, e.beginPath(), e.moveTo(d.x, d.y), h.type === 'spring') for (var f, p = x.sub(l, d), g = x.perp(x.normalise(p)), v = Math.ceil(y.clamp(t.length / 5, 12, 20)), m = 1; m < v; m += 1)f = m % 2 == 0 ? 1 : -1, e.lineTo(d.x + p.x * (m / v) + g.x * f * 4, d.y + p.y * (m / v) + g.y * f * 4); e.lineTo(l.x, l.y); } return e.strokePath(), h.anchors && a > 0 && (e.fillStyle(o), e.fillCircle(d.x, d.y, a), e.fillCircle(l.x, l.y, a)), this; },\n      resetCollisionIDs() { return n._nextCollidingGroupId = 1, n._nextNonCollidingGroupId = -1, n._nextCategory = 1, this; },\n      shutdown() { h.off(this.engine), this.removeAllListeners(), c.clear(this.localWorld, !1), T.clear(this.engine), this.drawDebug && this.debugGraphic.destroy(); },\n      destroy() { this.shutdown(); },\n    }); t.exports = d;\n  }, function (s, t, r) {\n    (function (t) {\n      r(518); const e = r(33); const i = r(18); let n = {\n        Actions: r(241), Animations: r(638), BlendModes: r(52), Cache: r(639), Cameras: r(642), Core: r(728), Class: r(0), Create: r(789), Curves: r(795), Data: r(798), Display: r(800), DOM: r(818), Events: r(819), Game: r(821), GameObjects: r(914), Geom: r(430), Input: r(1201), Loader: r(1235), Math: r(170), Physics: r(1394), Plugins: r(1304), Renderer: r(1431), Scale: r(1306), ScaleModes: r(234), Scene: r(374), Scenes: r(1307), Structs: r(1309), Textures: r(1310), Tilemaps: r(1312), Time: r(1353), Tweens: r(1355), Utils: r(1373),\n      }; n.Sound = r(1383), n = i(!1, n, e), s.exports = n, t.Phaser = n;\n    }).call(this, r(517));\n  }, function (t, e, i) { t.exports = { Arcade: i(1261), Matter: i(1395) }; }, function (t, e, i) {\n    t.exports = {\n      BodyBounds: i(1384), Factory: i(1385), Image: i(1387), Matter: i(1298), MatterPhysics: i(1427), PolyDecomp: i(1386), Sprite: i(1388), TileBody: i(1297), PhysicsEditorParser: i(1294), PhysicsJSONParser: i(1295), World: i(1392),\n    };\n  }, function (t, e, i) { const a = i(514); const h = i(2); const l = i(3); t.exports = function (t, n, e, i) { void 0 === e && (e = {}), void 0 === i && (i = !0); let s; const r = n.x; const o = n.y; return n.body = { temp: !0, position: { x: r, y: o } }, [a.Bounce, a.Collision, a.Force, a.Friction, a.Gravity, a.Mass, a.Sensor, a.SetBody, a.Sleep, a.Static, a.Transform, a.Velocity].forEach((t) => { for (const e in t)(i = t[e]).get && typeof i.get === 'function' || i.set && typeof i.set === 'function' ? Object.defineProperty(n, e, { get: t[e].get, set: t[e].set }) : Object.defineProperty(n, e, { value: t[e] }); let i; }), n.world = t, n._tempVec2 = new l(r, o), e.hasOwnProperty('type') && e.type === 'body' ? n.setExistingBody(e, i) : (s = (s = h(e, 'shape', null)) || 'rectangle', e.addToWorld = i, n.setBody(s, e)), n; }; }, function (t, e) { t.exports = { setBounce(t) { return this.body.restitution = t, this; } }; }, function (t, e) {\n    const i = {\n      setCollisionCategory(t) { return this.body.collisionFilter.category = t, this; }, setCollisionGroup(t) { return this.body.collisionFilter.group = t, this; }, setCollidesWith(t) { let e = 0; if (Array.isArray(t)) for (let i = 0; i < t.length; i++)e |= t[i]; else e = t; return this.body.collisionFilter.mask = e, this; }, setOnCollide(t) { return this.body.onCollideCallback = t, this; }, setOnCollideEnd(t) { return this.body.onCollideEndCallback = t, this; }, setOnCollideActive(t) { return this.body.onCollideActiveCallback = t, this; }, setOnCollideWith(t, e) { Array.isArray(t) || (t = [t]); for (let i = 0; i < t.length; i++) { const n = t[i].hasOwnProperty('body') ? t[i].body : t[i]; this.body.setOnCollideWith(n, e); } return this; },\n    }; t.exports = i;\n  }, function (t, e, i) {\n    const n = i(62); const s = {\n      applyForce(t) { return this._tempVec2.set(this.body.position.x, this.body.position.y), n.applyForce(this.body, this._tempVec2, t), this; }, applyForceFrom(t, e) { return n.applyForce(this.body, t, e), this; }, thrust(t) { const e = this.body.angle; return this._tempVec2.set(t * Math.cos(e), t * Math.sin(e)), n.applyForce(this.body, { x: this.body.position.x, y: this.body.position.y }, this._tempVec2), this; }, thrustLeft(t) { const e = this.body.angle - Math.PI / 2; return this._tempVec2.set(t * Math.cos(e), t * Math.sin(e)), n.applyForce(this.body, { x: this.body.position.x, y: this.body.position.y }, this._tempVec2), this; }, thrustRight(t) { const e = this.body.angle + Math.PI / 2; return this._tempVec2.set(t * Math.cos(e), t * Math.sin(e)), n.applyForce(this.body, { x: this.body.position.x, y: this.body.position.y }, this._tempVec2), this; }, thrustBack(t) { const e = this.body.angle - Math.PI; return this._tempVec2.set(t * Math.cos(e), t * Math.sin(e)), n.applyForce(this.body, { x: this.body.position.x, y: this.body.position.y }, this._tempVec2), this; },\n    }; t.exports = s;\n  }, function (t, e) { const i = { setFriction(t, e, i) { return this.body.friction = t, void 0 !== e && (this.body.frictionAir = e), void 0 !== i && (this.body.frictionStatic = i), this; }, setFrictionAir(t) { return this.body.frictionAir = t, this; }, setFrictionStatic(t) { return this.body.frictionStatic = t, this; } }; t.exports = i; }, function (t, e) { t.exports = { setIgnoreGravity(t) { return this.body.ignoreGravity = t, this; } }; }, function (t, e, i) { const n = i(62); const s = i(3); const r = { setMass(t) { return n.setMass(this.body, t), this; }, setDensity(t) { return n.setDensity(this.body, t), this; }, centerOfMass: { get() { return new s(this.body.centerOfMass.x, this.body.centerOfMass.y); } } }; t.exports = r; }, function (t, e, i) { const n = i(62); const s = { setStatic(t) { return n.setStatic(this.body, t), this; }, isStatic() { return this.body.isStatic; } }; t.exports = s; }, function (t, e) { t.exports = { setSensor(t) { return this.body.isSensor = t, this; }, isSensor() { return this.body.isSensor; } }; }, function (t, e, i) {\n    const m = i(109); const y = i(62); const u = i(106); const x = i(2); const T = i(1294); const w = i(1295); const b = i(86); const n = {\n      setRectangle(t, e, i) { return this.setBody({ type: 'rectangle', width: t, height: e }, i); },\n      setCircle(t, e) { return this.setBody({ type: 'circle', radius: t }, e); },\n      setPolygon(t, e, i) { return this.setBody({ type: 'polygon', sides: e, radius: t }, i); },\n      setTrapezoid(t, e, i, n) {\n        return this.setBody({\n          type: 'trapezoid', width: t, height: e, slope: i,\n        }, n);\n      },\n      setExistingBody(t, e) { void 0 === e && (e = !0), this.body && this.world.remove(this.body, !0), this.body = t; for (let i = 0; i < t.parts.length; i++)t.parts[i].gameObject = this; let n; let s; let r; let o; let a; let h; const l = this; return t.destroy = function () { l.world.remove(l.body, !0), l.body.gameObject = null; }, e && (this.world.has(t) && this.world.remove(t, !0), this.world.add(t)), this._originComponent && (n = t.render.sprite.xOffset, s = t.render.sprite.yOffset, r = t.centerOfMass.x, o = t.centerOfMass.y, u(r, 0.5) && u(o, 0.5) ? this.setOrigin(n + 0.5, s + 0.5) : (a = t.centerOffset.x, h = t.centerOffset.y, this.setOrigin(n + a / this.displayWidth, s + h / this.displayHeight))), this; },\n      setBody(t, e) { if (!t) return this; typeof t === 'string' && (t = { type: t }); const i = x(t, 'type', 'rectangle'); const n = x(t, 'x', this._tempVec2.x); const s = x(t, 'y', this._tempVec2.y); const r = x(t, 'width', this.width); const o = x(t, 'height', this.height); switch (i) { case 'rectangle': l = m.rectangle(n, s, r, o, e); break; case 'circle': var a = x(t, 'radius', Math.max(r, o) / 2); var h = x(t, 'maxSides', 25); var l = m.circle(n, s, a, e, h); break; case 'trapezoid': var u = x(t, 'slope', 0.5); l = m.trapezoid(n, s, r, o, u, e); break; case 'polygon': var c = x(t, 'sides', 5); var d = x(t, 'radius', Math.max(r, o) / 2); l = m.polygon(n, s, c, d, e); break; case 'fromVertices': case 'fromVerts': var f; var p; var g; var v = x(t, 'verts', null); v && (typeof v === 'string' && (v = b.fromPath(v)), l = this.body && !this.body.hasOwnProperty('temp') ? (y.setVertices(this.body, v), this.body) : (f = x(t, 'flagInternal', !1), p = x(t, 'removeCollinear', 0.01), g = x(t, 'minimumArea', 10), m.fromVertices(n, s, v, e, f, p, g))); break; case 'fromPhysicsEditor': l = T.parseBody(n, s, t, e); break; case 'fromPhysicsTracer': l = w.parseBody(n, s, t, e); } return l && this.setExistingBody(l, t.addToWorld), this; },\n    }; t.exports = n;\n  }, function (t, e, i) {\n    const n = i(1296); const s = i(239); const r = i(240); const o = {\n      setToSleep() { s.set(this.body, !0); }, setAwake() { s.set(this.body, !1); }, setSleepThreshold(t) { return void 0 === t && (t = 60), this.body.sleepThreshold = t, this; }, setSleepEvents(t, e) { return this.setSleepStartEvent(t), this.setSleepEndEvent(e), this; }, setSleepStartEvent(t) { let e; return t ? (e = this.world, r.on(this.body, 'sleepStart', function (t) { e.emit(n.SLEEP_START, t, this); })) : r.off(this.body, 'sleepStart'), this; }, setSleepEndEvent(t) { let e; return t ? (e = this.world, r.on(this.body, 'sleepEnd', function (t) { e.emit(n.SLEEP_END, t, this); })) : r.off(this.body, 'sleepEnd'), this; },\n    }; t.exports = o;\n  }, function (t, e) { t.exports = 'afteradd'; }, function (t, e) { t.exports = 'afterremove'; }, function (t, e) { t.exports = 'afterupdate'; }, function (t, e) { t.exports = 'beforeadd'; }, function (t, e) { t.exports = 'beforeremove'; }, function (t, e) { t.exports = 'beforeupdate'; }, function (t, e) { t.exports = 'collisionactive'; }, function (t, e) { t.exports = 'collisionend'; }, function (t, e) { t.exports = 'collisionstart'; }, function (t, e) { t.exports = 'dragend'; }, function (t, e) { t.exports = 'drag'; }, function (t, e) { t.exports = 'dragstart'; }, function (t, e) { t.exports = 'pause'; }, function (t, e) { t.exports = 'resume'; }, function (t, e) { t.exports = 'sleepend'; }, function (t, e) { t.exports = 'sleepstart'; }, function (t, e, i) {\n    const r = i(62); const n = i(13); const s = i(235); const o = i(236); const a = {\n      x: { get() { return this.body.position.x; }, set(t) { this._tempVec2.set(t, this.y), r.setPosition(this.body, this._tempVec2); } }, y: { get() { return this.body.position.y; }, set(t) { this._tempVec2.set(this.x, t), r.setPosition(this.body, this._tempVec2); } }, scaleX: { get() { return this._scaleX; }, set(t) { const e = 1 / this._scaleX; const i = 1 / this._scaleY; this._scaleX = t, this._scaleX === 0 ? this.renderFlags &= -5 : this.renderFlags |= 4, r.scale(this.body, e, i), r.scale(this.body, t, this._scaleY); } }, scaleY: { get() { return this._scaleY; }, set(t) { const e = 1 / this._scaleX; const i = 1 / this._scaleY; this._scaleY = t, this._scaleY === 0 ? this.renderFlags &= -5 : this.renderFlags |= 4, r.scale(this.body, e, i), r.scale(this.body, this._scaleX, t); } }, angle: { get() { return o(this.body.angle * n.RAD_TO_DEG); }, set(t) { this.rotation = o(t) * n.DEG_TO_RAD; } }, rotation: { get() { return this.body.angle; }, set(t) { this._rotation = s(t), r.setAngle(this.body, this._rotation); } }, setPosition(t, e) { return void 0 === t && (t = 0), void 0 === e && (e = t), this._tempVec2.set(t, e), r.setPosition(this.body, this._tempVec2), this; }, setRotation(t) { return void 0 === t && (t = 0), this._rotation = s(t), r.setAngle(this.body, t), this; }, setFixedRotation() { return r.setInertia(this.body, 1 / 0), this; }, setAngle(t) { return void 0 === t && (t = 0), this.angle = t, r.setAngle(this.body, this.rotation), this; }, setScale(t, e, i) { void 0 === t && (t = 1), void 0 === e && (e = t); const n = 1 / this._scaleX; const s = 1 / this._scaleY; return this._scaleX = t, this._scaleY = e, r.scale(this.body, n, s, i), r.scale(this.body, t, e, i), this; },\n    }; t.exports = a;\n  }, function (t, e, i) {\n    const n = i(62); const s = {\n      setAngularVelocity(t) { return n.setAngularVelocity(this.body, t), this; }, setVelocityX(t) { return this._tempVec2.set(t, this.body.velocity.y), n.setVelocity(this.body, this._tempVec2), this; }, setVelocityY(t) { return this._tempVec2.set(this.body.velocity.x, t), n.setVelocity(this.body, this._tempVec2), this; }, setVelocity(t, e) { return this._tempVec2.set(t, e), n.setVelocity(this.body, this._tempVec2), this; },\n    }; t.exports = s;\n  }, function (t, e, i) {\n    const o = i(100); const n = i(0); const a = i(148); const s = i(219); const h = i(515); const l = i(1296); const r = i(54); const u = i(126); const c = i(239); const d = i(3); const f = i(86); const p = new n({\n      initialize(t, e, i) {\n        void 0 === i && (i = {}); this.scene = t, this.world = e, this.camera = null, this.pointer = null, this.active = !0, this.position = new d(), this.body = null, this.part = null, this.constraint = s.create(u(i, {\n          label: 'Pointer Constraint', pointA: { x: 0, y: 0 }, pointB: { x: 0, y: 0 }, length: 0.01, stiffness: 0.1, angularStiffness: 1, collisionFilter: { category: 1, mask: 4294967295, group: 0 },\n        })), this.world.on(l.BEFORE_UPDATE, this.update, this), t.sys.input.on(r.POINTER_DOWN, this.onDown, this), t.sys.input.on(r.POINTER_UP, this.onUp, this);\n      },\n      onDown(t) { this.pointer || (this.pointer = t, this.camera = t.camera); },\n      onUp(t) { t === this.pointer && (this.pointer = null); },\n      getBody(t) { const e = this.position; const i = this.constraint; this.camera.getWorldPoint(t.x, t.y, e); for (let n = a.allBodies(this.world.localWorld), s = 0; s < n.length; s++) { const r = n[s]; if (!r.ignorePointer && o.contains(r.bounds, e) && h.canCollide(r.collisionFilter, i.collisionFilter) && this.hitTestBody(r, e)) return this.world.emit(l.DRAG_START, r, this.part, this), !0; } return !1; },\n      hitTestBody(t, e) { for (let i = this.constraint, n = t.parts.length, s = n > 1 ? 1 : 0; s < n; s++) { const r = t.parts[s]; if (f.contains(r.vertices, e)) return i.pointA = e, i.pointB = { x: e.x - t.position.x, y: e.y - t.position.y }, i.bodyB = t, i.angleB = t.angle, c.set(t, !1), this.part = r, this.body = t, !0; } return !1; },\n      update() { const t = this.pointer; let e = this.body; if (this.active && t) if (t.isDown || !e) { if (t.isDown) { if (!e && !this.getBody(t)) return; e = this.body; const i = this.position; const n = this.constraint; this.camera.getWorldPoint(t.x, t.y, i), n.pointA.x = i.x, n.pointA.y = i.y, c.set(e, !1), this.world.emit(l.DRAG, e, this); } } else this.stopDrag(); else e && this.stopDrag(); },\n      stopDrag() { const t = this.body; const e = this.constraint; e.bodyB = null, e.pointB = null, this.pointer = null, this.body = null, this.part = null, t && this.world.emit(l.DRAG_END, t, this); },\n      destroy() { this.world.removeConstraint(this.constraint), this.pointer = null, this.constraint = null, this.body = null, this.part = null, this.world.off(l.BEFORE_UPDATE, this.update), this.scene.sys.input.off(r.POINTER_DOWN, this.onDown, this), this.scene.sys.input.off(r.POINTER_UP, this.onUp, this); },\n    }); t.exports = p;\n  }, function (t, e, i) {\n    const n = {}; t.exports = n; const s = i(148); const r = i(42); n.create = function (t) {\n      return r.extend({\n        extended: !1, narrowDetections: 0, narrowphaseTests: 0, narrowReuse: 0, narrowReuseCount: 0, midphaseTests: 0, broadphaseTests: 0, narrowEff: 1e-4, midEff: 1e-4, broadEff: 1e-4, collisions: 0, buckets: 0, bodies: 0, pairs: 0,\n      }, !1, t);\n    }, n.reset = function (t) { t.extended && (t.narrowDetections = 0, t.narrowphaseTests = 0, t.narrowReuse = 0, t.narrowReuseCount = 0, t.midphaseTests = 0, t.broadphaseTests = 0, t.narrowEff = 0, t.midEff = 0, t.broadEff = 0, t.collisions = 0, t.buckets = 0, t.pairs = 0, t.bodies = 0); }, n.update = function (t, e) { let i; let n; t.extended && (i = e.world, n = s.allBodies(i), t.collisions = t.narrowDetections, t.pairs = e.pairs.list.length, t.bodies = n.length, t.midEff = (t.narrowDetections / (t.midphaseTests || 1)).toFixed(2), t.narrowEff = (t.narrowDetections / (t.narrowphaseTests || 1)).toFixed(2), t.broadEff = (1 - t.broadphaseTests / (n.length || 1)).toFixed(2), t.narrowReuse = (t.narrowReuseCount / (t.narrowphaseTests || 1)).toFixed(2)); };\n  }, function (t, e, i) {\n    const r = i(105); const n = i(513); const s = i(109); const o = i(62); const a = i(1384); const h = i(100); const l = i(0); const u = i(148); const c = i(1292); const d = i(219); const f = i(515); const p = i(53); const g = i(1385); const v = i(2); const m = i(6); const y = i(1301); const x = i(1428); const T = i(1429); const w = i(1389); const b = i(1430); const E = i(126); const S = i(473); const _ = i(1302); const A = i(1299); const C = i(23); const M = i(1390); const P = i(1303); const O = i(516); const R = i(22); const L = i(1293); const k = i(99); const D = i(86); const F = i(1392); const I = new l({\n      initialize(t) { this.scene = t, this.systems = t.sys, this.config = this.getConfig(), this.world, this.add, this.bodyBounds, this.body = o, this.composite = u, this.detector = f, this.grid = y, this.pair = S, this.pairs = _, this.query = M, this.resolver = P, this.sat = O, this.constraint = d, this.bodies = s, this.composites = c, this.axes = n, this.bounds = h, this.svg = L, this.vector = k, this.vertices = D, this.verts = D, this._tempVec2 = k.create(), m(this.config, 'plugins.collisionevents', !0) && this.enableCollisionEventsPlugin(), m(this.config, 'plugins.attractors', !1) && this.enableAttractorPlugin(), m(this.config, 'plugins.wrap', !1) && this.enableWrapPlugin(), P._restingThresh = m(this.config, 'restingThresh', 4), P._restingThreshTangent = m(this.config, 'restingThreshTangent', 6), P._positionDampen = m(this.config, 'positionDampen', 0.9), P._positionWarming = m(this.config, 'positionWarming', 0.8), P._frictionNormalMultiplier = m(this.config, 'frictionNormalMultiplier', 5), t.sys.events.once(R.BOOT, this.boot, this), t.sys.events.on(R.START, this.start, this); }, boot() { this.world = new F(this.scene, this.config), this.add = new g(this.world), this.bodyBounds = new a(), this.systems.events.once(R.DESTROY, this.destroy, this); }, start() { this.world || (this.world = new F(this.scene, this.config), this.add = new g(this.world)); const t = this.systems.events; t.on(R.UPDATE, this.world.update, this.world), t.on(R.POST_UPDATE, this.world.postUpdate, this.world), t.once(R.SHUTDOWN, this.shutdown, this); }, getConfig() { const t = this.systems.game.config.physics; const e = this.systems.settings.physics; return E(v(e, 'matter', {}), v(t, 'matter', {})); }, enableAttractorPlugin() { return A.register(x), A.use(w, x), this; }, enableWrapPlugin() { return A.register(b), A.use(w, b), this; }, enableCollisionEventsPlugin() { return A.register(T), A.use(w, T), this; }, pause() { return this.world.pause(); }, resume() { return this.world.resume(); }, set60Hz() { return this.world.getDelta = this.world.update60Hz, this.world.autoUpdate = !0, this; }, set30Hz() { return this.world.getDelta = this.world.update30Hz, this.world.autoUpdate = !0, this; }, step(t, e) { this.world.step(t, e); }, containsPoint(t, e, i) { t = this.getMatterBodies(t); const n = k.create(e, i); return M.point(t, n).length > 0; }, intersectPoint(t, e, i) { i = this.getMatterBodies(i); const n = k.create(t, e); const s = []; return M.point(i, n).forEach((t) => { s.indexOf(t) === -1 && s.push(t); }), s; }, intersectRect(t, e, i, n, s, r) { void 0 === s && (s = !1), r = this.getMatterBodies(r); const o = { min: { x: t, y: e }, max: { x: t + i, y: e + n } }; const a = []; return M.region(r, o, s).forEach((t) => { a.indexOf(t) === -1 && a.push(t); }), a; }, intersectRay(t, e, i, n, s, r) { void 0 === s && (s = 1), r = this.getMatterBodies(r); for (var o = [], a = M.ray(r, k.create(t, e), k.create(i, n), s), h = 0; h < a.length; h++)o.push(a[h].body); return o; }, intersectBody(t, e) { e = this.getMatterBodies(e); for (var i = [], n = M.collides(t, e), s = 0; s < n.length; s++) { const r = n[s]; r.bodyA === t ? i.push(r.bodyB) : i.push(r.bodyA); } return i; }, overlap(t, e, i, n, s) { void 0 === i && (i = null), void 0 === n && (n = null), void 0 === s && (s = i), Array.isArray(t) || (t = [t]), t = this.getMatterBodies(t), e = this.getMatterBodies(e); for (var r = !1, o = 0; o < t.length; o++) for (let a = t[o], h = M.collides(a, e), l = 0; l < h.length; l++) { const u = h[l]; const c = u.bodyA.id === a.id ? u.bodyB : u.bodyA; if (!n || n.call(s, a, c, u)) if (r = !0, i)i.call(s, a, c, u); else if (!n) return !0; } return r; }, setCollisionCategory(t, e) { return (t = this.getMatterBodies(t)).forEach((t) => { t.collisionFilter.category = e; }), this; }, setCollisionGroup(t, e) { return (t = this.getMatterBodies(t)).forEach((t) => { t.collisionFilter.group = e; }), this; }, setCollidesWith(t, e) { t = this.getMatterBodies(t); let i = 0; if (Array.isArray(e)) for (let n = 0; n < e.length; n++)i |= e[n]; else i = e; return t.forEach((t) => { t.collisionFilter.mask = i; }), this; }, getMatterBodies(t) { if (!t) return this.world.getAllBodies(); Array.isArray(t) || (t = [t]); for (var e = [], i = 0; i < t.length; i++) { const n = t[i].hasOwnProperty('body') ? t[i].body : t[i]; e.push(n); } return e; }, setVelocity(t, e, i) { t = this.getMatterBodies(t); const n = this._tempVec2; return n.x = e, n.y = i, t.forEach((t) => { o.setVelocity(t, n); }), this; }, setVelocityX(t, e) { t = this.getMatterBodies(t); const i = this._tempVec2; return i.x = e, t.forEach((t) => { i.y = t.velocity.y, o.setVelocity(t, i); }), this; }, setVelocityY(t, e) { t = this.getMatterBodies(t); const i = this._tempVec2; return i.y = e, t.forEach((t) => { i.x = t.velocity.x, o.setVelocity(t, i); }), this; }, setAngularVelocity(t, e) { return (t = this.getMatterBodies(t)).forEach((t) => { o.setAngularVelocity(t, e); }), this; }, applyForce(t, e) { t = this.getMatterBodies(t); const i = this._tempVec2; return t.forEach((t) => { i.x = t.position.x, i.y = t.position.y, o.applyForce(t, i, e); }), this; }, applyForceFromPosition(t, e, i, n) { t = this.getMatterBodies(t); const s = this._tempVec2; return t.forEach((t) => { void 0 === n && (n = t.angle), s.x = i * Math.cos(n), s.y = i * Math.sin(n), o.applyForce(t, e, s); }), this; }, applyForceFromAngle(t, e, i) { t = this.getMatterBodies(t); const n = this._tempVec2; return t.forEach((t) => { void 0 === i && (i = t.angle), n.x = e * Math.cos(i), n.y = e * Math.sin(i), o.applyForce(t, { x: t.position.x, y: t.position.y }, n); }), this; }, getConstraintLength(t) { let e = t.pointA.x; let i = t.pointA.y; let n = t.pointB.x; let s = t.pointB.y; return t.bodyA && (e += t.bodyA.position.x, i += t.bodyA.position.y), t.bodyB && (n += t.bodyB.position.x, s += t.bodyB.position.y), p(e, i, n, s); }, alignBody(t, e, i, n) { let s; switch (t = t.hasOwnProperty('body') ? t.body : t, n) { case r.TOP_LEFT: case r.LEFT_TOP: s = this.bodyBounds.getTopLeft(t, e, i); break; case r.TOP_CENTER: s = this.bodyBounds.getTopCenter(t, e, i); break; case r.TOP_RIGHT: case r.RIGHT_TOP: s = this.bodyBounds.getTopRight(t, e, i); break; case r.LEFT_CENTER: s = this.bodyBounds.getLeftCenter(t, e, i); break; case r.CENTER: s = this.bodyBounds.getCenter(t, e, i); break; case r.RIGHT_CENTER: s = this.bodyBounds.getRightCenter(t, e, i); break; case r.LEFT_BOTTOM: case r.BOTTOM_LEFT: s = this.bodyBounds.getBottomLeft(t, e, i); break; case r.BOTTOM_CENTER: s = this.bodyBounds.getBottomCenter(t, e, i); break; case r.BOTTOM_RIGHT: case r.RIGHT_BOTTOM: s = this.bodyBounds.getBottomRight(t, e, i); } return s && o.setPosition(t, s), this; }, shutdown() { const t = this.systems.events; this.world && (t.off(R.UPDATE, this.world.update, this.world), t.off(R.POST_UPDATE, this.world.postUpdate, this.world)), t.off(R.SHUTDOWN, this.shutdown, this), this.add && this.add.destroy(), this.world && this.world.destroy(), this.add = null, this.world = null; }, destroy() { this.shutdown(), this.scene.sys.events.off(R.START, this.start, this), this.scene = null, this.systems = null; },\n    }); C.register('MatterPhysics', I, 'matterPhysics'), t.exports = I;\n  }, function (t, e, i) {\n    const c = i(1298); var a = {\n      name: 'matter-attractors', version: '0.1.7', for: 'matter-js@^0.14.2', silent: !0, install(t) { t.after('Body.create', function () { a.Body.init(this); }), t.before('Engine.update', (t) => { a.Engine.update(t); }); }, Body: { init(t) { t.plugin.attractors = t.plugin.attractors || []; } }, Engine: { update(t) { for (let e = t.world, i = c.Composite.allBodies(e), n = 0; n < i.length; n += 1) { const s = i[n]; const r = s.plugin.attractors; if (r && r.length > 0) for (let o = n + 1; o < i.length; o += 1) for (let a = i[o], h = 0; h < r.length; h += 1) { const l = r[h]; let u = l; c.Common.isFunction(l) && (u = l(s, a)), u && c.Body.applyForce(a, a.position, u); } } } }, Attractors: { gravityConstant: 0.001, gravity(t, e) { const i = c.Vector.sub(e.position, t.position); const n = c.Vector.magnitudeSquared(i) || 1e-4; const s = c.Vector.normalise(i); const r = -a.Attractors.gravityConstant * (t.mass * e.mass / n); const o = c.Vector.mult(s, r); c.Body.applyForce(t, t.position, c.Vector.neg(o)), c.Body.applyForce(e, e.position, o); } },\n    }; t.exports = a;\n  }, function (t, e) {\n    t.exports = {\n      name: 'matter-collision-events', version: '0.1.6', for: 'matter-js@^0.14.2', silent: !0, install(n) { n.after('Engine.create', function () { n.Events.on(this, 'collisionStart', (t) => { t.pairs.map((t) => { const e = t.bodyA; const i = t.bodyB; e.gameObject && e.gameObject.emit('collide', e, i, t), i.gameObject && i.gameObject.emit('collide', i, e, t), n.Events.trigger(e, 'onCollide', { pair: t }), n.Events.trigger(i, 'onCollide', { pair: t }), e.onCollideCallback && e.onCollideCallback(t), i.onCollideCallback && i.onCollideCallback(t), e.onCollideWith[i.id] && e.onCollideWith[i.id](i, t), i.onCollideWith[e.id] && i.onCollideWith[e.id](e, t); }); }), n.Events.on(this, 'collisionActive', (t) => { t.pairs.map((t) => { const e = t.bodyA; const i = t.bodyB; e.gameObject && e.gameObject.emit('collideActive', e, i, t), i.gameObject && i.gameObject.emit('collideActive', i, e, t), n.Events.trigger(e, 'onCollideActive', { pair: t }), n.Events.trigger(i, 'onCollideActive', { pair: t }), e.onCollideActiveCallback && e.onCollideActiveCallback(t), i.onCollideActiveCallback && i.onCollideActiveCallback(t); }); }), n.Events.on(this, 'collisionEnd', (t) => { t.pairs.map((t) => { const e = t.bodyA; const i = t.bodyB; e.gameObject && e.gameObject.emit('collideEnd', e, i, t), i.gameObject && i.gameObject.emit('collideEnd', i, e, t), n.Events.trigger(e, 'onCollideEnd', { pair: t }), n.Events.trigger(i, 'onCollideEnd', { pair: t }), e.onCollideEndCallback && e.onCollideEndCallback(t), i.onCollideEndCallback && i.onCollideEndCallback(t); }); }); }); },\n    };\n  }, function (t, e, i) {\n    const a = i(1298); var h = {\n      name: 'matter-wrap', version: '0.1.4', for: 'matter-js@^0.14.2', silent: !0, install(t) { t.after('Engine.update', function () { h.Engine.update(this); }); }, Engine: { update(t) { for (var e = t.world, i = a.Composite.allBodies(e), n = a.Composite.allComposites(e), s = 0; s < i.length; s += 1) { const r = i[s]; r.plugin.wrap && h.Body.wrap(r, r.plugin.wrap); } for (s = 0; s < n.length; s += 1) { const o = n[s]; o.plugin.wrap && h.Composite.wrap(o, o.plugin.wrap); } } }, Bounds: { wrap(t, e) { let i = null; let n = null; if (void 0 !== e.min.x && void 0 !== e.max.x && (t.min.x > e.max.x ? i = e.min.x - t.max.x : t.max.x < e.min.x && (i = e.max.x - t.min.x)), void 0 !== e.min.y && void 0 !== e.max.y && (t.min.y > e.max.y ? n = e.min.y - t.max.y : t.max.y < e.min.y && (n = e.max.y - t.min.y)), i !== null || n !== null) return { x: i || 0, y: n || 0 }; } }, Body: { wrap(t, e) { const i = h.Bounds.wrap(t.bounds, e); return i && a.Body.translate(t, i), i; } }, Composite: { bounds(t) { for (var e = a.Composite.allBodies(t), i = [], n = 0; n < e.length; n += 1) { const s = e[n]; i.push(s.bounds.min, s.bounds.max); } return a.Bounds.create(i); }, wrap(t, e) { const i = h.Bounds.wrap(h.Composite.bounds(t), e); return i && a.Composite.translate(t, i), i; } },\n    }; t.exports = h;\n  }, function (t, e, i) { t.exports = { Canvas: i(1432), Snapshot: i(1433), WebGL: i(1434) }; }, function (t, e, i) { t.exports = { CanvasRenderer: i(505), GetBlendModes: i(507), SetTransform: i(28) }; }, function (t, e, i) { t.exports = { Canvas: i(506), WebGL: i(509) }; }, function (t, e, i) {\n    t.exports = {\n      Utils: i(9), WebGLPipeline: i(147), WebGLRenderer: i(508), Pipelines: i(1435), BYTE: 0, SHORT: 1, UNSIGNED_BYTE: 2, UNSIGNED_SHORT: 3, FLOAT: 4,\n    };\n  }, function (t, e, i) {\n    t.exports = {\n      BitmapMaskPipeline: i(510), ForwardDiffuseLightPipeline: i(511), TextureTintPipeline: i(237), TextureTintStripPipeline: i(512), ModelViewProjection: i(238),\n    };\n  }], s.c = n, s.d = function (t, e, i) { s.o(t, e) || Object.defineProperty(t, e, { enumerable: !0, get: i }); }, s.r = function (t) { typeof Symbol !== 'undefined' && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, { value: 'Module' }), Object.defineProperty(t, '__esModule', { value: !0 }); }, s.t = function (e, t) { if (1 & t && (e = s(e)), 8 & t) return e; if (4 & t && typeof e === 'object' && e && e.__esModule) return e; const i = Object.create(null); if (s.r(i), Object.defineProperty(i, 'default', { enumerable: !0, value: e }), 2 & t && typeof e !== 'string') for (const n in e)s.d(i, n, ((t) => e[t]).bind(null, n)); return i; }, s.n = function (t) { const e = t && t.__esModule ? function () { return t.default; } : function () { return t; }; return s.d(e, 'a', e), e; }, s.o = function (t, e) { return Object.prototype.hasOwnProperty.call(t, e); }, s.p = '', s(s.s = 1393); function s(t) { if (n[t]) return n[t].exports; const e = n[t] = { i: t, l: !1, exports: {} }; return i[t].call(e.exports, e, e.exports, s), e.l = !0, e.exports; } let i; let n;\n}));\n\n//# sourceURL=webpack://Shooter-Game/./src/phaser.min.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		if(__webpack_module_cache__[moduleId]) {
/******/ 			return __webpack_module_cache__[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => module['default'] :
/******/ 				() => module;
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop)
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		var scriptUrl;
/******/ 		if (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + "";
/******/ 		var document = __webpack_require__.g.document;
/******/ 		if (!scriptUrl && document) {
/******/ 			if (document.currentScript)
/******/ 				scriptUrl = document.currentScript.src
/******/ 			if (!scriptUrl) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				if(scripts.length) scriptUrl = scripts[scripts.length - 1].src
/******/ 			}
/******/ 		}
/******/ 		// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration
/******/ 		// or pass an empty string ("") and set the __webpack_public_path__ variable from your code to use your own logic.
/******/ 		if (!scriptUrl) throw new Error("Automatic publicPath is not supported in this browser");
/******/ 		scriptUrl = scriptUrl.replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/");
/******/ 		__webpack_require__.p = scriptUrl;
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	// startup
/******/ 	// Load entry module
/******/ 	__webpack_require__("./src/index.js");
/******/ 	// This entry module used 'exports' so it can't be inlined
/******/ })()
;